(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["AVPlayer"] = factory();
	else
		root["AVPlayer"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/avrender/image/webgl/glsl/vertex.vert":
/*!***************************************************!*\
  !*** ./src/avrender/image/webgl/glsl/vertex.vert ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 point;\nattribute vec4 color;\nvarying vec4 v_color;\n\nuniform mat4 rotateMatrix;\n\nvoid main(void){\n  gl_Position = rotateMatrix * vec4(point, 1.0);\n  v_color = color;\n}\n");

/***/ }),

/***/ "./src/avrender/image/webgpu/wgsl/compute/uint2FloatBE.wgsl":
/*!******************************************************************!*\
  !*** ./src/avrender/image/webgpu/wgsl/compute/uint2FloatBE.wgsl ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("\r\nstruct Meta {\r\n  max: u32,\r\n  width: u32,\r\n  height: u32\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> metaData: Meta;\r\n@group(0) @binding(1) var input: texture_2d<u32>;\r\n@group(0) @binding(2) var output: texture_storage_2d<r32float, write>;\r\n\r\n@compute @workgroup_size(8, 8) fn main(\r\n  @builtin(workgroup_id) workgroup_id: vec3<u32>,\r\n  @builtin(local_invocation_id) local_invocation_id: vec3<u32>\r\n) {\r\n  var x = workgroup_id.x * 8 + local_invocation_id.x;\r\n  var y = workgroup_id.y * 8 + local_invocation_id.y;\r\n  if (x < metaData.width && y < metaData.height) {\r\n    var value: u32 = textureLoad(input, vec2(x, y), 0).x;\r\n    var low = value & 0xff;\r\n    var high = (value >> 8) & 0xff;\r\n    value = (low << 8) | high;\r\n    var value_no: f32 = f32(value) / f32(metaData.max);\r\n    textureStore(output, vec2(x, y), vec4(value_no, 0, 0, 0));\r\n  }\r\n}");

/***/ }),

/***/ "./src/avrender/image/webgpu/wgsl/compute/uint2FloatLE.wgsl":
/*!******************************************************************!*\
  !*** ./src/avrender/image/webgpu/wgsl/compute/uint2FloatLE.wgsl ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("\r\nstruct Meta {\r\n  max: u32,\r\n  width: u32,\r\n  height: u32\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> metaData: Meta;\r\n@group(0) @binding(1) var input: texture_2d<u32>;\r\n@group(0) @binding(2) var output: texture_storage_2d<r32float, write>;\r\n\r\n@compute @workgroup_size(8, 8) fn main(\r\n  @builtin(workgroup_id) workgroup_id: vec3<u32>,\r\n  @builtin(local_invocation_id) local_invocation_id: vec3<u32>\r\n) {\r\n  var x = workgroup_id.x * 8 + local_invocation_id.x;\r\n  var y = workgroup_id.y * 8 + local_invocation_id.y;\r\n  if (x < metaData.width && y < metaData.height) {\r\n    var value: u32 = textureLoad(input, vec2(x, y), 0).x;\r\n    var value_no: f32 = f32(value) / f32(metaData.max);\r\n    textureStore(output, vec2(x, y), vec4(value_no, 0, 0, 0));\r\n  }\r\n}");

/***/ }),

/***/ "./src/avrender/image/webgpu/wgsl/fragment/external.wgsl":
/*!***************************************************************!*\
  !*** ./src/avrender/image/webgpu/wgsl/fragment/external.wgsl ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("\r\n@group(0) @binding(1) var eTexture: texture_external;\r\n@group(0) @binding(2) var s: sampler;\r\n\r\n@fragment\r\nfn main(@location(0) in_texcoord: vec4<f32>) -> @location(0) vec4<f32> {\r\n  return textureSampleBaseClampToEdge(eTexture, s, in_texcoord.xy);\r\n}");

/***/ }),

/***/ "./src/avrender/image/webgpu/wgsl/vertex.wgsl":
/*!****************************************************!*\
  !*** ./src/avrender/image/webgpu/wgsl/vertex.wgsl ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("struct PositionColorInput {\r\n    @location(0) in_position_3d: vec3<f32>,\r\n    @location(1) in_color_rgba: vec4<f32>\r\n};\r\n\r\nstruct PositionColorOutput {\r\n    @builtin(position) coords_output: vec4<f32>,\r\n    @location(0) color_output: vec4<f32>\r\n};\r\n\r\nstruct RotateMatrix {\r\n    matrix: mat4x4<f32>\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> rotateMatrix: RotateMatrix;\r\n\r\n@vertex\r\nfn main(input: PositionColorInput) -> PositionColorOutput {\r\n    var output: PositionColorOutput;\r\n    output.color_output = input.in_color_rgba;\r\n    output.coords_output = rotateMatrix.matrix * vec4<f32>(input.in_position_3d, 1.0);\r\n    return output;\r\n}");

/***/ }),

/***/ "./src/audioresample/Resampler.ts":
/*!****************************************!*\
  !*** ./src/audioresample/Resampler.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Resampler)
/* harmony export */ });
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\audioresample\\Resampler.ts";


class Resampler {
    resampler;
    options;
    inputParameters;
    outputParameters;
    constructor(options) {
        this.options = options;
        this.resampler = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__["default"](this.options.resource);
    }
    async open(input, output) {
        this.inputParameters = input;
        this.outputParameters = output;
        await this.resampler.run();
        this.resampler.call('resample_set_input_parameters', input.sampleRate, input.channels, input.format, input.layout || 0);
        this.resampler.call('resample_set_output_parameters', output.sampleRate, output.channels, output.format, output.layout || 0);
        let ret = this.resampler.call('resample_init');
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`open resampler failed, ret: ${ret}`, cheap__fileName__0, 84);
        }
    }
    resample(input, output, numberOfFrames) {
        return this.resampler.call('resample_process', input, output, numberOfFrames);
    }
    getOutputSampleCount(numberOfFrames) {
        return this.resampler.call('resample_nb_sample', numberOfFrames);
    }
    close() {
        this.resampler.call('resample_destroy');
        this.resampler.destroy();
        this.resampler = null;
    }
    getInputPCMParameters() {
        return this.inputParameters;
    }
    getOutputPCMParameters() {
        return this.outputParameters;
    }
}


/***/ }),

/***/ "./src/audiostretchpitch/StretchPitcher.ts":
/*!*************************************************!*\
  !*** ./src/audiostretchpitch/StretchPitcher.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StretchPitcher)
/* harmony export */ });
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/*
 * libmedia audio stretch and pitcher
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class StretchPitcher {
    processor;
    options;
    constructor(options) {
        this.options = options;
        this.processor = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__["default"](this.options.resource);
    }
    async open(parameters) {
        await this.processor.run();
        this.processor.call('stretchpitch_init');
        this.processor.call('stretchpitch_set_channels', parameters.channels);
        this.processor.call('stretchpitch_set_samplerate', parameters.sampleRate);
    }
    setRate(rate) {
        this.processor.call('stretchpitch_set_rate', rate);
    }
    setRateChange(change) {
        this.processor.call('stretchpitch_set_rate_change', change);
    }
    setTempo(tempo) {
        this.processor.call('stretchpitch_set_tempo', tempo);
    }
    setTempoChange(change) {
        this.processor.call('stretchpitch_set_tempo_change', change);
    }
    setPitch(pitch) {
        this.processor.call('stretchpitch_set_pitch', pitch);
    }
    setPitchOctaves(pitch) {
        this.processor.call('stretchpitch_set_pitch_octaves', pitch);
    }
    setPitchSemiTones(pitch) {
        this.processor.call('stretchpitch_set_pitch_semi_tones', pitch);
    }
    sendSamples(input, nbSamples) {
        this.processor.call('stretchpitch_send_samples', input, nbSamples);
    }
    receiveSamples(output, maxSamples) {
        return this.processor.call('stretchpitch_receive_samples', output, maxSamples);
    }
    flush() {
        this.processor.call('stretchpitch_flush');
    }
    clear() {
        this.processor.call('stretchpitch_clear');
    }
    getUnprocessedSamplesCount() {
        return this.processor.call('stretchpitch_get_unprocessed_samples_num');
    }
    getInputOutputSamplesRatio() {
        return this.processor.call('stretchpitch_get_input_output_sample_ratio');
    }
    getLatency() {
        return this.processor.call('get_latency');
    }
    close() {
        this.processor.call('stretchpitch_destroy');
        this.processor.destroy();
        this.processor = null;
    }
}


/***/ }),

/***/ "./src/avcodec/codec/codec.ts":
/*!************************************!*\
  !*** ./src/avcodec/codec/codec.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CodecId2String: () => (/* binding */ CodecId2String)
/* harmony export */ });
/*
 * libmedia  codec string map
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const CodecId2String = {
    [86017 /* AVCodecID.AV_CODEC_ID_MP3 */]: 'mp3',
    [86018 /* AVCodecID.AV_CODEC_ID_AAC */]: 'mp4a.40',
    [86021 /* AVCodecID.AV_CODEC_ID_VORBIS */]: 'vorbis',
    [86028 /* AVCodecID.AV_CODEC_ID_FLAC */]: 'flac',
    [86076 /* AVCodecID.AV_CODEC_ID_OPUS */]: 'opus',
    [65542 /* AVCodecID.AV_CODEC_ID_PCM_MULAW */]: 'ulaw',
    [65543 /* AVCodecID.AV_CODEC_ID_PCM_ALAW */]: 'alaw',
    [225 /* AVCodecID.AV_CODEC_ID_AV1 */]: 'av01',
    [27 /* AVCodecID.AV_CODEC_ID_H264 */]: 'avc1',
    [173 /* AVCodecID.AV_CODEC_ID_HEVC */]: 'hev1',
    [196 /* AVCodecID.AV_CODEC_ID_VVC */]: 'vvc1',
    [139 /* AVCodecID.AV_CODEC_ID_VP8 */]: 'vp8',
    [167 /* AVCodecID.AV_CODEC_ID_VP9 */]: 'vp09',
    [12 /* AVCodecID.AV_CODEC_ID_MPEG4 */]: 'mp4v'
};


/***/ }),

/***/ "./src/avcodec/function/getAudioCodec.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/function/getAudioCodec.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getAudioCodec)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _codec_codec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../codec/codec */ "./src/avcodec/codec/codec.ts");


function getAudioCodec(codecpar) {
    const codecId = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 4);
    let profile = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 48);
    let codec = _codec_codec__WEBPACK_IMPORTED_MODULE_1__.CodecId2String[codecId];
    if (codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */) {
        /*
         * mp4a.40.profile
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#iso_base_media_file_format_mp4_quicktime_and_3gp
         */
        codec = `${codec}.${profile}`;
    }
    return codec || 'unknown';
}


/***/ }),

/***/ "./src/avcodec/function/getHardwarePreference.ts":
/*!*******************************************************!*\
  !*** ./src/avcodec/function/getHardwarePreference.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getHardwarePreference: () => (/* binding */ getHardwarePreference)
/* harmony export */ });
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/*
 * libmedia webcodec hardware preference different chrome version
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function getHardwarePreference(enable) {
    if (enable) {
        if (!common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].chrome || common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '94', true)) {
            return 'prefer-hardware';
        }
        else {
            return 'allow';
        }
    }
    else {
        if (!common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].chrome || common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '94', true)) {
            return 'prefer-software';
        }
        else {
            return 'deny';
        }
    }
}


/***/ }),

/***/ "./src/avcodec/function/getVideoCodec.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/function/getVideoCodec.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getVideoCodec)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _codec_codec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../codec/codec */ "./src/avcodec/codec/codec.ts");
/* harmony import */ var avformat_codecs_av1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avformat/codecs/av1 */ "./src/avformat/codecs/av1.ts");
/* harmony import */ var avformat_codecs_vp8__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avformat/codecs/vp8 */ "./src/avformat/codecs/vp8.ts");
/* harmony import */ var avformat_codecs_vp9__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avformat/codecs/vp9 */ "./src/avformat/codecs/vp9.ts");
/* harmony import */ var avformat_codecs_vvc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avformat/codecs/vvc */ "./src/avformat/codecs/vvc.ts");
/* harmony import */ var common_util_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/string */ "./src/common/util/string.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_base32__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/util/base32 */ "./src/common/util/base32.ts");










function getVideoCodec(codecpar, extradata) {
    const codecId = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 4);
    let profile = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 48);
    let level = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 52);
    if (!extradata && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](codecpar + 12) !== 0 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 16)) {
        extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_8__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](codecpar + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 16));
    }
    let entry = _codec_codec__WEBPACK_IMPORTED_MODULE_1__.CodecId2String[codecId];
    let codec = '';
    if (codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */) {
        /*
         * avc1.profile_idc.constraint_set.level_idc
         * 每个参数 1 个字节压缩成 16 进制
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#iso_base_media_file_format_mp4_quicktime_and_3gp
         */
        // High 10 Profile 会提示不支持，但是能解码出来
        if (profile === 110 /* H264Profile.kHigh10 */) {
            profile = 100 /* H264Profile.kHigh */;
        }
        codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%02x00%02x', entry, profile & 0xff, level & 0xff);
    }
    else if (codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */) {
        /**
         *
         * hev1.[general_profile_space?general_profile_idc].[general_profile_compatibility_flags( 十六进制）][general_tier_flag general_level_idc][constraint_flags( 十六进制）]
         * general_profile_space:
         *  A -> 1
         *  B -> 2
         *  C -> 3
         * empty -> 0
         *
         * general_tier_flag:
         *  L -> 0
         *  H -> 1
         *
         */
        let generalProfileSpace = 0;
        let generalProfileCompatibilityFlags = 0;
        let generalTierFlag = 0;
        let constraintFlags = 0;
        if (extradata?.length > 13) {
            generalProfileSpace = (extradata[1] >>> 6) & 0x03;
            generalTierFlag = (extradata[1] >>> 5) & 0x01;
            generalProfileCompatibilityFlags = extradata[2] | (extradata[3] << 8) | (extradata[4] << 16) | (extradata[5] << 24);
            // constraintFlags 目前只能使用 4 个 bit
            constraintFlags = extradata[6] & 0xf0;
        }
        const generalProfileSpaceMap = {
            0: '',
            1: 'A',
            2: 'B',
            3: 'C'
        };
        codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%s%d.%x.%s%d.%x', entry, generalProfileSpaceMap[generalProfileSpace], profile, generalProfileCompatibilityFlags, generalTierFlag === 0 ? 'L' : 'H', level, constraintFlags);
    }
    else if (codecId === 196 /* AVCodecID.AV_CODEC_ID_VVC */) {
        /**
         *
         * vvc1.<sample entry 4CC>.<general_profile_idc>.[LH]<op_level_idc>{.C<general_constraint_info>}{.S<general_sub_profile_idc>}{.O{<OlsIdx>}{+<MaxTid>}}
         */
        let generalTierFlag = 0;
        if (extradata?.length > 13) {
            generalTierFlag = extradata[5] & 0x01;
        }
        codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%d.%s%d', entry, profile, generalTierFlag === 0 ? 'L' : 'H', level);
        if (extradata) {
            const params = avformat_codecs_vvc__WEBPACK_IMPORTED_MODULE_5__.parseExtraData(extradata);
            if (params.generalConstraintInfo.length) {
                let index = params.generalConstraintInfo.length - 1;
                while (index > 0 && params.generalConstraintInfo[index] === 0) {
                    index--;
                }
                const generalConstraintInfo = params.generalConstraintInfo.slice(0, index + 1);
                if (generalConstraintInfo.length) {
                    codec += `.C${common_util_base32__WEBPACK_IMPORTED_MODULE_9__.encode(new Uint8Array(generalConstraintInfo), false)}`;
                }
            }
            if (params.generalSubProfileIdc.length) {
                codec += `.S${params.generalSubProfileIdc.map((profile) => profile.toString(16)).join('+')}`;
            }
            codec += `.O${params.olsIdx}+${params.numSublayers}`;
        }
    }
    else if (codecId === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
        /*
         * av01.profile.level+seqTier.bitDepth[.monochrome[.chromaSubsampling[.colorPrimaries[.colorPrimaries[.matrixCoefficients]]]]]
         * url: https://aomediacodec.github.io/av1-isobmff/#codecsparam
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#av1
         */
        if (extradata) {
            const params = avformat_codecs_av1__WEBPACK_IMPORTED_MODULE_2__.parseExtraData(extradata);
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%d.%02d%s.%02d.%d.%d%d%d', entry, params.profile, params.level, params.tier ? 'H' : 'M', params.bitDepth, params.monochrome, params.chromaSubsamplingX, params.chromaSubsamplingY, params.chromaSamplePosition);
        }
        else {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%d.%02dM.08', entry, profile, level);
        }
    }
    else if (codecId === 139 /* AVCodecID.AV_CODEC_ID_VP8 */) {
        /*
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#videowebmcodecsvp08.00.41.08vorbis
         */
        if (extradata) {
            const params = avformat_codecs_vp8__WEBPACK_IMPORTED_MODULE_3__.parseExtraData(extradata);
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%02d.%02d.%02d', entry, params.profile, params.level, params.bitDepth);
        }
        else if (profile !== avutil_constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE && level !== avutil_constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE) {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%02d.%02d.08', entry, profile, level);
        }
        else {
            codec = entry;
        }
    }
    else if (codecId === 167 /* AVCodecID.AV_CODEC_ID_VP9 */) {
        /*
         * vp09.profile.level.colorDepth.chromaSubsampling[.colorPrimaries[.transferCharacteristics[.matrixCoefficients[.blackLevel and color range]]]]
         * url: https://www.webmproject.org/vp9/mp4/#CodecsParameterString
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#webm
         */
        if (extradata) {
            const params = avformat_codecs_vp9__WEBPACK_IMPORTED_MODULE_4__.parseExtraData(extradata);
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%02d.%02d.%02d.%02d.%02d.%02d.%02d.%02d', entry, params.profile, params.level, params.bitDepth, params.chromaSubsampling, params.colorPrimaries, params.colorTrc, params.colorSpace, params.fullRangeFlag);
        }
        else if (profile !== avutil_constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE && level !== avutil_constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE) {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%02d.%02d.08.00', entry, profile, level);
        }
        else {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%02d.%02d.08.00', entry, 0, 40);
        }
    }
    else {
        codec = entry || 'unknown';
    }
    return codec;
}


/***/ }),

/***/ "./src/avcodec/subtitle/SubtitleDecoder.ts":
/*!*************************************************!*\
  !*** ./src/avcodec/subtitle/SubtitleDecoder.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SubtitleDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var _decoder_WebVttDecoder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./decoder/WebVttDecoder */ "./src/avcodec/subtitle/decoder/WebVttDecoder.ts");
/* harmony import */ var _decoder_AssDecoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./decoder/AssDecoder */ "./src/avcodec/subtitle/decoder/AssDecoder.ts");
/* harmony import */ var _decoder_TtmlDecoder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./decoder/TtmlDecoder */ "./src/avcodec/subtitle/decoder/TtmlDecoder.ts");
/* harmony import */ var _decoder_TimedTextDecoder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./decoder/TimedTextDecoder */ "./src/avcodec/subtitle/decoder/TimedTextDecoder.ts");
/* harmony import */ var _decoder_TextDecoder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./decoder/TextDecoder */ "./src/avcodec/subtitle/decoder/TextDecoder.ts");







class SubtitleDecoder {
    options;
    frame;
    decoder;
    constructor(options) {
        this.options = options;
    }
    getAVFrame() {
        if (this.frame) {
            return this.frame;
        }
        return this.frame = {
            pts: BigInt(0),
            duration: BigInt(0),
            rects: [],
            timeBase: {
                den: 1,
                num: 1
            }
        };
    }
    outputAVFrame() {
        if (this.frame) {
            if (this.options.onReceiveSubtitle) {
                this.options.onReceiveSubtitle(this.frame);
            }
            this.frame = null;
        }
    }
    receiveAVFrame() {
        return this.decoder.receiveAVFrame(this.getAVFrame());
    }
    async open(parameters) {
        switch (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4)) {
            case 94226 /* AVCodecID.AV_CODEC_ID_WEBVTT */:
                this.decoder = new _decoder_WebVttDecoder__WEBPACK_IMPORTED_MODULE_2__["default"]();
                break;
            // case AVCodecID.AV_CODEC_ID_SUBRIP:
            //   this.decoder = new SubRipDecoder()
            //   break
            case 94232 /* AVCodecID.AV_CODEC_ID_TTML */:
                this.decoder = new _decoder_TtmlDecoder__WEBPACK_IMPORTED_MODULE_4__["default"]();
                break;
            case 94210 /* AVCodecID.AV_CODEC_ID_TEXT */:
            case 94225 /* AVCodecID.AV_CODEC_ID_SUBRIP */:
                this.decoder = new _decoder_TextDecoder__WEBPACK_IMPORTED_MODULE_6__["default"]();
                break;
            case 94213 /* AVCodecID.AV_CODEC_ID_MOV_TEXT */:
                this.decoder = new _decoder_TimedTextDecoder__WEBPACK_IMPORTED_MODULE_5__["default"]();
                break;
            case 94212 /* AVCodecID.AV_CODEC_ID_SSA */:
            case 94230 /* AVCodecID.AV_CODEC_ID_ASS */:
                this.decoder = new _decoder_AssDecoder__WEBPACK_IMPORTED_MODULE_3__["default"]();
                break;
            default:
                return avutil_error__WEBPACK_IMPORTED_MODULE_1__.CODEC_NOT_SUPPORT;
        }
        return 0;
    }
    decode(avpacket) {
        let ret = this.decoder.sendAVPacket(avpacket);
        if (ret) {
            return ret;
        }
        while (true) {
            ret = this.receiveAVFrame();
            if (ret === 1) {
                this.outputAVFrame();
            }
            else if (ret < 0) {
                return ret;
            }
            else {
                break;
            }
        }
        return 0;
    }
    async flush() {
        this.decoder.flush();
        while (1) {
            const ret = this.receiveAVFrame();
            if (ret < 1) {
                return;
            }
            this.outputAVFrame();
        }
    }
    close() {
        if (this.frame) {
            this.frame = null;
        }
    }
}


/***/ }),

/***/ "./src/avcodec/subtitle/decoder/AssDecoder.ts":
/*!****************************************************!*\
  !*** ./src/avcodec/subtitle/decoder/AssDecoder.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _Decoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Decoder */ "./src/avcodec/subtitle/decoder/Decoder.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_struct_avsubtitle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/struct/avsubtitle */ "./src/avutil/struct/avsubtitle.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");





class TextDecoder extends _Decoder__WEBPACK_IMPORTED_MODULE_1__["default"] {
    queue;
    constructor() {
        super();
        this.queue = [];
    }
    sendAVPacket(avpacket) {
        this.queue.push({
            data: (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_2__.getAVPacketData)(avpacket).slice(),
            pts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8),
            duration: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 48),
            timeBase: {
                den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 76),
                num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 72)
            }
        });
        return 0;
    }
    receiveAVFrame(sub) {
        if (this.queue.length) {
            const item = this.queue.shift();
            sub.pts = item.pts;
            sub.duration = item.duration;
            sub.timeBase.den = item.timeBase.den;
            sub.timeBase.num = item.timeBase.num;
            let line = common_util_text__WEBPACK_IMPORTED_MODULE_4__.decode(item.data);
            if (!/^\w+?\s*:/.test(line)) {
                line = 'Dialogue: ' + line;
            }
            sub.rects.push({
                type: avutil_struct_avsubtitle__WEBPACK_IMPORTED_MODULE_3__.AVSubtitleType.SUBTITLE_ASS,
                text: line,
                flags: 0
            });
            return 1;
        }
        return 0;
    }
    flush() {
        return 0;
    }
}


/***/ }),

/***/ "./src/avcodec/subtitle/decoder/Decoder.ts":
/*!*************************************************!*\
  !*** ./src/avcodec/subtitle/decoder/Decoder.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Decoder)
/* harmony export */ });
class Decoder {
}


/***/ }),

/***/ "./src/avcodec/subtitle/decoder/TextDecoder.ts":
/*!*****************************************************!*\
  !*** ./src/avcodec/subtitle/decoder/TextDecoder.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _Decoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Decoder */ "./src/avcodec/subtitle/decoder/Decoder.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_struct_avsubtitle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/struct/avsubtitle */ "./src/avutil/struct/avsubtitle.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");





class TextDecoder extends _Decoder__WEBPACK_IMPORTED_MODULE_1__["default"] {
    queue;
    constructor() {
        super();
        this.queue = [];
    }
    sendAVPacket(avpacket) {
        this.queue.push({
            data: (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_2__.getAVPacketData)(avpacket).slice(),
            pts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8),
            duration: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 48),
            timeBase: {
                den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 76),
                num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 72)
            }
        });
        return 0;
    }
    receiveAVFrame(sub) {
        if (this.queue.length) {
            const item = this.queue.shift();
            sub.pts = item.pts;
            sub.duration = item.duration;
            sub.timeBase.den = item.timeBase.den;
            sub.timeBase.num = item.timeBase.num;
            sub.rects.push({
                type: avutil_struct_avsubtitle__WEBPACK_IMPORTED_MODULE_3__.AVSubtitleType.SUBTITLE_TEXT,
                text: common_util_text__WEBPACK_IMPORTED_MODULE_4__.decode(item.data),
                flags: 0
            });
            return 1;
        }
        return 0;
    }
    flush() {
        return 0;
    }
}


/***/ }),

/***/ "./src/avcodec/subtitle/decoder/TimedTextDecoder.ts":
/*!**********************************************************!*\
  !*** ./src/avcodec/subtitle/decoder/TimedTextDecoder.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TimedTextDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _Decoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Decoder */ "./src/avcodec/subtitle/decoder/Decoder.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_struct_avsubtitle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/struct/avsubtitle */ "./src/avutil/struct/avsubtitle.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avcodec\\subtitle\\decoder\\TimedTextDecoder.ts";






class TimedTextDecoder extends _Decoder__WEBPACK_IMPORTED_MODULE_1__["default"] {
    queue;
    constructor() {
        super();
        this.queue = [];
    }
    sendAVPacket(avpacket) {
        const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_2__.getAVPacketData)(avpacket).slice();
        if (data.length < 2) {
            return 0;
        }
        const length = (data[0] << 8) | data[1];
        if (length + 2 > data.length) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.warn(`invalid timed text data, need ${length + 2} but got ${data.length}, ignore it`, cheap__fileName__0, 59);
            return 0;
        }
        const context = common_util_text__WEBPACK_IMPORTED_MODULE_4__.decode(data.subarray(2, 2 + length));
        this.queue.push({
            text: context,
            pts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8),
            duration: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 48),
            timeBase: {
                den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 76),
                num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 72)
            }
        });
        return 0;
    }
    receiveAVFrame(sub) {
        if (this.queue.length) {
            const item = this.queue.shift();
            sub.pts = item.pts;
            sub.duration = item.duration;
            sub.timeBase.den = item.timeBase.den;
            sub.timeBase.num = item.timeBase.num;
            sub.rects.push({
                type: avutil_struct_avsubtitle__WEBPACK_IMPORTED_MODULE_3__.AVSubtitleType.SUBTITLE_TEXT,
                text: item.text,
                flags: 0
            });
            return 1;
        }
        return 0;
    }
    flush() {
        return 0;
    }
}


/***/ }),

/***/ "./src/avcodec/subtitle/decoder/TtmlDecoder.ts":
/*!*****************************************************!*\
  !*** ./src/avcodec/subtitle/decoder/TtmlDecoder.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TtmlDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _Decoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Decoder */ "./src/avcodec/subtitle/decoder/Decoder.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avutil_struct_avsubtitle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/struct/avsubtitle */ "./src/avutil/struct/avsubtitle.ts");
/* harmony import */ var avformat_formats_ttml_ittml__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avformat/formats/ttml/ittml */ "./src/avformat/formats/ttml/ittml.ts");







class TtmlDecoder extends _Decoder__WEBPACK_IMPORTED_MODULE_1__["default"] {
    queue;
    constructor() {
        super();
        this.queue = [];
    }
    sendAVPacket(avpacket) {
        let context = common_util_text__WEBPACK_IMPORTED_MODULE_2__.decode((0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.getAVPacketData)(avpacket));
        if (!context) {
            return 0;
        }
        if (/<tt/.test(context.trim())) {
            this.queue = this.queue.concat(avformat_formats_ttml_ittml__WEBPACK_IMPORTED_MODULE_6__.parse(context).queue);
        }
        else {
            this.queue.push({
                pts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8),
                duration: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 48),
                context,
                region: 'Default'
            });
        }
        return 0;
    }
    receiveAVFrame(sub) {
        if (this.queue.length) {
            const item = this.queue.shift();
            sub.pts = item.pts;
            sub.duration = item.duration;
            sub.timeBase.den = avutil_constant__WEBPACK_IMPORTED_MODULE_4__.AV_MILLI_TIME_BASE;
            sub.timeBase.num = 1;
            sub.rects.push({
                type: avutil_struct_avsubtitle__WEBPACK_IMPORTED_MODULE_5__.AVSubtitleType.SUBTITLE_WEBVTT,
                text: item.context,
                flags: 0
            });
            return 1;
        }
        return 0;
    }
    flush() {
        return 0;
    }
}


/***/ }),

/***/ "./src/avcodec/subtitle/decoder/WebVttDecoder.ts":
/*!*******************************************************!*\
  !*** ./src/avcodec/subtitle/decoder/WebVttDecoder.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebVttDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _Decoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Decoder */ "./src/avcodec/subtitle/decoder/Decoder.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var common_util_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/time */ "./src/common/util/time.ts");
/* harmony import */ var avutil_struct_avsubtitle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/struct/avsubtitle */ "./src/avutil/struct/avsubtitle.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");







class WebVttDecoder extends _Decoder__WEBPACK_IMPORTED_MODULE_1__["default"] {
    queue;
    constructor() {
        super();
        this.queue = [];
    }
    findTimelineTag(constant) {
        const start = constant.indexOf('<');
        if (start >= 0) {
            const end = constant.indexOf('>', start);
            if (end > start) {
                if (/^(\d{2,}:)?\d{2}:\d{2}\.\d{1,3}$/.test(constant.substring(start + 1, end))) {
                    return {
                        start,
                        end
                    };
                }
            }
        }
        return {
            start: -1,
            end: -1,
        };
    }
    sendAVPacket(avpacket) {
        let context = common_util_text__WEBPACK_IMPORTED_MODULE_2__.decode((0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.getAVPacketData)(avpacket));
        let startPts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8);
        const endPts = startPts + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 48);
        const cache = [];
        while (true) {
            const { start, end } = this.findTimelineTag(context);
            if (start < 0) {
                break;
            }
            const pts = (0,common_util_time__WEBPACK_IMPORTED_MODULE_4__.hhColonDDColonSSDotMill2Int64)(context.substring(start + 1, end));
            cache.push(context.substring(0, start));
            this.queue.push({
                context: cache.join(''),
                pts: startPts,
                duration: pts - startPts,
                timeBase: {
                    den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 76),
                    num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 72)
                }
            });
            startPts = pts;
            context = context.substring(end + 1);
        }
        cache.push(context);
        this.queue.push({
            context: cache.join(''),
            pts: startPts,
            duration: endPts - startPts,
            timeBase: {
                den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 76),
                num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 72)
            }
        });
        return 0;
    }
    receiveAVFrame(sub) {
        if (this.queue.length) {
            const item = this.queue.shift();
            sub.pts = item.pts;
            sub.duration = item.duration;
            sub.timeBase.den = avutil_constant__WEBPACK_IMPORTED_MODULE_6__.AV_MILLI_TIME_BASE;
            sub.timeBase.num = 1;
            sub.rects.push({
                type: avutil_struct_avsubtitle__WEBPACK_IMPORTED_MODULE_5__.AVSubtitleType.SUBTITLE_WEBVTT,
                text: item.context,
                flags: 0
            });
            return 1;
        }
        return 0;
    }
    flush() {
        return 0;
    }
}


/***/ }),

/***/ "./src/avcodec/wasmcodec/AudioDecoder.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/wasmcodec/AudioDecoder.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WasmAudioDecoder)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var avutil_struct_avdict__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/struct/avdict */ "./src/avutil/struct/avdict.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/util/avdict */ "./src/avutil/util/avdict.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
var cheap__fileName__1 = "src\\avcodec\\wasmcodec\\AudioDecoder.ts";










class WasmAudioDecoder {
    options;
    decoder;
    frame;
    decoderOptions = 0;
    constructor(options) {
        this.options = options;
        this.decoder = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_1__["default"](options.resource);
    }
    getAVFrame() {
        if (this.frame) {
            return this.frame;
        }
        return this.frame = this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__.createAVFrame)();
    }
    outputAVFrame() {
        if (this.frame) {
            if (this.options.onReceiveFrame) {
                this.options.onReceiveFrame(this.frame);
            }
            else {
                this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__.destroyAVFrame)(this.frame);
            }
            this.frame = 0;
        }
    }
    receiveAVFrame() {
        return this.decoder.call('decoder_receive', this.getAVFrame());
    }
    async open(parameters, opts = {}) {
        await this.decoder.run();
        if (common_util_object__WEBPACK_IMPORTED_MODULE_6__.keys(opts).length) {
            if (this.decoderOptions) {
                avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__.freeAVDict2(this.decoderOptions);
                cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.decoderOptions);
                this.decoderOptions = 0;
            }
            this.decoderOptions = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMallocz)(8);
            common_util_object__WEBPACK_IMPORTED_MODULE_6__.each(opts, (value, key) => {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_8__.string(value) || common_util_is__WEBPACK_IMPORTED_MODULE_8__.string(key)) {
                    avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__.avDictSet(this.decoderOptions, key, value);
                }
            });
        }
        let ret = 0;
        if (common_util_support__WEBPACK_IMPORTED_MODULE_4__["default"].jspi) {
            ret = await this.decoder.callAsync('decoder_open', parameters, 0, 1, this.decoderOptions);
        }
        else {
            ret = this.decoder.call('decoder_open', parameters, 0, 1, this.decoderOptions);
            await this.decoder.childrenThreadReady();
        }
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_3__.fatal(`open audio decoder failed, ret: ${ret}`, cheap__fileName__1, 113);
        }
    }
    decode(avpacket) {
        let ret = this.decoder.call('decoder_decode', avpacket);
        if (ret) {
            return ret;
        }
        while (true) {
            ret = this.receiveAVFrame();
            if (ret === 1) {
                this.outputAVFrame();
            }
            else if (ret < 0) {
                return ret;
            }
            else {
                break;
            }
        }
        return 0;
    }
    async flush() {
        this.decoder.call('decoder_flush');
        while (1) {
            const ret = this.receiveAVFrame();
            if (ret < 1) {
                return;
            }
            this.outputAVFrame();
        }
    }
    close() {
        this.decoder.call('decoder_close');
        this.decoder.destroy();
        this.decoder = null;
        if (this.frame) {
            this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__.destroyAVFrame)(this.frame);
            this.frame = 0;
        }
        if (this.decoderOptions) {
            avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__.freeAVDict2(this.decoderOptions);
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.decoderOptions);
            this.decoderOptions = 0;
        }
    }
}


/***/ }),

/***/ "./src/avcodec/wasmcodec/VideoDecoder.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/wasmcodec/VideoDecoder.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WasmVideoDecoder)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var avutil_struct_avdict__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/struct/avdict */ "./src/avutil/struct/avdict.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/util/avdict */ "./src/avutil/util/avdict.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
var cheap__fileName__1 = "src\\avcodec\\wasmcodec\\VideoDecoder.ts";










class WasmVideoDecoder {
    options;
    decoder;
    frame;
    parameters;
    decoderOptions = 0;
    constructor(options) {
        this.options = options;
        this.decoder = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_1__["default"](this.options.resource);
    }
    getAVFrame() {
        if (this.frame) {
            return this.frame;
        }
        return this.frame = this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__.createAVFrame)();
    }
    outputAVFrame() {
        if (this.frame) {
            if (this.options.onReceiveFrame) {
                this.options.onReceiveFrame(this.frame);
            }
            else {
                this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__.destroyAVFrame)(this.frame);
            }
            this.frame = 0;
        }
    }
    receiveAVFrame() {
        return this.decoder.call('decoder_receive', this.getAVFrame());
    }
    async open(parameters, threadCount = 1, opts = {}) {
        await this.decoder.run(null, threadCount);
        let ret = 0;
        if (common_util_object__WEBPACK_IMPORTED_MODULE_6__.keys(opts).length) {
            if (this.decoderOptions) {
                avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__.freeAVDict2(this.decoderOptions);
                cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.decoderOptions);
                this.decoderOptions = 0;
            }
            this.decoderOptions = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMallocz)(8);
            common_util_object__WEBPACK_IMPORTED_MODULE_6__.each(opts, (value, key) => {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_8__.string(value) || common_util_is__WEBPACK_IMPORTED_MODULE_8__.string(key)) {
                    avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__.avDictSet(this.decoderOptions, key, value);
                }
            });
        }
        if (common_util_support__WEBPACK_IMPORTED_MODULE_4__["default"].jspi) {
            ret = await this.decoder.callAsync('decoder_open', parameters, 0, threadCount, this.decoderOptions);
        }
        else {
            ret = this.decoder.call('decoder_open', parameters, 0, threadCount, this.decoderOptions);
            await this.decoder.childrenThreadReady();
        }
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_3__.fatal(`open video decoder failed, ret: ${ret}`, cheap__fileName__1, 151);
        }
        this.parameters = parameters;
        await this.decoder.childrenThreadReady();
    }
    decode(avpacket) {
        let ret = this.decoder.call('decoder_decode', avpacket);
        if (ret) {
            return ret;
        }
        while (true) {
            ret = this.receiveAVFrame();
            if (ret === 1) {
                this.outputAVFrame();
            }
            else if (ret < 0) {
                return ret;
            }
            else {
                break;
            }
        }
        return 0;
    }
    async flush() {
        this.decoder.call('decoder_flush');
        while (1) {
            const ret = this.receiveAVFrame();
            if (ret < 1) {
                return;
            }
            this.outputAVFrame();
        }
    }
    close() {
        this.decoder.call('decoder_close');
        this.decoder.destroy();
        this.decoder = null;
        if (this.frame) {
            this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__.destroyAVFrame)(this.frame);
            this.frame = 0;
        }
        this.parameters = 0;
        if (this.decoderOptions) {
            avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__.freeAVDict2(this.decoderOptions);
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.decoderOptions);
            this.decoderOptions = 0;
        }
    }
    setSkipFrameDiscard(discard) {
        this.decoder.call('decoder_discard', discard);
    }
}


/***/ }),

/***/ "./src/avcodec/webcodec/AudioDecoder.ts":
/*!**********************************************!*\
  !*** ./src/avcodec/webcodec/AudioDecoder.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebAudioDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _function_getAudioCodec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/getAudioCodec */ "./src/avcodec/function/getAudioCodec.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_function_avpacket2EncodedAudioChunk__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/function/avpacket2EncodedAudioChunk */ "./src/avutil/function/avpacket2EncodedAudioChunk.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__9 = "src\\avcodec\\webcodec\\AudioDecoder.ts";






class WebAudioDecoder {
    options;
    decoder;
    parameters;
    extradata;
    currentError;
    constructor(options) {
        this.options = options;
    }
    output(frame) {
        if (this.options.onReceiveFrame) {
            this.options.onReceiveFrame(frame);
        }
        else {
            frame.close();
        }
    }
    error(error) {
        this.currentError = error;
        this.options.onError(error);
    }
    async open(parameters) {
        this.currentError = null;
        this.parameters = parameters;
        this.extradata = null;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12) !== 0) {
            this.extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 16)).slice();
        }
        const config = {
            codec: (0,_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_1__["default"])(this.parameters),
            sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 136),
            numberOfChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 116),
            description: this.extradata
        };
        if (!config.description) {
            // description 不是 arraybuffer 会抛错
            delete config.description;
        }
        const support = await AudioDecoder.isConfigSupported(config);
        if (!support.supported) {
            throw new Error('not support');
        }
        if (this.decoder && this.decoder.state !== 'closed') {
            this.decoder.close();
        }
        this.decoder = new AudioDecoder({
            output: this.output.bind(this),
            error: this.error.bind(this)
        });
        this.decoder.reset();
        this.decoder.configure(config);
        if (this.currentError) {
            throw this.currentError;
        }
    }
    changeExtraData(buffer) {
        if (buffer.length === this.extradata.length) {
            let same = true;
            for (let i = 0; i < buffer.length; i++) {
                if (buffer[i] !== this.extradata[i]) {
                    same = false;
                    break;
                }
            }
            if (same) {
                return;
            }
        }
        this.extradata = buffer.slice();
        this.decoder.reset();
        this.decoder.configure({
            codec: (0,_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_1__["default"])(this.parameters),
            sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.parameters + 136),
            numberOfChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.parameters + 116),
            description: this.extradata
        });
        if (this.currentError) {
            throw this.currentError;
        }
    }
    decode(avpacket, pts) {
        const element = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */);
        if (element !== 0) {
            this.changeExtraData((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](element), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](element + 4)));
        }
        const audioChunk = (0,avutil_function_avpacket2EncodedAudioChunk__WEBPACK_IMPORTED_MODULE_4__["default"])(avpacket, pts);
        try {
            this.decoder.decode(audioChunk);
        }
        catch (error) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`decode error, ${error}`, cheap__fileName__9, 155);
            return -1;
        }
        return 0;
    }
    async flush() {
        await this.decoder.flush();
    }
    close() {
        if (this.decoder.state !== 'closed') {
            this.decoder.close();
        }
        this.decoder = null;
    }
    getQueueLength() {
        return this.decoder.decodeQueueSize;
    }
    static async isSupported(parameters) {
        let extradata = null;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12) !== 0) {
            extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 16)).slice();
        }
        const config = {
            codec: (0,_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_1__["default"])(parameters),
            sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 136),
            numberOfChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 116),
            description: extradata
        };
        if (!config.description) {
            // description 不是 arraybuffer 会抛错
            delete config.description;
        }
        const support = await AudioDecoder.isConfigSupported(config);
        return support.supported;
    }
}


/***/ }),

/***/ "./src/avcodec/webcodec/VideoDecoder.ts":
/*!**********************************************!*\
  !*** ./src/avcodec/webcodec/VideoDecoder.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebVideoDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var _function_getVideoCodec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/getVideoCodec */ "./src/avcodec/function/getVideoCodec.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../function/getHardwarePreference */ "./src/avcodec/function/getHardwarePreference.ts");
/* harmony import */ var avutil_function_avpacket2EncodedVideoChunk__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/function/avpacket2EncodedVideoChunk */ "./src/avutil/function/avpacket2EncodedVideoChunk.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__10 = "src\\avcodec\\webcodec\\VideoDecoder.ts";








class WebVideoDecoder {
    decoder;
    options;
    parameters;
    extradata;
    currentError;
    inputQueue;
    outputQueue;
    sort;
    keyframeRequire;
    constructor(options) {
        this.options = options;
        this.inputQueue = [];
        this.outputQueue = [];
        this.sort = common_util_browser__WEBPACK_IMPORTED_MODULE_1__["default"].safari;
    }
    async output(frame) {
        if (this.sort) {
            let i = 0;
            for (; i < this.outputQueue.length; i++) {
                if (this.outputQueue[i].timestamp > frame.timestamp) {
                    this.outputQueue.splice(i, 0, frame);
                    break;
                }
            }
            if (i === this.outputQueue.length) {
                this.outputQueue.push(frame);
            }
            while (this.outputQueue.length > 2
                && this.outputQueue[0].timestamp === this.inputQueue[0]) {
                const output = this.outputQueue.shift();
                if (this.options.onReceiveFrame) {
                    this.options.onReceiveFrame(output);
                }
                else {
                    output.close();
                }
                this.inputQueue.shift();
            }
        }
        else {
            if (this.options.onReceiveFrame) {
                this.options.onReceiveFrame(frame);
            }
            else {
                frame.close();
            }
        }
    }
    error(error) {
        this.currentError = error;
        this.options.onError(error);
    }
    changeExtraData(buffer) {
        if (buffer.length === this.extradata.length) {
            let same = true;
            for (let i = 0; i < buffer.length; i++) {
                if (buffer[i] !== this.extradata[i]) {
                    same = false;
                    break;
                }
            }
            if (same) {
                return;
            }
        }
        this.extradata = buffer.slice();
        this.decoder.reset();
        this.decoder.configure({
            codec: (0,_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_2__["default"])(this.parameters, buffer),
            description: this.extradata,
            hardwareAcceleration: (0,_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_5__.getHardwarePreference)(this.options.enableHardwareAcceleration ?? true)
        });
        this.keyframeRequire = true;
    }
    async open(parameters) {
        this.currentError = null;
        this.extradata = null;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12) !== 0) {
            this.extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 16)).slice();
        }
        this.parameters = parameters;
        const config = {
            codec: (0,_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_2__["default"])(parameters),
            codedWidth: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 56),
            codedHeight: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 60),
            description: (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 160) !== 2 /* BitFormat.ANNEXB */) ? this.extradata : undefined,
            hardwareAcceleration: (0,_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_5__.getHardwarePreference)(this.options.enableHardwareAcceleration ?? true)
        };
        if (!config.description) {
            // description 不是 arraybuffer 会抛错
            delete config.description;
        }
        const support = await VideoDecoder.isConfigSupported(config);
        if (!support.supported) {
            throw new Error('not support');
        }
        if (this.decoder && this.decoder.state !== 'closed') {
            this.decoder.close();
        }
        this.decoder = new VideoDecoder({
            output: this.output.bind(this),
            error: this.error.bind(this)
        });
        this.decoder.reset();
        this.decoder.configure(config);
        if (this.currentError) {
            throw this.currentError;
        }
        this.keyframeRequire = true;
        this.inputQueue.length = 0;
        this.outputQueue.length = 0;
    }
    decode(avpacket) {
        const element = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_4__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */);
        if (element !== 0) {
            this.changeExtraData((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](element), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](element + 4)));
        }
        const key = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */;
        if (this.keyframeRequire && !key) {
            return 0;
        }
        const timestamp = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8));
        const videoChunk = (0,avutil_function_avpacket2EncodedVideoChunk__WEBPACK_IMPORTED_MODULE_6__["default"])(avpacket);
        if (this.sort) {
            let i = 0;
            for (; i < this.inputQueue.length; i++) {
                if (this.inputQueue[i] > timestamp) {
                    this.inputQueue.splice(i, 0, timestamp);
                    break;
                }
            }
            if (i === this.inputQueue.length) {
                this.inputQueue.push(timestamp);
            }
        }
        try {
            this.decoder.decode(videoChunk);
        }
        catch (error) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.error(`decode error, ${error}`, cheap__fileName__10, 223);
            return -1;
        }
        if (key) {
            this.keyframeRequire = false;
        }
        return 0;
    }
    async flush() {
        await this.decoder.flush();
        if (this.sort) {
            while (this.outputQueue.length) {
                const frame = this.outputQueue.shift();
                if (this.options.onReceiveFrame) {
                    this.options.onReceiveFrame(frame);
                }
                else {
                    frame.close();
                }
            }
        }
        this.keyframeRequire = true;
    }
    close() {
        if (this.decoder && this.decoder.state !== 'closed') {
            this.decoder.close();
        }
        this.decoder = null;
        this.currentError = null;
        if (this.outputQueue?.length) {
            this.outputQueue.forEach((frame) => {
                frame.close();
            });
        }
        this.inputQueue = null;
        this.outputQueue = null;
    }
    getQueueLength() {
        return this.decoder.decodeQueueSize;
    }
    setSkipFrameDiscard(discard) {
    }
    static async isSupported(parameters, enableHardwareAcceleration) {
        let extradata = null;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12) !== 0) {
            extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 16)).slice();
        }
        const config = {
            codec: (0,_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_2__["default"])(parameters),
            codedWidth: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 56),
            codedHeight: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 60),
            description: (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 160) !== 2 /* BitFormat.ANNEXB */) ? extradata : undefined,
            hardwareAcceleration: (0,_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_5__.getHardwarePreference)(enableHardwareAcceleration ?? true)
        };
        if (!config.description) {
            // description 不是 arraybuffer 会抛错
            delete config.description;
        }
        const support = await VideoDecoder.isConfigSupported(config);
        return support.supported;
    }
}


/***/ }),

/***/ "./src/avformat/AVFormatContext.ts":
/*!*****************************************!*\
  !*** ./src/avformat/AVFormatContext.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVFormatContext: () => (/* binding */ AVFormatContext),
/* harmony export */   createAVIFormatContext: () => (/* binding */ createAVIFormatContext),
/* harmony export */   createAVOFormatContext: () => (/* binding */ createAVOFormatContext)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _AVStream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AVStream */ "./src/avformat/AVStream.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var cheap_staticData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/staticData */ "./src/cheap/staticData.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");






// 在静态区分配 stream 计数器和计数器操作锁
const streamCounter = cheap_staticData__WEBPACK_IMPORTED_MODULE_4__.malloc(4, 4);
const streamCounterMutex = cheap_staticData__WEBPACK_IMPORTED_MODULE_4__.malloc(4, 4);
class AVFormatContextInterval {
    packetBuffer;
    constructor() {
        this.packetBuffer = [];
    }
}
class AVFormatContext {
    metadataHeaderPadding = -1;
    metadata;
    streams;
    options;
    chapters;
    privateData;
    processPrivateData;
    iformat;
    oformat;
    // @ts-ignore
    ioReader;
    ioWriter;
    errorFlag;
    interval;
    streamIndex;
    getDecoderResource = null;
    constructor() {
        this.streams = [];
        this.errorFlag = 0;
        this.streamIndex = 0;
        this.interval = new AVFormatContextInterval();
        this.options = {};
        this.privateData = {};
        this.metadata = {};
        this.chapters = [];
    }
    get format() {
        if (this.iformat) {
            return this.iformat.type;
        }
        else if (this.oformat) {
            return this.oformat.type;
        }
        return -1 /* AVFormat.UNKNOWN */;
    }
    getStreamById(id) {
        return this.streams.find((stream) => stream.id === id);
    }
    getStreamByIndex(index) {
        return this.streams.find((stream) => stream.index === index);
    }
    getStreamByMediaType(mediaType) {
        return this.streams.find((stream) => stream.codecpar?.codecType === mediaType);
    }
    createStream() {
        const stream = new _AVStream__WEBPACK_IMPORTED_MODULE_2__["default"]();
        stream.index = this.streamIndex++;
        {
            (0,cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_5__.lock)(streamCounterMutex);
        }
        stream.id = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](streamCounter);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](streamCounter, stream.id + 1);
        {
            (0,cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_5__.unlock)(streamCounterMutex);
        }
        this.removeStreamByIndex(stream.index);
        this.streams.push(stream);
        return stream;
    }
    addStream(stream) {
        this.removeStreamByIndex(stream.index);
        this.streams.push(stream);
    }
    removeStream(stream) {
        this.removeStreamByIndex(stream.index);
    }
    removeStreamById(id) {
        const index = this.streams.findIndex((stream) => stream.id === id);
        if (index > -1) {
            const st = this.streams.splice(index, 1);
            if (st[0]) {
                st[0].destroy();
            }
        }
    }
    removeStreamByIndex(i) {
        const index = this.streams.findIndex((stream) => stream.index === i);
        if (index > -1) {
            const st = this.streams.splice(index, 1);
            if (st[0]) {
                st[0].destroy();
            }
        }
    }
    destroy() {
        if (this.oformat) {
            this.oformat.destroy(this);
        }
        if (this.iformat) {
            this.iformat.destroy(this);
        }
        if (this.interval.packetBuffer.length) {
            this.interval.packetBuffer.forEach((avpacket) => {
                (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(avpacket);
            });
        }
        this.streams.forEach((stream) => {
            stream.destroy();
        });
        this.streams = [];
        this.interval = null;
        this.ioReader = this.ioWriter = null;
        this.oformat = this.iformat = null;
    }
}
/**
 * 创建 AVIFormatContext
 *
 * @returns
 */
function createAVIFormatContext() {
    return new AVFormatContext();
}
/**
 * 创建 AVOFormatContext
 *
 * @returns
 */
function createAVOFormatContext() {
    return new AVFormatContext();
}


/***/ }),

/***/ "./src/avformat/AVStream.ts":
/*!**********************************!*\
  !*** ./src/avformat/AVStream.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVStream)
/* harmony export */ });
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var avutil_struct_avcodecparameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/struct/avcodecparameters */ "./src/avutil/struct/avcodecparameters.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avutil_struct_rational__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/struct/rational */ "./src/avutil/struct/rational.ts");





/**
 * from FFmpeg
 *
 */
class AVStream {
    /**
     * stream index in AVFormatContext
     */
    index = avutil_constant__WEBPACK_IMPORTED_MODULE_3__.NOPTS_VALUE;
    /**
     * Format-specific stream ID.
     * decoding: set by libavformat
     * encoding: set by the user, replaced by libavformat if left unset
     */
    id = avutil_constant__WEBPACK_IMPORTED_MODULE_3__.NOPTS_VALUE;
    privData = null;
    codecpar = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_0__["default"])(avutil_struct_avcodecparameters__WEBPACK_IMPORTED_MODULE_2__["default"], new avutil_struct_avcodecparameters__WEBPACK_IMPORTED_MODULE_2__["default"]());
    /**
     * An array of side data that applies to the whole stream (i.e. the
     * container does not allow it to change between packets).
     *
     * There may be no overlap between the side data in this array and side data
     * in the packets. I.e. a given side data is either exported by the muxer
     * (demuxing) / set by the caller (muxing) in this array, then it never
     * appears in the packets, or the side data is exported / sent through
     * the packets (always in the first packet where the value becomes known or
     * changes), then it does not appear in this array.
     *
     * - demuxing: Set by libavformat when the stream is created.
     * - muxing: May be set by the caller before write_header().
     *
     */
    sideData = {};
    /**
     * number of frames in this stream if known or 0
     */
    nbFrames = BigInt(0);
    metadata = {};
    /**
     * Decoding: duration of the stream, in stream time base.
     * If a source file does not specify a duration, but does specify
     * a bitrate, this value will be estimated from bitrate and file size.
     *
     * Encoding: May be set by the caller before avformat_write_header() to
     * provide a hint to the muxer about the estimated duration.
     */
    duration = avutil_constant__WEBPACK_IMPORTED_MODULE_3__.NOPTS_VALUE_BIGINT;
    /**
     * Decoding: pts of the first frame of the stream in presentation order, in stream time base.
     * Only set this if you are absolutely 100% sure that the value you set
     * it to really is the pts of the first frame.
     * This may be undefined (AV_NOPTS_VALUE).
     * @note The ASF header does NOT contain a correct start_time the ASF
     * demuxer must NOT set this.
     */
    startTime = avutil_constant__WEBPACK_IMPORTED_MODULE_3__.NOPTS_VALUE_BIGINT;
    /**
     * 第一个 packet 的 dts
     */
    firstDTS = BigInt(0);
    /**
     * AV_DISPOSITION_* bit field
     */
    disposition = 0 /* AVDisposition.NONE */;
    /**
     *
     * 封装时间基
     *
     * decoding: set by libavformat
     * encoding: May be set by the caller before avformat_write_header() to
     *           provide a hint to the muxer about the desired timebase. In
     *           avformat_write_header(), the muxer will overwrite this field
     *           with the timebase that will actually be used for the timestamps
     *           written into the file (which may or may not be related to the
     *           user-provided one, depending on the format).
     */
    timeBase = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_0__["default"])(avutil_struct_rational__WEBPACK_IMPORTED_MODULE_4__.Rational);
    /**
     * 帧索引，可用于 seek
     */
    sampleIndexes = [];
    /**
     * pos 到 sample index 的映射
     */
    sampleIndexesPosMap = new Map();
    destroy() {
        if (this.codecpar) {
            this.codecpar.destroy();
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_1__["default"])(this.codecpar);
            this.codecpar = null;
        }
        if (this.timeBase) {
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_1__["default"])(this.timeBase);
            this.timeBase = null;
        }
        this.sampleIndexes.length = 0;
        this.sampleIndexesPosMap.clear();
    }
}


/***/ }),

/***/ "./src/avformat/bsf/AVBSFilter.ts":
/*!****************************************!*\
  !*** ./src/avformat/bsf/AVBSFilter.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVBSFilter)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avutil_struct_avcodecparameters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/struct/avcodecparameters */ "./src/avutil/struct/avcodecparameters.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/codecparameters */ "./src/avutil/util/codecparameters.ts");




class AVBSFilter {
    inCodecpar;
    inTimeBase;
    outCodecpar;
    init(codecpar, timeBase) {
        this.inCodecpar = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__.avMallocz)(168);
        (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_3__.copyCodecParameters)(this.inCodecpar, codecpar);
        this.inTimeBase = {
            den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](timeBase + 4),
            num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](timeBase)
        };
        return 0;
    }
    destroy() {
        if (this.inCodecpar) {
            (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_3__.freeCodecParameters)(this.inCodecpar);
            this.inCodecpar = 0;
        }
    }
}


/***/ }),

/***/ "./src/avformat/bsf/h2645/Annexb2AvccFilter.ts":
/*!*****************************************************!*\
  !*** ./src/avformat/bsf/h2645/Annexb2AvccFilter.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Annexb2AvccFilter)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _AVBSFilter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../AVBSFilter */ "./src/avformat/bsf/AVBSFilter.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _codecs_h264__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../codecs/h264 */ "./src/avformat/codecs/h264.ts");
/* harmony import */ var _codecs_hevc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../codecs/hevc */ "./src/avformat/codecs/hevc.ts");
/* harmony import */ var _codecs_vvc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../codecs/vvc */ "./src/avformat/codecs/vvc.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/nalu */ "./src/avutil/util/nalu.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__6 = "src\\avformat\\bsf\\h2645\\Annexb2AvccFilter.ts";












class Annexb2AvccFilter extends _AVBSFilter__WEBPACK_IMPORTED_MODULE_2__["default"] {
    cache;
    cached;
    init(codecpar, timeBase) {
        super.init(codecpar, timeBase);
        this.cache = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.createAVPacket)();
        this.cached = false;
        return 0;
    }
    destroy() {
        super.destroy();
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(this.cache);
        this.cache = 0;
    }
    sendAVPacket(avpacket) {
        const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.mapSafeUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 80) === 1 /* h264.BitFormat.AVCC */ || !(0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.isAnnexb)(buffer)) {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.refAVPacket)(this.cache, avpacket);
        }
        else {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.copyAVPacketProps)(this.cache, avpacket);
            let convert;
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.inCodecpar + 4) === 27 /* AVCodecID.AV_CODEC_ID_H264 */) {
                convert = _codecs_h264__WEBPACK_IMPORTED_MODULE_4__.annexb2Avcc(buffer);
            }
            else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.inCodecpar + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */) {
                convert = _codecs_hevc__WEBPACK_IMPORTED_MODULE_5__.annexb2Avcc(buffer);
            }
            else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.inCodecpar + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */) {
                convert = _codecs_vvc__WEBPACK_IMPORTED_MODULE_6__.annexb2Avcc(buffer);
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal(`not support for codecId: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.inCodecpar + 4)}`, cheap__fileName__6, 91);
            }
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.cache + 80, 1 /* h264.BitFormat.AVCC */);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.addAVPacketData)(this.cache, convert.bufferPointer, convert.length);
            if (convert.key) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.cache + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.cache + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
            }
            if (convert.extradata) {
                const extradata = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_10__.avMalloc)(convert.extradata.length);
                (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.memcpyFromUint8Array)(extradata, convert.extradata.length, convert.extradata);
                (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.addAVPacketSideData)(this.cache, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradata, convert.extradata.length);
            }
        }
        this.cached = true;
        return 0;
    }
    receiveAVPacket(avpacket) {
        if (this.cached) {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.unrefAVPacket)(avpacket);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.refAVPacket)(avpacket, this.cache);
            this.cached = false;
            return 0;
        }
        else {
            return avutil_error__WEBPACK_IMPORTED_MODULE_8__.DATA_INVALID;
        }
    }
}


/***/ }),

/***/ "./src/avformat/codecs/aac.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/aac.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AACProfile2Name: () => (/* binding */ AACProfile2Name),
/* harmony export */   MPEG4Channels: () => (/* binding */ MPEG4Channels),
/* harmony export */   MPEG4SamplingFrequencies: () => (/* binding */ MPEG4SamplingFrequencies),
/* harmony export */   avCodecParameters2Extradata: () => (/* binding */ avCodecParameters2Extradata),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters)
/* harmony export */ });
/* unused harmony exports MPEG4SamplingFrequencyIndex, getAVCodecParameters */
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/*
 * libmedia aac util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const AACProfile2Name = {
    [1 /* MPEG4AudioObjectTypes.AAC_MAIN */]: 'Main',
    [2 /* MPEG4AudioObjectTypes.AAC_LC */]: 'LC',
    [3 /* MPEG4AudioObjectTypes.AAC_SSR */]: 'LC',
    [4 /* MPEG4AudioObjectTypes.AAC_LTP */]: 'LC',
    [5 /* MPEG4AudioObjectTypes.AAC_SBR */]: 'HE',
    [6 /* MPEG4AudioObjectTypes.AAC_SCALABLE */]: 'HE'
};
const MPEG4SamplingFrequencyIndex = {
    96000: 0,
    88200: 1,
    64000: 2,
    48000: 3,
    44100: 4,
    32000: 5,
    24000: 6,
    22050: 7,
    16000: 8,
    12000: 9,
    11025: 10,
    8000: 11,
    7350: 12
};
const MPEG4SamplingFrequencies = [
    96000,
    88200,
    64000,
    48000,
    44100,
    32000,
    24000,
    22050,
    16000,
    12000,
    11025,
    8000,
    7350,
    avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
    avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
    avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE
];
const MPEG4Channels = [
    avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
    1,
    2,
    3,
    4,
    5,
    6,
    7
];
/**
 * 解析 AAC AudioSpecificConfig
 *
 *             frequency
 *              44100Hz        fill bit
 *               4 bit          3 bit
 *              -------         -----
 *    0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0
 *    ---------         -------
 *      5 bit            4 bit
 *     AAC LC           fl, fr
 *    profile           channel
 *
 * url: https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Audio_Specific_Config
 *
 */
function getAVCodecParameters(extradata) {
    let profile = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    let sampleRate = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    let channels = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    if (extradata.length >= 2) {
        profile = (extradata[0] >> 3) & 0x1f;
        sampleRate = MPEG4SamplingFrequencies[((extradata[0] & 0x07) << 1)
            | (extradata[1] >> 7)] ?? 48000;
        channels = MPEG4Channels[(extradata[1] >> 3) & 0x0f] ?? 2;
    }
    return {
        profile,
        sampleRate,
        channels
    };
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata) {
        const { profile, sampleRate, channels } = getAVCodecParameters(extradata);
        stream.codecpar.profile = profile;
        stream.codecpar.sampleRate = sampleRate;
        stream.codecpar.chLayout.nbChannels = channels;
    }
}
function avCodecParameters2Extradata(codecpar) {
    const samplingFreqIndex = MPEG4SamplingFrequencyIndex[codecpar.sampleRate];
    const channelConfig = codecpar.chLayout.nbChannels;
    const extradata = new Uint8Array(2);
    extradata[0] = ((codecpar.profile & 0x1f) << 3) | ((samplingFreqIndex & 0x0e) >> 1);
    extradata[1] = ((samplingFreqIndex & 0x01) << 7) | ((channelConfig & 0x0f) << 3);
    return extradata;
}


/***/ }),

/***/ "./src/avformat/codecs/ac3.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/ac3.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AC3ChannelLayout: () => (/* binding */ AC3ChannelLayout),
/* harmony export */   parseHeader: () => (/* binding */ parseHeader)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/*
 * libmedia ac3 util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


const AC3ChannelLayout = [
    3 /* AV_CH_LAYOUT.AV_CH_LAYOUT_STEREO */,
    4 /* AV_CH_LAYOUT.AV_CH_LAYOUT_MONO */,
    3 /* AV_CH_LAYOUT.AV_CH_LAYOUT_STEREO */,
    7 /* AV_CH_LAYOUT.AV_CH_LAYOUT_SURROUND */,
    259 /* AV_CH_LAYOUT.AV_CH_LAYOUT_2_1 */,
    263 /* AV_CH_LAYOUT.AV_CH_LAYOUT_4POINT0 */,
    1539 /* AV_CH_LAYOUT.AV_CH_LAYOUT_2_2 */,
    1543 /* AV_CH_LAYOUT.AV_CH_LAYOUT_5POINT0 */
];
const AC3FrameSizeTab = [
    [64, 69, 96],
    [64, 70, 96],
    [80, 87, 120],
    [80, 88, 120],
    [96, 104, 144],
    [96, 105, 144],
    [112, 121, 168],
    [112, 122, 168],
    [128, 139, 192],
    [128, 140, 192],
    [160, 174, 240],
    [160, 175, 240],
    [192, 208, 288],
    [192, 209, 288],
    [224, 243, 336],
    [224, 244, 336],
    [256, 278, 384],
    [256, 279, 384],
    [320, 348, 480],
    [320, 349, 480],
    [384, 417, 576],
    [384, 418, 576],
    [448, 487, 672],
    [448, 488, 672],
    [512, 557, 768],
    [512, 558, 768],
    [640, 696, 960],
    [640, 697, 960],
    [768, 835, 1152],
    [768, 836, 1152],
    [896, 975, 1344],
    [896, 976, 1344],
    [1024, 1114, 1536],
    [1024, 1115, 1536],
    [1152, 1253, 1728],
    [1152, 1254, 1728],
    [1280, 1393, 1920],
    [1280, 1394, 1920],
];
const CenterLevelsTab = [4, 5, 6, 5];
const SurroundLevelsTab = [4, 6, 7, 6];
const AC3SampleRateTab = [48000, 44100, 32000, 0];
const AC3BitrateTab = [
    32, 40, 48, 56, 64, 80, 96, 112, 128,
    160, 192, 224, 256, 320, 384, 448, 512, 576, 640
];
const AC3ChannelsTab = [
    2, 1, 2, 3, 3, 4, 4, 5
];
const EAC3Blocks = [
    1, 2, 3, 6
];
const AC3_HEADER_SIZE = 7;
function parseHeader(buf, size) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__["default"](size);
    bitReader.appendBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(buf, size));
    const info = {
        syncWord: 0,
        crc1: 0,
        srCode: 0,
        bitstreamId: 0,
        bitstreamMode: 0,
        channelMode: 0,
        lfeOn: 0,
        frameType: 0,
        substreamId: 0,
        centerMixLevel: 0,
        surroundMixLevel: 0,
        channelMap: 0,
        numBlocks: 0,
        dolbySurroundMode: 0,
        srShift: 0,
        sampleRate: 0,
        bitRate: 0,
        channels: 0,
        frameSize: 0,
        channelLayout: BigInt(0),
        ac3BitrateCode: 0
    };
    info.syncWord = bitReader.readU(16);
    if (info.syncWord !== 0x0B77) {
        return -1;
    }
    info.bitstreamId = bitReader.readU(29) & 0x1f;
    if (info.bitstreamId > 16) {
        return -2;
    }
    info.numBlocks = 6;
    info.ac3BitrateCode = -1;
    info.centerMixLevel = 5;
    info.surroundMixLevel = 6;
    info.dolbySurroundMode = 0 /* AC3DolbySurroundMode.AC3_DSURMOD_NOTINDICATED */;
    if (info.bitstreamId <= 10) {
        info.crc1 = bitReader.readU(16);
        info.srCode = bitReader.readU(2);
        if (info.srCode === 3) {
            return -3;
        }
        const frameSizeCode = bitReader.readU(6);
        if (frameSizeCode > 37) {
            return -4;
        }
        info.ac3BitrateCode = (frameSizeCode >> 1);
        bitReader.readU(5);
        info.bitstreamMode = bitReader.readU(3);
        info.channelMode = bitReader.readU(3);
        if (info.channelMode == 2 /* AC3ChannelMode.AC3_CHMODE_STEREO */) {
            info.dolbySurroundMode = bitReader.readU(2);
        }
        else {
            if ((info.channelMode & 1) && info.channelMode != 1 /* AC3ChannelMode.AC3_CHMODE_MONO */) {
                info.centerMixLevel = CenterLevelsTab[bitReader.readU(2)];
            }
            if (info.channelMode & 4) {
                info.surroundMixLevel = SurroundLevelsTab[bitReader.readU(2)];
            }
        }
        info.lfeOn = bitReader.readU(1);
        info.srShift = Math.max(info.bitstreamId, 8) - 8;
        info.sampleRate = AC3SampleRateTab[info.srCode] >> info.srShift;
        info.bitRate = (AC3BitrateTab[info.ac3BitrateCode] * 1000) >> info.srShift;
        info.channels = AC3ChannelsTab[info.channelMode] + info.lfeOn;
        info.frameSize = AC3FrameSizeTab[frameSizeCode][info.srCode] * 2;
        info.frameType = 2 /* EAC3FrameType.EAC3_FRAME_TYPE_AC3_CONVERT */;
        info.substreamId = 0;
    }
    else {
        /* Enhanced AC-3 */
        info.crc1 = 0;
        info.frameType = bitReader.readU(2);
        if (info.frameType == 3 /* EAC3FrameType.EAC3_FRAME_TYPE_RESERVED */) {
            return -5;
        }
        info.substreamId = bitReader.readU(3);
        info.frameSize = (bitReader.readU(11) + 1) << 1;
        if (info.frameSize < AC3_HEADER_SIZE) {
            return -6;
        }
        info.srCode = bitReader.readU(2);
        if (info.srCode == 3) {
            const srCode2 = bitReader.readU(2);
            if (srCode2 == 3) {
                return -7;
            }
            info.sampleRate = AC3SampleRateTab[srCode2] / 2;
            info.srShift = 1;
        }
        else {
            info.numBlocks = EAC3Blocks[bitReader.readU(2)];
            info.sampleRate = AC3SampleRateTab[info.srCode];
            info.srShift = 0;
        }
        info.channelMode = bitReader.readU(3);
        info.lfeOn = bitReader.readU(1);
        info.bitRate = 8 * info.frameSize * info.sampleRate / (info.numBlocks * 256);
        info.channels = AC3ChannelsTab[info.channelMode] + info.lfeOn;
    }
    info.channelLayout = BigInt.asUintN(64, AC3ChannelLayout[info.channelMode]);
    if (info.lfeOn) {
        info.channelLayout |= BigInt(8 /* AV_CH_LAYOUT.AV_CH_LOW_FREQUENCY */);
    }
    return info;
}


/***/ }),

/***/ "./src/avformat/codecs/av1.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/av1.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AV1Profile2Name: () => (/* binding */ AV1Profile2Name),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseExtraData: () => (/* binding */ parseExtraData)
/* harmony export */ });
/* unused harmony exports LevelCapabilities, AV1LevelIdx, getLevelByResolution, parseSequenceHeader, splitOBU, generateExtradata */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/av1syntax */ "./src/avutil/util/av1syntax.ts");
/* harmony import */ var common_io_BitWriter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/io/BitWriter */ "./src/common/io/BitWriter.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");





const AV1Profile2Name = {
    [0 /* AV1Profile.Main */]: 'Main',
    [1 /* AV1Profile.High */]: 'High',
    [2 /* AV1Profile.Professional */]: 'Professional'
};
const LevelCapabilities = [
    { level: 20, maxResolution: 2359296 },
    { level: 21, maxResolution: 4460544 },
    { level: 30, maxResolution: 10653696 },
    { level: 31, maxResolution: 17040384 },
    { level: 40, maxResolution: 21233664 },
    { level: 41, maxResolution: 21233664 },
    { level: 50, maxResolution: 35651584 },
    { level: 51, maxResolution: 35651584 },
    { level: 52, maxResolution: 35651584 },
    { level: 53, maxResolution: 35651584 },
    { level: 60, maxResolution: 142606336 },
    { level: 61, maxResolution: 142606336 },
    { level: 62, maxResolution: 142606336 },
    { level: 63, maxResolution: 142606336 }
];
const AV1LevelIdx = [20, 21, 22, 23, 30, 31, 32, 33, 40, 41, 42, 43, 50, 51, 52, 53, 60, 61, 62, 63, 70, 71, 72, 73];
function getLevelByResolution(width, height, fps) {
    const resolution = width * height;
    for (const level of LevelCapabilities) {
        if (resolution <= level.maxResolution) {
            return level.level;
        }
    }
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 4) {
        const params = parseExtraData(extradata);
        stream.codecpar.profile = params.profile;
        stream.codecpar.level = params.level;
    }
}
/**
 * - 1 bit marker
 * - 7 bit version
 * - 3 bit profile
 * - 5 bit level
 * - 1 bit tier
 * - 1 bit bitdepth > 8
 * - 1 bit bitdepth == 12
 * - 1 bit monochrome
 * - 1 bit chroma_subsampling_x
 * - 1 bit chroma_subsampling_y
 * - 2 bit chroma_sample_position
 * - 8 bit padding
 *
 * @param header
 */
function parseExtraData(extradata) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__["default"](extradata.length);
    bitReader.appendBuffer(extradata);
    // marker
    bitReader.readU1();
    // version
    bitReader.readU(7);
    const profile = bitReader.readU(3);
    const level = bitReader.readU(5);
    const tier = bitReader.readU1();
    let bitDepth = bitReader.readU1() ? 10 : 8;
    if (bitReader.readU1()) {
        bitDepth = 12;
    }
    const monochrome = bitReader.readU1();
    const chromaSubsamplingX = bitReader.readU1();
    const chromaSubsamplingY = bitReader.readU1();
    const chromaSamplePosition = bitReader.readU(2);
    return {
        profile,
        level,
        tier,
        bitDepth,
        monochrome,
        chromaSubsamplingX,
        chromaSubsamplingY,
        chromaSamplePosition
    };
}
/* eslint-disable camelcase */
function parseSequenceHeader(header) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__["default"](header.length);
    bitReader.appendBuffer(header);
    bitReader.readU1();
    bitReader.readU(4);
    const extensionFlag = bitReader.readU1();
    const hasSizeFlag = bitReader.readU1();
    // obu_reserved_1bit
    bitReader.readU1();
    if (extensionFlag) {
        bitReader.readU(8);
    }
    if (hasSizeFlag) {
        avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.leb128(bitReader);
    }
    const seq_profile = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 3);
    const still_picture = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    const reduced_still_picture_header = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let timing_info_present_flag = 0;
    let decoder_model_info_present_flag = 0;
    let initial_display_delay_present_flag = 0;
    let operating_points_cnt_minus_1 = 0;
    let operating_point_idc = [0];
    let seq_level_idx = [0];
    let seq_tier = [0];
    let decoder_model_present_for_this_op = [0];
    let initial_display_delay_present_for_this_op = [0];
    let initial_display_delay_minus_1 = [0];
    let buffer_delay_length_minus_1 = 0;
    let decoder_buffer_delay = [0];
    let encoder_buffer_delay = [0];
    let low_delay_mode_flag = [0];
    if (reduced_still_picture_header) {
        seq_level_idx[0] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 5);
    }
    else {
        timing_info_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        if (timing_info_present_flag) {
            let num_units_in_display_tick = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 32);
            let time_scale = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 32);
            let equal_picture_interval = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
            if (equal_picture_interval) {
                let num_ticks_per_picture_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.uvlc(bitReader);
            }
            let decoder_model_info_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
            if (decoder_model_info_present_flag) {
                buffer_delay_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 5);
                let num_units_in_decoding_tick = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 32);
                let buffer_removal_time_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 5);
                let frame_presentation_time_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 5);
            }
        }
        else {
            decoder_model_info_present_flag = 0;
        }
        let initial_display_delay_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        let operating_points_cnt_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 5);
        for (let i = 0; i <= operating_points_cnt_minus_1; i++) {
            operating_point_idc[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 12);
            seq_level_idx[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 5);
            if (seq_level_idx[i] > 7) {
                seq_tier[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
            }
            else {
                seq_tier[i] = 0;
            }
            if (decoder_model_info_present_flag) {
                decoder_model_present_for_this_op[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
                if (decoder_model_present_for_this_op[i]) {
                    let n = buffer_delay_length_minus_1 + 1;
                    decoder_buffer_delay[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, n);
                    encoder_buffer_delay[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, n);
                    low_delay_mode_flag[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
                }
            }
            else {
                decoder_model_present_for_this_op[i] = 0;
            }
            if (initial_display_delay_present_flag) {
                initial_display_delay_present_for_this_op[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
                if (initial_display_delay_present_for_this_op[i]) {
                    initial_display_delay_minus_1[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 4);
                }
            }
        }
    }
    let frame_width_bits_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 4);
    let frame_height_bits_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 4);
    let n = frame_width_bits_minus_1 + 1;
    let max_frame_width_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, n);
    n = frame_height_bits_minus_1 + 1;
    let max_frame_height_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, n);
    let frame_id_numbers_present_flag = 0;
    let delta_frame_id_length_minus_2 = 0;
    let additional_frame_id_length_minus_1 = 0;
    if (reduced_still_picture_header) {
        frame_id_numbers_present_flag = 0;
    }
    else {
        frame_id_numbers_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    }
    if (frame_id_numbers_present_flag) {
        delta_frame_id_length_minus_2 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 4);
        additional_frame_id_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 3);
    }
    let use_128x128_superblock = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let enable_filter_intra = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let enable_intra_edge_filter = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let enable_interintra_compound = 0;
    let enable_masked_compound = 0;
    let enable_warped_motion = 0;
    let enable_dual_filter = 0;
    let enable_order_hint = 0;
    let enable_jnt_comp = 0;
    let enable_ref_frame_mvs = 0;
    let seq_force_screen_content_tools = 2;
    let seq_force_integer_mv = 2;
    let OrderHintBits = 0;
    if (!reduced_still_picture_header) {
        let enable_interintra_compound = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        enable_masked_compound = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        enable_warped_motion = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        enable_dual_filter = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        enable_order_hint = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        if (enable_order_hint) {
            enable_jnt_comp = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
            enable_ref_frame_mvs = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        }
        else {
            enable_jnt_comp = 0;
            enable_ref_frame_mvs = 0;
        }
        let seq_choose_screen_content_tools = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        if (seq_choose_screen_content_tools) {
            seq_force_screen_content_tools = 2;
        }
        else {
            seq_force_screen_content_tools = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        }
        if (seq_force_screen_content_tools > 0) {
            let seq_choose_integer_mv = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
            if (seq_choose_integer_mv) {
                seq_force_integer_mv = 2;
            }
            else {
                seq_force_integer_mv = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
            }
        }
        else {
            seq_force_integer_mv = 2;
        }
        if (enable_order_hint) {
            const order_hint_bits_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 3);
            OrderHintBits = order_hint_bits_minus_1 + 1;
        }
        else {
            OrderHintBits = 0;
        }
    }
    let enable_superres = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let enable_cdef = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let enable_restoration = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let high_bitdepth = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let twelve_bit = 0;
    let bit_depth = 0;
    let mono_chrome = 0;
    if (seq_profile == 2 && high_bitdepth) {
        twelve_bit = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        bit_depth = twelve_bit ? 12 : 10;
    }
    else if (seq_profile <= 2) {
        bit_depth = high_bitdepth ? 10 : 8;
    }
    if (seq_profile == 1) {
        mono_chrome = 0;
    }
    else {
        mono_chrome = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    }
    const color_description_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let color_primaries = 0;
    let transfer_characteristics = 0;
    let matrix_coefficients = 0;
    if (color_description_present_flag) {
        color_primaries = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 8);
        transfer_characteristics = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 8);
        matrix_coefficients = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 8);
    }
    else {
        color_primaries = 2;
        transfer_characteristics = 2;
        matrix_coefficients = 2;
    }
    let color_range = 0;
    let subsampling_x = 0;
    let subsampling_y = 0;
    let chroma_sample_position = 0;
    let separate_uv_delta_q = 0;
    if (mono_chrome) {
        color_range = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        subsampling_x = 1;
        subsampling_y = 1;
        chroma_sample_position = 0;
        separate_uv_delta_q = 0;
    }
    else if (color_primaries == 1
        && transfer_characteristics == 13
        && matrix_coefficients == 0) {
        color_range = 1;
        subsampling_x = 0;
        subsampling_y = 0;
        separate_uv_delta_q = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    }
    else {
        color_range = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        if (seq_profile == 0) {
            subsampling_x = 1;
            subsampling_y = 1;
        }
        else if (seq_profile == 1) {
            subsampling_x = 0;
            subsampling_y = 0;
        }
        else {
            if (bit_depth == 12) {
                subsampling_x = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
                if (subsampling_x) {
                    subsampling_y = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
                }
                else {
                    subsampling_y = 0;
                }
            }
            else {
                subsampling_x = 1;
                subsampling_y = 0;
            }
        }
        if (subsampling_x && subsampling_y) {
            chroma_sample_position = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 2);
        }
        separate_uv_delta_q = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    }
    let film_grain_params_present = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    return {
        width: max_frame_width_minus_1 + 1,
        height: max_frame_height_minus_1 + 1,
        profile: seq_profile,
        level: AV1LevelIdx[seq_level_idx[0]],
        tier: seq_tier[0],
        bitDepth: bit_depth,
        monoChrome: mono_chrome,
        colorRange: color_range,
        colorPrimaries: color_primaries,
        transferCharacteristics: transfer_characteristics,
        matrixCoefficients: matrix_coefficients,
        subsamplingX: subsampling_x,
        subsamplingY: subsampling_y,
        chromaSamplePosition: chroma_sample_position
    };
}
function splitOBU(buffer) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__["default"]();
    bitReader.appendBuffer(buffer);
    const list = [];
    while (bitReader.remainingLength()) {
        const now = bitReader.getPos();
        // obu_forbidden_bit
        bitReader.readU1();
        const type = bitReader.readU(4);
        const extensionFlag = bitReader.readU1();
        const hasSizeFlag = bitReader.readU1();
        // obu_reserved_1bit
        bitReader.readU1();
        if (extensionFlag) {
            bitReader.readU(8);
        }
        const size = hasSizeFlag ? avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.leb128(bitReader) : buffer.length - 1 - extensionFlag;
        const headerSize = bitReader.getPos() - now;
        list.push(buffer.subarray(now, now + headerSize + size));
        bitReader.skip(size * 8);
    }
    return list;
}
function generateExtradata(codecpar, buffer) {
    const bitWriter = new common_io_BitWriter__WEBPACK_IMPORTED_MODULE_3__["default"](4);
    // marker
    bitWriter.writeU1(1);
    // version
    bitWriter.writeU(7, 1);
    const header = splitOBU(buffer).find((buffer) => {
        return ((buffer[0] >>> 3) & 0x0f) === 1 /* OBUType.SEQUENCE_HEADER */;
    });
    if (header) {
        const params = parseSequenceHeader(header);
        bitWriter.writeU(3, params.profile);
        bitWriter.writeU(5, params.level);
        bitWriter.writeU(1, params.tier);
        bitWriter.writeU(1, params.bitDepth > 8 ? 1 : 0);
        bitWriter.writeU(1, params.bitDepth === 12 ? 1 : 0);
        bitWriter.writeU(1, params.monoChrome);
        bitWriter.writeU(1, params.subsamplingX);
        bitWriter.writeU(1, params.subsamplingY);
        bitWriter.writeU(1, params.chromaSamplePosition);
    }
    else {
        const desc = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 28)];
        bitWriter.writeU(3, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 48));
        bitWriter.writeU(5, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 52));
        bitWriter.writeU(1, 0);
        bitWriter.writeU(1, desc.comp[0].depth > 8 ? 1 : 0);
        bitWriter.writeU(1, desc.comp[0].depth === 12 ? 1 : 0);
        bitWriter.writeU(1, 0);
        bitWriter.writeU(1, 1);
        bitWriter.writeU(1, 1);
        bitWriter.writeU(1, 0);
    }
    // padding
    bitWriter.writeU(8, 0);
    return bitWriter.getBuffer();
}


/***/ }),

/***/ "./src/avformat/codecs/h264.ts":
/*!*************************************!*\
  !*** ./src/avformat/codecs/h264.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H264Profile2Name: () => (/* binding */ H264Profile2Name),
/* harmony export */   annexb2Avcc: () => (/* binding */ annexb2Avcc),
/* harmony export */   annexbExtradata2AvccExtradata: () => (/* binding */ annexbExtradata2AvccExtradata),
/* harmony export */   extradata2SpsPps: () => (/* binding */ extradata2SpsPps),
/* harmony export */   isIDR: () => (/* binding */ isIDR),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseAnnexbExtraData: () => (/* binding */ parseAnnexbExtraData),
/* harmony export */   parseAvccExtraData: () => (/* binding */ parseAvccExtraData),
/* harmony export */   parseSPS: () => (/* binding */ parseSPS)
/* harmony export */ });
/* unused harmony exports NALULengthSizeMinusOne, LevelCapabilities, getLevelByResolution, spsPps2Extradata, avcc2Annexb */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/nalu */ "./src/avutil/util/nalu.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avutil/util/expgolomb */ "./src/avutil/util/expgolomb.ts");
/* harmony import */ var avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avutil/util/intread */ "./src/avutil/util/intread.ts");
var cheap__fileName__0 = "src\\avformat\\codecs\\h264.ts";


/*
 * libmedia h264 util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */











const NALULengthSizeMinusOne = 3;
const H264Profile2Name = {
    [66 /* H264Profile.kBaseline */]: 'Constrained Baseline',
    [77 /* H264Profile.kMain */]: 'Main',
    [100 /* H264Profile.kHigh */]: 'High',
    [110 /* H264Profile.kHigh10 */]: 'High10',
    [122 /* H264Profile.kHigh422 */]: 'High422',
    [244 /* H264Profile.kHigh444 */]: 'High444'
};
const LevelCapabilities = [
    { level: 10, maxResolution: 25344, maxFrameRate: 15 },
    { level: 11, maxResolution: 25344, maxFrameRate: 30 },
    { level: 12, maxResolution: 101376, maxFrameRate: 30 },
    { level: 13, maxResolution: 101376, maxFrameRate: 30 },
    { level: 20, maxResolution: 101376, maxFrameRate: 30 },
    { level: 21, maxResolution: 202752, maxFrameRate: 30 },
    { level: 22, maxResolution: 414720, maxFrameRate: 30 },
    { level: 30, maxResolution: 414720, maxFrameRate: 30 },
    { level: 31, maxResolution: 921600, maxFrameRate: 30 },
    { level: 32, maxResolution: 1310720, maxFrameRate: 60 },
    { level: 40, maxResolution: 2097152, maxFrameRate: 30 },
    { level: 41, maxResolution: 2097152, maxFrameRate: 60 },
    { level: 42, maxResolution: 2228224, maxFrameRate: 60 },
    { level: 50, maxResolution: 8912896, maxFrameRate: 30 },
    { level: 51, maxResolution: 8912896, maxFrameRate: 60 },
    { level: 52, maxResolution: 8912896, maxFrameRate: 120 },
    { level: 60, maxResolution: 35651584, maxFrameRate: 30 },
    { level: 61, maxResolution: 35651584, maxFrameRate: 60 },
    { level: 62, maxResolution: 35651584, maxFrameRate: 120 }
];
function getLevelByResolution(width, height, fps) {
    const resolution = width * height;
    for (const level of LevelCapabilities) {
        if (resolution <= level.maxResolution && fps <= level.maxFrameRate) {
            return level.level;
        }
    }
}
/**
 *
 * avcc 格式的 extradata 转 annexb sps pps
 *
 * bits
 * - 8   version ( always 0x01 )
 * - 8   avc profile ( sps[0][1] )
 * - 8   avc compatibility ( sps[0][2] )
 * - 8   avc level ( sps[0][3] )
 * - 6   reserved ( all bits on )
 * - 2   NALULengthSizeMinusOne
 * - 3   reserved ( all bits on )
 * - 5   number of SPS NALUs (usually 1)
 * - repeated once per SPS:
 *   - 16         SPS size
 *   - variable   SPS NALU data
 * - 8 number of PPS NALUs (usually 1)
 * - repeated once per PPS:
 *   - 16       PPS size
 *   - variable PPS NALU data
 *
 * - ext (profile !== 66 && profile !== 77 && profile !== 88)
 *  - 6 reserved ( all bits on )
 *  - 2 chroma_format_idc
 *  - 5 reserved ( all bits on )
 *  - 3 bit_depth_luma_minus8
 *  - 5 reserved ( all bits on )
 *  - 3 bit_depth_chroma_minus8
 *  - 8 number of SPS_EXT NALUs
 *    - 16 SPS_EXT size
 *    - variable   SPS_EXT NALU data
 *
 */
function extradata2SpsPps(extradata) {
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](extradata);
    bufferReader.skip(5);
    const spss = [];
    const ppss = [];
    const spsExts = [];
    const spsLength = bufferReader.readUint8() & 0x1f;
    for (let i = 0; i < spsLength; i++) {
        const length = bufferReader.readUint16();
        spss.push(bufferReader.readBuffer(length));
    }
    const ppsLength = bufferReader.readUint8();
    for (let i = 0; i < ppsLength; i++) {
        const length = bufferReader.readUint16();
        ppss.push(bufferReader.readBuffer(length));
    }
    if (bufferReader.remainingSize() > 4) {
        bufferReader.skip(3);
        const spsExtLength = bufferReader.readUint8();
        if (spsExtLength > 0) {
            for (let i = 0; i < spsExtLength; i++) {
                const length = bufferReader.readUint16();
                spsExts.push(bufferReader.readBuffer(length));
            }
        }
    }
    return {
        spss,
        ppss,
        spsExts
    };
}
function spsPps2Extradata(spss, ppss, spsExts = []) {
    if (spss.length > 32) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_6__.warn(`h264 metadata\'s sps max length is 32, but get ${spss.length}`, cheap__fileName__0, 210);
        spss = spss.slice(0, 32);
    }
    if (spss.length > 256) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_6__.warn(`h264 metadata\'s pps max length is 256, but get ${spss.length}`, cheap__fileName__0, 214);
        spss = spss.slice(0, 256);
    }
    let length = 7;
    length = spss.reduce((prev, sps) => {
        return prev + 2 + sps.length;
    }, length);
    length = ppss.reduce((prev, pps) => {
        return prev + 2 + pps.length;
    }, length);
    const sps = spss[0];
    const params = parseSPS(sps);
    if (params.profile !== 66 && params.profile !== 77 && params.profile !== 88) {
        length += 4;
        if (spsExts.length) {
            length = spsExts.reduce((prev, ext) => {
                return prev + 2 + ext.length;
            }, length);
        }
    }
    const buffer = new Uint8Array(length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(sps[1]);
    bufferWriter.writeUint8(sps[2]);
    bufferWriter.writeUint8(sps[3]);
    bufferWriter.writeUint8(0xfc | NALULengthSizeMinusOne);
    // sps
    bufferWriter.writeUint8(0xe0 | (spss.length & 0x1f));
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
        bufferWriter.writeUint16(sps.length);
        bufferWriter.writeBuffer(sps);
    });
    // pps
    bufferWriter.writeUint8(ppss.length);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
        bufferWriter.writeUint16(pps.length);
        bufferWriter.writeBuffer(pps);
    });
    if (params.profile !== 66 && params.profile !== 77 && params.profile !== 88) {
        bufferWriter.writeUint8(0xfc | params.chromaFormatIdc);
        bufferWriter.writeUint8(0xf8 | params.bitDepthLumaMinus8);
        bufferWriter.writeUint8(0xf8 | params.bitDepthChromaMinus8);
        if (spsExts.length) {
            common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spsExts, (ext) => {
                bufferWriter.writeUint16(ext.length);
                bufferWriter.writeBuffer(ext);
            });
        }
    }
    return buffer;
}
function annexbExtradata2AvccExtradata(data) {
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.splitNaluByStartCode)(data);
    if (nalus.length > 1) {
        const spss = [];
        const ppss = [];
        const spsExts = [];
        nalus.forEach((nalu) => {
            const type = nalu[0] & 0x1f;
            if (type === 7 /* H264NaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 8 /* H264NaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
            else if (type === 13 /* H264NaluType.kSPSExt */) {
                spsExts.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            return spsPps2Extradata(spss, ppss, spsExts);
        }
    }
}
/**
 *
 * annexb 格式的 NALU 转 avcc NALU
 *
 */
function annexb2Avcc(data) {
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.splitNaluByStartCode)(data);
    let extradata;
    let key = false;
    if (nalus.length > 1) {
        const spss = [];
        const ppss = [];
        const spsExts = [];
        nalus.forEach((nalu) => {
            const type = nalu[0] & 0x1f;
            if (type === 7 /* H264NaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 8 /* H264NaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
            else if (type === 13 /* H264NaluType.kSPSExt */) {
                spsExts.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            extradata = spsPps2Extradata(spss, ppss, spsExts);
        }
        nalus = nalus.filter((nalu) => {
            const type = nalu[0] & 0x1f;
            return type !== 9 /* H264NaluType.kSliceAUD */
                && type !== 8 /* H264NaluType.kSlicePPS */
                && type !== 7 /* H264NaluType.kSliceSPS */
                && type !== 13 /* H264NaluType.kSPSExt */;
        });
    }
    const length = nalus.reduce((prev, nalu) => {
        return prev + NALULengthSizeMinusOne + 1 + nalu.length;
    }, 0);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_10__.avMalloc)(length);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.mapUint8Array)(bufferPointer, length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu) => {
        if (NALULengthSizeMinusOne === 3) {
            bufferWriter.writeUint32(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 2) {
            bufferWriter.writeUint24(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 1) {
            bufferWriter.writeUint16(nalu.length);
        }
        else {
            bufferWriter.writeUint8(nalu.length);
        }
        bufferWriter.writeBuffer(nalu.subarray(0));
        const type = nalu[0] & 0x1f;
        if (type === 5 /* H264NaluType.kSliceIDR */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length,
        key,
        extradata
    };
}
/**
 * avcc 格式的 NALU 转 annexb NALU
 *
 */
function avcc2Annexb(data, extradata) {
    const naluLengthSizeMinusOne = extradata ? (extradata[4] & 0x03) : NALULengthSizeMinusOne;
    let spss = [];
    let ppss = [];
    let spsExts = [];
    let key = false;
    if (extradata) {
        const result = extradata2SpsPps(extradata);
        spss = result.spss;
        ppss = result.ppss;
        spsExts = result.spsExts;
        key = true;
    }
    const nalus = [];
    const seis = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = data.subarray((Number(bufferReader.getPos() & 0xffffffffn) >> 0), (Number(bufferReader.getPos() & 0xffffffffn) >> 0) + length);
        bufferReader.skip(length);
        const naluType = nalu[0] & 0x1f;
        if (naluType === 6 /* H264NaluType.kSliceSEI */) {
            seis.push(nalu);
        }
        else if (naluType !== 9 /* H264NaluType.kSliceAUD */) {
            nalus.push(nalu);
        }
    }
    let length = spss.reduce((prev, sps) => {
        return prev + 4 + sps.length;
    }, 0);
    length = ppss.reduce((prev, pps) => {
        return prev + 4 + pps.length;
    }, length);
    length = spsExts.reduce((prev, ext) => {
        return prev + 4 + ext.length;
    }, length);
    length = seis.reduce((prev, sei) => {
        return prev + 4 + sei.length;
    }, length);
    length = nalus.reduce((prev, nalu, index) => {
        return prev + (index ? 3 : 4) + nalu.length;
    }, length);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_10__.avMalloc)(length + 6);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"]((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.mapUint8Array)(bufferPointer, length + 6));
    // AUD
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(0x09);
    bufferWriter.writeUint8(0xf0);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(seis, (sei) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(sei);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(sps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(pps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spsExts, (ext) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(ext);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu, index) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        if (!index) {
            bufferWriter.writeUint8(0x00);
        }
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(nalu);
        const type = nalu[0] & 0x1f;
        if (type === 5 /* H264NaluType.kSliceIDR */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length: length + 6,
        key
    };
}
function parseAvccExtraData(avpacket, stream) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if ((0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.isAnnexb)(data)) {
        return;
    }
    const naluLengthSizeMinusOne = stream.metadata.naluLengthSizeMinusOne ?? NALULengthSizeMinusOne;
    let spss = [];
    let ppss = [];
    let spsExts = [];
    let others = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = data.subarray((Number(bufferReader.getPos() & 0xffffffffn) >> 0), (Number(bufferReader.getPos() & 0xffffffffn) >> 0) + length);
        bufferReader.skip(length);
        const naluType = nalu[0] & 0x1f;
        if (naluType === 7 /* H264NaluType.kSliceSPS */) {
            spss.push(nalu);
        }
        else if (naluType === 8 /* H264NaluType.kSlicePPS */) {
            ppss.push(nalu);
        }
        else if (naluType === 13 /* H264NaluType.kSPSExt */) {
            spsExts.push(nalu);
        }
        else {
            others.push(nalu);
        }
    }
    if (spss.length || ppss.length) {
        const extradata = spsPps2Extradata(spss, ppss, spsExts);
        const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_10__.avMalloc)(extradata.length);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
    }
}
function parseAnnexbExtraData(avpacket, force = false) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) && !force) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if (!(0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.isAnnexb)(data)) {
        return;
    }
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.splitNaluByStartCode)(data);
    if (nalus.length > 1) {
        const spss = [];
        const ppss = [];
        const spsExts = [];
        nalus.forEach((nalu) => {
            const type = nalu[0] & 0x1f;
            if (type === 7 /* H264NaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 8 /* H264NaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
            else if (type === 13 /* H264NaluType.kSPSExt */) {
                spsExts.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            const extradata = spsPps2Extradata(spss, ppss, spsExts);
            const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_10__.avMalloc)(extradata.length);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
        }
    }
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        stream.metadata.naluLengthSizeMinusOne = (extradata[4] & 0x03);
        const { spss } = extradata2SpsPps(extradata);
        if (spss.length) {
            const { profile, level, width, height } = parseSPS(spss[0]);
            stream.codecpar.profile = profile;
            stream.codecpar.level = level;
            stream.codecpar.width = width;
            stream.codecpar.height = height;
        }
    }
}
function isIDR(avpacket, naluLengthSize = 4) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
        return false;
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 80) === 2 /* BitFormat.ANNEXB */) {
        let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.splitNaluByStartCode)((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28)));
        return nalus.some((nalu) => {
            const type = nalu[0] & 0x1f;
            return type === 5 /* H264NaluType.kSliceIDR */;
        });
    }
    else {
        const size = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28);
        let i = 0;
        while (i < (size - naluLengthSize)) {
            const type = avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + (i + naluLengthSize)) & 0x1f;
            if (type === 5 /* H264NaluType.kSliceIDR */) {
                return true;
            }
            if (naluLengthSize === 4) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.rb32(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else if (naluLengthSize === 3) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.rb24(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else if (naluLengthSize === 2) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.rb16(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            i += naluLengthSize;
        }
        return false;
    }
}
function parseSPS(sps) {
    if (!sps || sps.length < 3) {
        return;
    }
    let offset = 0;
    if (sps[0] === 0x00
        && sps[1] === 0x00
        && sps[2] === 0x00
        && sps[3] === 0x01) {
        offset = 4;
    }
    const buffer = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.naluUnescape)(sps.subarray(offset));
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__["default"](buffer.length);
    bitReader.appendBuffer(buffer);
    // forbidden_zero_bit
    bitReader.readU1();
    // nal_ref_idc
    bitReader.readU(2);
    // nal_unit_type
    bitReader.readU(5);
    const profile = bitReader.readU(8);
    // constraint_set0_flag
    bitReader.readU1();
    // constraint_set1_flag
    bitReader.readU1();
    // constraint_set2_flag
    bitReader.readU1();
    // constraint_set3_flag
    bitReader.readU1();
    // constraint_set4_flag
    bitReader.readU1();
    // constraint_set4_flag
    bitReader.readU1();
    // reserved_zero_2bits
    bitReader.readU(2);
    const level = bitReader.readU(8);
    // seq_parameter_set_id
    avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    // 摄像机出图大部分格式是 4:2:0
    let chromaFormatIdc = 1;
    let bitDepthLumaMinus8 = 0;
    let bitDepthChromaMinus8 = 0;
    if (profile == 100 || profile == 110 || profile == 122
        || profile == 244 || profile == 44 || profile == 83
        || profile == 86 || profile == 118 || profile == 128
        || profile == 138 || profile == 139 || profile == 134 || profile == 135) {
        chromaFormatIdc = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        if (chromaFormatIdc === 3) {
            // separate_colour_plane_flag
            bitReader.readU1();
        }
        // bit_depth_luma_minus8
        bitDepthLumaMinus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        // bit_depth_chroma_minus8
        bitDepthChromaMinus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        // qpprime_y_zero_transform_bypass_flag
        bitReader.readU1();
        let seqScalingMatrixPresentFlag = bitReader.readU1();
        if (seqScalingMatrixPresentFlag) {
            const seqScalingListPresentFlag = new Array(8);
            for (let i = 0; i < ((chromaFormatIdc != 3) ? 8 : 12); i++) {
                seqScalingListPresentFlag[i] = bitReader.readU1();
            }
        }
    }
    // log2_max_frame_num_minus4
    const log2MaxFrameNumMinus4 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    const picOrderCntType = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    let log2MaxPicOrderCntLsbMinus4 = 0;
    let deltaPicOrderAlwaysZeroFlag = 0;
    if (picOrderCntType === 0) {
        // log2_max_pic_order_cnt_lsb_minus4
        log2MaxPicOrderCntLsbMinus4 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    }
    else if (picOrderCntType === 1) {
        // delta_pic_order_always_zero_flag
        deltaPicOrderAlwaysZeroFlag = bitReader.readU1();
        // offset_for_non_ref_pic
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readSE(bitReader);
        // offset_for_top_to_bottom_field
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readSE(bitReader);
        const numRefFramesInPicOrderCntCycle = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        for (let i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
            avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readSE(bitReader);
        }
    }
    // max_num_ref_frames
    avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    // gaps_in_frame_num_value_allowed_flag
    bitReader.readU1();
    const picWidthInMbsMinus1 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    const picHeightInMapUnitsMinus1 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    const frameMbsOnlyFlag = bitReader.readU1();
    let width = (picWidthInMbsMinus1 + 1) * 16;
    let height = (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16;
    if (!frameMbsOnlyFlag) {
        // mb_adaptive_frame_field_flag
        bitReader.readU1();
    }
    // direct_8x8_inference_flag
    bitReader.readU1();
    const frameCroppingFlag = bitReader.readU1();
    if (frameCroppingFlag) {
        const frameCropLeftOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        const frameCropRightOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        const frameCropTopOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        const frameCropBottomOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        let cropUnitX = 1;
        let cropUnitY = 2 - frameCroppingFlag;
        if (chromaFormatIdc === 1) {
            cropUnitX = 2;
            cropUnitY = 2 * (2 - frameCroppingFlag);
        }
        else if (frameCroppingFlag === 2) {
            cropUnitX = 2;
            cropUnitY = 2 - frameCroppingFlag;
        }
        width -= cropUnitX * (frameCropLeftOffset + frameCropRightOffset);
        height -= cropUnitY * (frameCropTopOffset + frameCropBottomOffset);
    }
    return {
        profile,
        level,
        width,
        height,
        chromaFormatIdc,
        bitDepthLumaMinus8,
        bitDepthChromaMinus8,
        frameMbsOnlyFlag,
        picOrderCntType,
        log2MaxPicOrderCntLsbMinus4,
        deltaPicOrderAlwaysZeroFlag,
        log2MaxFrameNumMinus4
    };
}


/***/ }),

/***/ "./src/avformat/codecs/hevc.ts":
/*!*************************************!*\
  !*** ./src/avformat/codecs/hevc.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HEVCProfile2Name: () => (/* binding */ HEVCProfile2Name),
/* harmony export */   annexb2Avcc: () => (/* binding */ annexb2Avcc),
/* harmony export */   annexbExtradata2AvccExtradata: () => (/* binding */ annexbExtradata2AvccExtradata),
/* harmony export */   extradata2VpsSpsPps: () => (/* binding */ extradata2VpsSpsPps),
/* harmony export */   isIDR: () => (/* binding */ isIDR),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseAnnexbExtraData: () => (/* binding */ parseAnnexbExtraData),
/* harmony export */   parseAvccExtraData: () => (/* binding */ parseAvccExtraData),
/* harmony export */   parsePPS: () => (/* binding */ parsePPS),
/* harmony export */   parseSPS: () => (/* binding */ parseSPS)
/* harmony export */ });
/* unused harmony exports LevelCapabilities, getLevelByResolution, vpsSpsPps2Extradata, avcc2Annexb */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/util/nalu */ "./src/avutil/util/nalu.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/util/expgolomb */ "./src/avutil/util/expgolomb.ts");
/* harmony import */ var avutil_util_intread__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avutil/util/intread */ "./src/avutil/util/intread.ts");


/*
 * libmedia hevc util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */










const HEVCProfile2Name = {
    [1 /* HEVCProfile.Main */]: 'Main',
    [2 /* HEVCProfile.Main10 */]: 'Main10',
    [3 /* HEVCProfile.MainStillPicture */]: 'MainStillPicture',
    [4 /* HEVCProfile.Main444 */]: 'Main444'
};
const LevelCapabilities = [
    { level: 10, maxLumaSamplesPerSecond: 552960, maxLumaPictureSize: 36864, maxBitRate: { main: 128, main10: 150 } },
    { level: 20, maxLumaSamplesPerSecond: 3686400, maxLumaPictureSize: 122880, maxBitRate: { main: 1500, main10: 1875 } },
    { level: 21, maxLumaSamplesPerSecond: 7372800, maxLumaPictureSize: 245760, maxBitRate: { main: 3000, main10: 3750 } },
    { level: 30, maxLumaSamplesPerSecond: 16588800, maxLumaPictureSize: 552960, maxBitRate: { main: 6000, main10: 7500 } },
    { level: 31, maxLumaSamplesPerSecond: 33177600, maxLumaPictureSize: 983040, maxBitRate: { main: 10000, main10: 12500 } },
    { level: 40, maxLumaSamplesPerSecond: 66846720, maxLumaPictureSize: 2228224, maxBitRate: { main: 12000, main10: 15000 } },
    { level: 41, maxLumaSamplesPerSecond: 133693440, maxLumaPictureSize: 2228224, maxBitRate: { main: 20000, main10: 25000 } },
    { level: 50, maxLumaSamplesPerSecond: 267386880, maxLumaPictureSize: 8912896, maxBitRate: { main: 25000, main10: 40000 } },
    { level: 51, maxLumaSamplesPerSecond: 534773760, maxLumaPictureSize: 8912896, maxBitRate: { main: 40000, main10: 60000 } },
    { level: 52, maxLumaSamplesPerSecond: 1069547520, maxLumaPictureSize: 35651584, maxBitRate: { main: 60000, main10: 100000 } },
    { level: 60, maxLumaSamplesPerSecond: 1069547520, maxLumaPictureSize: 35651584, maxBitRate: { main: 60000, main10: 100000 } },
    { level: 61, maxLumaSamplesPerSecond: 2139095040, maxLumaPictureSize: 89128960, maxBitRate: { main: 120000, main10: 240000 } },
    { level: 62, maxLumaSamplesPerSecond: 4278190080, maxLumaPictureSize: 356515840, maxBitRate: { main: 240000, main10: 480000 } }
];
function getLevelByResolution(profile, width, height, fps, bitrate) {
    bitrate /= 1000;
    const selectedProfile = profile === 1 /* HEVCProfile.Main */ ? 'main' : 'main10';
    const lumaSamplesPerSecond = width * height * fps;
    for (const level of LevelCapabilities) {
        if (lumaSamplesPerSecond <= level.maxLumaSamplesPerSecond && width * height <= level.maxLumaPictureSize && bitrate <= level.maxBitRate[selectedProfile]) {
            return level.level;
        }
    }
}
const NALULengthSizeMinusOne = 3;
/**
 *
 * avcc 格式的 extradata 转 annexb vps sps pps
 *
 * bits
 * - 8   configurationVersion( 固定   1)
 * - 2   general_profile_space
 * - 1   general_tier_flag
 * - 5   general_profile_idc
 * - 32  general_profile_compatibility_flags
 * - 48  general_constraint_indicator_flags (6 个 字节）
 * - 8   general_level_idc
 * - 4   reserved1 (1111)
 * - 4   min_spatial_segmentation_idc_L
 * - 8   min_spatial_segmentation_idc_H
 * - 6   reserved2 (111111)
 * - 2   parallelismType
 * - 6   reserved3 (111111)
 * - 2   chromaFormat
 * - 5   reserved4 (11111)
 * - 3   bitDepthLumaMinus8
 * - 5   reserved5(11111)
 * - 3   bitDepthChromaMinus8
 * - 16  avgFrameRate
 * - 2   constantFrameRate
 * - 3   numTemporalLayers
 * - 1   temporalIdNested
 * - 2   lengthSizeMinusOne
 * - 8   numOfArrays
 * - repeated of array (vps/sps/pps)
 * - 1   array_completeness
 * - 1   reserved (0)
 * - 6   NAL_unit_type
 * - 16  numNalus
 * - repeated once per NAL
 * - 16  nalUnitLength
 * - N   NALU data
 *
 */
function extradata2VpsSpsPps(extradata) {
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](extradata, true);
    bufferReader.skip(22);
    let vpss = [];
    let spss = [];
    let ppss = [];
    const arrayLen = bufferReader.readUint8();
    for (let i = 0; i < arrayLen; i++) {
        const naluType = bufferReader.readUint8() & 0x3f;
        const count = bufferReader.readUint16();
        const list = [];
        for (let j = 0; j < count; j++) {
            const len = bufferReader.readUint16();
            list.push(bufferReader.readBuffer(len));
        }
        if (naluType === 32 /* HEVCNaluType.kSliceVPS */) {
            vpss = list;
        }
        else if (naluType === 33 /* HEVCNaluType.kSliceSPS */) {
            spss = list;
        }
        else if (naluType === 34 /* HEVCNaluType.kSlicePPS */) {
            ppss = list;
        }
    }
    return {
        vpss,
        spss,
        ppss
    };
}
function vpsSpsPps2Extradata(vpss, spss, ppss) {
    const sps = spss[0];
    let length = 23;
    if (vpss.length) {
        // type + count
        length += 3;
        length = vpss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    if (spss.length) {
        // type + count
        length += 3;
        length = spss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    if (ppss.length) {
        // type + count
        length += 3;
        length = ppss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    const buffer = new Uint8Array(length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer, true);
    const spsData = parseSPS(sps);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(sps[1]);
    bufferWriter.writeUint8(sps[2]);
    bufferWriter.writeUint8(sps[3]);
    bufferWriter.writeUint8(sps[4]);
    bufferWriter.writeUint8(sps[5]);
    // general_constraint_indicator_flags
    bufferWriter.writeUint8(sps[6]);
    bufferWriter.writeUint8(sps[7]);
    bufferWriter.writeUint8(sps[8]);
    bufferWriter.writeUint8(sps[9]);
    bufferWriter.writeUint8(sps[10]);
    bufferWriter.writeUint8(sps[11]);
    bufferWriter.writeUint8(spsData.level);
    // min_spatial_segmentation_idc
    bufferWriter.writeUint8((1020) | 0);
    bufferWriter.writeUint8(0);
    // parallelismType
    bufferWriter.writeUint8((16320) | 0);
    // chromaFormat
    bufferWriter.writeUint8((16320) | spsData.chroma_format_idc);
    // bitDepthLumaMinus8
    bufferWriter.writeUint8((8160) | spsData.bit_depth_luma_minus8);
    // bitDepthChromaMinus8
    bufferWriter.writeUint8((8160) | spsData.bit_depth_chroma_minus8);
    // avgFrameRate
    bufferWriter.writeUint16(0);
    // constantFrameRate numTemporalLayers temporalIdNested lengthSizeMinusOne
    bufferWriter.writeUint8((0) | (8) | ((sps[0] & 0x01) << 2) | NALULengthSizeMinusOne);
    // numOfArrays
    let numOfArrays = 0;
    if (vpss.length) {
        numOfArrays++;
    }
    if (spss.length) {
        numOfArrays++;
    }
    if (ppss.length) {
        numOfArrays++;
    }
    bufferWriter.writeUint8(numOfArrays);
    // vps
    if (vpss.length) {
        bufferWriter.writeUint8((128) | 32 /* HEVCNaluType.kSliceVPS */);
        bufferWriter.writeUint16(vpss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(vpss, (vps) => {
            bufferWriter.writeUint16(vps.length);
            bufferWriter.writeBuffer(vps);
        });
    }
    // sps
    if (spss.length) {
        bufferWriter.writeUint8((128) | 33 /* HEVCNaluType.kSliceSPS */);
        bufferWriter.writeUint16(spss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
            bufferWriter.writeUint16(sps.length);
            bufferWriter.writeBuffer(sps);
        });
    }
    // pps
    if (ppss.length) {
        bufferWriter.writeUint8((128) | 34 /* HEVCNaluType.kSlicePPS */);
        bufferWriter.writeUint16(ppss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
            bufferWriter.writeUint16(pps.length);
            bufferWriter.writeBuffer(pps);
        });
    }
    return buffer;
}
function annexbExtradata2AvccExtradata(data) {
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)(data);
    if (nalus.length >= 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[0] >>> 1) & 0x3f;
            if (type === 32 /* HEVCNaluType.kSliceVPS */) {
                vpss.push(nalu);
            }
            else if (type === 33 /* HEVCNaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 34 /* HEVCNaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            return vpsSpsPps2Extradata(vpss, spss, ppss);
        }
    }
}
/**
 *
 * annexb 格式的 NALU 转 avcc NALU
 *
 */
function annexb2Avcc(data) {
    let extradata;
    let key = false;
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)(data);
    if (nalus.length >= 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[0] >>> 1) & 0x3f;
            if (type === 32 /* HEVCNaluType.kSliceVPS */) {
                vpss.push(nalu);
            }
            else if (type === 33 /* HEVCNaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 34 /* HEVCNaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
            nalus = nalus.filter((nalu) => {
                const type = (nalu[0] >>> 1) & 0x3f;
                return type !== 32 /* HEVCNaluType.kSliceVPS */
                    && type !== 33 /* HEVCNaluType.kSliceSPS */
                    && type !== 34 /* HEVCNaluType.kSlicePPS */
                    && type !== 35 /* HEVCNaluType.kSliceAUD */;
            });
        }
    }
    const length = nalus.reduce((prev, nalu) => {
        return prev + NALULengthSizeMinusOne + 1 + nalu.length;
    }, 0);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(length);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(bufferPointer, length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu) => {
        if (NALULengthSizeMinusOne === 3) {
            bufferWriter.writeUint32(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 2) {
            bufferWriter.writeUint24(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 1) {
            bufferWriter.writeUint16(nalu.length);
        }
        else {
            bufferWriter.writeUint8(nalu.length);
        }
        bufferWriter.writeBuffer(nalu.subarray(0));
        const type = (nalu[0] >>> 1) & 0x3f;
        if (type === 19 /* HEVCNaluType.kSliceIDR_W_RADL */
            || type === 20 /* HEVCNaluType.kSliceIDR_N_LP */
            || type === 21 /* HEVCNaluType.kSliceCRA_NUT */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length,
        extradata,
        key
    };
}
/**
 * avcc 格式的 NALU 转 annexb NALU
 *
 */
function avcc2Annexb(data, extradata) {
    const naluLengthSizeMinusOne = extradata ? (extradata[21] & 0x03) : NALULengthSizeMinusOne;
    let vpss = [];
    let spss = [];
    let ppss = [];
    let key = false;
    if (extradata) {
        const result = extradata2VpsSpsPps(extradata);
        vpss = result.vpss;
        spss = result.spss;
        ppss = result.ppss;
        key = true;
    }
    const nalus = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        nalus.push(bufferReader.readBuffer(length));
    }
    let length = vpss.reduce((prev, vps) => {
        return prev + 4 + vps.length;
    }, 0);
    length = spss.reduce((prev, sps) => {
        return prev + 4 + sps.length;
    }, length);
    length = ppss.reduce((prev, pps) => {
        return prev + 4 + pps.length;
    }, length);
    length = nalus.reduce((prev, nalu, index) => {
        return prev + (index ? 3 : 4) + nalu.length;
    }, length);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(length + 7);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(bufferPointer, length + 7);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer);
    // AUD
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(35 /* HEVCNaluType.kSliceAUD */ << 1);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0xf0);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(vpss, (vps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(vps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(sps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(pps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu, index) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        if (!index) {
            bufferWriter.writeUint8(0x00);
        }
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(nalu);
        const type = (nalu[0] >>> 1) & 0x3f;
        if (type === 19 /* HEVCNaluType.kSliceIDR_W_RADL */
            || type === 20 /* HEVCNaluType.kSliceIDR_N_LP */
            || type === 21 /* HEVCNaluType.kSliceCRA_NUT */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length: length + 7,
        key
    };
}
function parseAvccExtraData(avpacket, stream) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if ((0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.isAnnexb)(data)) {
        return;
    }
    const naluLengthSizeMinusOne = stream.metadata.naluLengthSizeMinusOne ?? NALULengthSizeMinusOne;
    let vpss = [];
    let spss = [];
    let ppss = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = data.subarray((Number(bufferReader.getPos() & 0xffffffffn) >> 0), (Number(bufferReader.getPos() & 0xffffffffn) >> 0) + length);
        bufferReader.skip(length);
        const naluType = (nalu[0] >>> 1) & 0x3f;
        if (naluType === 33 /* HEVCNaluType.kSliceSPS */) {
            spss.push(nalu);
        }
        else if (naluType === 34 /* HEVCNaluType.kSlicePPS */) {
            ppss.push(nalu);
        }
        else if (naluType === 32 /* HEVCNaluType.kSliceVPS */) {
            vpss.push(nalu);
        }
    }
    if (spss.length || ppss.length || vpss.length) {
        const extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
        const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(extradata.length);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
    }
}
function parseAnnexbExtraData(avpacket, force = false) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) && !force) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if (!(0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.isAnnexb)(data)) {
        return;
    }
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)(data);
    if (nalus.length > 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[0] >>> 1) & 0x3f;
            if (type === 32 /* HEVCNaluType.kSliceVPS */) {
                vpss.push(nalu);
            }
            else if (type === 33 /* HEVCNaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 34 /* HEVCNaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
        });
        if (vpss.length && spss.length && ppss.length) {
            const extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
            const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(extradata.length);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
        }
    }
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        stream.metadata.naluLengthSizeMinusOne = (extradata[21] & 0x03);
        const { spss } = extradata2VpsSpsPps(extradata);
        if (spss.length) {
            const { profile, level, width, height } = parseSPS(spss[0]);
            stream.codecpar.profile = profile;
            stream.codecpar.level = level;
            stream.codecpar.width = width;
            stream.codecpar.height = height;
        }
    }
}
function isIDR(avpacket, naluLengthSize = 4) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
        return false;
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 80) === 2 /* BitFormat.ANNEXB */) {
        let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28)));
        return nalus.some((nalu) => {
            const type = (nalu[0] >>> 1) & 0x3f;
            return type === 20 /* HEVCNaluType.kSliceIDR_N_LP */ || type === 19 /* HEVCNaluType.kSliceIDR_W_RADL */;
        });
    }
    else {
        const size = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28);
        let i = 0;
        while (i < (size - naluLengthSize)) {
            const type = (avutil_util_intread__WEBPACK_IMPORTED_MODULE_11__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + (i + naluLengthSize)) >>> 1) & 0x3f;
            if (type === 20 /* HEVCNaluType.kSliceIDR_N_LP */ || type === 19 /* HEVCNaluType.kSliceIDR_W_RADL */) {
                return true;
            }
            if (naluLengthSize === 4) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_11__.rb32(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else if (naluLengthSize === 3) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_11__.rb24(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else if (naluLengthSize === 2) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_11__.rb16(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_11__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            i += naluLengthSize;
        }
        return false;
    }
}
function parseSPS(sps) {
    if (!sps || sps.length < 3) {
        return;
    }
    let offset = 0;
    if (sps[0] === 0x00
        && sps[1] === 0x00
        && sps[2] === 0x00
        && sps[3] === 0x01) {
        offset = 4;
    }
    let profile = 0;
    let level = 0;
    let width = 0;
    let height = 0;
    let bit_depth_luma_minus8 = 0;
    let bit_depth_chroma_minus8 = 0;
    let chroma_format_idc = 1;
    let general_profile_space = 0;
    let general_tier_flag = 0;
    let general_profile_compatibility_flags = 0;
    let constraint_flags = 0;
    const buffer = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.naluUnescape)(sps.subarray(offset));
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__["default"](buffer.length);
    bitReader.appendBuffer(buffer);
    // forbidden_zero_bit
    bitReader.readU1();
    // nalu type
    bitReader.readU(6);
    // layerId
    bitReader.readU(6);
    // tid
    bitReader.readU(3);
    // sps_video_parameter_set_id
    bitReader.readU(4);
    // The value of sps_max_sub_layers_minus1 shall be in the range of 0 to 6, inclusive.
    const spsMaxSubLayersMinus1 = bitReader.readU(3);
    // sps_temporal_id_nesting_flag
    bitReader.readU1();
    let separate_colour_plane_flag = 0;
    if (spsMaxSubLayersMinus1 <= 6) {
        // profile_tier_level(sps_max_sub_layers_minus1)
        // general_profile_space
        general_profile_space = bitReader.readU(2);
        // general_tier_flag
        general_tier_flag = bitReader.readU1();
        // general_profile_idc
        profile = bitReader.readU(5);
        // general_profile_compatibility_flag[32]
        general_profile_compatibility_flags = bitReader.readU(32);
        /**
         * 1 general_progressive_source_flag
         * 1 general_interlaced_source_flag
         * 1 general_non_packed_constraint_flag
         * 1 general_frame_only_constraint_flag
         * 44 general_reserved_zero_44bits
         */
        constraint_flags = bitReader.readU(48);
        // general_level_idc
        level = bitReader.readU(8);
        const subLayerProfilePresentFlag = new Array(6);
        const subLayerLevelPresentFlag = new Array(6);
        for (let i = 0; i < spsMaxSubLayersMinus1; i++) {
            subLayerProfilePresentFlag[i] = bitReader.readU1();
            subLayerLevelPresentFlag[i] = bitReader.readU1();
        }
        if (spsMaxSubLayersMinus1 > 0) {
            for (let i = spsMaxSubLayersMinus1; i < 8; i++) {
                // reserved_zero_2bits
                bitReader.readU(2);
            }
        }
        for (let i = 0; i < spsMaxSubLayersMinus1; i++) {
            if (subLayerProfilePresentFlag[i]) {
                // sub_layer_profile_space[i]
                bitReader.readU(2);
                // sub_layer_tier_flag[i]
                bitReader.readU(1);
                // sub_layer_profile_idc[i]
                bitReader.readU(5);
                // sub_layer_profile_compatibility_flag[i][32]
                bitReader.readU(32);
                // sub_layer_progressive_source_flag[i]
                bitReader.readU(1);
                // sub_layer_interlaced_source_flag[i]
                bitReader.readU(1);
                // sub_layer_non_packed_constraint_flag[i]
                bitReader.readU(1);
                // sub_layer_frame_only_constraint_flag[i]
                bitReader.readU(1);
                // sub_layer_reserved_zero_44bits[i]
                bitReader.readU(44);
            }
            if (subLayerLevelPresentFlag[i]) {
                // sub_layer_level_idc[i]
                bitReader.readU(8);
            }
        }
        // "The  value  of sps_seq_parameter_set_id shall be in the range of 0 to 15, inclusive."
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        chroma_format_idc = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        if (chroma_format_idc === 3) {
            // separate_colour_plane_flag
            separate_colour_plane_flag = bitReader.readU(1);
        }
        width = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        height = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        const conformanceWindowFlag = bitReader.readU1();
        let confWinLeftOffset = 0;
        let confWinRightOffset = 0;
        let confWinTopOffset = 0;
        let confWinBottomOffset = 0;
        if (conformanceWindowFlag) {
            confWinLeftOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
            confWinRightOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
            confWinTopOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
            confWinBottomOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        }
        bit_depth_luma_minus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        bit_depth_chroma_minus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        let SubWidthC = 2;
        let SubHeightC = 2;
        if (chroma_format_idc === 0) {
            SubWidthC = SubHeightC = 0;
        }
        else if (chroma_format_idc === 2) {
            SubWidthC = 2;
            SubHeightC = 1;
        }
        else if (chroma_format_idc === 3) {
            SubWidthC = SubHeightC = 1;
        }
        const cropUnitX = SubWidthC * (1 << (bit_depth_luma_minus8 + 1));
        const cropUnitY = SubHeightC * (1 << (bit_depth_luma_minus8 + 1));
        width -= cropUnitX * (confWinLeftOffset + confWinRightOffset);
        height -= cropUnitY * (confWinTopOffset + confWinBottomOffset);
    }
    const log2_max_poc_lsb = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader) + 4;
    const sublayer_ordering_info_flag = bitReader.readU1();
    const start = sublayer_ordering_info_flag ? 0 : spsMaxSubLayersMinus1;
    for (let i = start; i < (spsMaxSubLayersMinus1 + 1); i++) {
        // max_dec_pic_buffering
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        // num_reorder_pics
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        // max_latency_increase
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    }
    const log2_min_cb_size = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader) + 3;
    const log2_diff_max_min_coding_block_size = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    const log2_min_tb_size = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader) + 2;
    const log2_diff_max_min_transform_block_size = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    const log2_max_trafo_size = log2_diff_max_min_transform_block_size + log2_min_tb_size;
    const log2_ctb_size = log2_min_cb_size + log2_diff_max_min_coding_block_size;
    const log2_min_pu_size = log2_min_cb_size - 1;
    const ctb_width = (width + (1 << log2_ctb_size) - 1) >> log2_ctb_size;
    const ctb_height = (height + (1 << log2_ctb_size) - 1) >> log2_ctb_size;
    const ctb_size = ctb_width * ctb_height;
    const min_cb_width = width >> log2_min_cb_size;
    const min_cb_height = height >> log2_min_cb_size;
    const min_tb_width = width >> log2_min_tb_size;
    const min_tb_height = height >> log2_min_tb_size;
    const min_pu_width = width >> log2_min_pu_size;
    const min_pu_height = height >> log2_min_pu_size;
    return {
        profile,
        level,
        width,
        height,
        chroma_format_idc,
        bit_depth_luma_minus8,
        bit_depth_chroma_minus8,
        general_profile_space,
        general_tier_flag,
        general_profile_compatibility_flags,
        constraint_flags,
        separate_colour_plane_flag,
        log2_min_cb_size,
        log2_diff_max_min_coding_block_size,
        log2_min_tb_size,
        log2_diff_max_min_transform_block_size,
        log2_max_trafo_size,
        log2_ctb_size,
        log2_min_pu_size,
        ctb_width,
        ctb_height,
        ctb_size,
        min_cb_width,
        min_cb_height,
        min_tb_width,
        min_tb_height,
        min_pu_width,
        min_pu_height,
        log2_max_poc_lsb
    };
}
function parsePPS(pps) {
    if (!pps || pps.length < 3) {
        return;
    }
    let offset = 0;
    if (pps[0] === 0x00
        && pps[1] === 0x00
        && pps[2] === 0x00
        && pps[3] === 0x01) {
        offset = 4;
    }
    const buffer = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.naluUnescape)(pps.subarray(offset));
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__["default"](buffer.length);
    bitReader.appendBuffer(buffer);
    const pps_pic_parameter_set_id = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    const pps_seq_parameter_set_id = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    const dependent_slice_segment_flag = bitReader.readU1();
    const output_flag_present_flag = bitReader.readU1();
    const num_extra_slice_header_bits = bitReader.readU(3);
    return {
        pps_pic_parameter_set_id,
        pps_seq_parameter_set_id,
        dependent_slice_segment_flag,
        output_flag_present_flag,
        num_extra_slice_header_bits
    };
}


/***/ }),

/***/ "./src/avformat/codecs/mp3.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/mp3.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MP3Profile2Name: () => (/* binding */ MP3Profile2Name),
/* harmony export */   getBitRateByVersionLayerIndex: () => (/* binding */ getBitRateByVersionLayerIndex),
/* harmony export */   getFrameSizeByVersionLayer: () => (/* binding */ getFrameSizeByVersionLayer),
/* harmony export */   getProfileByLayer: () => (/* binding */ getProfileByLayer),
/* harmony export */   getSampleRateByVersionIndex: () => (/* binding */ getSampleRateByVersionIndex),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/*
 * libmedia mp3 util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const MpegAudioV10SampleRateTable = [44100, 48000, 32000, 0];
const MpegAudioV20SampleRateTable = [22050, 24000, 16000, 0];
const MpegAudioV25SampleRateTable = [11025, 12000, 8000, 0];
const MpegAudioV10FrameSizeTable = [0, 1152, 1152, 384];
const MpegAudioV20FrameSizeTable = [0, 576, 1152, 384];
const MpegAudioV25FrameSizeTable = [0, 576, 1152, 384];
const MpegAudioV1L1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1];
const MpegAudioV1L2BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1];
const MpegAudioV1L3BitRateTable = [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1];
const MpegAudioV2L1BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, -1];
const MpegAudioV2L2L3BitRateTable = [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1];
function getSampleRateByVersionIndex(version, samplingFreqIndex) {
    switch (version) {
        case 0:
            // MPEG 2.5
            return MpegAudioV25SampleRateTable[samplingFreqIndex];
        case 2:
            // MPEG 2
            return MpegAudioV20SampleRateTable[samplingFreqIndex];
        case 3:
            // MPEG 1
            return MpegAudioV10SampleRateTable[samplingFreqIndex];
    }
    return avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
}
function getFrameSizeByVersionLayer(version, layer) {
    switch (version) {
        case 0:
            // MPEG 2.5
            return MpegAudioV25FrameSizeTable[layer];
        case 2:
            // MPEG 2
            return MpegAudioV20FrameSizeTable[layer];
        case 3:
            // MPEG 1
            return MpegAudioV10FrameSizeTable[layer];
    }
    return avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
}
function getBitRateByVersionLayerIndex(version, layer, index) {
    switch (layer) {
        // layer3
        case 1:
            switch (version) {
                case 0:
                case 2:
                    return MpegAudioV2L2L3BitRateTable[index];
                case 3:
                    return MpegAudioV1L3BitRateTable[index];
            }
            break;
        // layer2
        case 2:
            switch (version) {
                case 0:
                case 2:
                    return MpegAudioV2L2L3BitRateTable[index];
                case 3:
                    return MpegAudioV1L2BitRateTable[index];
            }
        // layer1
        case 3:
            switch (version) {
                case 0:
                case 2:
                    return MpegAudioV2L1BitRateTable[index];
                case 3:
                    return MpegAudioV1L1BitRateTable[index];
            }
    }
    return avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
}
function getProfileByLayer(layer) {
    switch (layer) {
        case 1:
            // Layer 3
            return 34;
        case 2:
            // Layer 2
            return 33;
        case 3:
            // Layer 1
            return 32;
    }
    return avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
}
const MP3Profile2Name = {
    [32 /* MP3Profile.Layer1 */]: 'Layer1',
    [33 /* MP3Profile.Layer2 */]: 'Layer2',
    [34 /* MP3Profile.Layer3 */]: 'Layer3'
};
function parseAVCodecParameters(stream, buffer) {
    if (buffer && buffer.length >= 4) {
        const ver = (buffer[1] >>> 3) & 0x03;
        const layer = (buffer[1] & 0x06) >> 1;
        // const bitrateIndex = (buffer[2] & 0xF0) >>> 4
        const samplingFreqIndex = (buffer[2] & 0x0C) >>> 2;
        const channelMode = (buffer[3] >>> 6) & 0x03;
        const channelCount = channelMode !== 3 ? 2 : 1;
        const profile = getProfileByLayer(layer);
        const sampleRate = getSampleRateByVersionIndex(ver, samplingFreqIndex);
        stream.codecpar.profile = profile;
        stream.codecpar.sampleRate = sampleRate;
        stream.codecpar.chLayout.nbChannels = channelCount;
    }
}


/***/ }),

/***/ "./src/avformat/codecs/vp8.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/vp8.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseExtraData: () => (/* binding */ parseExtraData)
/* harmony export */ });
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/*
 * libmedia vp8 util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        const params = parseExtraData(extradata);
        stream.codecpar.profile = params.profile;
        stream.codecpar.level = params.level;
    }
}
/**
 * - 1 byte profile
 * - 1 byte level
 * - 4 bit bitdepth
 * - 3 bit chroma_subsampling
 * - 1 bit full_range_flag
 * - 1 byte color_primaries
 * - 1 byte color_trc
 * - 1 byte color_space
 *
 * @param extradata
 */
function parseExtraData(extradata) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__["default"](extradata.length);
    bitReader.appendBuffer(extradata.subarray(4));
    const profile = bitReader.readU(8);
    const level = bitReader.readU(8);
    let bitDepth = bitReader.readU(4);
    const chromaSubsampling = bitReader.readU(3);
    const fullRangeFlag = bitReader.readU1();
    const colorPrimaries = bitReader.readU(8);
    const colorTrc = bitReader.readU(8);
    const colorSpace = bitReader.readU(8);
    return {
        profile,
        level,
        bitDepth,
        chromaSubsampling,
        fullRangeFlag,
        colorPrimaries,
        colorTrc,
        colorSpace
    };
}


/***/ }),

/***/ "./src/avformat/codecs/vp9.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/vp9.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VP9Profile2Name: () => (/* binding */ VP9Profile2Name),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseExtraData: () => (/* binding */ parseExtraData)
/* harmony export */ });
/* unused harmony exports LevelCapabilities, getLevelByResolution, generateExtradata */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./..\..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");








const VP9Profile2Name = {
    [0 /* VP9Profile.Profile0 */]: 'Profile0',
    [1 /* VP9Profile.Profile1 */]: 'Profile1',
    [2 /* VP9Profile.Profile2 */]: 'Profile2',
    [3 /* VP9Profile.Profile3 */]: 'Profile3'
};
const LevelCapabilities = [
    { level: 10, maxResolution: 196608, maxFrameRate: 30 },
    { level: 11, maxResolution: 196608, maxFrameRate: 60 },
    { level: 20, maxResolution: 518400, maxFrameRate: 30 },
    { level: 21, maxResolution: 518400, maxFrameRate: 60 },
    { level: 30, maxResolution: 2073600, maxFrameRate: 30 },
    { level: 31, maxResolution: 2073600, maxFrameRate: 60 },
    { level: 40, maxResolution: 3686400, maxFrameRate: 30 },
    { level: 41, maxResolution: 3686400, maxFrameRate: 60 },
    { level: 50, maxResolution: 8294400, maxFrameRate: 30 },
    { level: 51, maxResolution: 8294400, maxFrameRate: 60 },
    { level: 60, maxResolution: 8847360, maxFrameRate: 30 },
    { level: 61, maxResolution: 8847360, maxFrameRate: 60 },
    { level: 70, maxResolution: 35389440, maxFrameRate: 30 },
    { level: 71, maxResolution: 35389440, maxFrameRate: 60 }
];
function getLevelByResolution(width, height, fps) {
    const resolution = width * height;
    for (const level of LevelCapabilities) {
        if (resolution <= level.maxResolution && fps <= level.maxFrameRate) {
            return level.level;
        }
    }
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        const params = parseExtraData(extradata);
        stream.codecpar.profile = params.profile;
        stream.codecpar.level = params.level;
    }
}
/**
 * - 1 byte profile
 * - 1 byte level
 * - 4 bit bitdepth
 * - 3 bit chroma_subsampling
 * - 1 bit full_range_flag
 * - 1 byte color_primaries
 * - 1 byte color_trc
 * - 1 byte color_space
 *
 * @param extradata
 */
function parseExtraData(extradata) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_3__["default"](extradata.length);
    bitReader.appendBuffer(extradata);
    const profile = bitReader.readU(8);
    const level = bitReader.readU(8);
    let bitDepth = bitReader.readU(4);
    const chromaSubsampling = bitReader.readU(3);
    const fullRangeFlag = bitReader.readU1();
    const colorPrimaries = bitReader.readU(8);
    const colorTrc = bitReader.readU(8);
    const colorSpace = bitReader.readU(8);
    return {
        profile,
        level,
        bitDepth,
        chromaSubsampling,
        fullRangeFlag,
        colorPrimaries,
        colorTrc,
        colorSpace
    };
}
function getVpccFeature(codecpar) {
    let profile = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 48);
    let level = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 52);
    if (level === avutil_constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE) {
        level = getLevelByResolution(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 56), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 60), (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_6__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__["default"])(codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_1__.Rational)));
    }
    const desc = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 28)];
    let bitDepth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 40);
    let chromaSubsampling = 1 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_COLLOCATED_WITH_LUMA */;
    if (desc) {
        bitDepth = desc.comp[0].depth;
        if (desc.log2ChromaW === 1 && desc.log2ChromaH === 1) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 100) === 1 /* AVChromaLocation.AVCHROMA_LOC_LEFT */) {
                chromaSubsampling = 0 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_VERTICAL */;
            }
        }
        else if (desc.log2ChromaW === 1 && desc.log2ChromaH === 0) {
            chromaSubsampling = 2 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_422 */;
        }
        else if (desc.log2ChromaW === 0 && desc.log2ChromaH === 0) {
            chromaSubsampling = 3 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_444 */;
        }
    }
    const fullRange = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 84) === 2 /* AVColorRange.AVCOL_RANGE_JPEG */ ? 1 : 0;
    if (profile === avutil_constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE && bitDepth) {
        if (chromaSubsampling == 0 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_VERTICAL */
            || chromaSubsampling == 1 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_COLLOCATED_WITH_LUMA */) {
            profile = (bitDepth == 8) ? 0 /* VP9Profile.Profile0 */ : 2 /* VP9Profile.Profile2 */;
        }
        else {
            profile = (bitDepth == 8) ? 1 /* VP9Profile.Profile1 */ : 3 /* VP9Profile.Profile3 */;
        }
    }
    return {
        profile,
        level,
        bitDepth,
        chromaSubsampling,
        fullRange
    };
}
function generateExtradata(codecpar) {
    const ioWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_7__["default"](new Uint8Array(8));
    const vpcc = getVpccFeature(codecpar);
    ioWriter.writeUint8(vpcc.profile);
    ioWriter.writeUint8(vpcc.level);
    ioWriter.writeUint8((vpcc.bitDepth << 4) | (vpcc.chromaSubsampling << 1) | vpcc.fullRange);
    ioWriter.writeUint8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 88));
    ioWriter.writeUint8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 92));
    ioWriter.writeUint8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 96));
    ioWriter.writeUint16(0);
    return ioWriter.getWroteBuffer();
}


/***/ }),

/***/ "./src/avformat/codecs/vvc.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/vvc.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annexb2Avcc: () => (/* binding */ annexb2Avcc),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseAVCodecParametersBySps: () => (/* binding */ parseAVCodecParametersBySps),
/* harmony export */   parseAnnexbExtraData: () => (/* binding */ parseAnnexbExtraData),
/* harmony export */   parseAvccExtraData: () => (/* binding */ parseAvccExtraData),
/* harmony export */   parseExtraData: () => (/* binding */ parseExtraData),
/* harmony export */   parseSPS: () => (/* binding */ parseSPS)
/* harmony export */ });
/* unused harmony exports extradata2VpsSpsPps, vpsSpsPps2Extradata, annexbExtradata2AvccExtradata, avcc2Annexb, isIDR */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/util/nalu */ "./src/avutil/util/nalu.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/util/expgolomb */ "./src/avutil/util/expgolomb.ts");
/* harmony import */ var common_io_BitWriter__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/io/BitWriter */ "./src/common/io/BitWriter.ts");
/* harmony import */ var avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avutil/util/intread */ "./src/avutil/util/intread.ts");


/*
 * libmedia vvc util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */











const NALULengthSizeMinusOne = 3;
function parsePTL(bitReader) {
    const olsIdx = bitReader.readU(9);
    const numSublayers = bitReader.readU(3);
    const constantFrameRate = bitReader.readU(2);
    const chromaFormatIdc = bitReader.readU(2);
    const bitDepthMinus8 = bitReader.readU(3);
    bitReader.readU(5);
    // VvcPTLRecord
    bitReader.readU(2);
    const num_bytes_constraint_info = bitReader.readU(6);
    const generalProfileIdc = bitReader.readU(7);
    const generalTierFlag = bitReader.readU(1);
    const generalLevelIdc = bitReader.readU(8);
    const ptlFrameOnlyConstraintFlag = bitReader.readU(1);
    const ptlMultilayerEnabledFlag = bitReader.readU(1);
    const generalConstraintInfo = [];
    const sublayerLevelIdc = [];
    if (num_bytes_constraint_info) {
        for (let i = 0; i < num_bytes_constraint_info - 1; i++) {
            generalConstraintInfo[i] = bitReader.readU(8);
        }
        generalConstraintInfo[num_bytes_constraint_info - 1] = bitReader.readU(6);
    }
    else {
        bitReader.readU(6);
    }
    if (numSublayers > 1) {
        let ptl_sublayer_present_mask = 0;
        for (let j = numSublayers - 2; j >= 0; --j) {
            const val = bitReader.readU(1);
            ptl_sublayer_present_mask |= val << j;
        }
        for (let j = numSublayers; j <= 8 && numSublayers > 1; ++j) {
            bitReader.readU(1);
        }
        for (let j = numSublayers - 2; j >= 0; --j) {
            if (ptl_sublayer_present_mask & (1 << j)) {
                sublayerLevelIdc[j] = bitReader.readU(8);
            }
        }
    }
    const ptl_num_sub_profiles = bitReader.readU(8);
    const generalSubProfileIdc = [];
    if (ptl_num_sub_profiles) {
        for (let i = 0; i < ptl_num_sub_profiles; i++) {
            generalSubProfileIdc.push(bitReader.readU(8));
        }
    }
    const maxPictureWidth = bitReader.readU(16);
    const maxPictureHeight = bitReader.readU(16);
    const avgFramerate = bitReader.readU(16);
    return {
        olsIdx,
        numSublayers,
        bitDepthMinus8,
        chromaFormatIdc,
        constantFrameRate,
        generalProfileIdc,
        generalTierFlag,
        generalLevelIdc,
        ptlFrameOnlyConstraintFlag,
        ptlMultilayerEnabledFlag,
        generalConstraintInfo,
        sublayerLevelIdc,
        generalSubProfileIdc,
        maxPictureWidth,
        maxPictureHeight,
        avgFramerate
    };
}
/**
 *
 * vvcc 格式的 extradata 转 annexb vps sps pps
 *
 * bits
 * - 5   reserved (11111)
 * - 2   lengthSizeMinusOne
 * - 1   ptl_present_flag
 * if ptl_present_flag
 *   - 9   ols_idx
 *   - 3  num_sublayers
 *   - 2  constant_frame_rate
 *   - 2  chroma_format_idc
 *   - 3  bit_depth_minus8
 *   - 5  reserved (11111)
 *   VvcPTLRecord
 *   - 2 reserved (11)
 *   - 6 num_bytes_constraint_info
 *   - 7 general_profile_idc
 *   - 1 general_tier_flag
 *   - 8 general_level_idc
 *   - 1 general_level_idc
 *   - 1 ptl_multilayer_enabled_flag
 *   if num_bytes_constraint_info > 0
 *      for (i = 0; i < num_bytes_constraint_info - 1; i++)
 *        - 8 general_constraint_info[i]
 *      - 6 general_constraint_info[num_bytes_constraint_info - 1]
 *   else
 *      - 6 reserved
 *   if num_sublayers > 1
 *      - num_sublayers - 2 ptl_sublayer_level_present_flag
 *      - 8 - num_sublayers + 1 ptl_reserved_zero_bit
 *      for (i = num_sublayers -2; i >= 0; i--)
 *        if ptl_sublayer_present_mask & (1 << i)
 *          - 8 sublayer_level_idc[i]
 *    - 8 ptl_num_sub_profiles
 *    if ptl_num_sub_profiles
 *      for (i = 0; i < ptl_num_sub_profiles; i++)
 *        - 32 general_sub_profile_idc[i]
 *    - 16 max_picture_width
 *    - 16 max_picture_height
 *    - 16 avg_frame_rate
 * - 8   numOfArrays
 * - repeated of array (vps/sps/pps)
 * - 1   array_completeness
 * - 2   reserved (0)
 * - 5   NAL_unit_type
 * if nalu_type != VVC_NALU_DEC_PARAM && nalu_type != VVC_NALU_OPI
 *    - 16  numNalus
 * else
 *   numNalus = 1
 * - repeated once per NAL
 * - 16  nalUnitLength
 * - N   NALU data
 *
 */
function extradata2VpsSpsPps(extradata) {
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](extradata, true);
    const ptlPresentFlag = bufferReader.readUint8() & 0x01;
    if (ptlPresentFlag) {
        const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__["default"]();
        bitReader.appendBuffer(extradata.subarray(1));
        parsePTL(bitReader);
        bufferReader.skip(bitReader.getPos());
    }
    let vpss = [];
    let spss = [];
    let ppss = [];
    const arrayLen = bufferReader.readUint8();
    for (let i = 0; i < arrayLen; i++) {
        const naluType = bufferReader.readUint8() & 0x1f;
        let count = 1;
        if (naluType !== 13 /* VVCNaluType.kDCI_NUT */ && naluType !== 12 /* VVCNaluType.kOPI_NUT */) {
            count = bufferReader.readUint16();
        }
        const list = [];
        for (let j = 0; j < count; j++) {
            const len = bufferReader.readUint16();
            list.push(bufferReader.readBuffer(len));
        }
        if (naluType === 14 /* VVCNaluType.kVPS_NUT */) {
            vpss = list;
        }
        else if (naluType === 15 /* VVCNaluType.kSPS_NUT */) {
            spss = list;
        }
        else if (naluType === 16 /* VVCNaluType.kPPS_NUT */) {
            ppss = list;
        }
    }
    return {
        vpss,
        spss,
        ppss
    };
}
function vpsSpsPps2Extradata(vpss, spss, ppss) {
    const sps = spss[0];
    let ptl;
    if (sps) {
        const spsParams = parseSPS(sps);
        let generalConstraintInfo = spsParams.generalConstraintInfo;
        if (!generalConstraintInfo.length) {
            generalConstraintInfo = new Array(12).fill(0);
        }
        const biWriter = new common_io_BitWriter__WEBPACK_IMPORTED_MODULE_11__["default"]();
        biWriter.writeU(9, 0);
        biWriter.writeU(3, spsParams.spsMaxSublayersMinus1 + 1);
        biWriter.writeU(2, 1);
        biWriter.writeU(2, spsParams.chromaFormatIdc);
        biWriter.writeU(3, spsParams.bitDepthMinus8);
        biWriter.writeU(5, 0b11111);
        biWriter.writeU(2, 0);
        biWriter.writeU(6, generalConstraintInfo.length);
        biWriter.writeU(7, spsParams.profile);
        biWriter.writeU1(spsParams.tierFlag);
        biWriter.writeU(8, spsParams.level);
        biWriter.writeU1(spsParams.ptlFrameOnlyConstraintFlag);
        biWriter.writeU1(spsParams.ptlMultilayerEnabledFlag);
        if (generalConstraintInfo.length) {
            for (let i = 0; i < generalConstraintInfo.length - 1; i++) {
                biWriter.writeU(8, generalConstraintInfo[i]);
            }
            biWriter.writeU(6, generalConstraintInfo[generalConstraintInfo.length - 1]);
        }
        else {
            biWriter.writeU(6, 0b111111);
        }
        if (spsParams.spsMaxSublayersMinus1 + 1 > 1) {
            let ptl_sublayer_level_present_flags = 0;
            for (let i = spsParams.spsMaxSublayersMinus1 - 1; i >= 0; i--) {
                ptl_sublayer_level_present_flags = (ptl_sublayer_level_present_flags << 1 | spsParams.ptlSublayerLevelPresentFlag[i]);
            }
            biWriter.writeU(spsParams.spsMaxSublayersMinus1, ptl_sublayer_level_present_flags);
            for (let j = spsParams.spsMaxSublayersMinus1 + 1; j <= 8 && spsParams.spsMaxSublayersMinus1 > 0; ++j) {
                biWriter.writeU1(0);
            }
            for (let i = spsParams.spsMaxSublayersMinus1 - 1; i >= 0; i--) {
                if (spsParams.ptlSublayerLevelPresentFlag[i]) {
                    biWriter.writeU(8, spsParams.sublayerLevelIdc[i]);
                }
            }
        }
        biWriter.writeU(8, spsParams.generalSubProfileIdc.length);
        for (let i = 0; i < spsParams.generalSubProfileIdc.length; i++) {
            biWriter.writeU(8, spsParams.sublayerLevelIdc[i]);
        }
        biWriter.writeU(16, spsParams.width);
        biWriter.writeU(16, spsParams.height);
        biWriter.writeU(16, 0);
        biWriter.padding();
        ptl = biWriter.getBuffer().subarray(0, biWriter.getPointer());
    }
    let length = 2 + (ptl ? ptl.length : 0);
    if (vpss.length) {
        // type + count
        length += 3;
        length = vpss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    if (spss.length) {
        // type + count
        length += 3;
        length = spss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    if (ppss.length) {
        // type + count
        length += 3;
        length = ppss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    const buffer = new Uint8Array(length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer, true);
    bufferWriter.writeUint8(NALULengthSizeMinusOne << 1 | (ptl ? 1 : 0) | 0xf8);
    if (ptl) {
        bufferWriter.writeBuffer(ptl);
    }
    // numOfArrays
    let numOfArrays = 0;
    if (vpss.length) {
        numOfArrays++;
    }
    if (spss.length) {
        numOfArrays++;
    }
    if (ppss.length) {
        numOfArrays++;
    }
    bufferWriter.writeUint8(numOfArrays);
    // vps
    if (vpss.length) {
        bufferWriter.writeUint8((128) | 14 /* VVCNaluType.kVPS_NUT */);
        bufferWriter.writeUint16(vpss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(vpss, (vps) => {
            bufferWriter.writeUint16(vps.length);
            bufferWriter.writeBuffer(vps);
        });
    }
    // sps
    if (spss.length) {
        bufferWriter.writeUint8((128) | 15 /* VVCNaluType.kSPS_NUT */);
        bufferWriter.writeUint16(spss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
            bufferWriter.writeUint16(sps.length);
            bufferWriter.writeBuffer(sps);
        });
    }
    // pps
    if (ppss.length) {
        bufferWriter.writeUint8((128) | 16 /* VVCNaluType.kPPS_NUT */);
        bufferWriter.writeUint16(ppss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
            bufferWriter.writeUint16(pps.length);
            bufferWriter.writeBuffer(pps);
        });
    }
    return buffer;
}
function annexbExtradata2AvccExtradata(data) {
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)(data);
    if (nalus.length >= 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[1] >>> 3) & 0x1f;
            if (type === 14 /* VVCNaluType.kVPS_NUT */) {
                vpss.push(nalu);
            }
            else if (type === 15 /* VVCNaluType.kSPS_NUT */) {
                spss.push(nalu);
            }
            else if (type === 16 /* VVCNaluType.kPPS_NUT */) {
                ppss.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            return vpsSpsPps2Extradata(vpss, spss, ppss);
        }
    }
}
/**
 *
 * annexb 格式的 NALU 转 avcc NALU
 *
 */
function annexb2Avcc(data) {
    let extradata;
    let key = false;
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)(data);
    if (nalus.length >= 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[1] >>> 3) & 0x1f;
            if (type === 14 /* VVCNaluType.kVPS_NUT */) {
                vpss.push(nalu);
            }
            else if (type === 15 /* VVCNaluType.kSPS_NUT */) {
                spss.push(nalu);
            }
            else if (type === 16 /* VVCNaluType.kPPS_NUT */) {
                ppss.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
            nalus = nalus.filter((nalu) => {
                const type = (nalu[1] >>> 3) & 0x1f;
                return type !== 14 /* VVCNaluType.kVPS_NUT */
                    && type !== 15 /* VVCNaluType.kSPS_NUT */
                    && type !== 16 /* VVCNaluType.kPPS_NUT */
                    && type !== 20 /* VVCNaluType.kAUD_NUT */;
            });
        }
    }
    const length = nalus.reduce((prev, nalu) => {
        return prev + NALULengthSizeMinusOne + 1 + nalu.length;
    }, 0);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(length);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(bufferPointer, length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu) => {
        if (NALULengthSizeMinusOne === 3) {
            bufferWriter.writeUint32(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 2) {
            bufferWriter.writeUint24(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 1) {
            bufferWriter.writeUint16(nalu.length);
        }
        else {
            bufferWriter.writeUint8(nalu.length);
        }
        bufferWriter.writeBuffer(nalu.subarray(0));
        const type = (nalu[1] >>> 3) & 0x1f;
        if (type === 8 /* VVCNaluType.kIDR_N_LP */
            || type === 7 /* VVCNaluType.kIDR_W_RADL */
            || type === 9 /* VVCNaluType.kCRA_NUT */
            || type === 10 /* VVCNaluType.kGDR_NUT */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length,
        extradata,
        key
    };
}
/**
 * avcc 格式的 NALU 转 annexb NALU
 *
 */
function avcc2Annexb(data, extradata) {
    const naluLengthSizeMinusOne = extradata ? ((extradata[0] >>> 1) & 0x03) : NALULengthSizeMinusOne;
    let vpss = [];
    let spss = [];
    let ppss = [];
    let key = false;
    if (extradata) {
        const result = extradata2VpsSpsPps(extradata);
        vpss = result.vpss;
        spss = result.spss;
        ppss = result.ppss;
        key = true;
    }
    const nalus = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        nalus.push(bufferReader.readBuffer(length));
    }
    let length = vpss.reduce((prev, vps) => {
        return prev + 4 + vps.length;
    }, 0);
    length = spss.reduce((prev, sps) => {
        return prev + 4 + sps.length;
    }, length);
    length = ppss.reduce((prev, pps) => {
        return prev + 4 + pps.length;
    }, length);
    length = nalus.reduce((prev, nalu, index) => {
        return prev + (index ? 3 : 4) + nalu.length;
    }, length);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(length + 7);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(bufferPointer, length + 7);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer);
    // AUD
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(20 /* VVCNaluType.kAUD_NUT */ << 3);
    bufferWriter.writeUint8(0xf0);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(vpss, (vps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(vps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(sps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(pps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu, index) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        if (!index) {
            bufferWriter.writeUint8(0x00);
        }
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(nalu);
        const type = (nalu[1] >>> 3) & 0x1f;
        if (type === 8 /* VVCNaluType.kIDR_N_LP */
            || type === 7 /* VVCNaluType.kIDR_W_RADL */
            || type === 9 /* VVCNaluType.kCRA_NUT */
            || type === 10 /* VVCNaluType.kGDR_NUT */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length: length + 7,
        key
    };
}
function parseAvccExtraData(avpacket, stream) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if ((0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.isAnnexb)(data)) {
        return;
    }
    const naluLengthSizeMinusOne = stream.metadata.naluLengthSizeMinusOne ?? NALULengthSizeMinusOne;
    let vpss = [];
    let spss = [];
    let ppss = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = data.subarray((Number(bufferReader.getPos() & 0xffffffffn) >> 0), (Number(bufferReader.getPos() & 0xffffffffn) >> 0) + length);
        bufferReader.skip(length);
        const naluType = (nalu[1] >>> 3) & 0x1f;
        if (naluType === 15 /* VVCNaluType.kSPS_NUT */) {
            spss.push(nalu);
        }
        else if (naluType === 16 /* VVCNaluType.kPPS_NUT */) {
            ppss.push(nalu);
        }
        else if (naluType === 14 /* VVCNaluType.kVPS_NUT */) {
            vpss.push(nalu);
        }
    }
    if (spss.length || ppss.length || vpss.length) {
        const extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
        const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(extradata.length);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
    }
}
function parseAnnexbExtraData(avpacket, force = false) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) && !force) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if (!(0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.isAnnexb)(data)) {
        return;
    }
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)(data);
    if (nalus.length > 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[1] >>> 3) & 0x1f;
            if (type === 14 /* VVCNaluType.kVPS_NUT */) {
                vpss.push(nalu);
            }
            else if (type === 15 /* VVCNaluType.kSPS_NUT */) {
                spss.push(nalu);
            }
            else if (type === 16 /* VVCNaluType.kPPS_NUT */) {
                ppss.push(nalu);
            }
        });
        if (vpss.length && spss.length && ppss.length) {
            const extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
            const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(extradata.length);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
        }
    }
}
function parseAVCodecParametersBySps(stream, sps) {
    const { profile, level, width, height } = parseSPS(sps);
    stream.codecpar.profile = profile;
    stream.codecpar.level = level;
    stream.codecpar.width = width;
    stream.codecpar.height = height;
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        stream.metadata.naluLengthSizeMinusOne = (extradata[0] >>> 1) & 0x03;
        const { spss } = extradata2VpsSpsPps(extradata);
        if (spss.length) {
            parseAVCodecParametersBySps(stream, spss[0]);
        }
    }
}
function isIDR(avpacket, naluLengthSize = 4) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
        return false;
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 80) === 2 /* BitFormat.ANNEXB */) {
        let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28)));
        return nalus.some((nalu) => {
            const type = (nalu[1] >>> 3) & 0x1f;
            return type === 8 /* VVCNaluType.kIDR_N_LP */ || type === 7 /* VVCNaluType.kIDR_W_RADL */;
        });
    }
    else {
        const size = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28);
        let i = 0;
        while (i < (size - naluLengthSize)) {
            const type = (avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + (i + naluLengthSize + 1)) >>> 3) & 0x1f;
            if (type === 8 /* VVCNaluType.kIDR_N_LP */ || type === 7 /* VVCNaluType.kIDR_W_RADL */) {
                return true;
            }
            if (naluLengthSize === 4) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.rb32(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else if (naluLengthSize === 3) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.rb24(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else if (naluLengthSize === 2) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.rb16(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            i += naluLengthSize;
        }
        return false;
    }
}
function parseSPS(sps) {
    if (!sps || sps.length < 3) {
        return;
    }
    let offset = 0;
    if (sps[0] === 0x00
        && sps[1] === 0x00
        && sps[2] === 0x00
        && sps[3] === 0x01) {
        offset = 4;
    }
    let profile = 0;
    let level = 0;
    let width = 0;
    let height = 0;
    let bitDepthMinus8 = 0;
    let chromaFormatIdc = 1;
    let generalProfileSpace = 0;
    let tierFlag = 0;
    let ptlFrameOnlyConstraintFlag = 0;
    let ptlMultilayerEnabledFlag = 0;
    const generalConstraintInfo = [];
    const ptlSublayerLevelPresentFlag = [];
    const sublayerLevelIdc = [];
    const generalSubProfileIdc = [];
    const buffer = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.naluUnescape)(sps.subarray(offset));
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__["default"](buffer.length);
    bitReader.appendBuffer(buffer);
    // forbidden_zero_bit
    bitReader.readU1();
    // nuh_reserved_zero_bit
    bitReader.readU1();
    // layerId
    bitReader.readU(6);
    // nalu type
    bitReader.readU(5);
    // tid
    bitReader.readU(3);
    // sps_seq_parameter_set_id && sps_video_parameter_set_id
    bitReader.readU(8);
    const spsMaxSublayersMinus1 = bitReader.readU(3);
    chromaFormatIdc = bitReader.readU(2);
    const sps_log2_ctu_size_minus5 = bitReader.readU(2);
    const sps_ptl_dpb_hrd_params_present_flag = bitReader.readU(1);
    if (sps_ptl_dpb_hrd_params_present_flag) {
        profile = bitReader.readU(7);
        tierFlag = bitReader.readU(1);
        level = bitReader.readU(8);
        ptlFrameOnlyConstraintFlag = bitReader.readU(1);
        ptlMultilayerEnabledFlag = bitReader.readU(1);
        const gci_present_flag = bitReader.readU(1);
        if (gci_present_flag) {
            for (let j = 0; j < 8; j++) {
                generalConstraintInfo[j] = bitReader.readU(8);
            }
            generalConstraintInfo[8] = bitReader.readU(7);
            const gci_num_reserved_bits = bitReader.readU(8);
            bitReader.readU(gci_num_reserved_bits);
        }
        bitReader.skipPadding();
        for (let i = spsMaxSublayersMinus1 - 1; i >= 0; i--) {
            ptlSublayerLevelPresentFlag[i] = bitReader.readU(1);
        }
        bitReader.skipPadding();
        for (let i = spsMaxSublayersMinus1 - 1; i >= 0; i--) {
            if (ptlSublayerLevelPresentFlag[i]) {
                sublayerLevelIdc[i] = bitReader.readU(8);
            }
        }
        const ptl_num_sub_profiles = bitReader.readU(8);
        if (ptl_num_sub_profiles) {
            for (let i = 0; i < ptl_num_sub_profiles; i++) {
                generalSubProfileIdc[i] = bitReader.readU(32);
            }
        }
    }
    // sps_gdr_enabled_flag
    bitReader.readU1();
    const sps_ref_pic_resampling_enabled_flag = bitReader.readU1();
    if (sps_ref_pic_resampling_enabled_flag) {
        // sps_res_change_in_clvs_allowed_flag
        bitReader.readU1();
    }
    const sps_pic_width_max_in_luma_samples = width = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    const sps_pic_height_max_in_luma_samples = height = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    if (bitReader.readU1()) {
        // sps_conf_win_left_offset
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        // sps_conf_win_right_offset
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        // sps_conf_win_top_offset
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        // sps_conf_win_bottom_offset
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    }
    if (bitReader.readU1()) {
        const sps_num_subpics_minus1 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        const ctb_log2_size_y = sps_log2_ctu_size_minus5 + 5;
        const ctb_size_y = 1 << ctb_log2_size_y;
        const tmp_width_val = sps_pic_width_max_in_luma_samples / (1 << ctb_log2_size_y);
        const tmp_height_val = sps_pic_height_max_in_luma_samples / (1 << ctb_log2_size_y);
        const wlen = Math.ceil(Math.log2(tmp_width_val));
        const hlen = Math.ceil(Math.log2(tmp_height_val));
        let sps_subpic_id_len = 0;
        let sps_subpic_same_size_flag = 0;
        let sps_independent_subpics_flag = 0;
        // sps_num_subpics_minus1
        if (sps_num_subpics_minus1 > 0) {
            sps_independent_subpics_flag = bitReader.readU1();
            sps_subpic_same_size_flag = bitReader.readU1();
        }
        for (let i = 0; sps_num_subpics_minus1 > 0 && i <= sps_num_subpics_minus1; i++) {
            if (!sps_subpic_same_size_flag || i == 0) {
                if (i > 0 && sps_pic_width_max_in_luma_samples > ctb_size_y) {
                    bitReader.readU(wlen);
                }
                if (i > 0 && sps_pic_height_max_in_luma_samples > ctb_size_y) {
                    bitReader.readU(hlen);
                }
                if (i < sps_num_subpics_minus1 && sps_pic_width_max_in_luma_samples > ctb_size_y) {
                    bitReader.readU(wlen);
                }
                if (i < sps_num_subpics_minus1 && sps_pic_height_max_in_luma_samples > ctb_size_y) {
                    bitReader.readU(hlen);
                }
            }
            if (!sps_independent_subpics_flag) {
                // sps_subpic_treated_as_pic_flag && sps_loop_filter_across_subpic_enabled_flag
                bitReader.readU(2);
            }
        }
        sps_subpic_id_len = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader) + 1;
        // sps_subpic_id_mapping_explicitly_signalled_flag
        if (bitReader.readU(1)) {
            // sps_subpic_id_mapping_present_flag
            if (bitReader.readU(1)) {
                for (let i = 0; i <= sps_num_subpics_minus1; i++) {
                    // sps_subpic_id[i]
                    bitReader.readU(sps_subpic_id_len);
                }
            }
        }
    }
    bitDepthMinus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    // sps_entropy_coding_sync_enabled_flag
    bitReader.readU(1);
    // sps_entry_point_offsets_present_flag
    bitReader.readU(1);
    const sps_log2_max_pic_order_cnt_lsb_minus4 = bitReader.readU(4);
    const sps_poc_msb_cycle_flag = bitReader.readU(1);
    let sps_poc_msb_cycle_len_minus1 = 0;
    if (sps_poc_msb_cycle_flag) {
        sps_poc_msb_cycle_len_minus1 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    }
    const sps_extra_ph_bit_present_flag = [];
    const sps_num_extra_ph_bytes = bitReader.readU(2);
    for (let i = 0; i < (sps_num_extra_ph_bytes * 8); i++) {
        sps_extra_ph_bit_present_flag[i] = bitReader.readU(1);
    }
    return {
        profile,
        level,
        width,
        height,
        chromaFormatIdc,
        bitDepthMinus8,
        generalProfileSpace,
        tierFlag,
        generalConstraintInfo,
        generalSubProfileIdc,
        ptlFrameOnlyConstraintFlag,
        ptlMultilayerEnabledFlag,
        spsMaxSublayersMinus1,
        ptlSublayerLevelPresentFlag,
        sublayerLevelIdc,
        sps_log2_max_pic_order_cnt_lsb_minus4,
        sps_poc_msb_cycle_flag,
        sps_poc_msb_cycle_len_minus1,
        sps_num_extra_ph_bytes,
        sps_extra_ph_bit_present_flag
    };
}
function parseExtraData(extradata) {
    if (extradata[0] === 0 && extradata[1] === 0 && extradata[2] === 0 && extradata[3] === 1) {
        extradata = annexbExtradata2AvccExtradata(extradata);
    }
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__["default"]();
    bitReader.appendBuffer(extradata);
    const ptlPresentFlag = bitReader.readU(8) & 0x01;
    if (ptlPresentFlag) {
        return parsePTL(bitReader);
    }
    return {};
}


/***/ }),

/***/ "./src/avformat/config.ts":
/*!********************************!*\
  !*** ./src/avformat/config.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DURATION_MAX_READ_SIZE: () => (/* binding */ DURATION_MAX_READ_SIZE),
/* harmony export */   SAMPLE_INDEX_STEP: () => (/* binding */ SAMPLE_INDEX_STEP)
/* harmony export */ });
/*
 * libmedia avformat config
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const DURATION_MAX_READ_SIZE = 256000;
const SAMPLE_INDEX_STEP = BigInt(5000);


/***/ }),

/***/ "./src/avformat/demux.ts":
/*!*******************************!*\
  !*** ./src/avformat/demux.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   analyzeStreams: () => (/* binding */ analyzeStreams),
/* harmony export */   open: () => (/* binding */ open),
/* harmony export */   readAVPacket: () => (/* binding */ readAVPacket),
/* harmony export */   seek: () => (/* binding */ seek)
/* harmony export */ });
/* unused harmony export DefaultDemuxOptions */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var _function_checkStreamParameters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./function/checkStreamParameters */ "./src/avformat/function/checkStreamParameters.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./config */ "./src/avformat/config.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avcodec/wasmcodec/VideoDecoder */ "./src/avcodec/wasmcodec/VideoDecoder.ts");
/* harmony import */ var avcodec_wasmcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! avcodec/wasmcodec/AudioDecoder */ "./src/avcodec/wasmcodec/AudioDecoder.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
var cheap__fileName__0 = "src\\avformat\\demux.ts";
















const DefaultDemuxOptions = {
    fastOpen: false,
    maxAnalyzeDuration: 1000
};
// @ts-ignore
async function open(formatContext, options = {}) {
    const opts = common_util_object__WEBPACK_IMPORTED_MODULE_4__.extend({}, DefaultDemuxOptions, options);
    if (!formatContext.ioReader) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('need IOReader', cheap__fileName__0, 65);
    }
    if (!formatContext.iformat) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_12__.fatal('need iformat', cheap__fileName__0, 68);
    }
    if (formatContext.iformat.type === 2 /* AVFormat.MPEGTS */) {
        // mpegts 的最小分析时长为 2 秒，mpegts 的 dts 一般从 1.4 秒开始
        opts.maxAnalyzeDuration = Math.max(opts.maxAnalyzeDuration, 2000);
    }
    formatContext.iformat.init(formatContext);
    formatContext.options = opts;
    return formatContext.iformat.readHeader(formatContext);
}
// @ts-ignore
async function estimateDurationFromPts(formatContext) {
    const fileSize = await formatContext.ioReader.fileSize();
    if (fileSize <= BigInt(0)) {
        return;
    }
    const cache = formatContext.interval.packetBuffer;
    formatContext.interval.packetBuffer = [];
    let now = formatContext.ioReader.getPos();
    let retry = 0;
    while (retry < 4) {
        const pos = fileSize - BigInt(Math.floor(_config__WEBPACK_IMPORTED_MODULE_10__.DURATION_MAX_READ_SIZE << retry));
        const nextPos = await formatContext.iformat.seek(formatContext, null, pos, 2 /* AVSeekFlags.BYTE */);
        if (nextPos > BigInt(0)) {
            now = nextPos;
        }
        const lastDurationMap = {};
        const avpacket = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.createAVPacket)();
        while (true) {
            const ret = await readAVPacket(formatContext, avpacket);
            if (ret < 0) {
                break;
            }
            else {
                let duration = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8);
                const stream = formatContext.getStreamByIndex(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32));
                if (stream.startTime !== avutil_constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT) {
                    duration -= stream.startTime;
                }
                else {
                    duration -= stream.firstDTS;
                }
                if (duration > BigInt(0)) {
                    if (stream.duration === avutil_constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT
                        || !lastDurationMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32)]
                        || (stream.duration < duration
                            && Math.abs(Number(duration - stream.duration)) < 60 * stream.timeBase.den / stream.timeBase.num)) {
                        stream.duration = duration;
                    }
                    lastDurationMap[avpacket.streamIndex] = duration;
                }
            }
        }
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.destroyAVPacket)(avpacket);
        let hasDuration = true;
        common_util_array__WEBPACK_IMPORTED_MODULE_5__.each(formatContext.streams, (stream) => {
            if (stream.duration === avutil_constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT) {
                hasDuration = false;
                return false;
            }
        });
        if (hasDuration) {
            break;
        }
        retry++;
    }
    common_util_array__WEBPACK_IMPORTED_MODULE_5__.each(formatContext.interval.packetBuffer, (avpacket) => {
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.destroyAVPacket)(avpacket);
    });
    formatContext.interval.packetBuffer = cache;
    await formatContext.iformat.seek(formatContext, null, now, 2 /* AVSeekFlags.BYTE */);
}
// @ts-ignore
async function analyzeStreams(formatContext) {
    const needStreams = formatContext.iformat.getAnalyzeStreamsCount();
    const streamFirstGotMap = {};
    const streamDtsMap = {};
    const streamBitMap = {};
    let avpacket = 0;
    const caches = [];
    let ret = 0;
    const decoderMap = {};
    const pictureGot = {};
    function checkPictureGot() {
        if (!formatContext.getDecoderResource) {
            return true;
        }
        for (let i = 0; i < formatContext.streams.length; i++) {
            if (decoderMap[formatContext.streams[i].index] && !pictureGot[formatContext.streams[i].index]) {
                return false;
            }
        }
        return true;
    }
    while (true) {
        if (formatContext.streams.length >= needStreams
            && (0,_function_checkStreamParameters__WEBPACK_IMPORTED_MODULE_7__.checkStreamParameters)(formatContext)
            && formatContext.options.fastOpen
            && checkPictureGot()) {
            break;
        }
        if (!avpacket) {
            avpacket = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.createAVPacket)();
        }
        let packetCached = false;
        ret = await readAVPacket(formatContext, avpacket);
        if (ret !== 0) {
            break;
        }
        const stream = formatContext.getStreamByIndex(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28)) {
            packetCached = true;
            caches.push(avpacket);
            if (!streamFirstGotMap[stream.index]) {
                stream.firstDTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16);
                stream.startTime = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8);
                streamFirstGotMap[stream.index] = true;
            }
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8) < stream.startTime) {
                stream.startTime = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8);
            }
            if (streamDtsMap[stream.index]) {
                streamDtsMap[stream.index].push(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16));
            }
            else {
                streamDtsMap[stream.index] = [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16)];
            }
            if (streamBitMap[stream.index]) {
                streamBitMap[stream.index] += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28);
            }
            else {
                streamBitMap[stream.index] = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28);
            }
            if (!pictureGot[stream.index] && formatContext.getDecoderResource) {
                let decoder = decoderMap[stream.index];
                if (!decoder) {
                    const resource = await formatContext.getDecoderResource(stream.codecpar.codecType, stream.codecpar.codecId);
                    if (resource) {
                        if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                            decoder = new avcodec_wasmcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_14__["default"]({
                                resource,
                                onReceiveFrame: (avframe) => {
                                    stream.codecpar.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 80);
                                    stream.codecpar.frameSize = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 76);
                                    (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_15__.destroyAVFrame)(avframe);
                                    pictureGot[stream.index] = true;
                                },
                                onError: () => {
                                    pictureGot[stream.index] = true;
                                }
                            });
                        }
                        else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                            if (resource.threadModule) {
                                delete resource.threadModule;
                            }
                            decoder = new avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_13__["default"]({
                                resource,
                                onReceiveFrame: (avframe) => {
                                    stream.codecpar.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 80);
                                    stream.codecpar.colorSpace = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 220);
                                    stream.codecpar.colorPrimaries = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 212);
                                    stream.codecpar.colorTrc = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 216);
                                    stream.codecpar.chromaLocation = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 224);
                                    stream.codecpar.sampleAspectRatio = (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avframe + 92, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational);
                                    (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_15__.destroyAVFrame)(avframe);
                                    pictureGot[stream.index] = true;
                                },
                                onError: () => {
                                    pictureGot[stream.index] = true;
                                }
                            });
                        }
                        await decoder.open(stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
                        decoderMap[stream.index] = decoder;
                    }
                }
                if (decoder) {
                    decoder.decode(avpacket);
                }
            }
        }
        if (streamDtsMap[stream.index] && streamDtsMap[stream.index].length === 12) {
            let count = BigInt(0);
            for (let i = 1; i < streamDtsMap[stream.index].length; i++) {
                count += streamDtsMap[stream.index][i] - streamDtsMap[stream.index][i - 1];
            }
            let value = Number(count) / (streamDtsMap[stream.index].length - 1);
            if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                && stream.codecpar.sampleRate > 0) {
                stream.codecpar.frameSize = Math.round(value / stream.timeBase.den * stream.timeBase.num * stream.codecpar.sampleRate);
            }
            else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                const framerate = stream.timeBase.den * stream.timeBase.num / value;
                stream.codecpar.framerate.num = Math.round(framerate);
                stream.codecpar.framerate.den = 1;
            }
            const duration = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16) - stream.firstDTS) * stream.timeBase.num / stream.timeBase.den;
            if (duration) {
                stream.codecpar.bitRate = BigInt(Math.floor(streamBitMap[stream.index] * 8 / duration));
            }
        }
        if ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16) - stream.startTime) > (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(BigInt(Math.floor(formatContext.options.maxAnalyzeDuration)), avutil_constant__WEBPACK_IMPORTED_MODULE_6__.AV_MILLI_TIME_BASE_Q, stream.timeBase)) {
            common_util_object__WEBPACK_IMPORTED_MODULE_4__.each(streamDtsMap, (list, id) => {
                const stream = formatContext.getStreamByIndex(+id);
                if (list && list.length > 1) {
                    let count = BigInt(0);
                    for (let i = 1; i < list.length; i++) {
                        count += list[i] - list[i - 1];
                    }
                    let value = Number(count) / (streamDtsMap[stream.index].length - 1);
                    if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                        && stream.codecpar.sampleRate > 0) {
                        stream.codecpar.frameSize = Math.round(value / stream.timeBase.den * stream.timeBase.num * stream.codecpar.sampleRate);
                    }
                    else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                        const framerate = stream.timeBase.den * stream.timeBase.num / value;
                        stream.codecpar.framerate.num = Math.round(framerate);
                        stream.codecpar.framerate.den = 1;
                    }
                    const duration = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16) - stream.firstDTS) * stream.timeBase.num / stream.timeBase.den;
                    if (duration) {
                        stream.codecpar.bitRate = BigInt(Math.floor(streamBitMap[stream.index] * 8 / duration));
                    }
                }
            });
            if (packetCached) {
                avpacket = 0;
            }
            break;
        }
        if (packetCached) {
            avpacket = 0;
        }
    }
    if (avpacket) {
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.destroyAVPacket)(avpacket);
    }
    if (caches.length) {
        formatContext.interval.packetBuffer = caches.concat(formatContext.interval.packetBuffer);
    }
    common_util_object__WEBPACK_IMPORTED_MODULE_4__.each(decoderMap, (decoder) => {
        if (decoder) {
            decoder.close();
        }
    });
    if (ret === -1048576 /* IOError.END */) {
        return 0;
    }
    else if (ret !== 0) {
        return ret;
    }
    if ((formatContext.iformat.type === 2 /* AVFormat.MPEGTS */)
        && (formatContext.ioReader.flags & 1 /* IOFlags.SEEKABLE */)) {
        await estimateDurationFromPts(formatContext);
    }
    return 0;
}
function addSample(stream, avpacket) {
    const index = common_util_array__WEBPACK_IMPORTED_MODULE_5__.binarySearch(stream.sampleIndexes, (sample) => {
        if (sample.pts < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8)) {
            return 1;
        }
        else {
            return -1;
        }
    });
    const sample = {
        dts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16),
        pts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8),
        pos: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 56),
        size: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28),
        duration: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 48),
        flags: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 36)
    };
    if (index > -1) {
        stream.sampleIndexesPosMap.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 56), index);
        stream.sampleIndexes.splice(index, 0, sample);
    }
    else {
        stream.sampleIndexesPosMap.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 56), stream.sampleIndexes.length);
        stream.sampleIndexes.push(sample);
    }
}
// @ts-ignore
async function packetNeedRead(formatContext, avpacket) {
    const stream = formatContext.getStreamByIndex(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32));
    let ret = 0;
    // h264 hevc aac 解析到 extradata，继续
    if (stream
        && (stream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */
            || stream.codecpar.codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
            || stream.codecpar.codecId === 196 /* AVCodecID.AV_CODEC_ID_VVC */
            || stream.codecpar.codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */)) {
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28)
            && (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.hasAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */)) {
            while (1) {
                const tmpPacket = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.createAVPacket)();
                ret = await formatContext.iformat.readAVPacket(formatContext, tmpPacket);
                if (ret !== 0) {
                    if (formatContext.interval.packetBuffer.length) {
                        let cache = formatContext.interval.packetBuffer.shift();
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.unrefAVPacket)(avpacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.refAVPacket)(avpacket, cache);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.destroyAVPacket)(cache);
                        return packetNeedRead(formatContext, avpacket);
                    }
                    return ret;
                }
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](tmpPacket + 32) === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32)) {
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](tmpPacket + 28)) {
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.copyAVPacketData)(avpacket, tmpPacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.destroyAVPacket)(tmpPacket);
                        return 0;
                    }
                    else {
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.unrefAVPacket)(avpacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.refAVPacket)(avpacket, tmpPacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.destroyAVPacket)(tmpPacket);
                        continue;
                    }
                }
                else {
                    formatContext.interval.packetBuffer.push(tmpPacket);
                }
            }
        }
        else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 36) & 32 /* AVPacketFlags.AV_PKT_FLAG_END */) {
            return readAVPacket(formatContext, avpacket);
        }
    }
    if (formatContext.ioReader.flags & 1 /* IOFlags.SEEKABLE */) {
        if (!stream.sampleIndexesPosMap.has(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 56))) {
            if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                    addSample(stream, avpacket);
                }
            }
            else if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                const index = common_util_array__WEBPACK_IMPORTED_MODULE_5__.binarySearch(stream.sampleIndexes, (sample) => {
                    if (sample.pts < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8)) {
                        return 1;
                    }
                    else {
                        return -1;
                    }
                });
                if (!stream.sampleIndexes.length
                    || (index < 0
                        && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8) - stream.sampleIndexes[stream.sampleIndexes.length - 1].pts, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_6__.AV_MILLI_TIME_BASE_Q) >= _config__WEBPACK_IMPORTED_MODULE_10__.SAMPLE_INDEX_STEP)
                    || (index > 0
                        && index < stream.sampleIndexes.length - 1
                        && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8) - stream.sampleIndexes[index - 1].pts, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_6__.AV_MILLI_TIME_BASE_Q) >= _config__WEBPACK_IMPORTED_MODULE_10__.SAMPLE_INDEX_STEP)
                    || (index === 0
                        && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(stream.sampleIndexes[0].pts - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_6__.AV_MILLI_TIME_BASE_Q) >= _config__WEBPACK_IMPORTED_MODULE_10__.SAMPLE_INDEX_STEP)) {
                    addSample(stream, avpacket);
                }
            }
        }
    }
    return 0;
}
// @ts-ignore
async function readAVPacket(formatContext, avpacket) {
    let ret = 0;
    (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.unrefAVPacket)(avpacket);
    if (formatContext.interval.packetBuffer.length) {
        const cache = formatContext.interval.packetBuffer.shift();
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.refAVPacket)(avpacket, cache);
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.destroyAVPacket)(cache);
        return packetNeedRead(formatContext, avpacket);
    }
    ret = await formatContext.iformat.readAVPacket(formatContext, avpacket);
    if (ret !== 0) {
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.unrefAVPacket)(avpacket);
        return ret;
    }
    return packetNeedRead(formatContext, avpacket);
}
// @ts-ignore
async function seek(formatContext, streamIndex, timestamp, flags) {
    let stream = streamIndex > -1 ? formatContext.streams.find((stream) => stream.index === streamIndex) : null;
    if (!stream) {
        stream = formatContext.getStreamByMediaType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
        if (!stream) {
            stream = formatContext.getStreamByMediaType(1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
        }
        if (!stream) {
            stream = formatContext.getStreamByMediaType(3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */);
        }
    }
    if (!stream) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_12__.error(`not found any stream to seek, streamIndex: ${stream.index}`, cheap__fileName__0, 543);
        return BigInt(avutil_error__WEBPACK_IMPORTED_MODULE_11__.DATA_INVALID);
    }
    common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`seek in ${stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */
        ? 'video'
        : 'audio'} stream, streamIndex: ${stream.index}, timestamp: ${timestamp}, flags: ${flags}`, cheap__fileName__0, 547);
    timestamp = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(timestamp, avutil_constant__WEBPACK_IMPORTED_MODULE_6__.AV_MILLI_TIME_BASE_Q, stream.timeBase);
    const ret = await formatContext.iformat.seek(formatContext, stream, timestamp, flags);
    if (ret >= BigInt(0)) {
        common_util_array__WEBPACK_IMPORTED_MODULE_5__.each(formatContext.interval.packetBuffer, (avpacket) => {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.destroyAVPacket)(avpacket);
        });
        formatContext.interval.packetBuffer.length = 0;
        return BigInt(0);
    }
    return ret;
}


/***/ }),

/***/ "./src/avformat/dump.ts":
/*!******************************!*\
  !*** ./src/avformat/dump.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ dump),
/* harmony export */   dumpCodecName: () => (/* binding */ dumpCodecName),
/* harmony export */   dumpFormatName: () => (/* binding */ dumpFormatName),
/* harmony export */   dumpKey: () => (/* binding */ dumpKey)
/* harmony export */ });
/* unused harmony exports dumpTime, dumpInt64, dumpBitrate */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _AVFormatContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AVFormatContext */ "./src/avformat/AVFormatContext.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/stringEnum */ "./src/avutil/stringEnum.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_string__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/util/string */ "./src/common/util/string.ts");
/* harmony import */ var common_function_toString__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/function/toString */ "./src/common/function/toString.ts");
/* harmony import */ var _codecs_aac__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./codecs/aac */ "./src/avformat/codecs/aac.ts");
/* harmony import */ var _codecs_h264__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./codecs/h264 */ "./src/avformat/codecs/h264.ts");
/* harmony import */ var _codecs_hevc__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./codecs/hevc */ "./src/avformat/codecs/hevc.ts");
/* harmony import */ var _codecs_av1__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./codecs/av1 */ "./src/avformat/codecs/av1.ts");
/* harmony import */ var _codecs_vp9__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./codecs/vp9 */ "./src/avformat/codecs/vp9.ts");
/* harmony import */ var _codecs_mp3__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./codecs/mp3 */ "./src/avformat/codecs/mp3.ts");


















function dumpTime(time) {
    if (time < 0) {
        time = BigInt(0);
    }
    const ms = (Number(time % BigInt(1000) & 0xffffffffn) >> 0);
    const secs = (Number(time / BigInt(1000) % BigInt(60) & 0xffffffffn) >> 0);
    const mins = (Number(time / BigInt(1000) / BigInt(60) % BigInt(60) & 0xffffffffn) >> 0);
    const hours = (Number(time / BigInt(1000) / BigInt(3600) & 0xffffffffn) >> 0);
    return common_util_string__WEBPACK_IMPORTED_MODULE_10__.format('%02d:%02d:%02d.%03d', hours, mins, secs, ms);
}
function dumpInt64(v) {
    if (v < BigInt(10000)) {
        return (0,common_function_toString__WEBPACK_IMPORTED_MODULE_11__["default"])((Number(v & 0xffffffffn) >> 0));
    }
    return (Number(v / BigInt(1000) & 0xffffffffn) >> 0) + 'k';
}
function dumpBitrate(v) {
    if (v < BigInt(10000)) {
        return (0,common_function_toString__WEBPACK_IMPORTED_MODULE_11__["default"])((Number(v & 0xffffffffn) >> 0)) + ' bps/s';
    }
    return (Number(v / BigInt(1000) & 0xffffffffn) >> 0) + ' kbps/s';
}
function dumpKey(obj, value, defaultValue = 'unknown') {
    let name = defaultValue;
    common_util_object__WEBPACK_IMPORTED_MODULE_5__.each(obj, (v, k) => {
        if (value === v) {
            name = k;
            return false;
        }
    });
    return name;
}
function dumpCodecName(codecType, codecId) {
    if (codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
        return dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.AudioCodecString2CodecId, codecId);
    }
    else if (codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
        return dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.VideoCodecString2CodecId, codecId);
    }
    else if (codecType === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */) {
        return dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.SubtitleCodecString2CodecId, codecId);
    }
    return 'unknown';
}
function dumpFormatName(format) {
    return dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.Format2AVFormat, format);
}
function dumpProfileName(codecId, profile) {
    switch (codecId) {
        case 86018 /* AVCodecID.AV_CODEC_ID_AAC */:
            return _codecs_aac__WEBPACK_IMPORTED_MODULE_12__.AACProfile2Name[profile] || 'LC';
        case 86017 /* AVCodecID.AV_CODEC_ID_MP3 */:
            return _codecs_mp3__WEBPACK_IMPORTED_MODULE_17__.MP3Profile2Name[profile] || 'Layer3';
        case 27 /* AVCodecID.AV_CODEC_ID_H264 */:
            return _codecs_h264__WEBPACK_IMPORTED_MODULE_13__.H264Profile2Name[profile] || 'High';
        case 173 /* AVCodecID.AV_CODEC_ID_HEVC */:
            return _codecs_hevc__WEBPACK_IMPORTED_MODULE_14__.HEVCProfile2Name[profile] || 'Main';
        case 225 /* AVCodecID.AV_CODEC_ID_AV1 */:
            return _codecs_av1__WEBPACK_IMPORTED_MODULE_15__.AV1Profile2Name[profile] || 'Main';
        case 167 /* AVCodecID.AV_CODEC_ID_VP9 */:
            return _codecs_vp9__WEBPACK_IMPORTED_MODULE_16__.VP9Profile2Name[profile] || 'Profile0';
    }
}
function dumpAVStreamInterface(stream, index, prefix) {
    const mediaType = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.mediaType2AVMediaType, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar));
    const list = [];
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
        const profileName = dumpProfileName(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 48));
        const codecName = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.AudioCodecString2CodecId, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 4));
        list.push(`${codecName}${profileName ? ` (${profileName})` : ''}`);
        list.push(`${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 136)} Hz`);
        let channel = `${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 116)} channels`;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 116) === 1) {
            channel = 'mono';
        }
        else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 116) === 2) {
            channel = 'stereo';
        }
        list.push(channel);
        list.push(dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.SampleFmtString2SampleFormat, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 28)));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32) > BigInt(0)) {
            list.push(`${dumpBitrate(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32))}`);
        }
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
        const profileName = dumpProfileName(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 48));
        const codecName = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.VideoCodecString2CodecId, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 4));
        list.push(`${codecName}${profileName ? ` (${profileName})` : ''}`);
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 28) !== avutil_constant__WEBPACK_IMPORTED_MODULE_9__.NOPTS_VALUE) {
            const pixfmt = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.PixfmtString2AVPixelFormat, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 28));
            const range = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.colorRange2AVColorRange, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 84), 'tv');
            const space = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.colorSpace2AVColorSpace, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 96), 'bt709');
            list.push(`${pixfmt}(${range}, ${space})`);
        }
        const dar = {
            num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 56) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 64),
            den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 60) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 68)
        };
        (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avReduce)(dar);
        list.push(`${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 56)}x${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 60)} [SAR: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 64)}:${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 68)} DAR ${dar.num}:${dar.den}]`);
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32) > BigInt(0)) {
            list.push(`${dumpBitrate(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32))}`);
        }
        if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(stream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational)) > 0) {
            list.push(`${(0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(stream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational)).toFixed(2)} fps`);
            list.push(`${(0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(stream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational)).toFixed(2)} tbr`);
        }
        list.push(`${dumpInt64(BigInt(Math.floor((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avQ2D)({
            num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.timeBase + 4),
            den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.timeBase)
        }))))} tbn`);
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar) === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */) {
        const codecName = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.SubtitleCodecString2CodecId, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 4));
        list.push(codecName);
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32) > BigInt(0)) {
            list.push(`${dumpBitrate(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32))}`);
        }
    }
    else {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32) > BigInt(0)) {
            list.push(`${dumpBitrate(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32))}`);
        }
    }
    let disposition = '';
    if (stream.disposition) {
        disposition = ' ';
        if (stream.disposition & 1 /* AVDisposition.DEFAULT */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 1 /* AVDisposition.DEFAULT */)}) `;
        }
        if (stream.disposition & 2 /* AVDisposition.DUB */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 2 /* AVDisposition.DUB */)}) `;
        }
        if (stream.disposition & 4 /* AVDisposition.ORIGINAL */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 4 /* AVDisposition.ORIGINAL */)}) `;
        }
        if (stream.disposition & 8 /* AVDisposition.COMMENT */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 8 /* AVDisposition.COMMENT */)}) `;
        }
        if (stream.disposition & 16 /* AVDisposition.LYRICS */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 16 /* AVDisposition.LYRICS */)}) `;
        }
        if (stream.disposition & 32 /* AVDisposition.KARAOKE */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 32 /* AVDisposition.KARAOKE */)}) `;
        }
        if (stream.disposition & 64 /* AVDisposition.FORCED */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 64 /* AVDisposition.FORCED */)}) `;
        }
        if (stream.disposition & 128 /* AVDisposition.HEARING_IMPAIRED */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 128 /* AVDisposition.HEARING_IMPAIRED */)}) `;
        }
        if (stream.disposition & 256 /* AVDisposition.VISUAL_IMPAIRED */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 256 /* AVDisposition.VISUAL_IMPAIRED */)}) `;
        }
        if (stream.disposition & 512 /* AVDisposition.CLEAN_EFFECTS */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 512 /* AVDisposition.CLEAN_EFFECTS */)}) `;
        }
        if (stream.disposition & 1024 /* AVDisposition.ATTACHED_PIC */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 1024 /* AVDisposition.ATTACHED_PIC */)}) `;
        }
        if (stream.disposition & 2048 /* AVDisposition.TIMED_THUMBNAILS */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 2048 /* AVDisposition.TIMED_THUMBNAILS */)}) `;
        }
        if (stream.disposition & 65536 /* AVDisposition.CAPTIONS */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 65536 /* AVDisposition.CAPTIONS */)}) `;
        }
        if (stream.disposition & 131072 /* AVDisposition.DESCRIPTIONS */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 131072 /* AVDisposition.DESCRIPTIONS */)}) `;
        }
        if (stream.disposition & 262144 /* AVDisposition.METADATA */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 262144 /* AVDisposition.METADATA */)}) `;
        }
        if (stream.disposition & 524288 /* AVDisposition.DEPENDENT */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 524288 /* AVDisposition.DEPENDENT */)}) `;
        }
        if (stream.disposition & 1048576 /* AVDisposition.STILL_IMAGE */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 1048576 /* AVDisposition.STILL_IMAGE */)}) `;
        }
    }
    let dump = `${prefix}Stream #${index}:${stream.index} ${mediaType}: ${list.join(', ')}${disposition}\n`;
    if (Object.keys(stream.metadata).length) {
        dump += `${prefix}  Metadata:\n`;
        common_util_object__WEBPACK_IMPORTED_MODULE_5__.each(stream.metadata, (value, key) => {
            if (!common_util_is__WEBPACK_IMPORTED_MODULE_7__.object(value) && !common_util_is__WEBPACK_IMPORTED_MODULE_7__.array(value)) {
                dump += `${prefix}    ${key}: ${value}\n`;
            }
        });
    }
    return dump;
}
function dumpAVFormatContextInterface(formatContext, index, input) {
    let dump = `${input.tag} #${index}, ${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.Format2AVFormat, formatContext.format)}, from '${input.from}':\n`;
    if (Object.keys(formatContext.metadata).length) {
        dump += `  Metadata:\n`;
        common_util_object__WEBPACK_IMPORTED_MODULE_5__.each(formatContext.metadata, (value, key) => {
            if (!common_util_is__WEBPACK_IMPORTED_MODULE_7__.object(value) || !common_util_is__WEBPACK_IMPORTED_MODULE_7__.array(value)) {
                dump += `    ${key}: ${value}\n`;
            }
        });
    }
    let duration = BigInt(0);
    let bitrate = BigInt(0);
    let start = -BigInt(1);
    formatContext.streams.forEach((stream) => {
        const d = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(stream.duration, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(stream.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_9__.AV_MILLI_TIME_BASE_Q);
        const s = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(stream.startTime, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(stream.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_9__.AV_MILLI_TIME_BASE_Q);
        if (d > duration) {
            duration = d;
        }
        if (s < start || start === -BigInt(1)) {
            start = s;
        }
        bitrate += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32);
    });
    dump += `  Duration: ${dumpTime(duration)}, start: ${dumpTime(start)}, bitrate: ${dumpBitrate(bitrate)}\n`;
    formatContext.streams.forEach((stream, i) => {
        dump += dumpAVStreamInterface(stream, index, '  ');
    });
    return dump;
}
function dump(formatContexts, inputs) {
    let dump = '';
    formatContexts.forEach((formatContext, index) => {
        if (formatContext instanceof _AVFormatContext__WEBPACK_IMPORTED_MODULE_4__.AVFormatContext) {
            const streams = [];
            for (let i = 0; i < formatContext.streams.length; i++) {
                const stream = formatContext.streams[i];
                streams.push({
                    index: stream.index,
                    id: stream.id,
                    codecpar: stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    nbFrames: stream.nbFrames,
                    metadata: stream.metadata,
                    duration: stream.duration,
                    startTime: stream.startTime,
                    disposition: stream.disposition,
                    timeBase: stream.timeBase[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]
                });
            }
            formatContext = {
                metadata: formatContext.metadata,
                format: formatContext.format,
                chapters: formatContext.chapters,
                streams
            };
        }
        dump += dumpAVFormatContextInterface(formatContext, index, inputs[index]);
    });
    return dump;
}


/***/ }),

/***/ "./src/avformat/formats/OFormat.ts":
/*!*****************************************!*\
  !*** ./src/avformat/formats/OFormat.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OFormatSupportedCodecs: () => (/* binding */ OFormatSupportedCodecs),
/* harmony export */   "default": () => (/* binding */ OFormat)
/* harmony export */ });
/*
 * libmedia abstract format encoder
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class OFormat {
    type = -1 /* AVFormat.UNKNOWN */;
    destroy(formatContext) { }
}
const OFormatSupportedCodecs = {
    [12 /* AVFormat.AAC */]: [86018 /* AVCodecID.AV_CODEC_ID_AAC */],
    [7 /* AVFormat.AVI */]: [
        86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
        86019 /* AVCodecID.AV_CODEC_ID_AC3 */,
        86018 /* AVCodecID.AV_CODEC_ID_AAC */,
        12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
        27 /* AVCodecID.AV_CODEC_ID_H264 */
    ],
    [14 /* AVFormat.FLAC */]: [86028 /* AVCodecID.AV_CODEC_ID_FLAC */],
    [0 /* AVFormat.FLV */]: [
        86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
        86018 /* AVCodecID.AV_CODEC_ID_AAC */,
        86051 /* AVCodecID.AV_CODEC_ID_SPEEX */,
        69645 /* AVCodecID.AV_CODEC_ID_ADPCM_SWF */,
        86049 /* AVCodecID.AV_CODEC_ID_NELLYMOSER */,
        65543 /* AVCodecID.AV_CODEC_ID_PCM_ALAW */,
        65542 /* AVCodecID.AV_CODEC_ID_PCM_MULAW */,
        12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
        27 /* AVCodecID.AV_CODEC_ID_H264 */,
        173 /* AVCodecID.AV_CODEC_ID_HEVC */,
        225 /* AVCodecID.AV_CODEC_ID_AV1 */,
        167 /* AVCodecID.AV_CODEC_ID_VP9 */,
        196 /* AVCodecID.AV_CODEC_ID_VVC */
    ],
    [4 /* AVFormat.IVF */]: [139 /* AVCodecID.AV_CODEC_ID_VP8 */, 167 /* AVCodecID.AV_CODEC_ID_VP9 */],
    [5 /* AVFormat.MATROSKA */]: [
        86021 /* AVCodecID.AV_CODEC_ID_VORBIS */,
        86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
        86018 /* AVCodecID.AV_CODEC_ID_AAC */,
        86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
        86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
        86032 /* AVCodecID.AV_CODEC_ID_ALAC */,
        86020 /* AVCodecID.AV_CODEC_ID_DTS */,
        86056 /* AVCodecID.AV_CODEC_ID_EAC3 */,
        65557 /* AVCodecID.AV_CODEC_ID_PCM_F32LE */,
        65537 /* AVCodecID.AV_CODEC_ID_PCM_S16BE */,
        65536 /* AVCodecID.AV_CODEC_ID_PCM_S16LE */,
        139 /* AVCodecID.AV_CODEC_ID_VP8 */,
        167 /* AVCodecID.AV_CODEC_ID_VP9 */,
        225 /* AVCodecID.AV_CODEC_ID_AV1 */,
        27 /* AVCodecID.AV_CODEC_ID_H264 */,
        173 /* AVCodecID.AV_CODEC_ID_HEVC */,
        196 /* AVCodecID.AV_CODEC_ID_VVC */,
        12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
        30 /* AVCodecID.AV_CODEC_ID_THEORA */,
        94226 /* AVCodecID.AV_CODEC_ID_WEBVTT */
    ],
    [6 /* AVFormat.WEBM */]: [
        86021 /* AVCodecID.AV_CODEC_ID_VORBIS */,
        86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
        139 /* AVCodecID.AV_CODEC_ID_VP8 */,
        167 /* AVCodecID.AV_CODEC_ID_VP9 */,
        225 /* AVCodecID.AV_CODEC_ID_AV1 */,
        94226 /* AVCodecID.AV_CODEC_ID_WEBVTT */
    ],
    [1 /* AVFormat.MOV */]: [
        86021 /* AVCodecID.AV_CODEC_ID_VORBIS */,
        86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
        86018 /* AVCodecID.AV_CODEC_ID_AAC */,
        86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
        86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
        86051 /* AVCodecID.AV_CODEC_ID_SPEEX */,
        86019 /* AVCodecID.AV_CODEC_ID_AC3 */,
        86056 /* AVCodecID.AV_CODEC_ID_EAC3 */,
        167 /* AVCodecID.AV_CODEC_ID_VP9 */,
        225 /* AVCodecID.AV_CODEC_ID_AV1 */,
        27 /* AVCodecID.AV_CODEC_ID_H264 */,
        173 /* AVCodecID.AV_CODEC_ID_HEVC */,
        196 /* AVCodecID.AV_CODEC_ID_VVC */,
        12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
        94226 /* AVCodecID.AV_CODEC_ID_WEBVTT */,
        94213 /* AVCodecID.AV_CODEC_ID_MOV_TEXT */
    ],
    [11 /* AVFormat.MP3 */]: [86017 /* AVCodecID.AV_CODEC_ID_MP3 */],
    [2 /* AVFormat.MPEGTS */]: [
        86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
        86018 /* AVCodecID.AV_CODEC_ID_AAC */,
        86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
        86019 /* AVCodecID.AV_CODEC_ID_AC3 */, ,
        86020 /* AVCodecID.AV_CODEC_ID_DTS */,
        86065 /* AVCodecID.AV_CODEC_ID_AAC_LATM */,
        86056 /* AVCodecID.AV_CODEC_ID_EAC3 */,
        12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
        225 /* AVCodecID.AV_CODEC_ID_AV1 */,
        27 /* AVCodecID.AV_CODEC_ID_H264 */,
        173 /* AVCodecID.AV_CODEC_ID_HEVC */,
        196 /* AVCodecID.AV_CODEC_ID_VVC */
    ],
    [3 /* AVFormat.OGGS */]: [
        86021 /* AVCodecID.AV_CODEC_ID_VORBIS */
    ],
    [13 /* AVFormat.WAV */]: [],
    [15 /* AVFormat.WEBVTT */]: [94226 /* AVCodecID.AV_CODEC_ID_WEBVTT */],
    [17 /* AVFormat.ASS */]: [94230 /* AVCodecID.AV_CODEC_ID_ASS */, 94212 /* AVCodecID.AV_CODEC_ID_SSA */],
    [16 /* AVFormat.SUBRIP */]: [94225 /* AVCodecID.AV_CODEC_ID_SUBRIP */],
    [18 /* AVFormat.TTML */]: [94232 /* AVCodecID.AV_CODEC_ID_TTML */],
    [8 /* AVFormat.H264 */]: [27 /* AVCodecID.AV_CODEC_ID_H264 */],
    [9 /* AVFormat.HEVC */]: [173 /* AVCodecID.AV_CODEC_ID_HEVC */],
    [10 /* AVFormat.VVC */]: [196 /* AVCodecID.AV_CODEC_ID_VVC */]
};


/***/ }),

/***/ "./src/avformat/formats/OMovFormat.ts":
/*!********************************************!*\
  !*** ./src/avformat/formats/OMovFormat.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OMovFormat)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _OFormat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./OFormat */ "./src/avformat/formats/OFormat.ts");
/* harmony import */ var _mov_function_createMovContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mov/function/createMovContext */ "./src/avformat/formats/mov/function/createMovContext.ts");
/* harmony import */ var _function_mktag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../function/mktag */ "./src/avformat/function/mktag.ts");
/* harmony import */ var _mov_omov__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mov/omov */ "./src/avformat/formats/mov/omov.ts");
/* harmony import */ var _mov_function_createMovStreamContext__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mov/function/createMovStreamContext */ "./src/avformat/formats/mov/function/createMovStreamContext.ts");
/* harmony import */ var _mov_function_createFragmentTrack__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mov/function/createFragmentTrack */ "./src/avformat/formats/mov/function/createFragmentTrack.ts");
/* harmony import */ var common_io_IOWriterSync__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/io/IOWriterSync */ "./src/common/io/IOWriterSync.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/function/concatTypeArray */ "./src/common/function/concatTypeArray.ts");
/* harmony import */ var _mov_function_updatePositionSize__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./mov/function/updatePositionSize */ "./src/avformat/formats/mov/function/updatePositionSize.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var _function_rewriteIO__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../function/rewriteIO */ "./src/avformat/function/rewriteIO.ts");
/* harmony import */ var _function_arrayItemSame__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../function/arrayItemSame */ "./src/avformat/function/arrayItemSame.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _bsf_h2645_Annexb2AvccFilter__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../bsf/h2645/Annexb2AvccFilter */ "./src/avformat/bsf/h2645/Annexb2AvccFilter.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _codecs_ac3__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../codecs/ac3 */ "./src/avformat/codecs/ac3.ts");
var cheap__fileName__2 = "src\\avformat\\formats\\OMovFormat.ts";




/*
 * libmedia mov encoder
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




















const defaultOptions = {
    fragmentMode: 0 /* FragmentMode.GOP */,
    movMode: 0 /* MovMode.MP4 */,
    fragment: false,
    fastOpen: false,
    defaultBaseIsMoof: false
};
class OMovFormat extends _OFormat__WEBPACK_IMPORTED_MODULE_4__["default"] {
    type = 1 /* AVFormat.MOV */;
    context;
    options;
    annexb2AvccFilter;
    constructor(options = {}) {
        super();
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_16__.extend({}, defaultOptions, options);
        this.context = (0,_mov_function_createMovContext__WEBPACK_IMPORTED_MODULE_5__["default"])();
    }
    init(formatContext) {
        formatContext.ioWriter.setEndian(true);
        const videoStream = formatContext.getStreamByMediaType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
        if (videoStream) {
            this.annexb2AvccFilter = new _bsf_h2645_Annexb2AvccFilter__WEBPACK_IMPORTED_MODULE_21__["default"]();
            this.annexb2AvccFilter.init(videoStream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress], videoStream.timeBase[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
        }
        return 0;
    }
    destroy(formatContext) {
        super.destroy(formatContext);
        if (this.annexb2AvccFilter) {
            this.annexb2AvccFilter.destroy();
            this.annexb2AvccFilter = null;
        }
    }
    /*
     * stream.disposition controls the "enabled" flag in the tkhd tag.
     * QuickTime will not play a track if it is not enabled.  So make sure
     * that one track of each type (audio, video, subtitle) is enabled.
     *
     * Subtitles are special.  For audio and video, setting "enabled" also
     * makes the track "default" (i.e. it is rendered when played). For
     * subtitles, an "enabled" subtitle is not rendered by default, but
     * if no subtitle is enabled, the subtitle menu in QuickTime will be
     * empty!
     */
    enableStreams(formatContext) {
        const enabled = [];
        const first = [];
        for (let i = 0; i < 5 /* AVMediaType.AVMEDIA_TYPE_NB */; i++) {
            enabled[i] = 0;
            first[i] = -1;
        }
        common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(formatContext.streams, (stream, index) => {
            if (stream.codecpar.codecType === -1 /* AVMediaType.AVMEDIA_TYPE_UNKNOWN */
                || stream.codecpar.codecType >= 5 /* AVMediaType.AVMEDIA_TYPE_NB */) {
                return true;
            }
            if (first[stream.codecpar.codecType] < 0) {
                first[stream.codecpar.codecType] = index;
            }
            if (stream.disposition & 1 /* AVDisposition.DEFAULT */) {
                enabled[stream.codecpar.codecType]++;
                stream.privData.flags |= 1 /* TKHDFlags.ENABLED */;
            }
        });
        for (let i = 0; i < 5 /* AVMediaType.AVMEDIA_TYPE_NB */; i++) {
            switch (i) {
                case 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */:
                case 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */:
                case 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */:
                    if (enabled[i] > 1) {
                        formatContext.streams[enabled[i]].privData.perStreamGrouping = true;
                    }
                    if (!enabled[i] && first[i] >= 0) {
                        formatContext.streams[first[i]].privData.flags |= 1 /* TKHDFlags.ENABLED */;
                    }
                    break;
            }
        }
    }
    writeHeader(formatContext) {
        this.context.majorBrand = (0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('isom');
        this.context.minorVersion = 512;
        this.context.compatibleBrand = [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('isom')];
        this.context.timescale = 1000;
        if (this.options.fragment) {
            this.context.compatibleBrand.push((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('iso6'));
            this.context.fragment = true;
        }
        if (this.options.movMode === 1 /* MovMode.MOV */) {
            this.context.isom = true;
            this.context.majorBrand = (0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('qt  ');
            this.context.compatibleBrand = [this.context.majorBrand];
        }
        if (this.options.movMode !== 1 /* MovMode.MOV */) {
            this.context.compatibleBrand.push((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('iso2'));
            const videoStream = formatContext.getStreamByMediaType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
            if (videoStream && videoStream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */) {
                this.context.compatibleBrand.push((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('avc1'));
            }
            this.context.compatibleBrand.push((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('mp41'));
        }
        _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeFtyp(formatContext.ioWriter, this.context);
        this.context.holdMoovPos = formatContext.ioWriter.getPos();
        if (this.options.fragment) {
            this.context.currentFragment = {
                pos: BigInt(0),
                currentTrack: null,
                sequence: 1,
                tracks: [],
                size: 0,
                firstWrote: false
            };
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(formatContext.streams, (stream, index) => {
                const streamContext = (0,_mov_function_createMovStreamContext__WEBPACK_IMPORTED_MODULE_8__["default"])();
                stream.privData = streamContext;
                streamContext.chunkOffsets = [];
                streamContext.cttsSampleCounts = [];
                streamContext.cttsSampleOffsets = [];
                streamContext.stscFirstChunk = [];
                streamContext.stscSamplesPerChunk = [];
                streamContext.stscSampleDescriptionIndex = [];
                streamContext.stssSampleNumbers = [];
                streamContext.sampleSizes = [];
                streamContext.sttsSampleCounts = [];
                streamContext.sttsSampleDeltas = [];
                streamContext.alternateGroup = index;
                const track = (0,_mov_function_createFragmentTrack__WEBPACK_IMPORTED_MODULE_9__["default"])();
                track.baseIsMoof = this.options.defaultBaseIsMoof;
                track.streamIndex = stream.index;
                track.trackId = this.context.nextTrackId++;
                streamContext.trackId = track.trackId;
                track.ioWriter = new common_io_IOWriterSync__WEBPACK_IMPORTED_MODULE_10__["default"]();
                track.ioWriter.onFlush = (data) => {
                    track.buffers.push(data.slice());
                    return 0;
                };
                this.context.currentFragment.tracks.push(track);
            });
            this.enableStreams(formatContext);
            _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeMoov(formatContext.ioWriter, formatContext, this.context);
            formatContext.ioWriter.flush();
        }
        else {
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(formatContext.streams, (stream, index) => {
                const streamContext = (0,_mov_function_createMovStreamContext__WEBPACK_IMPORTED_MODULE_8__["default"])();
                stream.privData = streamContext;
                streamContext.trackId = this.context.nextTrackId++;
                streamContext.chunkOffsets = [];
                streamContext.cttsSampleCounts = [];
                streamContext.cttsSampleOffsets = [];
                streamContext.stscFirstChunk = [];
                streamContext.stscSamplesPerChunk = [];
                streamContext.stscSampleDescriptionIndex = [];
                streamContext.stssSampleNumbers = [];
                streamContext.sampleSizes = [];
                streamContext.sttsSampleCounts = [];
                streamContext.sttsSampleDeltas = [];
                streamContext.alternateGroup = index;
            });
            this.enableStreams(formatContext);
            const pos = formatContext.ioWriter.getPos();
            formatContext.ioWriter.writeUint32(0);
            formatContext.ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])("mdat" /* BoxType.MDAT */));
            this.context.boxsPositionInfo.push({
                pos,
                type: "mdat" /* BoxType.MDAT */,
                size: 0
            });
        }
        return 0;
    }
    updateCurrentChunk(formatContext) {
        let currentChunk = this.context.currentChunk;
        if (!currentChunk.sampleCount) {
            return;
        }
        const prevStream = formatContext.streams.find((stream) => {
            return stream.index === currentChunk.streamIndex;
        });
        const prevMovStreamContext = prevStream.privData;
        prevMovStreamContext.chunkCount++;
        prevMovStreamContext.chunkOffsets.push(currentChunk.pos);
        if (!prevMovStreamContext.stscFirstChunk.length) {
            prevMovStreamContext.stscFirstChunk.push(prevMovStreamContext.chunkCount);
            prevMovStreamContext.stscSamplesPerChunk.push(currentChunk.sampleCount);
            prevMovStreamContext.stscSampleDescriptionIndex.push(1);
            prevMovStreamContext.lastStscCount = currentChunk.sampleCount;
        }
        else {
            if (prevMovStreamContext.lastStscCount !== currentChunk.sampleCount) {
                prevMovStreamContext.stscFirstChunk.push(prevMovStreamContext.chunkCount);
                prevMovStreamContext.stscSamplesPerChunk.push(currentChunk.sampleCount);
                prevMovStreamContext.stscSampleDescriptionIndex.push(1);
                prevMovStreamContext.lastStscCount = currentChunk.sampleCount;
            }
        }
    }
    checkMdat(formatContext, len) {
        const mdat = this.context.boxsPositionInfo[this.context.boxsPositionInfo.length - 1];
        if (mdat.type !== "mdat" /* BoxType.MDAT */) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.error('last box is not mdat', cheap__fileName__2, 301);
            return;
        }
        const pos = formatContext.ioWriter.getPos();
        const size = Number(pos - mdat.pos);
        if (size + len > avutil_constant__WEBPACK_IMPORTED_MODULE_15__.UINT32_MAX) {
            mdat.size = size;
            formatContext.ioWriter.writeUint32(0);
            formatContext.ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])("mdat" /* BoxType.MDAT */));
            this.context.boxsPositionInfo.push({
                pos,
                type: "mdat" /* BoxType.MDAT */,
                size: 0
            });
        }
    }
    updateCurrentFragment(formatContext, currentDts) {
        if (this.context.currentFragment.firstWrote) {
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(this.context.currentFragment.tracks, (track) => {
                const stream = formatContext.streams.find((stream) => {
                    return stream.index === track.streamIndex;
                });
                if (!track.sampleCount || !stream) {
                    return true;
                }
                const streamContext = stream.privData;
                track.baseDataOffset = formatContext.ioWriter.getPos();
                if (!track.sampleDurations.length) {
                    if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                        if (currentDts) {
                            track.sampleDurations.push(Number(currentDts - streamContext.lastDts));
                        }
                        else if (stream.codecpar.frameSize > 0) {
                            track.sampleDurations.push(Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(BigInt(stream.codecpar.frameSize / stream.codecpar.sampleRate * avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE), avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE_Q, stream.timeBase)));
                        }
                        else if (stream.codecpar.codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */) {
                            track.sampleDurations.push(Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(BigInt(1024 / stream.codecpar.sampleRate * avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE), avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE_Q, stream.timeBase)));
                        }
                        else {
                            // 随便猜一个？每帧一个 fragment 没有 sampleDuration QuickTime 无法播放
                            track.sampleDurations.push(Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(BigInt(1024 / stream.codecpar.sampleRate * avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE), avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE_Q, stream.timeBase)));
                        }
                    }
                    else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                        if (currentDts) {
                            track.sampleDurations.push(Number(currentDts - streamContext.lastDts));
                        }
                        else if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avQ2D)(stream.codecpar.framerate) > 0) {
                            track.sampleDurations.push(Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(BigInt(Math.floor(1 / (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avQ2D)(stream.codecpar.framerate) * avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE)), avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE_Q, stream.timeBase)));
                        }
                        else {
                            // 随便猜一个？每帧一个 fragment 没有 sampleDuration QuickTime 无法播放
                            // 取帧率 30
                            track.sampleDurations.push((stream.timeBase.den / (30 * stream.timeBase.num)) >>> 0);
                        }
                    }
                    else {
                        track.sampleDurations.push(0);
                    }
                }
                else if (currentDts && track.sampleDurations.length === track.sampleSizes.length - 1) {
                    track.sampleDurations.push(Number(currentDts - streamContext.lastDts));
                }
                streamContext.lastDuration = track.sampleDurations[track.sampleSizes.length - 1];
                if (track.sampleFlags.length === 1 || (0,_function_arrayItemSame__WEBPACK_IMPORTED_MODULE_18__["default"])(track.sampleFlags, 1)) {
                    track.firstSampleFlags = track.sampleFlags[0];
                    track.defaultSampleFlags = track.sampleFlags[1] ?? track.firstSampleFlags;
                    track.sampleFlags = [];
                }
                if (track.sampleSizes.length === 1 || (0,_function_arrayItemSame__WEBPACK_IMPORTED_MODULE_18__["default"])(track.sampleSizes)) {
                    track.defaultSampleSize = track.sampleSizes[0];
                    track.sampleSizes = [];
                }
                if (track.sampleDurations.length === 1 || (0,_function_arrayItemSame__WEBPACK_IMPORTED_MODULE_18__["default"])(track.sampleDurations)) {
                    track.defaultSampleDuration = track.sampleDurations[0];
                    track.sampleDurations = [];
                }
                if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                    track.defaultSampleFlags = 33554432 /* SampleFlags.DEPENDS_NO */;
                }
                else if (track.sampleFlags.length) {
                    track.defaultSampleFlags = track.sampleFlags[0];
                }
                if (track.sampleSizes.length) {
                    track.defaultSampleSize = track.sampleSizes[0];
                }
                if (track.sampleDurations.length) {
                    track.defaultSampleDuration = track.sampleDurations[0];
                }
            });
            formatContext.ioWriter.flush();
            _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeMoof(formatContext.ioWriter, formatContext, this.context);
            let dataOffset = this.context.currentFragment.size + 8;
            const buffers = [];
            let mdatSize = 8;
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(this.context.currentFragment.tracks, (track) => {
                if (!track.sampleCount) {
                    return true;
                }
                track.ioWriter.flush();
                const buffer = (0,common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_13__["default"])(Uint8Array, track.buffers);
                track.dataOffset = dataOffset;
                dataOffset += buffer.length;
                mdatSize += buffer.length;
                buffers.push(buffer);
                (0,_function_rewriteIO__WEBPACK_IMPORTED_MODULE_17__["default"])(formatContext.ioWriter, track.dataOffsetPos, track.dataOffset, 'int32');
                track.buffers = [];
                track.sampleFlags = [];
                track.sampleSizes = [];
                track.sampleDurations = [];
                track.sampleCompositionTimeOffset = [];
                track.sampleCount = 0;
                track.firstSampleFlags = 0;
            });
            formatContext.ioWriter.writeUint32(mdatSize);
            formatContext.ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])("mdat" /* BoxType.MDAT */));
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(buffers, (buffer) => {
                formatContext.ioWriter.writeBuffer(buffer);
            });
            (0,_mov_function_updatePositionSize__WEBPACK_IMPORTED_MODULE_14__["default"])(formatContext.ioWriter, this.context);
            formatContext.ioWriter.flush();
            this.context.currentFragment.firstWrote = false;
            this.context.currentFragment.sequence++;
        }
    }
    handleEAC3(avpacket, stream) {
        if (!this.context.ac3Info) {
            this.context.ac3Info = {
                done: false,
                numBlocks: 0,
                dataRate: 0,
                ac3BitrateCode: -1,
                numIndSub: 0,
                substream: []
            };
        }
        const ac3Info = this.context.ac3Info;
        const info = _codecs_ac3__WEBPACK_IMPORTED_MODULE_23__.parseHeader(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28));
        if (common_util_is__WEBPACK_IMPORTED_MODULE_22__.number(info)) {
            ac3Info.done = true;
            return;
        }
        ac3Info.dataRate = Math.max(ac3Info.dataRate, info.bitRate / 1000);
        ac3Info.ac3BitrateCode = Math.max(ac3Info.ac3BitrateCode, info.ac3BitrateCode);
        if (!ac3Info.done) {
            if (info.bitstreamId <= 10 && info.substreamId != 0) {
                return;
            }
            if (info.frameType === 0 /* ac3.EAC3FrameType.EAC3_FRAME_TYPE_INDEPENDENT */
                || info.frameType == 2 /* ac3.EAC3FrameType.EAC3_FRAME_TYPE_AC3_CONVERT */) {
                /* substream ids must be incremental */
                if (info.substreamId > ac3Info.numIndSub + 1) {
                    return;
                }
                if (info.substreamId == ac3Info.numIndSub + 1) {
                    return;
                }
                else if (info.substreamId < ac3Info.numIndSub ||
                    info.substreamId == 0 && ac3Info.substream[0]?.bsid) {
                    ac3Info.done = true;
                    return;
                }
            }
            else {
                if (info.substreamId != 0) {
                    return;
                }
            }
            if (!ac3Info.substream[info.substreamId]) {
                ac3Info.substream[info.substreamId] = {
                    fscod: 0,
                    bsid: 0,
                    bsmod: 0,
                    acmod: 0,
                    lfeon: 0,
                    numDepSub: 0,
                    chanLoc: 0
                };
            }
            ac3Info.substream[info.substreamId].fscod = info.srCode;
            ac3Info.substream[info.substreamId].bsid = info.bitstreamId;
            ac3Info.substream[info.substreamId].bsmod = info.bitstreamMode;
            ac3Info.substream[info.substreamId].acmod = info.channelMode;
            ac3Info.substream[info.substreamId].lfeon = info.lfeOn;
            if (stream.codecpar.codecId === 86019 /* AVCodecID.AV_CODEC_ID_AC3 */) {
                ac3Info.done = true;
                return;
            }
        }
    }
    writeAVPacket(formatContext, avpacket) {
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28)) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.warn(`packet\'s size is 0: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32)}, ignore it`, cheap__fileName__2, 542);
            return 0;
        }
        const stream = formatContext.getStreamByIndex(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32));
        if (!stream) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.warn(`can not found the stream width the avpacket\'s streamIndex: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32)}, ignore it`, cheap__fileName__2, 549);
            return;
        }
        const streamContext = stream.privData;
        const dts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational), stream.timeBase);
        const pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8) < BigInt(0) ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational), stream.timeBase);
        if ((stream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */
            || stream.codecpar.codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
            || stream.codecpar.codecId === 196 /* AVCodecID.AV_CODEC_ID_VVC */)
            && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 80) === 2 /* BitFormat.ANNEXB */) {
            this.annexb2AvccFilter.sendAVPacket(avpacket);
            this.annexb2AvccFilter.receiveAVPacket(avpacket);
        }
        else if ((stream.codecpar.codecId === 86019 /* AVCodecID.AV_CODEC_ID_AC3 */
            || stream.codecpar.codecId === 86056 /* AVCodecID.AV_CODEC_ID_EAC3 */)
            && (!this.context.ac3Info || !this.context.ac3Info.done)) {
            this.handleEAC3(avpacket, stream);
        }
        if (this.context.fragment) {
            const track = this.context.currentFragment.tracks.find((track) => {
                return track.streamIndex === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32);
            });
            if (track) {
                if (this.options.fragmentMode === 0 /* FragmentMode.GOP */
                    && stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */
                    && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */
                    || this.options.fragmentMode === 1 /* FragmentMode.FRAME */) {
                    if (this.context.currentFragment.tracks.length === 1) {
                        this.updateCurrentFragment(formatContext, dts);
                    }
                    else {
                        this.updateCurrentFragment(formatContext);
                    }
                }
                track.ioWriter.writeBuffer((0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_20__.getAVPacketData)(avpacket));
                if (!track.sampleSizes.length) {
                    track.baseMediaDecodeTime = dts;
                }
                if (track.sampleSizes.length
                    && (!track.sampleDurations[track.sampleSizes.length - 1]
                        || track.sampleDurations[track.sampleSizes.length - 1] <= 0)) {
                    track.sampleDurations[track.sampleSizes.length - 1] = Number(dts - streamContext.lastDts);
                }
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 48) > 0) {
                    track.sampleDurations.push(Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 48), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational), stream.timeBase)));
                }
                track.sampleSizes.push(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28));
                if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    let flag = 0;
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                        flag |= 33554432 /* SampleFlags.DEPENDS_NO */;
                    }
                    else {
                        flag |= (16777216 /* SampleFlags.DEPENDS_YES */ | 65536 /* SampleFlags.IS_NON_SYN */);
                    }
                    track.sampleCompositionTimeOffset.push(Number((pts || dts) - dts));
                    track.sampleFlags.push(flag);
                }
                track.sampleCount++;
                streamContext.lastPts = pts > streamContext.lastPts ? pts : streamContext.lastPts;
                streamContext.lastDts = dts;
                this.context.currentFragment.firstWrote = true;
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.warn(`can not found track width streamIndex ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32)}, ignore it`, cheap__fileName__2, 635);
            }
        }
        else {
            this.checkMdat(formatContext, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28));
            const pos = formatContext.ioWriter.getPos();
            let currentChunk = this.context.currentChunk;
            if (!currentChunk) {
                currentChunk = this.context.currentChunk = {
                    pos,
                    streamIndex: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32),
                    sampleCount: 1
                };
            }
            else if (currentChunk.streamIndex !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32)) {
                this.updateCurrentChunk(formatContext);
                currentChunk.streamIndex = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32);
                currentChunk.sampleCount = 1;
                currentChunk.pos = pos;
            }
            else {
                currentChunk.sampleCount++;
            }
            formatContext.ioWriter.writeBuffer((0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_20__.getAVPacketData)(avpacket));
            streamContext.sampleSizes.push(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28));
            if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */
                && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                streamContext.stssSampleNumbers.push(streamContext.sampleSizes.length);
            }
            if (!streamContext.firstWrote) {
                streamContext.startDts = dts;
                streamContext.startCT = Number((pts || dts) - dts);
                streamContext.firstWrote = true;
            }
            else {
                const deltas = Number(dts - streamContext.lastDts);
                if (!streamContext.sttsSampleCounts.length) {
                    streamContext.sttsSampleCounts.push(1);
                    streamContext.sttsSampleDeltas.push(deltas);
                }
                else {
                    if (streamContext.sttsSampleDeltas[streamContext.sttsSampleDeltas.length - 1] === deltas) {
                        streamContext.sttsSampleCounts[streamContext.sttsSampleCounts.length - 1]++;
                    }
                    else {
                        streamContext.sttsSampleCounts.push(1);
                        streamContext.sttsSampleDeltas.push(deltas);
                    }
                }
            }
            if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                const ctts = Number((pts || dts) - dts);
                if (!streamContext.cttsSampleCounts.length) {
                    streamContext.cttsSampleCounts.push(1);
                    streamContext.cttsSampleOffsets.push(ctts);
                }
                else {
                    if (streamContext.cttsSampleOffsets[streamContext.cttsSampleOffsets.length - 1]
                        === ctts) {
                        streamContext.cttsSampleCounts[streamContext.cttsSampleCounts.length - 1]++;
                    }
                    else {
                        streamContext.cttsSampleCounts.push(1);
                        streamContext.cttsSampleOffsets.push(ctts);
                    }
                }
            }
            streamContext.lastPts = (pts || dts) > streamContext.lastPts ? (pts || dts) : streamContext.lastPts;
            streamContext.lastDts = dts;
        }
        return 0;
    }
    writeTrailer(formatContext) {
        if (!this.context.fragment) {
            this.updateCurrentChunk(formatContext);
            let lastPts = BigInt(0);
            let timeBase;
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(formatContext.streams, (stream) => {
                const streamContext = stream.privData;
                if (streamContext.sampleSizes.length) {
                    if (streamContext.sttsSampleDeltas.length) {
                        streamContext.sttsSampleCounts[streamContext.sttsSampleCounts.length - 1]++;
                    }
                    else {
                        streamContext.sttsSampleCounts = [1];
                        streamContext.sttsSampleDeltas = [0];
                    }
                }
                if (streamContext.lastPts > lastPts) {
                    lastPts = streamContext.lastPts;
                    timeBase = stream.timeBase;
                }
            });
            if (lastPts) {
                this.context.duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(lastPts, timeBase, { den: 1000, num: 1 });
            }
            const mdat = this.context.boxsPositionInfo[this.context.boxsPositionInfo.length - 1];
            if (mdat.type !== "mdat" /* BoxType.MDAT */) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.error('last box is not mdat', cheap__fileName__2, 751);
            }
            mdat.size = Number(formatContext.ioWriter.getPos() - mdat.pos);
            (0,_mov_function_updatePositionSize__WEBPACK_IMPORTED_MODULE_14__["default"])(formatContext.ioWriter, this.context);
            if (this.options.fastOpen) {
                formatContext.ioWriter.flush();
                let buffers = [];
                const rawFlush = formatContext.ioWriter.onFlush;
                formatContext.ioWriter.onFlush = (buffer) => {
                    buffers.push(buffer.slice());
                    return 0;
                };
                _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeMoov(formatContext.ioWriter, formatContext, this.context);
                formatContext.ioWriter.flush();
                let data = (0,common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_13__["default"])(Uint8Array, buffers);
                common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(formatContext.streams, (stream) => {
                    const streamContext = stream.privData;
                    if (streamContext.chunkOffsets.length) {
                        for (let i = 0; i < streamContext.chunkOffsets.length; i++) {
                            streamContext.chunkOffsets[i] += BigInt(Math.floor(data.length));
                        }
                    }
                });
                buffers = [];
                _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeMoov(formatContext.ioWriter, formatContext, this.context);
                formatContext.ioWriter.flush();
                data = (0,common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_13__["default"])(Uint8Array, buffers);
                if (rawFlush) {
                    rawFlush(data, this.context.holdMoovPos);
                }
                formatContext.ioWriter.onFlush = rawFlush;
            }
            else {
                _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeMoov(formatContext.ioWriter, formatContext, this.context);
                formatContext.ioWriter.flush();
            }
        }
        else {
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(this.context.currentFragment.tracks, (track) => {
                const stream = formatContext.streams.find((stream) => {
                    return stream.index === track.streamIndex;
                });
                const streamContext = stream.privData;
                if (track.sampleCount) {
                    if (track.sampleDurations.length) {
                        track.sampleDurations.push(track.sampleDurations[track.sampleDurations.length - 1]);
                    }
                    else {
                        track.sampleDurations = [streamContext.lastDuration];
                    }
                }
            });
            this.updateCurrentFragment(formatContext);
            formatContext.ioWriter.writeUint32(8);
            formatContext.ioWriter.writeString("mfra" /* BoxType.MFRA */);
            formatContext.ioWriter.flush();
        }
        return 0;
    }
    flush(formatContext) {
        if (this.options.fragment) {
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(this.context.currentFragment.tracks, (track) => {
                const stream = formatContext.streams.find((stream) => {
                    return stream.index === track.streamIndex;
                });
                const streamContext = stream.privData;
                if (track.sampleCount) {
                    if (track.sampleDurations.length) {
                        track.sampleDurations.push(track.sampleDurations[track.sampleDurations.length - 1]);
                    }
                    else {
                        track.sampleDurations = [streamContext.lastDuration];
                    }
                }
            });
            this.updateCurrentFragment(formatContext);
        }
        formatContext.ioWriter.flush();
        return 0;
    }
}


/***/ }),

/***/ "./src/avformat/formats/ass/ass.ts":
/*!*****************************************!*\
  !*** ./src/avformat/formats/ass/ass.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AssEventsFormatList: () => (/* binding */ AssEventsFormatList),
/* harmony export */   AssStylesFormatList: () => (/* binding */ AssStylesFormatList)
/* harmony export */ });
/*
 * libmedia ass defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const AssStylesFormatList = [
    "Name" /* AssStylesFormat.Name */,
    "Fontname" /* AssStylesFormat.FontName */,
    "Fontsize" /* AssStylesFormat.FontSize */,
    "PrimaryColour" /* AssStylesFormat.PrimaryColour */,
    "SecondaryColour" /* AssStylesFormat.SecondaryColour */,
    "OutlineColour" /* AssStylesFormat.OutlineColour */,
    "BackColour" /* AssStylesFormat.BackColour */,
    "Bold" /* AssStylesFormat.Bold */,
    "Italic" /* AssStylesFormat.Italic */,
    "Underline" /* AssStylesFormat.Underline */,
    "StrikeOut" /* AssStylesFormat.StrikeOut */,
    "ScaleX" /* AssStylesFormat.ScaleX */,
    "ScaleY" /* AssStylesFormat.ScaleY */,
    "Spacing" /* AssStylesFormat.Spacing */,
    "Angle" /* AssStylesFormat.Angle */,
    "BorderStyle" /* AssStylesFormat.BorderStyle */,
    "Outline" /* AssStylesFormat.Outline */,
    "Shadow" /* AssStylesFormat.Shadow */,
    "Alignment" /* AssStylesFormat.Alignment */,
    "MarginL" /* AssStylesFormat.MarginL */,
    "MarginR" /* AssStylesFormat.MarginR */,
    "MarginV" /* AssStylesFormat.MarginV */,
    "Encoding" /* AssStylesFormat.Encoding */
];
const AssEventsFormatList = [
    "ReadOrder" /* AssEventsFormat.ReadOrder */,
    "Layer" /* AssEventsFormat.Layer */,
    "Start" /* AssEventsFormat.Start */,
    "End" /* AssEventsFormat.End */,
    "Style" /* AssEventsFormat.Style */,
    "Name" /* AssEventsFormat.Name */,
    "MarginL" /* AssEventsFormat.MarginL */,
    "MarginR" /* AssEventsFormat.MarginR */,
    "MarginV" /* AssEventsFormat.MarginV */,
    "Effect" /* AssEventsFormat.Effect */,
    "Text" /* AssEventsFormat.Text */
];


/***/ }),

/***/ "./src/avformat/formats/ass/iass.ts":
/*!******************************************!*\
  !*** ./src/avformat/formats/ass/iass.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getEventLineTime: () => (/* binding */ getEventLineTime),
/* harmony export */   parseEvent: () => (/* binding */ parseEvent),
/* harmony export */   parseEventFormat: () => (/* binding */ parseEventFormat)
/* harmony export */ });
/* unused harmony exports parseFormat, parseStyleFormat, parseEventLine, parseDrawing, parseStyle */
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _ass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ass */ "./src/avformat/formats/ass/ass.ts");
/* harmony import */ var common_util_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/time */ "./src/common/util/time.ts");
/* harmony import */ var ass_compiler_src_parser_effect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ass-compiler/src/parser/effect */ "./node_modules/ass-compiler/src/parser/effect.js");
/* harmony import */ var ass_compiler_src_parser_text__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ass-compiler/src/parser/text */ "./node_modules/ass-compiler/src/parser/text.js");
var cheap__fileName__0 = "src\\avformat\\formats\\ass\\iass.ts";
/*
 * libmedia ass input util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





function parseFormat(fields, format) {
    const items = format.match(/Format\s*:\s*(.*)/i)[1].split(/\s*,\s*/);
    const result = [];
    for (let i = 0; i < items.length; i++) {
        const field = fields.find(f => f.toLowerCase() === items[i].toLowerCase());
        if (!field) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_0__.warn(`not support ass field(${items[i]})`, cheap__fileName__0, 40);
        }
        result.push(field || items[i]);
    }
    return result;
}
function parseStyleFormat(format) {
    return parseFormat(_ass__WEBPACK_IMPORTED_MODULE_1__.AssStylesFormatList, format);
}
function parseEventFormat(format) {
    return parseFormat(_ass__WEBPACK_IMPORTED_MODULE_1__.AssEventsFormatList, format);
}
function parseEventLine(formats, text) {
    let fields = text.split(',');
    if (fields.length > formats.length) {
        const textField = fields.slice(formats.length - 1).join(',');
        fields = fields.slice(0, formats.length - 1);
        fields.push(textField);
    }
    return fields;
}
function getEventLineTime(formats, event, startIndex, endIndex) {
    const [, , value] = event.match(/^(\w+?)\s*:\s*(.*)/i);
    const fields = parseEventLine(formats, value);
    return {
        start: (0,common_util_time__WEBPACK_IMPORTED_MODULE_2__.hhColonDDColonSSDotMill2Int64)(fields[startIndex]),
        end: (0,common_util_time__WEBPACK_IMPORTED_MODULE_2__.hhColonDDColonSSDotMill2Int64)(fields[endIndex])
    };
}
function parseDrawing(text) {
    if (!text) {
        return [];
    }
    return text
        .toLowerCase()
        // numbers
        .replace(/([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)/g, ' $1 ')
        // commands
        .replace(/([mnlbspc])/g, ' $1 ')
        .trim()
        .replace(/\s+/g, ' ')
        .split(/\s(?=[mnlbspc])/)
        .map((cmd) => (cmd.split(' ').filter((x, i) => !(i && Number.isNaN(+x)))));
}
function parseStyle(styleFormat, style) {
    const values = style.match(/Style\s*:\s*(.*)/i)[1].split(/\s*,\s*/);
    const result = {};
    for (let i = 0; i < values.length; i++) {
        result[styleFormat[i]] = values[i];
    }
    return result;
}
function parseEvent(formats, event) {
    const [, key, value] = event.match(/^(\w+?)\s*:\s*(.*)/i);
    let type = 0 /* AssEventType.NONE */;
    switch (key) {
        case 'Comment':
            type = 2 /* AssEventType.Comment */;
            break;
        case 'Dialogue':
            type = 1 /* AssEventType.Dialogue */;
            break;
        case 'Command':
            type = 6 /* AssEventType.Command */;
            break;
        case 'Movie':
            type = 5 /* AssEventType.Movie */;
            break;
        case 'Picture':
            type = 3 /* AssEventType.Picture */;
            break;
        case 'Sound':
            type = 4 /* AssEventType.Sound */;
            break;
    }
    const fields = parseEventLine(formats, value);
    const result = {
        type
    };
    for (let i = 0; i < fields.length; i++) {
        result[formats[i]] = fields[i];
        const fmt = formats[i];
        const fld = fields[i].trim();
        switch (fmt) {
            case 'Layer':
            case 'MarginL':
            case 'MarginR':
            case 'MarginV':
                result[fmt] = +fld;
                break;
            case 'Start':
            case 'End':
                result[fmt] = (0,common_util_time__WEBPACK_IMPORTED_MODULE_2__.hhColonDDColonSSDotMill2Int64)(fld);
                break;
            case 'Effect':
                result[fmt] = (0,ass_compiler_src_parser_effect__WEBPACK_IMPORTED_MODULE_3__.parseEffect)(fld);
                break;
            case 'Text':
                result[fmt] = (0,ass_compiler_src_parser_text__WEBPACK_IMPORTED_MODULE_4__.parseText)(fld);
                break;
            default:
                result[fmt] = fld;
        }
    }
    return result;
}


/***/ }),

/***/ "./src/avformat/formats/mov/boxType.ts":
/*!*********************************************!*\
  !*** ./src/avformat/formats/mov/boxType.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContainerBoxs: () => (/* binding */ ContainerBoxs),
/* harmony export */   FullBoxs: () => (/* binding */ FullBoxs)
/* harmony export */ });
/* unused harmony export BasicBoxs */
/*
 * libmedia mp4 box defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const BasicBoxs = [
    "ftyp" /* BoxType.FTYP */,
    "mdat" /* BoxType.MDAT */,
    "idat" /* BoxType.IDAT */,
    "free" /* BoxType.FREE */,
    "skip" /* BoxType.SKIP */,
    "meco" /* BoxType.MECO */,
    "strk" /* BoxType.STRK */,
];
const FullBoxs = [
    "hmhd" /* BoxType.HMHD */,
    "nmhd" /* BoxType.NMHD */,
    "iods" /* BoxType.IODS */,
    "xml " /* BoxType.XML */,
    "url " /* BoxType.URL */,
    "bxml" /* BoxType.BXML */,
    "ipro" /* BoxType.IPRO */,
    "mere" /* BoxType.MERE */,
    "stts" /* BoxType.STTS */,
    "ctts" /* BoxType.CTTS */,
    "stss" /* BoxType.STSS */,
    "stsz" /* BoxType.STSZ */,
    "stz2" /* BoxType.STZ2 */,
    "stsc" /* BoxType.STSC */,
    "stco" /* BoxType.STCO */,
    "co64" /* BoxType.CO64 */,
    "stsd" /* BoxType.STSD */,
    "dref" /* BoxType.DREF */,
    "mvhd" /* BoxType.MVHD */,
    "tkhd" /* BoxType.TKHD */,
    "mdhd" /* BoxType.MDHD */,
    "hdlr" /* BoxType.HDLR */
];
const ContainerBoxs = [
    "moov" /* BoxType.MOOV */,
    "trak" /* BoxType.TRAK */,
    "edts" /* BoxType.EDTS */,
    "mdia" /* BoxType.MDIA */,
    "minf" /* BoxType.MINF */,
    "dinf" /* BoxType.DINF */,
    "stbl" /* BoxType.STBL */,
    "mvex" /* BoxType.MVEX */,
    "moof" /* BoxType.MOOF */,
    "traf" /* BoxType.TRAF */,
    "vttc" /* BoxType.VTTC */,
    "tref" /* BoxType.TREF */,
    "iref" /* BoxType.IREF */,
    "mfra" /* BoxType.MFRA */,
    "hnti" /* BoxType.HNTI */,
    "hinf" /* BoxType.HINF */,
    "strd" /* BoxType.STRD */,
    "sinf" /* BoxType.SINF */,
    "rinf" /* BoxType.RINF */,
    "schi" /* BoxType.SCHI */,
    "trgr" /* BoxType.TRGR */,
    "udta" /* BoxType.UDTA */,
    "iprp" /* BoxType.IPRP */,
    "ipco" /* BoxType.IPCO */,
    "strk" /* BoxType.STRK */,
    "meco" /* BoxType.MECO */
];


/***/ }),

/***/ "./src/avformat/formats/mov/function/createFragmentTrack.ts":
/*!******************************************************************!*\
  !*** ./src/avformat/formats/mov/function/createFragmentTrack.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createFragmentTrack)
/* harmony export */ });
/*
 * libmedia create fragment track
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function createFragmentTrack() {
    return {
        trackId: 0,
        baseDataOffset: BigInt(0),
        defaultSampleDuration: 0,
        defaultSampleSize: 0,
        defaultSampleFlags: 0,
        baseMediaDecodeTime: BigInt(0),
        sampleCount: 0,
        dataOffset: 0,
        dataOffsetPos: BigInt(0),
        firstSampleFlags: 0,
        sampleDurations: [],
        sampleSizes: [],
        sampleFlags: [],
        sampleCompositionTimeOffset: [],
        baseIsMoof: false,
        ioWriter: null,
        buffers: []
    };
}


/***/ }),

/***/ "./src/avformat/formats/mov/function/createMovContext.ts":
/*!***************************************************************!*\
  !*** ./src/avformat/formats/mov/function/createMovContext.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createMovContext)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/*
 * libmedia create mov context
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function createMovContext() {
    return {
        isom: false,
        timescale: avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
        duration: avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT,
        foundMoov: false,
        foundMdat: false,
        majorBrand: 0,
        minorVersion: 0,
        compatibleBrand: [],
        creationTime: BigInt(0),
        modificationTime: BigInt(0),
        rate: avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
        volume: avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
        matrix: null,
        nextTrackId: 1,
        fragment: false,
        trexs: [],
        currentFragment: null,
        boxsPositionInfo: [],
        holdMoovPos: BigInt(0),
        currentChunk: null
    };
}


/***/ }),

/***/ "./src/avformat/formats/mov/function/createMovStreamContext.ts":
/*!*********************************************************************!*\
  !*** ./src/avformat/formats/mov/function/createMovStreamContext.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createMovStreamContext)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/*
 * libmedia create mov stream context
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function createMovStreamContext() {
    return {
        chunkOffsets: null,
        cttsSampleCounts: null,
        cttsSampleOffsets: null,
        stscFirstChunk: null,
        stscSamplesPerChunk: null,
        stscSampleDescriptionIndex: null,
        stssSampleNumbersMap: null,
        stssSampleNumbers: null,
        sampleSizes: null,
        sttsSampleCounts: null,
        sttsSampleDeltas: null,
        timescale: 0,
        duration: BigInt(0),
        trackId: avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
        layer: 0,
        alternateGroup: 0,
        volume: 0,
        matrix: null,
        width: 0,
        height: 0,
        audioCid: 0,
        samplesPerFrame: 0,
        bytesPerFrame: 0,
        currentSample: 0,
        sampleEnd: false,
        samplesIndex: [],
        fragIndexes: [],
        lastPts: BigInt(0),
        lastDts: BigInt(0),
        startDts: BigInt(0),
        startCT: 0,
        lastDuration: 0,
        chunkCount: 0,
        firstWrote: false,
        lastStscCount: 0,
        perStreamGrouping: false,
        index: 0,
        flags: 0
    };
}


/***/ }),

/***/ "./src/avformat/formats/mov/function/updatePositionSize.ts":
/*!*****************************************************************!*\
  !*** ./src/avformat/formats/mov/function/updatePositionSize.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updatePositionSize)
/* harmony export */ });
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/*
 * libmedia update box position size
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function updatePositionSize(ioWriter, movContext) {
    const pos = ioWriter.getPos();
    const pointer = ioWriter.getPointer();
    const minPos = pos - BigInt(Math.floor(pointer));
    const seeks = [];
    common_util_array__WEBPACK_IMPORTED_MODULE_0__.each(movContext.boxsPositionInfo, (item) => {
        if (item.pos < pos && item.pos >= minPos) {
            ioWriter.seekInline(pointer + Number(item.pos - pos));
            ioWriter.writeUint32(item.size);
        }
        else {
            seeks.push(item);
        }
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_0__.each(seeks, (item) => {
        ioWriter.seek(item.pos);
        ioWriter.writeUint32(item.size);
    });
    if (seeks.length) {
        ioWriter.seek(pos);
    }
    else {
        ioWriter.seekInline(pointer);
    }
    movContext.boxsPositionInfo = [];
}


/***/ }),

/***/ "./src/avformat/formats/mov/layout.ts":
/*!********************************************!*\
  !*** ./src/avformat/formats/mov/layout.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FragmentTrackBoxLayoutMap: () => (/* binding */ FragmentTrackBoxLayoutMap),
/* harmony export */   MoofTrafBoxLayout: () => (/* binding */ MoofTrafBoxLayout),
/* harmony export */   TrackBoxLayoutMap: () => (/* binding */ TrackBoxLayoutMap)
/* harmony export */ });
/*
 * libmedia mp4 box layout
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function getTrackBoxAudioLayout(context) {
    return [
        {
            type: "tkhd" /* BoxType.TKHD */
        },
        {
            type: "edts" /* BoxType.EDTS */
        },
        {
            type: "mdia" /* BoxType.MDIA */,
            children: [
                {
                    type: "mdhd" /* BoxType.MDHD */
                },
                {
                    type: "hdlr" /* BoxType.HDLR */
                },
                {
                    type: "minf" /* BoxType.MINF */,
                    children: [
                        {
                            type: "smhd" /* BoxType.SMHD */
                        },
                        context.isom
                            ? {
                                type: "minf_hdlr" /* BoxType.MINF_HDLR */
                            }
                            : null,
                        {
                            type: "dinf" /* BoxType.DINF */,
                            children: [
                                {
                                    type: "dref" /* BoxType.DREF */,
                                    children: [
                                        {
                                            type: "url " /* BoxType.URL */
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            type: "stbl" /* BoxType.STBL */,
                            children: [
                                {
                                    type: "stsd" /* BoxType.STSD */
                                },
                                {
                                    type: "stts" /* BoxType.STTS */
                                },
                                {
                                    type: "stsc" /* BoxType.STSC */
                                },
                                {
                                    type: "stsz" /* BoxType.STSZ */
                                },
                                {
                                    type: "stco" /* BoxType.STCO */
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ];
}
function getTrackBoxVideoLayout(context) {
    return [
        {
            type: "tkhd" /* BoxType.TKHD */
        },
        {
            type: "edts" /* BoxType.EDTS */
        },
        {
            type: "mdia" /* BoxType.MDIA */,
            children: [
                {
                    type: "mdhd" /* BoxType.MDHD */
                },
                {
                    type: "hdlr" /* BoxType.HDLR */
                },
                {
                    type: "minf" /* BoxType.MINF */,
                    children: [
                        {
                            type: "vmhd" /* BoxType.VMHD */
                        },
                        context.isom
                            ? {
                                type: "minf_hdlr" /* BoxType.MINF_HDLR */
                            }
                            : null,
                        {
                            type: "dinf" /* BoxType.DINF */,
                            children: [
                                {
                                    type: "dref" /* BoxType.DREF */,
                                    children: [
                                        {
                                            type: "url " /* BoxType.URL */
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            type: "stbl" /* BoxType.STBL */,
                            children: [
                                {
                                    type: "stsd" /* BoxType.STSD */
                                },
                                {
                                    type: "stts" /* BoxType.STTS */
                                },
                                {
                                    type: "stss" /* BoxType.STSS */
                                },
                                {
                                    type: "ctts" /* BoxType.CTTS */
                                },
                                {
                                    type: "stsc" /* BoxType.STSC */
                                },
                                {
                                    type: "stsz" /* BoxType.STSZ */
                                },
                                {
                                    type: "stco" /* BoxType.STCO */
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ];
}
function getFragmentTrackAudioBoxLayout(context) {
    return [
        {
            type: "tkhd" /* BoxType.TKHD */
        },
        {
            type: "mdia" /* BoxType.MDIA */,
            children: [
                {
                    type: "mdhd" /* BoxType.MDHD */
                },
                {
                    type: "hdlr" /* BoxType.HDLR */
                },
                {
                    type: "minf" /* BoxType.MINF */,
                    children: [
                        {
                            type: "smhd" /* BoxType.SMHD */
                        },
                        context.isom
                            ? {
                                type: "minf_hdlr" /* BoxType.MINF_HDLR */
                            }
                            : null,
                        {
                            type: "dinf" /* BoxType.DINF */,
                            children: [
                                {
                                    type: "dref" /* BoxType.DREF */,
                                    children: [
                                        {
                                            type: "url " /* BoxType.URL */
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            type: "stbl" /* BoxType.STBL */,
                            children: [
                                {
                                    type: "stsd" /* BoxType.STSD */
                                },
                                {
                                    type: "stts" /* BoxType.STTS */
                                },
                                {
                                    type: "stsc" /* BoxType.STSC */
                                },
                                {
                                    type: "stsz" /* BoxType.STSZ */
                                },
                                {
                                    type: "stco" /* BoxType.STCO */
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ];
}
function getFragmentTrackVideoBoxLayout(context) {
    return [
        {
            type: "tkhd" /* BoxType.TKHD */
        },
        {
            type: "mdia" /* BoxType.MDIA */,
            children: [
                {
                    type: "mdhd" /* BoxType.MDHD */
                },
                {
                    type: "hdlr" /* BoxType.HDLR */
                },
                {
                    type: "minf" /* BoxType.MINF */,
                    children: [
                        {
                            type: "vmhd" /* BoxType.VMHD */
                        },
                        context.isom
                            ? {
                                type: "minf_hdlr" /* BoxType.MINF_HDLR */
                            }
                            : null,
                        {
                            type: "dinf" /* BoxType.DINF */,
                            children: [
                                {
                                    type: "dref" /* BoxType.DREF */,
                                    children: [
                                        {
                                            type: "url " /* BoxType.URL */
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            type: "stbl" /* BoxType.STBL */,
                            children: [
                                {
                                    type: "stsd" /* BoxType.STSD */
                                },
                                {
                                    type: "stts" /* BoxType.STTS */
                                },
                                {
                                    type: "stsc" /* BoxType.STSC */
                                },
                                {
                                    type: "stsz" /* BoxType.STSZ */
                                },
                                {
                                    type: "stco" /* BoxType.STCO */
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ];
}
const FragmentTrackBoxLayoutMap = {
    [1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */]: getFragmentTrackAudioBoxLayout,
    [0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */]: getFragmentTrackVideoBoxLayout
};
const TrackBoxLayoutMap = {
    [1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */]: getTrackBoxAudioLayout,
    [0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */]: getTrackBoxVideoLayout
};
const MoofTrafBoxLayout = [
    {
        type: "tfhd" /* BoxType.TFHD */
    },
    {
        type: "tfdt" /* BoxType.TFDT */
    },
    {
        type: "trun" /* BoxType.TRUN */
    }
];


/***/ }),

/***/ "./src/avformat/formats/mov/mov.ts":
/*!*****************************************!*\
  !*** ./src/avformat/formats/mov/mov.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVCodecID2Mp4a: () => (/* binding */ AVCodecID2Mp4a),
/* harmony export */   HandlerType2MediaType: () => (/* binding */ HandlerType2MediaType),
/* harmony export */   Mp4aObj2AVCodecID: () => (/* binding */ Mp4aObj2AVCodecID),
/* harmony export */   tag2CodecId: () => (/* binding */ tag2CodecId)
/* harmony export */ });
/* unused harmony export Mp4Tag2AVCodecID */
/* harmony import */ var _function_mktag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../function/mktag */ "./src/avformat/function/mktag.ts");
/*
 * libmedia mp4 identify defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const Mp4Tag2AVCodecID = {
    mp4v: 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
    avc1: 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    avc3: 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    hev1: 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    hvc1: 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    vvc1: 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    vvi1: 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    vp09: 167 /* AVCodecID.AV_CODEC_ID_VP9 */,
    av01: 225 /* AVCodecID.AV_CODEC_ID_AV1 */,
    mp4a: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    opus: 86076 /* AVCodecID.AV_CODEC_ID_OPUS */
};
const AVCodecID2Mp4a = {
    [86018 /* AVCodecID.AV_CODEC_ID_AAC */]: 0x40,
    [86017 /* AVCodecID.AV_CODEC_ID_MP3 */]: 0x69,
    [86076 /* AVCodecID.AV_CODEC_ID_OPUS */]: 0xAD,
    [86028 /* AVCodecID.AV_CODEC_ID_FLAC */]: 0xC1,
    [86021 /* AVCodecID.AV_CODEC_ID_VORBIS */]: 0xDD,
    [12 /* AVCodecID.AV_CODEC_ID_MPEG4 */]: 0x20,
    [27 /* AVCodecID.AV_CODEC_ID_H264 */]: 0x21,
    [173 /* AVCodecID.AV_CODEC_ID_HEVC */]: 0x23,
    [196 /* AVCodecID.AV_CODEC_ID_VVC */]: 0x33,
    [167 /* AVCodecID.AV_CODEC_ID_VP9 */]: 0xB1,
    [0 /* AVCodecID.AV_CODEC_ID_NONE */]: 0
};
const Mp4aObj2AVCodecID = {
    0x20: 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
    0x21: 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    0x23: 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    0x33: 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    0xB1: 167 /* AVCodecID.AV_CODEC_ID_VP9 */,
    0x40: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    0x66: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    0x67: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    0x68: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    0x69: 86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
    0x6B: 86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
    0xAD: 86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
    0xC1: 86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
    0xDD: 86021 /* AVCodecID.AV_CODEC_ID_VORBIS */,
    0: 0 /* AVCodecID.AV_CODEC_ID_NONE */
};
const HandlerType2MediaType = {
    vide: 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */,
    soun: 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */,
    clcp: 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */,
    sbtl: 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */,
    subt: 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */,
    subp: 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */,
    text: 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */
};
const tag2CodecId = {
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("mp4a" /* BoxType.MP4A */)]: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    [0x6D730055]: 86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('Opus')]: 86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('fLaC')]: 86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('spex')]: 86051 /* AVCodecID.AV_CODEC_ID_SPEEX */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('SPXN')]: 86051 /* AVCodecID.AV_CODEC_ID_SPEEX */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('ac-3')]: 86019 /* AVCodecID.AV_CODEC_ID_AC3 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('sac3')]: 86019 /* AVCodecID.AV_CODEC_ID_AC3 */,
    [_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"]["mp4v" /* BoxType.MP4V */]]: 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('av01')]: 225 /* AVCodecID.AV_CODEC_ID_AV1 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('vp08')]: 139 /* AVCodecID.AV_CODEC_ID_VP8 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('vp09')]: 167 /* AVCodecID.AV_CODEC_ID_VP9 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('avc1')]: 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('hev1')]: 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('hvc1')]: 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('vvc1')]: 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('vvi1')]: 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('text')]: 94213 /* AVCodecID.AV_CODEC_ID_MOV_TEXT */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('tx3g')]: 94213 /* AVCodecID.AV_CODEC_ID_MOV_TEXT */
};


/***/ }),

/***/ "./src/avformat/formats/mov/omov.ts":
/*!******************************************!*\
  !*** ./src/avformat/formats/mov/omov.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   writeFtyp: () => (/* binding */ writeFtyp),
/* harmony export */   writeMoof: () => (/* binding */ writeMoof),
/* harmony export */   writeMoov: () => (/* binding */ writeMoov)
/* harmony export */ });
/* unused harmony export updateSize */
/* harmony import */ var _function_mktag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../function/mktag */ "./src/avformat/function/mktag.ts");
/* harmony import */ var _boxType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./boxType */ "./src/avformat/formats/mov/boxType.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var _writing_writers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./writing/writers */ "./src/avformat/formats/mov/writing/writers.ts");
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./layout */ "./src/avformat/formats/mov/layout.ts");
/* harmony import */ var _function_updatePositionSize__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./function/updatePositionSize */ "./src/avformat/formats/mov/function/updatePositionSize.ts");
/*
 * libmedia mp4 encode util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */






function updateSize(ioWriter, pointer, size) {
    const current = ioWriter.getPointer();
    ioWriter.seekInline(pointer);
    ioWriter.writeUint32(size);
    ioWriter.seekInline(current);
}
function writeFtyp(ioWriter, context) {
    ioWriter.flush();
    const pointer = ioWriter.getPointer();
    const now = ioWriter.getPos();
    ioWriter.writeUint32(0);
    ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("ftyp" /* BoxType.FTYP */));
    ioWriter.writeUint32(context.majorBrand || (0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('isom'));
    ioWriter.writeUint32(context.minorVersion || 512);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(context.compatibleBrand, (value) => {
        ioWriter.writeUint32(value);
    });
    updateSize(ioWriter, pointer, Number(ioWriter.getPos() - now));
    if (context.isom) {
        ioWriter.writeUint32(8);
        ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("wide" /* BoxType.WIDE */));
    }
    else if (!context.fragment) {
        ioWriter.writeUint32(8);
        ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("free" /* BoxType.FREE */));
    }
}
function writeEmptyBox(ioWriter, tag) {
    const isFullBox = common_util_array__WEBPACK_IMPORTED_MODULE_2__.has(_boxType__WEBPACK_IMPORTED_MODULE_1__.FullBoxs, tag);
    ioWriter.writeUint32(isFullBox ? 12 : 8);
    ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])(tag));
    if (isFullBox) {
        // version & flags
        ioWriter.writeUint32(0);
    }
}
function writeLayout(ioWriter, layouts, stream, movContext) {
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(layouts, (layout) => {
        if (!layout) {
            return true;
        }
        if (_writing_writers__WEBPACK_IMPORTED_MODULE_3__["default"][layout.type]) {
            _writing_writers__WEBPACK_IMPORTED_MODULE_3__["default"][layout.type](ioWriter, stream, movContext);
        }
        else if (layout.children) {
            const pos = ioWriter.getPos();
            ioWriter.writeUint32(0);
            ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])(layout.type));
            writeLayout(ioWriter, layout.children, stream, movContext);
            movContext.boxsPositionInfo.push({
                pos,
                type: layout.type,
                size: Number(ioWriter.getPos() - pos)
            });
        }
        else {
            writeEmptyBox(ioWriter, layout.type);
        }
    });
}
function writeMoov(ioWriter, formatContext, movContext) {
    const pos = ioWriter.getPos();
    ioWriter.writeUint32(0);
    ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("moov" /* BoxType.MOOV */));
    _writing_writers__WEBPACK_IMPORTED_MODULE_3__["default"]["mvhd" /* BoxType.MVHD */](ioWriter, null, movContext);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(formatContext.streams, (stream) => {
        const pos = ioWriter.getPos();
        ioWriter.writeUint32(0);
        ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("trak" /* BoxType.TRAK */));
        writeLayout(ioWriter, movContext.fragment
            ? _layout__WEBPACK_IMPORTED_MODULE_4__.FragmentTrackBoxLayoutMap[stream.codecpar.codecType](movContext)
            : _layout__WEBPACK_IMPORTED_MODULE_4__.TrackBoxLayoutMap[stream.codecpar.codecType](movContext), stream, movContext);
        movContext.boxsPositionInfo.push({
            pos,
            type: "trak" /* BoxType.TRAK */,
            size: Number(ioWriter.getPos() - pos)
        });
    });
    if (movContext.fragment) {
        const pos = ioWriter.getPos();
        ioWriter.writeUint32(0);
        ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("mvex" /* BoxType.MVEX */));
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(formatContext.streams, (stream) => {
            _writing_writers__WEBPACK_IMPORTED_MODULE_3__["default"]["trex" /* BoxType.TREX */](ioWriter, stream, movContext);
        });
        movContext.boxsPositionInfo.push({
            pos,
            type: "mvex" /* BoxType.MVEX */,
            size: Number(ioWriter.getPos() - pos)
        });
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: "moov" /* BoxType.MOOV */,
        size: Number(ioWriter.getPos() - pos)
    });
    (0,_function_updatePositionSize__WEBPACK_IMPORTED_MODULE_5__["default"])(ioWriter, movContext);
}
function writeMoof(ioWriter, formatContext, movContext) {
    const pos = ioWriter.getPos();
    ioWriter.writeUint32(0);
    ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("moof" /* BoxType.MOOF */));
    _writing_writers__WEBPACK_IMPORTED_MODULE_3__["default"]["mfhd" /* BoxType.MFHD */](ioWriter, null, movContext);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(movContext.currentFragment.tracks, (track) => {
        if (!track.sampleCount) {
            return true;
        }
        const pos = ioWriter.getPos();
        ioWriter.writeUint32(0);
        ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("traf" /* BoxType.TRAF */));
        const stream = formatContext.streams.find((stream) => {
            return stream.privData.trackId === track.trackId;
        });
        writeLayout(ioWriter, _layout__WEBPACK_IMPORTED_MODULE_4__.MoofTrafBoxLayout, stream, movContext);
        movContext.boxsPositionInfo.push({
            pos,
            type: "traf" /* BoxType.TRAF */,
            size: Number(ioWriter.getPos() - pos)
        });
    });
    const size = Number(ioWriter.getPos() - pos);
    movContext.boxsPositionInfo.push({
        pos,
        type: "moof" /* BoxType.MOOF */,
        size
    });
    movContext.currentFragment.size = size;
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/av1c.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/av1c.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 av1c box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(8 + stream.codecpar.extradataSize ?? 0);
    // tag
    ioWriter.writeString("av1C" /* BoxType.AV1C */);
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
        }
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/avcc.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/avcc.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 avcc box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(8 + stream.codecpar.extradataSize ?? 0);
    // tag
    ioWriter.writeString("avcC" /* BoxType.AVCC */);
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
        }
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/btrt.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/btrt.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 btrt box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(20);
    // tag
    ioWriter.writeString("btrt" /* BoxType.BTRT */);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/co64.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/co64.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 co64 box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const chunkOffsets = stream.privData.chunkOffsets || [];
    // size
    ioWriter.writeUint32(8 + chunkOffsets.length * 8);
    // tag
    ioWriter.writeString("co64" /* BoxType.CO64 */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(chunkOffsets.length);
    for (let i = 0; i < chunkOffsets.length; i++) {
        ioWriter.writeUint64(chunkOffsets[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/colr.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/colr.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 colr box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const icc = stream.sideData[28 /* AVPacketSideDataType.AV_PKT_DATA_ICC_PROFILE */];
    if (icc) {
        // size
        ioWriter.writeUint32(12 + icc.length);
        // tag
        ioWriter.writeString("colr" /* BoxType.COLR */);
        ioWriter.writeString('prof');
        ioWriter.writeBuffer(icc);
    }
    else {
        const fullRange = stream.codecpar.colorRange === 2 /* AVColorRange.AVCOL_RANGE_JPEG */;
        // size
        ioWriter.writeUint32(19);
        // tag
        ioWriter.writeString("colr" /* BoxType.COLR */);
        ioWriter.writeString('nclx');
        ioWriter.writeUint16(stream.codecpar.colorPrimaries);
        ioWriter.writeUint16(stream.codecpar.colorTrc);
        ioWriter.writeUint16(stream.codecpar.colorSpace);
        ioWriter.writeUint8(fullRange ? (128) : 0);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/ctts.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/ctts.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avformat\\formats\\mov\\writing\\ctts.ts";

function write(ioWriter, stream, movContext) {
    const context = stream.privData;
    const sampleCounts = context.cttsSampleCounts || [];
    const sampleOffsets = context.cttsSampleOffsets || [];
    if (sampleCounts.length !== sampleOffsets.length) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('ctts sampleCounts\'s length is not match sampleOffsets\'s length', cheap__fileName__0, 39);
    }
    const entryCount = Math.min(sampleCounts.length, sampleOffsets.length);
    // size
    ioWriter.writeUint32(16 + entryCount * 8);
    // tag
    ioWriter.writeString("ctts" /* BoxType.CTTS */);
    // version use int
    ioWriter.writeUint8(1);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(entryCount);
    for (let i = 0; i < entryCount; i++) {
        ioWriter.writeUint32(sampleCounts[i]);
        ioWriter.writeInt32(sampleOffsets[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/dac3.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/dac3.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var common_io_BitWriter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BitWriter */ "./src/common/io/BitWriter.ts");
/*
 * libmedia mp4 dac3 box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(11);
    // tag
    ioWriter.writeString("dac3" /* BoxType.DAC3 */);
    const bitWriter = new common_io_BitWriter__WEBPACK_IMPORTED_MODULE_0__["default"](3);
    const info = movContext.ac3Info;
    bitWriter.writeU(2, info.substream[0].fscod);
    bitWriter.writeU(5, info.substream[0].bsid);
    bitWriter.writeU(3, info.substream[0].bsmod);
    bitWriter.writeU(3, info.substream[0].acmod);
    bitWriter.writeU(1, info.substream[0].lfeon);
    bitWriter.writeU(5, info.ac3BitrateCode);
    bitWriter.writeU(5, 0);
    ioWriter.writeBuffer(bitWriter.getBuffer());
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/dec3.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/dec3.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var common_io_BitWriter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BitWriter */ "./src/common/io/BitWriter.ts");
/*
 * libmedia mp4 dec3 box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    const info = movContext.ac3Info;
    const bitWriter = new common_io_BitWriter__WEBPACK_IMPORTED_MODULE_0__["default"](2 + ((34 * (info.numIndSub + 1) + 7) >> 3));
    bitWriter.writeU(13, info.dataRate);
    bitWriter.writeU(3, info.numIndSub);
    for (let i = 0; i < info.numIndSub; i++) {
        bitWriter.writeU(2, info.substream[i].fscod);
        bitWriter.writeU(5, info.substream[i].bsid);
        bitWriter.writeU(1, 0);
        bitWriter.writeU(1, 0);
        bitWriter.writeU(3, info.substream[i].bsmod);
        bitWriter.writeU(3, info.substream[i].acmod);
        bitWriter.writeU(1, info.substream[i].lfeon);
        bitWriter.writeU(5, 0);
        bitWriter.writeU(4, info.substream[i].numDepSub);
        if (!info.substream[i].numDepSub) {
            bitWriter.writeU(1, 0);
        }
        else {
            bitWriter.writeU(9, info.substream[i].chanLoc);
        }
    }
    bitWriter.padding();
    const size = bitWriter.getPointer();
    // size
    ioWriter.writeUint32(8 + size);
    // tag
    ioWriter.writeString("dec3" /* BoxType.DEC3 */);
    ioWriter.writeBuffer(bitWriter.getBuffer().subarray(0, size));
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/dfla.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/dfla.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avformat\\formats\\mov\\writing\\dfla.ts";


function write(ioWriter, stream, movContext) {
    let extradata;
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize);
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize);
        }
    }
    if (!extradata) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.error('invalid extradata', cheap__fileName__0, 56);
    }
    else {
        // size
        ioWriter.writeUint32(extradata.length + 16);
        // tag
        ioWriter.writeString("dfLa" /* BoxType.DFLA */);
        // version
        ioWriter.writeUint8(0);
        // flags
        ioWriter.writeUint24(0);
        ioWriter.writeUint8((128) | 0 /* FlacMetadataType.FLAC_METADATA_TYPE_STREAMINFO */);
        ioWriter.writeUint24(extradata.length);
        ioWriter.writeBuffer(extradata);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/dops.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/dops.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/*
 * libmedia mp4 dops box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function write(ioWriter, stream, movContext) {
    let extradata;
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize);
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize);
        }
    }
    if (!extradata || extradata.length < 19) {
        ioWriter.writeUint32(19);
        ioWriter.writeString("dOps" /* BoxType.DOPS */);
        ioWriter.writeUint8(0);
        ioWriter.writeUint8(stream.codecpar.chLayout.nbChannels);
        ioWriter.writeUint16(stream.codecpar.initialPadding);
        ioWriter.writeUint32(stream.codecpar.sampleRate);
        ioWriter.writeUint16(0);
        ioWriter.writeUint8(0);
    }
    else {
        const reader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_1__["default"](extradata, false);
        // size
        ioWriter.writeUint32(extradata.length);
        // tag
        ioWriter.writeString("dOps" /* BoxType.DOPS */);
        // Version
        ioWriter.writeUint8(0);
        reader.seek(9);
        ioWriter.writeUint8(reader.readUint8());
        ioWriter.writeUint16(reader.readUint16());
        ioWriter.writeUint32(reader.readUint32());
        ioWriter.writeUint16(reader.readUint16());
        ioWriter.writeBuffer(extradata.subarray(18));
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/dref.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/dref.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 dref box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(28);
    // tag
    ioWriter.writeString("dref" /* BoxType.DREF */);
    // version & flags
    ioWriter.writeUint32(0);
    // entry count
    ioWriter.writeUint32(1);
    // size
    ioWriter.writeUint32(0x0c);
    ioWriter.writeString("url " /* BoxType.URL */);
    // version & flags
    ioWriter.writeUint32(1);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/edts.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/edts.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/*
 * libmedia mp4 edts box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function write(ioWriter, stream, movContext) {
    const streamContext = stream.privData;
    let duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_1__.avRescaleQ)(streamContext.lastPts, stream.timeBase, {
        den: movContext.timescale,
        num: 1
    });
    let startCT = streamContext.startCT;
    const delay = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_1__.avRescaleQ)(streamContext.startDts + BigInt(Math.floor(startCT)), stream.timeBase, {
        den: streamContext.timescale,
        num: 1
    });
    let version = duration < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.INT32_MAX ? 0 : 1;
    version |= delay < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.INT32_MAX ? 0 : 1;
    const entrySize = (version === 1) ? 20 : 12;
    const entryCount = 1 + (delay > 0 ? 1 : 0);
    const size = 24 + entryCount * entrySize;
    // size
    ioWriter.writeUint32(size);
    // tag
    ioWriter.writeString("edts" /* BoxType.EDTS */);
    ioWriter.writeUint32(size - 8);
    ioWriter.writeString("elst" /* BoxType.ELST */);
    ioWriter.writeUint8(version);
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(entryCount);
    if (delay > 0) {
        if (version === 1) {
            ioWriter.writeUint64(delay);
            ioWriter.writeInt64(avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT);
        }
        else {
            ioWriter.writeUint32(Number(delay));
            ioWriter.writeInt32(-1);
        }
        ioWriter.writeUint32(0x00010000);
    }
    else {
        startCT = -Math.min(Number(streamContext.startDts), 0);
        duration += delay;
    }
    if (movContext.fragment) {
        duration = BigInt(0);
    }
    if (version === 1) {
        ioWriter.writeUint64(duration);
        ioWriter.writeInt64(BigInt(Math.floor(startCT)));
    }
    else {
        ioWriter.writeUint32(Number(duration));
        ioWriter.writeInt32(startCT);
    }
    ioWriter.writeUint32(0x00010000);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/esds.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/esds.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var _mov__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mov */ "./src/avformat/formats/mov/mov.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 esds box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function writeDescriptorLength(ioWriter, tag, size) {
    ioWriter.writeUint8(tag);
    for (let i = 3; i > 0; i--) {
        ioWriter.writeUint8((size >> (7 * i)) | 0x80);
    }
    ioWriter.writeUint8(size & 0x7F);
}
function write(ioWriter, stream, movContext) {
    const streamContext = stream.privData;
    const decoderSpecificInfoLen = stream.codecpar.extradata ? 5 + stream.codecpar.extradataSize : 0;
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("esds" /* BoxType.ESDS */);
    // version = 0
    ioWriter.writeUint32(0);
    // ES descriptor
    writeDescriptorLength(ioWriter, 3 /* MP4Tag.MP4_ES_DESCR_TAG */, 21 + decoderSpecificInfoLen + 5 + 1);
    ioWriter.writeUint16(streamContext.trackId);
    // ioWriter
    ioWriter.writeUint8(0x00);
    // DecoderConfig descriptor
    writeDescriptorLength(ioWriter, 4 /* MP4Tag.MP4_DEC_CONFIG_DESCR_TAG */, 13 + decoderSpecificInfoLen);
    // Object type indication
    if ((stream.codecpar.codecId === 86016 /* AVCodecID.AV_CODEC_ID_MP2 */ || stream.codecpar.codecId === 86017 /* AVCodecID.AV_CODEC_ID_MP3 */)
        && stream.codecpar.sampleRate > 24000) {
        // 11172-3
        ioWriter.writeUint8(0x6B);
    }
    else {
        ioWriter.writeUint8(_mov__WEBPACK_IMPORTED_MODULE_0__.AVCodecID2Mp4a[stream.codecpar.codecId]);
    }
    if (stream.codecpar.codecId === 94208 /* AVCodecID.AV_CODEC_ID_DVD_SUBTITLE */) {
        // flags (= NeroSubpicStream)
        ioWriter.writeUint8((224) | 1);
    }
    else if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
        // flags (= Audiostream)
        ioWriter.writeUint8(0x15);
    }
    else {
        // flags (= Visualstream)
        ioWriter.writeUint8(0x11);
    }
    //  Buffersize DB
    ioWriter.writeUint24(0);
    // maxbitrate
    ioWriter.writeUint32(0);
    // avgbitrate
    ioWriter.writeUint32(0);
    if (stream.codecpar.extradata) {
        writeDescriptorLength(ioWriter, 5 /* MP4Tag.MP4_DEC_SPECIFIC_DESCR_TAG */, stream.codecpar.extradataSize);
        ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
    }
    // SL descriptor
    writeDescriptorLength(ioWriter, 6 /* MP4Tag.MP4_SL_DESCR_TAG */, 1);
    ioWriter.writeUint8(0x02);
    movContext.boxsPositionInfo.push({
        pos,
        type: "esds" /* BoxType.ESDS */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/function/writeMatrix.ts":
/*!******************************************************************!*\
  !*** ./src/avformat/formats/mov/writing/function/writeMatrix.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ writeMatrix)
/* harmony export */ });
/*
 * libmedia write matrix
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
/**
 * transformation matrix
 *  |a  b  u|
 *  |c  d  v|
 *  |tx ty w|
 */
function writeMatrix(ioWriter, a, b, c, d, tx, ty) {
    ioWriter.writeUint32(a << 16);
    ioWriter.writeUint32(b << 16);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(c << 16);
    ioWriter.writeUint32(d << 16);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(tx << 16);
    ioWriter.writeUint32(ty << 16);
    ioWriter.writeUint32(1073741824);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/hdlr.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/hdlr.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 hdlr box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("hdlr" /* BoxType.HDLR */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    let hdlr = 'dhlr';
    let hdlrType = 'url ';
    let descr = 'DataHandler';
    if (stream) {
        hdlr = 'mhlr';
        if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
            hdlrType = 'soun';
            descr = 'SoundHandler';
        }
        else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
            hdlrType = 'vide';
            descr = 'VideoHandler';
        }
        else if (stream.codecpar.codecType === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */) {
            hdlrType = 'text';
            descr = 'SubtitleHandler';
        }
        else {
            if (stream.metadata['handlerName']) {
                descr = stream.metadata['handlerName'];
            }
            if (stream.metadata['hdlrType']) {
                hdlrType = stream.metadata['hdlrType'];
            }
        }
    }
    // handler
    ioWriter.writeString(hdlr);
    // handler type 
    ioWriter.writeString(hdlrType);
    // reserved
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
    if (!stream || movContext.isom) {
        ioWriter.writeUint8(descr.length);
    }
    ioWriter.writeString(descr);
    if (stream && !movContext.isom) {
        // c string
        ioWriter.writeUint8(0);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: "hdlr" /* BoxType.HDLR */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/hvcc.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/hvcc.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 hvcc box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(8 + stream.codecpar.extradataSize ?? 0);
    // tag
    ioWriter.writeString("hvcC" /* BoxType.HVCC */);
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
        }
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/mdhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/mdhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/*
 * libmedia mp4 mdhd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    const streamContext = stream.privData;
    const duration = streamContext.lastPts;
    const creationTime = stream.metadata['creationTime'] || 0;
    const modificationTime = stream.metadata['modificationTime'] || 0;
    const languge = stream.metadata['language'] || 21956;
    let version = duration < BigInt(avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX) ? 0 : 1;
    version = creationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    version = modificationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    // size
    ioWriter.writeUint32(version === 1 ? 44 : 32);
    // tag
    ioWriter.writeString("mdhd" /* BoxType.MDHD */);
    // version
    ioWriter.writeUint8(version);
    // flags
    ioWriter.writeUint24(0);
    if (version === 1) {
        ioWriter.writeUint64(creationTime);
        ioWriter.writeUint64(modificationTime);
    }
    else {
        ioWriter.writeUint32(Number(creationTime));
        ioWriter.writeUint32(Number(modificationTime));
    }
    // timescale
    ioWriter.writeUint32(stream.timeBase.den);
    if (version === 1) {
        ioWriter.writeUint64(duration);
    }
    else {
        ioWriter.writeUint32(Number(duration));
    }
    // language
    ioWriter.writeUint16(languge);
    // reserved (quality) 
    ioWriter.writeUint16(0);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/mfhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/mfhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 mfhd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(16);
    // tag
    ioWriter.writeString("mfhd" /* BoxType.MFHD */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(movContext.currentFragment.sequence);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/minfHdlr.ts":
/*!******************************************************!*\
  !*** ./src/avformat/formats/mov/writing/minfHdlr.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var _hdlr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hdlr */ "./src/avformat/formats/mov/writing/hdlr.ts");
/*
 * libmedia mp4 hdlr box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    (0,_hdlr__WEBPACK_IMPORTED_MODULE_0__["default"])(ioWriter, null, movContext);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/mvhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/mvhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var _function_writeMatrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./function/writeMatrix */ "./src/avformat/formats/mov/writing/function/writeMatrix.ts");
/*
 * libmedia mp4 mvhd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function write(ioWriter, stream, movContext) {
    const duration = movContext.duration;
    const creationTime = movContext.creationTime || 0;
    const modificationTime = movContext.modificationTime || 0;
    const timescale = movContext.timescale || 0;
    let nextTrackId = movContext.nextTrackId || 1;
    if (movContext.fragment) {
        nextTrackId = 2;
    }
    let version = duration < BigInt(avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX) ? 0 : 1;
    version = creationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    version = modificationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    // size
    ioWriter.writeUint32(version === 1 ? 120 : 108);
    // tag
    ioWriter.writeString("mvhd" /* BoxType.MVHD */);
    // version
    ioWriter.writeUint8(version);
    // flags
    ioWriter.writeUint24(0);
    if (version === 1) {
        ioWriter.writeUint64(creationTime);
        ioWriter.writeUint64(modificationTime);
    }
    else {
        ioWriter.writeUint32(Number(creationTime));
        ioWriter.writeUint32(Number(modificationTime));
    }
    // timescale
    ioWriter.writeUint32(timescale);
    if (version === 1) {
        ioWriter.writeUint64(duration);
    }
    else {
        ioWriter.writeUint32(Number(duration));
    }
    // reserved (preferred rate) 1.0 = normal
    ioWriter.writeUint32(0x00010000);
    // reserved (preferred volume) 1.0 = normal
    ioWriter.writeUint16(0x0100);
    // reserved
    ioWriter.writeUint16(0);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
    (0,_function_writeMatrix__WEBPACK_IMPORTED_MODULE_1__["default"])(ioWriter, 1, 0, 0, 1, 0, 0);
    // reserved (preview time)
    ioWriter.writeUint32(0);
    // reserved (preview duration)
    ioWriter.writeUint32(0);
    // reserved (poster time)
    ioWriter.writeUint32(0);
    // reserved (selection time)
    ioWriter.writeUint32(0);
    // reserved (selection time)
    ioWriter.writeUint32(0);
    // reserved (current time)
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(nextTrackId);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/pasp.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/pasp.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 pasp box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(16);
    // tag
    ioWriter.writeString("pasp" /* BoxType.PASP */);
    ioWriter.writeUint32(1);
    ioWriter.writeUint32(1);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/smhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/smhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 smhd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(16);
    // tag
    ioWriter.writeString("smhd" /* BoxType.SMHD */);
    // version & flags
    ioWriter.writeUint32(0);
    // reserved (balance, normally = 0
    ioWriter.writeUint16(0);
    // reserved
    ioWriter.writeUint16(0);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stco.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stco.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 stco box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const context = stream.privData;
    const chunkOffsets = context.chunkOffsets || [];
    // size
    ioWriter.writeUint32(16 + chunkOffsets.length * 4);
    // tag
    ioWriter.writeString("stco" /* BoxType.STCO */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(chunkOffsets.length);
    for (let i = 0; i < chunkOffsets.length; i++) {
        ioWriter.writeUint32(Number(chunkOffsets[i]));
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stsc.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stsc.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avformat\\formats\\mov\\writing\\stsc.ts";

function write(ioWriter, stream, movContext) {
    const context = stream.privData;
    const firstChunk = context.stscFirstChunk;
    const samplesPerChunk = context.stscSamplesPerChunk;
    const sampleDescriptionIndex = context.stscSampleDescriptionIndex;
    if (firstChunk.length !== samplesPerChunk.length
        || firstChunk.length !== sampleDescriptionIndex.length) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('ctts firstChunk\'s length is not match samplesPerChunk\'s length or sampleDescriptionIndex\'s length', cheap__fileName__0, 42);
    }
    const entryCount = Math.min(firstChunk.length, samplesPerChunk.length, sampleDescriptionIndex.length);
    // size
    ioWriter.writeUint32(16 + entryCount * 12);
    // tag
    ioWriter.writeString("stsc" /* BoxType.STSC */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(entryCount);
    for (let i = 0; i < entryCount; i++) {
        ioWriter.writeUint32(firstChunk[i]);
        ioWriter.writeUint32(samplesPerChunk[i]);
        ioWriter.writeUint32(sampleDescriptionIndex[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stsd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stsd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var _avcc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./avcc */ "./src/avformat/formats/mov/writing/avcc.ts");
/* harmony import */ var _hvcc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hvcc */ "./src/avformat/formats/mov/writing/hvcc.ts");
/* harmony import */ var _vvcc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vvcc */ "./src/avformat/formats/mov/writing/vvcc.ts");
/* harmony import */ var _vpcc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vpcc */ "./src/avformat/formats/mov/writing/vpcc.ts");
/* harmony import */ var _av1c__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./av1c */ "./src/avformat/formats/mov/writing/av1c.ts");
/* harmony import */ var _dfla__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dfla */ "./src/avformat/formats/mov/writing/dfla.ts");
/* harmony import */ var _dops__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dops */ "./src/avformat/formats/mov/writing/dops.ts");
/* harmony import */ var _esds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./esds */ "./src/avformat/formats/mov/writing/esds.ts");
/* harmony import */ var _colr__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./colr */ "./src/avformat/formats/mov/writing/colr.ts");
/* harmony import */ var _pasp__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./pasp */ "./src/avformat/formats/mov/writing/pasp.ts");
/* harmony import */ var _btrt__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./btrt */ "./src/avformat/formats/mov/writing/btrt.ts");
/* harmony import */ var _wave__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./wave */ "./src/avformat/formats/mov/writing/wave.ts");
/* harmony import */ var _dac3__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./dac3 */ "./src/avformat/formats/mov/writing/dac3.ts");
/* harmony import */ var _dec3__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dec3 */ "./src/avformat/formats/mov/writing/dec3.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _function_digital2Tag__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../../function/digital2Tag */ "./src/avformat/function/digital2Tag.ts");
/*
 * libmedia mp4 stsd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
















const AVCodecID2Tag = {
    [27 /* AVCodecID.AV_CODEC_ID_H264 */]: "avc1" /* BoxType.AVC1 */,
    [173 /* AVCodecID.AV_CODEC_ID_HEVC */]: "hvc1" /* BoxType.HVC1 */,
    [196 /* AVCodecID.AV_CODEC_ID_VVC */]: "vvc1" /* BoxType.VVC1 */,
    [225 /* AVCodecID.AV_CODEC_ID_AV1 */]: "av01" /* BoxType.AV01 */,
    [167 /* AVCodecID.AV_CODEC_ID_VP9 */]: "vp09" /* BoxType.VP09 */,
    [86019 /* AVCodecID.AV_CODEC_ID_AC3 */]: "ac-3" /* BoxType.AC_3 */,
    [86056 /* AVCodecID.AV_CODEC_ID_EAC3 */]: "ec-3" /* BoxType.EC_3 */,
};
function getTag(codecpar) {
    if (codecpar.codecTag) {
        return (0,_function_digital2Tag__WEBPACK_IMPORTED_MODULE_15__["default"])(codecpar.codecTag);
    }
    let tag = AVCodecID2Tag[codecpar.codecId];
    if (!tag) {
        if (codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
            tag = "mp4v" /* BoxType.MP4V */;
        }
        else if (codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
            if (codecpar.codecId === 86076 /* AVCodecID.AV_CODEC_ID_OPUS */) {
                tag = "Opus" /* BoxType.OPUS */;
            }
            else if (codecpar.codecId === 86028 /* AVCodecID.AV_CODEC_ID_FLAC */) {
                tag = "fLaC" /* BoxType.FLAC */;
            }
            else {
                tag = "mp4a" /* BoxType.MP4A */;
            }
        }
        else if (codecpar.codecType === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */) {
            tag = "text" /* BoxType.TEXT */;
        }
        else {
            tag = "none" /* BoxType.NONE */;
        }
    }
    return tag;
}
function writeAudioTag(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    const tag = getTag(stream.codecpar);
    const version = movContext.isom ? 1 : 0;
    // size
    ioWriter.writeUint32(0);
    ioWriter.writeString(tag);
    // Reserved
    ioWriter.writeUint32(0);
    // Reserved
    ioWriter.writeUint16(0);
    // Data-reference index
    ioWriter.writeUint16(1);
    // SoundDescription Version
    ioWriter.writeUint16(version);
    // SoundDescription Revision level
    ioWriter.writeUint16(0);
    // Reserved
    ioWriter.writeUint32(0);
    if (movContext.isom) {
        ioWriter.writeUint16(stream.codecpar.chLayout.nbChannels);
        if (stream.codecpar.codecId === 65541 /* AVCodecID.AV_CODEC_ID_PCM_U8 */
            || stream.codecpar.codecId === 65540 /* AVCodecID.AV_CODEC_ID_PCM_S8 */) {
            ioWriter.writeUint16(8);
        }
        else if (stream.codecpar.codecId === 69643 /* AVCodecID.AV_CODEC_ID_ADPCM_G726 */) {
            ioWriter.writeUint16(stream.codecpar.bitsPerCodedSample);
        }
        else {
            ioWriter.writeUint16(16);
        }
        ioWriter.writeUint16(-2);
    }
    else {
        if (stream.codecpar.codecId === 86028 /* AVCodecID.AV_CODEC_ID_FLAC */
            || stream.codecpar.codecId === 86032 /* AVCodecID.AV_CODEC_ID_ALAC */
            || stream.codecpar.codecId === 86076 /* AVCodecID.AV_CODEC_ID_OPUS */) {
            ioWriter.writeUint16(stream.codecpar.chLayout.nbChannels);
        }
        else {
            ioWriter.writeUint16(2);
        }
        if (stream.codecpar.codecId === 86028 /* AVCodecID.AV_CODEC_ID_FLAC */
            || stream.codecpar.codecId === 86032 /* AVCodecID.AV_CODEC_ID_ALAC */) {
            ioWriter.writeUint16(stream.codecpar.bitsPerCodedSample);
        }
        else {
            ioWriter.writeUint16(16);
        }
        ioWriter.writeUint16(0);
    }
    // packet size (= 0) 
    ioWriter.writeUint16(0);
    if (stream.codecpar.codecId === 86076 /* AVCodecID.AV_CODEC_ID_OPUS */) {
        ioWriter.writeUint16(48000);
    }
    else if (stream.codecpar.codecId === 86060 /* AVCodecID.AV_CODEC_ID_TRUEHD */) {
        ioWriter.writeUint32(stream.codecpar.sampleRate);
    }
    else {
        ioWriter.writeUint16(stream.codecpar.sampleRate);
    }
    if (stream.codecpar.codecId !== 86060 /* AVCodecID.AV_CODEC_ID_TRUEHD */) {
        // Reserved
        ioWriter.writeUint16(0);
    }
    // SoundDescription V1 extended info
    if (version === 1) {
        // Samples per packet
        ioWriter.writeUint32(stream.codecpar.frameSize);
        // Bytes per packet
        ioWriter.writeUint32(0);
        // Bytes per frame
        ioWriter.writeUint32(0);
        // Bytes per sample
        ioWriter.writeUint32(2);
    }
    if (movContext.isom
        && (stream.codecpar.codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */
            || stream.codecpar.codecId === 86019 /* AVCodecID.AV_CODEC_ID_AC3 */
            || stream.codecpar.codecId === 86056 /* AVCodecID.AV_CODEC_ID_EAC3 */
            || stream.codecpar.codecId === 73728 /* AVCodecID.AV_CODEC_ID_AMR_NB */
            || stream.codecpar.codecId === 86032 /* AVCodecID.AV_CODEC_ID_ALAC */
            || stream.codecpar.codecId === 69638 /* AVCodecID.AV_CODEC_ID_ADPCM_MS */
            || stream.codecpar.codecId === 69633 /* AVCodecID.AV_CODEC_ID_ADPCM_IMA_WAV */
            || stream.codecpar.codecId === 86035 /* AVCodecID.AV_CODEC_ID_QDM2 */)) {
        (0,_wave__WEBPACK_IMPORTED_MODULE_11__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 86028 /* AVCodecID.AV_CODEC_ID_FLAC */) {
        (0,_dfla__WEBPACK_IMPORTED_MODULE_5__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 86076 /* AVCodecID.AV_CODEC_ID_OPUS */) {
        (0,_dops__WEBPACK_IMPORTED_MODULE_6__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 86019 /* AVCodecID.AV_CODEC_ID_AC3 */) {
        (0,_dac3__WEBPACK_IMPORTED_MODULE_12__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 86056 /* AVCodecID.AV_CODEC_ID_EAC3 */) {
        (0,_dec3__WEBPACK_IMPORTED_MODULE_13__["default"])(ioWriter, stream, movContext);
    }
    else if (tag == "mp4a" /* BoxType.MP4A */) {
        (0,_esds__WEBPACK_IMPORTED_MODULE_7__["default"])(ioWriter, stream, movContext);
    }
    if (!movContext.isom) {
        (0,_btrt__WEBPACK_IMPORTED_MODULE_10__["default"])(ioWriter, stream, movContext);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: tag,
        size: Number(ioWriter.getPos() - pos)
    });
}
function writeVideoTag(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    const tag = getTag(stream.codecpar);
    const uncompressedYcbcr = ((stream.codecpar.codecId == 13 /* AVCodecID.AV_CODEC_ID_RAWVIDEO */
        && stream.codecpar.format == 15 /* AVPixelFormat.AV_PIX_FMT_UYVY422 */)
        || (stream.codecpar.codecId == 13 /* AVCodecID.AV_CODEC_ID_RAWVIDEO */
            && stream.codecpar.format == 1 /* AVPixelFormat.AV_PIX_FMT_YUYV422 */)
        || stream.codecpar.codecId == 202 /* AVCodecID.AV_CODEC_ID_V308 */
        || stream.codecpar.codecId == 203 /* AVCodecID.AV_CODEC_ID_V408 */
        || stream.codecpar.codecId == 156 /* AVCodecID.AV_CODEC_ID_V410 */
        || stream.codecpar.codecId == 127 /* AVCodecID.AV_CODEC_ID_V210 */);
    // size
    ioWriter.writeUint32(0);
    ioWriter.writeString(tag);
    // Reserved
    ioWriter.writeUint32(0);
    // Reserved
    ioWriter.writeUint16(0);
    // Data-reference index
    ioWriter.writeUint16(1);
    // Codec stream version
    ioWriter.writeUint16(uncompressedYcbcr ? 2 : 0);
    // Codec stream revision (=0)
    ioWriter.writeUint16(0);
    // Reserved
    if (movContext.isom) {
        ioWriter.writeString('FFMP');
        if (stream.codecpar.codecId === 13 /* AVCodecID.AV_CODEC_ID_RAWVIDEO */ || uncompressedYcbcr) {
            /* Temporal Quality */
            ioWriter.writeUint32(0);
            /* Spatial Quality = lossless*/
            ioWriter.writeUint32(0x400);
        }
        else {
            /* Temporal Quality = normal */
            ioWriter.writeUint32(0x200);
            /* Spatial Quality = normal */
            ioWriter.writeUint32(0x200);
        }
    }
    else {
        ioWriter.writeUint32(0);
        ioWriter.writeUint32(0);
        ioWriter.writeUint32(0);
    }
    ioWriter.writeUint16(stream.codecpar.width);
    ioWriter.writeUint16(stream.codecpar.height);
    // Horizontal resolution 72dpi
    ioWriter.writeUint32(0x00480000);
    // Vertical resolution 72dpi
    ioWriter.writeUint32(0x00480000);
    // Data size (= 0)
    ioWriter.writeUint32(0);
    // Frame count (= 1)
    ioWriter.writeUint16(1);
    let compressorName = (stream.metadata['compressorName'] || '');
    compressorName = compressorName.slice(0, 31);
    ioWriter.writeUint8(compressorName.length);
    ioWriter.writeString(compressorName);
    if (compressorName.length < 31) {
        let len = 31 - compressorName.length;
        while (len > 0) {
            ioWriter.writeUint8(0);
            len--;
        }
    }
    // Reserved
    if (movContext.isom && stream.codecpar.bitsPerCodedSample) {
        ioWriter.writeUint16(stream.codecpar.bitsPerCodedSample);
    }
    else {
        ioWriter.writeUint16(0x18);
    }
    ioWriter.writeUint16(0xffff);
    if (tag === "mp4v" /* BoxType.MP4V */) {
        (0,_esds__WEBPACK_IMPORTED_MODULE_7__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */) {
        (0,_avcc__WEBPACK_IMPORTED_MODULE_0__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */) {
        (0,_hvcc__WEBPACK_IMPORTED_MODULE_1__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 196 /* AVCodecID.AV_CODEC_ID_VVC */) {
        (0,_vvcc__WEBPACK_IMPORTED_MODULE_2__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 167 /* AVCodecID.AV_CODEC_ID_VP9 */) {
        (0,_vpcc__WEBPACK_IMPORTED_MODULE_3__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
        (0,_av1c__WEBPACK_IMPORTED_MODULE_4__["default"])(ioWriter, stream, movContext);
    }
    (0,_colr__WEBPACK_IMPORTED_MODULE_8__["default"])(ioWriter, stream, movContext);
    (0,_pasp__WEBPACK_IMPORTED_MODULE_9__["default"])(ioWriter, stream, movContext);
    if (!movContext.isom) {
        (0,_btrt__WEBPACK_IMPORTED_MODULE_10__["default"])(ioWriter, stream, movContext);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: tag,
        size: Number(ioWriter.getPos() - pos)
    });
}
function writeSubtitleTag(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    const tag = getTag(stream.codecpar);
    // size
    ioWriter.writeUint32(0);
    ioWriter.writeString(tag);
    // Reserved
    ioWriter.writeUint32(0);
    // Reserved
    ioWriter.writeUint16(0);
    // Data-reference index
    ioWriter.writeUint16(1);
    if (stream.codecpar.codecId === 94208 /* AVCodecID.AV_CODEC_ID_DVD_SUBTITLE */) {
        (0,_esds__WEBPACK_IMPORTED_MODULE_7__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.extradata) {
        ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_14__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
    }
    if (!movContext.isom) {
        (0,_btrt__WEBPACK_IMPORTED_MODULE_10__["default"])(ioWriter, stream, movContext);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: tag,
        size: Number(ioWriter.getPos() - pos)
    });
}
function write(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("stsd" /* BoxType.STSD */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    // entry count
    ioWriter.writeUint32(1);
    if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
        writeAudioTag(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
        writeVideoTag(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecType === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */) {
        writeSubtitleTag(ioWriter, stream, movContext);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: "esds" /* BoxType.ESDS */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stss.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stss.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 stss box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const sampleNumbers = stream.privData.stssSampleNumbers;
    // size
    ioWriter.writeUint32(16 + sampleNumbers.length * 4);
    // tag
    ioWriter.writeString("stss" /* BoxType.STSS */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(sampleNumbers.length);
    for (let i = 0; i < sampleNumbers.length; i++) {
        ioWriter.writeUint32(sampleNumbers[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stsz.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stsz.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 stsz box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const sampleSizes = stream.privData.sampleSizes;
    // size
    ioWriter.writeUint32(20 + sampleSizes.length * 4);
    // tag
    ioWriter.writeString("stsz" /* BoxType.STSZ */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(sampleSizes.length);
    for (let i = 0; i < sampleSizes.length; i++) {
        ioWriter.writeUint32(sampleSizes[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stts.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stts.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avformat\\formats\\mov\\writing\\stts.ts";

function write(ioWriter, stream, movContext) {
    const context = stream.privData;
    const sampleCounts = context.sttsSampleCounts || [];
    const sampleDeltas = context.sttsSampleDeltas || [];
    if (sampleCounts.length !== sampleDeltas.length) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('stts sampleCounts\'s length is not match sampleDeltas\'s length', cheap__fileName__0, 39);
    }
    const entryCount = Math.min(sampleCounts.length, sampleDeltas.length);
    // size
    ioWriter.writeUint32(16 + entryCount * 8);
    // tag
    ioWriter.writeString("stts" /* BoxType.STTS */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(entryCount);
    for (let i = 0; i < entryCount; i++) {
        ioWriter.writeUint32(sampleCounts[i]);
        ioWriter.writeInt32(sampleDeltas[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/tfdt.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/tfdt.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 tfdt box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const track = movContext.currentFragment.tracks.find((track) => {
        return track.trackId === stream.privData.trackId;
    });
    const baseMediaDecodeTime = track ? track.baseMediaDecodeTime : BigInt(0);
    // size
    ioWriter.writeUint32(20);
    // tag
    ioWriter.writeString("tfdt" /* BoxType.TFDT */);
    // version use int64
    ioWriter.writeUint8(1);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint64(baseMediaDecodeTime);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/tfhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/tfhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 tfhd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const track = movContext.currentFragment.tracks.find((track) => {
        return track.trackId === stream.privData.trackId;
    });
    let flags = 1 /* TFHDFlags.BASE_DATA_OFFSET */
        | 8 /* TFHDFlags.SAMPLE_DURATION */
        | 16 /* TFHDFlags.SAMPLE_SIZE */
        | 32 /* TFHDFlags.SAMPLE_FLAGS */;
    if (track.baseIsMoof) {
        flags &= ~1 /* TFHDFlags.BASE_DATA_OFFSET */;
        flags |= 131072 /* TFHDFlags.DEFAULT_BASE_IS_MOOF */;
    }
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("tfhd" /* BoxType.TFHD */);
    // version use int64
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(flags);
    ioWriter.writeUint32(track.trackId);
    if (flags & 1 /* TFHDFlags.BASE_DATA_OFFSET */) {
        ioWriter.writeUint64(track.baseDataOffset);
    }
    if (flags & 8 /* TFHDFlags.SAMPLE_DURATION */) {
        ioWriter.writeUint32(track.defaultSampleDuration);
    }
    if (flags & 16 /* TFHDFlags.SAMPLE_SIZE */) {
        ioWriter.writeUint32(track.defaultSampleSize);
    }
    if (flags & 32 /* TFHDFlags.SAMPLE_FLAGS */) {
        ioWriter.writeUint32(track.defaultSampleFlags);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: "tfhd" /* BoxType.TFHD */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/tkhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/tkhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var _function_writeMatrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./function/writeMatrix */ "./src/avformat/formats/mov/writing/function/writeMatrix.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/*
 * libmedia mp4 tkhd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function write(ioWriter, stream, movContext) {
    const streamContext = stream.privData;
    const duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(streamContext.lastPts, stream.timeBase, {
        den: movContext.timescale,
        num: 1
    });
    const creationTime = stream.metadata['creationTime'] || 0;
    const modificationTime = stream.metadata['modificationTime'] || 0;
    const layer = streamContext.layer || 0;
    const alternateGroup = streamContext.alternateGroup || 0;
    let width = stream.codecpar.width > 0 ? stream.codecpar.width : 0;
    let height = stream.codecpar.height > 0 ? stream.codecpar.height : 0;
    if (width < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT16_MAX) {
        width = width << 16;
    }
    if (height < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT16_MAX) {
        height = height << 16;
    }
    let version = duration < BigInt(avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX) ? 0 : 1;
    version = creationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    version = modificationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    let flags = 2 /* TKHDFlags.IN_MOVIE */;
    if (streamContext.flags & 1 /* TKHDFlags.ENABLED */) {
        flags |= 1 /* TKHDFlags.ENABLED */;
    }
    // size
    ioWriter.writeUint32(version === 1 ? 100 : 92);
    // tag
    ioWriter.writeString("tkhd" /* BoxType.TKHD */);
    // version
    ioWriter.writeUint8(version);
    // flags
    ioWriter.writeUint24(flags);
    if (version === 1) {
        ioWriter.writeUint64(creationTime);
        ioWriter.writeUint64(modificationTime);
    }
    else {
        ioWriter.writeUint32(Number(creationTime));
        ioWriter.writeUint32(Number(modificationTime));
    }
    // trackId
    ioWriter.writeUint32(streamContext.trackId);
    // reserved
    ioWriter.writeUint32(0);
    if (version === 1) {
        ioWriter.writeUint64(duration);
    }
    else {
        ioWriter.writeUint32(Number(duration));
    }
    // reserved
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
    ioWriter.writeInt16(layer);
    ioWriter.writeInt16(streamContext.perStreamGrouping ? alternateGroup : stream.codecpar.codecType);
    if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
        ioWriter.writeInt16(0x0100);
    }
    else {
        ioWriter.writeInt16(0);
    }
    // reserved
    ioWriter.writeInt16(0);
    (0,_function_writeMatrix__WEBPACK_IMPORTED_MODULE_1__["default"])(ioWriter, 1, 0, 0, 1, 0, 0);
    ioWriter.writeUint32(width);
    ioWriter.writeUint32(height);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/trex.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/trex.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 trex box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const track = movContext.currentFragment.tracks.find((track) => {
        return track.trackId === stream.privData.trackId;
    });
    const trex = movContext.trexs.find((trex) => {
        trex.trackId === stream.privData.trackId;
    });
    const duration = trex?.duration ?? 0;
    const size = trex?.size ?? 0;
    const flags = trex?.flags ?? 0;
    // size
    ioWriter.writeUint32(32);
    // tag
    ioWriter.writeString("trex" /* BoxType.TREX */);
    // version use int64
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(track.trackId);
    // default_sample_description_index
    ioWriter.writeUint32(1);
    ioWriter.writeUint32(duration);
    ioWriter.writeUint32(size);
    ioWriter.writeUint32(flags);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/trun.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/trun.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 trun box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const streamContext = stream.privData;
    const track = movContext.currentFragment.tracks.find((track) => {
        return track.trackId === streamContext.trackId;
    });
    const firstSampleFlags = track.firstSampleFlags || 0;
    const dataOffset = track.dataOffset || 0;
    const sampleDurations = track.sampleDurations;
    const sampleSizes = track.sampleSizes;
    const sampleFlags = track.sampleFlags;
    const sampleCompositionTimeOffset = track.sampleCompositionTimeOffset;
    const sampleCount = track.sampleCount;
    const hasSampleDurations = sampleDurations.length > 0;
    const hasSampleSizes = sampleSizes.length > 0;
    const hasSampleFlags = sampleFlags.length > 0;
    const hasSampleCompositionTimeOffset = sampleCompositionTimeOffset.length > 0;
    const hasFirstFlag = firstSampleFlags !== 0;
    let flags = 1 /* TRUNFlags.DATA_OFFSET */;
    if (hasFirstFlag) {
        flags |= 4 /* TRUNFlags.FIRST_FLAG */;
    }
    if (hasSampleDurations) {
        flags |= 256 /* TRUNFlags.DURATION */;
    }
    if (hasSampleSizes) {
        flags |= 512 /* TRUNFlags.SIZE */;
    }
    if (hasSampleFlags) {
        flags |= 1024 /* TRUNFlags.FLAGS */;
    }
    if (hasSampleCompositionTimeOffset) {
        flags |= 2048 /* TRUNFlags.CTS_OFFSET */;
    }
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("trun" /* BoxType.TRUN */);
    // version use int32
    ioWriter.writeUint8(1);
    // flags
    ioWriter.writeUint24(flags);
    ioWriter.writeUint32(sampleCount);
    track.dataOffsetPos = ioWriter.getPos();
    ioWriter.writeInt32(dataOffset);
    if (hasFirstFlag) {
        ioWriter.writeUint32(firstSampleFlags);
    }
    for (let i = 0; i < sampleCount; i++) {
        if (hasSampleDurations) {
            ioWriter.writeUint32(sampleDurations[i] || 0);
        }
        if (hasSampleSizes) {
            ioWriter.writeUint32(sampleSizes[i] || 0);
        }
        if (hasSampleFlags) {
            ioWriter.writeUint32(sampleFlags[i] || 0);
        }
        if (hasSampleCompositionTimeOffset) {
            ioWriter.writeInt32(sampleCompositionTimeOffset[i] || 0);
        }
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: "trun" /* BoxType.TRUN */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/vmhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/vmhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 vmhd box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(20);
    // tag
    ioWriter.writeString("vmhd" /* BoxType.VMHD */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(1);
    // reserved (graphics mode = copy)
    ioWriter.writeUint64(BigInt(0));
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/vpcc.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/vpcc.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 vpcc box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(12 + stream.codecpar.extradataSize ?? 0);
    // tag
    ioWriter.writeString("vpcC" /* BoxType.VPCC */);
    // version
    ioWriter.writeUint8(1);
    // flags
    ioWriter.writeUint24(0);
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
        }
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/vvcc.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/vvcc.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 vvcc box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(8 + stream.codecpar.extradataSize ?? 0);
    // tag
    ioWriter.writeString("vvcC" /* BoxType.VVCC */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
        }
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/wave.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/wave.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _esds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./esds */ "./src/avformat/formats/mov/writing/esds.ts");
/*
 * libmedia mp4 wave box write
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function write(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("wave" /* BoxType.WAVE */);
    if (stream.codecpar.codecId !== 86035 /* AVCodecID.AV_CODEC_ID_QDM2 */) {
        ioWriter.writeUint32(12);
        ioWriter.writeString("frma" /* BoxType.FRMA */);
        ioWriter.writeUint32(stream.codecpar.codecTag);
    }
    if (stream.codecpar.codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */) {
        // seless atom needed by mplayer, ipod, not needed by quicktime
        ioWriter.writeUint32(12);
        ioWriter.writeString("mp4a" /* BoxType.MP4A */);
        ioWriter.writeUint32(0);
        (0,_esds__WEBPACK_IMPORTED_MODULE_1__["default"])(ioWriter, stream, movContext);
    }
    else {
        if (movContext.fragment) {
            if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
                ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
                delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
            }
            else {
                if (stream.codecpar.extradata) {
                    ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
                }
            }
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    // null tag
    ioWriter.writeUint32(8);
    ioWriter.writeUint32(0);
    movContext.boxsPositionInfo.push({
        pos,
        type: "wave" /* BoxType.WAVE */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/writers.ts":
/*!*****************************************************!*\
  !*** ./src/avformat/formats/mov/writing/writers.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stts */ "./src/avformat/formats/mov/writing/stts.ts");
/* harmony import */ var _ctts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ctts */ "./src/avformat/formats/mov/writing/ctts.ts");
/* harmony import */ var _stss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stss */ "./src/avformat/formats/mov/writing/stss.ts");
/* harmony import */ var _stsz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stsz */ "./src/avformat/formats/mov/writing/stsz.ts");
/* harmony import */ var _stsc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stsc */ "./src/avformat/formats/mov/writing/stsc.ts");
/* harmony import */ var _stco__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./stco */ "./src/avformat/formats/mov/writing/stco.ts");
/* harmony import */ var _co64__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./co64 */ "./src/avformat/formats/mov/writing/co64.ts");
/* harmony import */ var _mdhd__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mdhd */ "./src/avformat/formats/mov/writing/mdhd.ts");
/* harmony import */ var _mvhd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mvhd */ "./src/avformat/formats/mov/writing/mvhd.ts");
/* harmony import */ var _tkhd__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tkhd */ "./src/avformat/formats/mov/writing/tkhd.ts");
/* harmony import */ var _hdlr__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./hdlr */ "./src/avformat/formats/mov/writing/hdlr.ts");
/* harmony import */ var _stsd__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./stsd */ "./src/avformat/formats/mov/writing/stsd.ts");
/* harmony import */ var _vmhd__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./vmhd */ "./src/avformat/formats/mov/writing/vmhd.ts");
/* harmony import */ var _edts__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./edts */ "./src/avformat/formats/mov/writing/edts.ts");
/* harmony import */ var _smhd__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./smhd */ "./src/avformat/formats/mov/writing/smhd.ts");
/* harmony import */ var _dref__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./dref */ "./src/avformat/formats/mov/writing/dref.ts");
/* harmony import */ var _trex__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./trex */ "./src/avformat/formats/mov/writing/trex.ts");
/* harmony import */ var _mfhd__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./mfhd */ "./src/avformat/formats/mov/writing/mfhd.ts");
/* harmony import */ var _tfhd__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./tfhd */ "./src/avformat/formats/mov/writing/tfhd.ts");
/* harmony import */ var _tfdt__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./tfdt */ "./src/avformat/formats/mov/writing/tfdt.ts");
/* harmony import */ var _trun__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./trun */ "./src/avformat/formats/mov/writing/trun.ts");
/* harmony import */ var _minfHdlr__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./minfHdlr */ "./src/avformat/formats/mov/writing/minfHdlr.ts");
/*
 * libmedia mp4 box writers
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */






















const writers = {
    ["stts" /* BoxType.STTS */]: _stts__WEBPACK_IMPORTED_MODULE_0__["default"],
    ["ctts" /* BoxType.CTTS */]: _ctts__WEBPACK_IMPORTED_MODULE_1__["default"],
    ["stss" /* BoxType.STSS */]: _stss__WEBPACK_IMPORTED_MODULE_2__["default"],
    ["stsz" /* BoxType.STSZ */]: _stsz__WEBPACK_IMPORTED_MODULE_3__["default"],
    ["stsc" /* BoxType.STSC */]: _stsc__WEBPACK_IMPORTED_MODULE_4__["default"],
    ["stco" /* BoxType.STCO */]: _stco__WEBPACK_IMPORTED_MODULE_5__["default"],
    ["co64" /* BoxType.CO64 */]: _co64__WEBPACK_IMPORTED_MODULE_6__["default"],
    ["mdhd" /* BoxType.MDHD */]: _mdhd__WEBPACK_IMPORTED_MODULE_7__["default"],
    ["mvhd" /* BoxType.MVHD */]: _mvhd__WEBPACK_IMPORTED_MODULE_8__["default"],
    ["tkhd" /* BoxType.TKHD */]: _tkhd__WEBPACK_IMPORTED_MODULE_9__["default"],
    ["hdlr" /* BoxType.HDLR */]: _hdlr__WEBPACK_IMPORTED_MODULE_10__["default"],
    ["stsd" /* BoxType.STSD */]: _stsd__WEBPACK_IMPORTED_MODULE_11__["default"],
    ["vmhd" /* BoxType.VMHD */]: _vmhd__WEBPACK_IMPORTED_MODULE_12__["default"],
    ["edts" /* BoxType.EDTS */]: _edts__WEBPACK_IMPORTED_MODULE_13__["default"],
    ["smhd" /* BoxType.SMHD */]: _smhd__WEBPACK_IMPORTED_MODULE_14__["default"],
    ["dref" /* BoxType.DREF */]: _dref__WEBPACK_IMPORTED_MODULE_15__["default"],
    ["trex" /* BoxType.TREX */]: _trex__WEBPACK_IMPORTED_MODULE_16__["default"],
    ["mfhd" /* BoxType.MFHD */]: _mfhd__WEBPACK_IMPORTED_MODULE_17__["default"],
    ["tfhd" /* BoxType.TFHD */]: _tfhd__WEBPACK_IMPORTED_MODULE_18__["default"],
    ["tfdt" /* BoxType.TFDT */]: _tfdt__WEBPACK_IMPORTED_MODULE_19__["default"],
    ["trun" /* BoxType.TRUN */]: _trun__WEBPACK_IMPORTED_MODULE_20__["default"],
    ["minf_hdlr" /* BoxType.MINF_HDLR */]: _minfHdlr__WEBPACK_IMPORTED_MODULE_21__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (writers);


/***/ }),

/***/ "./src/avformat/formats/ttml/ittml.ts":
/*!********************************************!*\
  !*** ./src/avformat/formats/ttml/ittml.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parse: () => (/* binding */ parse)
/* harmony export */ });
/* harmony import */ var common_util_xml2Json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/xml2Json */ "./src/common/util/xml2Json.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_util_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/time */ "./src/common/util/time.ts");




function parse(text) {
    const xml = (0,common_util_xml2Json__WEBPACK_IMPORTED_MODULE_0__["default"])(text, {
        aloneValueName: 'context'
    });
    if (!xml.tt) {
        return {
            queue: [],
            head: {}
        };
    }
    const queue = [];
    function formatContext(list) {
        let context = '';
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(list, ((c) => {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.string(c)) {
                context += c;
            }
            else {
                if (c.context) {
                    context += `<${c.tagName}>${c.context}</${c.tagName}>`;
                }
                else {
                    context += `<${c.tagName}/>`;
                }
            }
        }));
        return context;
    }
    function add(p, start, end) {
        const pts = (0,common_util_time__WEBPACK_IMPORTED_MODULE_3__.hhColonDDColonSSDotMill2Int64)(start || p.begin);
        let context = p.context || '';
        let region = p.region || 'Default';
        if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.array(context)) {
            context = formatContext(context);
        }
        if (p.span?.context) {
            if (p.span.region) {
                region = p.span.region;
            }
            if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.string(p.span.context)) {
                context += p.span.context;
            }
            else {
                context += formatContext(p.span.context);
            }
        }
        queue.push({
            context,
            pts,
            region: region,
            duration: p.dur ? (0,common_util_time__WEBPACK_IMPORTED_MODULE_3__.hhColonDDColonSSDotMill2Int64)(p.dur) : ((0,common_util_time__WEBPACK_IMPORTED_MODULE_3__.hhColonDDColonSSDotMill2Int64)(end || p.end) - pts),
        });
    }
    function praseP(p, start, end) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.array(p)) {
            common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(p, (_) => {
                add(_, start, end);
            });
        }
        else {
            add(p, start, end);
        }
    }
    if (xml.tt.body) {
        if (xml.tt.body.div) {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.array(xml.tt.body.div)) {
                common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(xml.tt.body.div, (div) => {
                    if (div.p) {
                        praseP(div.p, div.begin, div.end);
                    }
                });
            }
            else {
                if (xml.tt.body.div.p) {
                    praseP(xml.tt.body.div.p, xml.tt.body.div.begin, xml.tt.body.end);
                }
            }
        }
    }
    return {
        queue,
        head: xml.tt.head || {}
    };
}


/***/ }),

/***/ "./src/avformat/function/arrayItemSame.ts":
/*!************************************************!*\
  !*** ./src/avformat/function/arrayItemSame.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ arrayItemSame)
/* harmony export */ });
/*
 * libmedia array item is all same
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function arrayItemSame(data, start = 0) {
    if (!data) {
        return false;
    }
    if (data.length < 2) {
        return true;
    }
    let first = data[start];
    let i = start + 1;
    for (; i < data.length; i++) {
        if (first !== data[i]) {
            break;
        }
    }
    return i === data.length;
}


/***/ }),

/***/ "./src/avformat/function/checkStreamParameters.ts":
/*!********************************************************!*\
  !*** ./src/avformat/function/checkStreamParameters.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkStreamParameters: () => (/* binding */ checkStreamParameters)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/*
 * libmedia check stream parameters
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function checkStreamParameters(context) {
    let result = true;
    common_util_array__WEBPACK_IMPORTED_MODULE_1__.each(context.streams, (stream) => {
        switch (stream.codecpar.codecType) {
            case 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */:
                if (stream.codecpar.chLayout.nbChannels === avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE
                    || stream.codecpar.sampleRate === avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE
                    || stream.codecpar.frameSize === avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE
                    || stream.codecpar.bitRate === BigInt(0)) {
                    result = false;
                }
                break;
            case 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */:
                if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avQ2D)(stream.codecpar.framerate) === 0
                    || stream.codecpar.width === avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE
                    || stream.codecpar.height === avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE
                    || stream.codecpar.bitRate === BigInt(0)) {
                    result = false;
                }
                if ((stream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */
                    || stream.codecpar.codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                    || stream.codecpar.codecId === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                    || stream.codecpar.codecId === 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */)
                    && (stream.codecpar.profile === avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE
                        || stream.codecpar.level === avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE)) {
                    result = false;
                }
                break;
        }
    });
    return result;
}


/***/ }),

/***/ "./src/avformat/function/digital2Tag.ts":
/*!**********************************************!*\
  !*** ./src/avformat/function/digital2Tag.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ digital2Tag)
/* harmony export */ });
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/*
 * libmedia number to tag string
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function digital2Tag(value, len = 4) {
    let tag = '';
    for (let i = 0; i < len; i++) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.number(value)) {
            tag = String.fromCharCode(value & 0xff) + tag;
            value >>>= 8;
        }
        else {
            tag = String.fromCharCode(Number(value & BigInt(0xff))) + tag;
            value >>= BigInt(8);
        }
    }
    return tag;
}


/***/ }),

/***/ "./src/avformat/function/mktag.ts":
/*!****************************************!*\
  !*** ./src/avformat/function/mktag.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mktag)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avformat\\function\\mktag.ts";
/*
 * libmedia string tag to uint32 in big end
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function mktag(tag) {
    if (tag.length !== 4) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.warn(`tag length is not 4, tag: ${tag}`, cheap__fileName__0, 30);
    }
    let value = 0;
    for (let i = 0; i < 4; i++) {
        value = (value << 8) | tag.charCodeAt(i);
    }
    return value;
}


/***/ }),

/***/ "./src/avformat/function/rewriteIO.ts":
/*!********************************************!*\
  !*** ./src/avformat/function/rewriteIO.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rewriteIO)
/* harmony export */ });
/*
 * libmedia rewrite value with pos
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function rewriteIO(ioWriter, pos, value, type) {
    const nowPos = ioWriter.getPos();
    const pointer = ioWriter.getPointer();
    const minPos = nowPos - BigInt(Math.floor(pointer));
    let inline = false;
    if (pos < nowPos && pos >= minPos) {
        ioWriter.seekInline(pointer + Number(pos - nowPos));
        inline = true;
    }
    else {
        ioWriter.seek(pos);
    }
    switch (type) {
        case 'uint8':
            ioWriter.writeUint8((value & 0xff));
            break;
        case 'int8':
            ioWriter.writeInt8(value);
            break;
        case 'uint16':
            ioWriter.writeUint16((value & 0xffff));
            break;
        case 'int16':
            ioWriter.writeInt16(value);
            break;
        case 'uint32':
            ioWriter.writeUint32((value >>> 0));
            break;
        case 'int32':
            ioWriter.writeInt32(value);
            break;
        case 'uint64':
            ioWriter.writeUint64(BigInt.asUintN(64, value));
            break;
        case 'int64':
            ioWriter.writeInt64(value);
            break;
        case 'float':
            ioWriter.writeFloat(value);
            break;
        case 'double':
            ioWriter.writeDouble(value);
            break;
    }
    if (inline) {
        ioWriter.seekInline(pointer);
    }
    else {
        ioWriter.seek(nowPos);
    }
}


/***/ }),

/***/ "./src/avformat/mux.ts":
/*!*****************************!*\
  !*** ./src/avformat/mux.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   flush: () => (/* binding */ flush),
/* harmony export */   open: () => (/* binding */ open),
/* harmony export */   writeAVPacket: () => (/* binding */ writeAVPacket),
/* harmony export */   writeHeader: () => (/* binding */ writeHeader),
/* harmony export */   writeTrailer: () => (/* binding */ writeTrailer)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _formats_OFormat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formats/OFormat */ "./src/avformat/formats/OFormat.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var _dump__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dump */ "./src/avformat/dump.ts");
var cheap__fileName__0 = "src\\avformat\\mux.ts";








const defaultMuxOptions = {
    paddingZero: false
};
function open(formatContext, options = {}) {
    const opts = common_util_object__WEBPACK_IMPORTED_MODULE_2__.extend({}, defaultMuxOptions, options);
    if (!formatContext.ioWriter) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_3__.fatal('need ioWriter', cheap__fileName__0, 52);
    }
    if (!formatContext.oformat) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_3__.fatal('need oformat', cheap__fileName__0, 55);
    }
    formatContext.options = opts;
    formatContext.processPrivateData = {
        first: new Map()
    };
    let supportCodecs = _formats_OFormat__WEBPACK_IMPORTED_MODULE_4__.OFormatSupportedCodecs[formatContext.oformat.type];
    if (supportCodecs) {
        for (let i = 0; i < formatContext.streams.length; i++) {
            const codecId = formatContext.streams[i].codecpar.codecId;
            if (formatContext.oformat.type === 13 /* AVFormat.WAV */) {
                if (codecId < 65536 /* AVCodecID.AV_CODEC_ID_PCM_S16LE */
                    || codecId > 69683 /* AVCodecID.AV_CODEC_ID_ADPCM_XMD */) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_3__.error(`format ${(0,_dump__WEBPACK_IMPORTED_MODULE_7__.dumpFormatName)(formatContext.oformat.type)} not support codecId ${(0,_dump__WEBPACK_IMPORTED_MODULE_7__.dumpCodecName)(formatContext.streams[i].codecpar.codecType, codecId)}`, cheap__fileName__0, 71);
                    return avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT;
                }
            }
            else if (!common_util_array__WEBPACK_IMPORTED_MODULE_5__.has(supportCodecs, codecId)) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_3__.error(`format ${(0,_dump__WEBPACK_IMPORTED_MODULE_7__.dumpFormatName)(formatContext.oformat.type)} not support codecId ${(0,_dump__WEBPACK_IMPORTED_MODULE_7__.dumpCodecName)(formatContext.streams[i].codecpar.codecType, codecId)}`, cheap__fileName__0, 76);
                return avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT;
            }
        }
    }
    return formatContext.oformat.init(formatContext);
}
function writeHeader(formatContext) {
    formatContext.oformat.writeHeader(formatContext);
    return 0;
}
function writeAVPacket(formatContext, avpacket) {
    const privateData = formatContext.processPrivateData;
    if (!privateData.first.has(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 32))) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16) > BigInt(0)) {
            privateData.first.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 32), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16));
        }
        else {
            privateData.first.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 32), BigInt(0));
        }
    }
    if (formatContext.options.paddingZero) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avpacket + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16) - privateData.first.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 32)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avpacket + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8) - privateData.first.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 32)));
    }
    return formatContext.oformat.writeAVPacket(formatContext, avpacket);
}
function writeTrailer(formatContext) {
    formatContext.oformat.writeTrailer(formatContext);
    return 0;
}
function flush(formatContext) {
    formatContext.oformat.flush(formatContext);
}


/***/ }),

/***/ "./src/avnetwork/ioLoader/FetchIOLoader.ts":
/*!*************************************************!*\
  !*** ./src/avnetwork/ioLoader/FetchIOLoader.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FetchIOLoader)
/* harmony export */ });
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var _IOLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IOLoader */ "./src/avnetwork/ioLoader/IOLoader.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avnetwork\\ioLoader\\FetchIOLoader.ts";
/*
 * libmedia fetch loader
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class FetchIOLoader extends _IOLoader__WEBPACK_IMPORTED_MODULE_1__["default"] {
    contentLength;
    receivedLength;
    info;
    range;
    startBytes;
    endBytes;
    eofIndex;
    abortController;
    reader;
    buffers;
    constructor(options = {}) {
        super(options);
    }
    async open(info, range) {
        this.info = info;
        this.range = range;
        if (!this.range.to) {
            this.range.to = -1;
        }
        this.range.from = Math.max(this.range.from, 0);
        if (this.eofIndex < 0) {
            this.eofIndex = range.to;
        }
        this.startBytes = 0;
        this.endBytes = -1;
        this.receivedLength = 0;
        this.buffers = [];
        if (this.range && !this.options.isLive) {
            this.startBytes = this.range.from ?? 0;
        }
        this.status = 1 /* IOLoaderStatus.CONNECTING */;
        if (!this.options.isLive && !this.options.disableSegment) {
            const params = {
                method: 'HEAD',
                headers: {},
                mode: 'cors',
                cache: 'default',
                referrerPolicy: 'no-referrer-when-downgrade'
            };
            if (this.info.headers) {
                common_util_object__WEBPACK_IMPORTED_MODULE_2__.each(this.info.headers, (value, key) => {
                    params.headers[key] = value;
                });
            }
            if (this.info.withCredentials) {
                params.credentials = 'include';
            }
            if (this.info.referrerPolicy) {
                params.referrerPolicy = this.info.referrerPolicy;
            }
            if (AbortController) {
                this.abortController = new AbortController();
                params.signal = this.abortController.signal;
            }
            try {
                const res = await fetch(this.info.url, params);
                if (res.ok && (res.status >= 200 && res.status <= 299)) {
                    const lengthHeader = res.headers.get('X-Content-Length') || res.headers.get('Content-Length');
                    if (lengthHeader != null) {
                        this.contentLength = parseInt(lengthHeader);
                        if (this.range.to < 0) {
                            this.eofIndex = this.contentLength + this.range.to;
                        }
                    }
                    this.endBytes = Math.min(this.startBytes + this.options.preload - 1, this.eofIndex);
                    this.status = 2 /* IOLoaderStatus.BUFFERING */;
                }
                else {
                    this.endBytes = -1;
                }
            }
            catch (error) {
                this.endBytes = -1;
            }
        }
    }
    async openReader() {
        const params = {
            method: 'GET',
            headers: {},
            mode: 'cors',
            cache: 'default',
            referrerPolicy: 'no-referrer-when-downgrade'
        };
        if (this.info.headers) {
            common_util_object__WEBPACK_IMPORTED_MODULE_2__.each(this.info.headers, (value, key) => {
                params.headers[key] = value;
            });
        }
        if (!this.options.isLive && !this.options.disableSegment) {
            params.headers['range'] = `bytes=${this.startBytes}-${this.endBytes > 0 ? this.endBytes : ''}`;
        }
        if (this.info.withCredentials) {
            params.credentials = 'include';
        }
        if (this.info.referrerPolicy) {
            params.referrerPolicy = this.info.referrerPolicy;
        }
        if (this.abortController) {
            this.abortController.abort();
        }
        if (typeof AbortController === 'function') {
            this.abortController = new AbortController();
            params.signal = this.abortController.signal;
        }
        try {
            const res = await fetch(this.info.url, params);
            if (res.ok && (res.status >= 200 && res.status <= 299)) {
                this.reader = res.body.getReader();
            }
            else {
                this.status = 3 /* IOLoaderStatus.ERROR */;
                common_util_logger__WEBPACK_IMPORTED_MODULE_3__.fatal(`FetchStreamLoader: Http code invalid, ${res.status} ${res.statusText}`, cheap__fileName__0, 189);
            }
        }
        catch (error) {
            if (this.retryCount < this.options.retryCount && (!this.options.isLive || !this.receivedLength)) {
                this.retryCount++;
                this.status = 1 /* IOLoaderStatus.CONNECTING */;
                await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_0__["default"](this.options.retryInterval);
                return this.openReader();
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_3__.fatal(`FetchStreamLoader: exception ${error.message}`, cheap__fileName__0, 202);
            }
        }
    }
    async readInterval(buffer, preLen = 0) {
        let pos = 0;
        while (this.buffers.length && pos < buffer.length) {
            const cache = this.buffers.shift();
            if (cache.length > buffer.length - pos) {
                buffer.set(cache.subarray(0, buffer.length - pos), pos);
                this.buffers.unshift(cache.subarray(buffer.length - pos));
                pos = buffer.length;
            }
            else {
                buffer.set(cache, pos);
                pos += cache.length;
            }
        }
        if (pos >= buffer.length) {
            return buffer.length + preLen;
        }
        if (this.status === 4 /* IOLoaderStatus.COMPLETE */) {
            return pos > 0 ? (pos + preLen) : (preLen > 0 ? preLen : -1048576 /* IOError.END */);
        }
        if (!this.reader) {
            await this.openReader();
        }
        const { value, done } = await this.reader.read();
        if (done) {
            if (this.contentLength !== null && (this.receivedLength + this.range.from) < this.endBytes + 1) {
                this.status = 3 /* IOLoaderStatus.ERROR */;
                common_util_logger__WEBPACK_IMPORTED_MODULE_3__.fatal('Fetch stream meet Early-EOF', cheap__fileName__0, 241);
            }
            else if (this.options.isLive || this.options.disableSegment || (this.receivedLength + this.range.from) >= this.eofIndex) {
                this.status = 4 /* IOLoaderStatus.COMPLETE */;
                this.startBytes = 0;
                return pos > 0 ? (pos + preLen) : (preLen > 0 ? preLen : -1048576 /* IOError.END */);
            }
            else {
                await this.reader.cancel();
                if (this.abortController) {
                    this.abortController.abort();
                }
                this.reader = null;
                this.startBytes = this.endBytes + 1;
                this.endBytes = Math.min(this.startBytes + this.options.preload - 1, this.eofIndex);
                return this.readInterval(buffer.subarray(pos), pos);
            }
        }
        else {
            this.receivedLength += value.length;
            if (value.length > buffer.length - pos) {
                buffer.set(value.subarray(0, buffer.length - pos), pos);
                this.buffers.push(value.subarray(buffer.length - pos));
                return buffer.length + preLen;
            }
            else {
                buffer.set(value, pos);
                pos += value.length;
                return pos + preLen;
            }
        }
    }
    async read(buffer) {
        return this.readInterval(buffer);
    }
    async seek(pos) {
        await this.abort();
        this.receivedLength = Number(pos) - this.range.from;
        this.startBytes = Number(pos);
        if (!this.options.disableSegment) {
            this.endBytes = Math.min(this.startBytes + this.options.preload, this.eofIndex);
        }
        this.buffers.length = 0;
        if (this.status === 4 /* IOLoaderStatus.COMPLETE */) {
            this.status = 2 /* IOLoaderStatus.BUFFERING */;
        }
    }
    async size() {
        if (this.options.isLive) {
            return BigInt(0);
        }
        return BigInt(Math.floor(this.contentLength || 0));
    }
    async abort() {
        if (!this.reader) {
            return;
        }
        await this.reader.cancel();
        if (this.abortController) {
            this.abortController.abort();
        }
        this.reader = null;
    }
    async stop() {
        await this.abort();
        this.status = 0 /* IOLoaderStatus.IDLE */;
    }
}


/***/ }),

/***/ "./src/avnetwork/ioLoader/FileIOLoader.ts":
/*!************************************************!*\
  !*** ./src/avnetwork/ioLoader/FileIOLoader.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FileIOLoader)
/* harmony export */ });
/* harmony import */ var _IOLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IOLoader */ "./src/avnetwork/ioLoader/IOLoader.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/*
 * libmedia file loader
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class FileIOLoader extends _IOLoader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    info;
    range;
    readPos;
    endPos;
    reader;
    readerResolve;
    async open(info, range) {
        this.info = info;
        this.range = range;
        this.readPos = 0;
        this.endPos = this.info.file.size;
        if (range.from > 0) {
            this.readPos = range.from;
        }
        if (range.to > 0) {
            this.endPos = range.to;
        }
        this.status = 2 /* IOLoaderStatus.BUFFERING */;
    }
    async readBufferByReader(len) {
        if (!this.reader) {
            this.reader = new FileReader();
            this.reader.onloadend = (event) => {
                if (this.readerResolve) {
                    this.readerResolve(event.target.result);
                }
            };
        }
        const blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;
        return new Promise((resolve) => {
            this.readerResolve = resolve;
            this.reader.readAsArrayBuffer(blobSlice.call(this.info.file, this.readPos, this.readPos + len));
        });
    }
    async read(buffer) {
        if (this.readPos >= this.endPos) {
            this.status === 4 /* IOLoaderStatus.COMPLETE */;
            return -1048576 /* IOError.END */;
        }
        const len = Math.min(buffer.length, this.endPos - this.readPos);
        if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.func(Blob.prototype.arrayBuffer)) {
            buffer.set(new Uint8Array(await (this.info.file.slice(this.readPos, this.readPos + len).arrayBuffer())), 0);
        }
        else {
            buffer.set(new Uint8Array(await this.readBufferByReader(len)), 0);
        }
        this.readPos += len;
        if (this.readPos >= this.endPos) {
            this.status = 4 /* IOLoaderStatus.COMPLETE */;
        }
        return len;
    }
    async seek(pos) {
        await this.abort();
        this.readPos = Number(pos);
        if (this.status === 4 /* IOLoaderStatus.COMPLETE */) {
            this.status = 2 /* IOLoaderStatus.BUFFERING */;
        }
        return 0;
    }
    async size() {
        return BigInt(Math.floor(this.info.file.size));
    }
    async abort() {
    }
    async stop() {
        await this.abort();
        this.status = 0 /* IOLoaderStatus.IDLE */;
    }
}


/***/ }),

/***/ "./src/avnetwork/ioLoader/IOLoader.ts":
/*!********************************************!*\
  !*** ./src/avnetwork/ioLoader/IOLoader.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOLoader)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/*
 * libmedia abstract loader
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const optionsDefault = {
    isLive: true,
    preload: 5242880,
    retryCount: 20,
    retryInterval: 1
};
class IOLoader {
    options;
    status;
    retryCount;
    retryTimeout;
    constructor(options = {}) {
        this.options = options;
        this.status = 0 /* IOLoaderStatus.IDLE */;
        this.retryCount = 0;
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend({}, optionsDefault);
        common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend(this.options, options);
    }
}


/***/ }),

/***/ "./src/avpipeline/AudioDecodePipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/AudioDecodePipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioDecodePipeline)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\cheap\std\collection\List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avcodec_wasmcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avcodec/wasmcodec/AudioDecoder */ "./src/avcodec/wasmcodec/AudioDecoder.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var avcodec_webcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avcodec/webcodec/AudioDecoder */ "./src/avcodec/webcodec/AudioDecoder.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var avutil_function_audioData2AVFrame__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/function/audioData2AVFrame */ "./src/avutil/function/audioData2AVFrame.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
var cheap__fileName__0 = "src\\avpipeline\\AudioDecodePipeline.ts";





/*
 * libmedia AudioDecodePipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */















class AudioDecodePipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor() {
        super();
    }
    createWebcodecDecoder(task) {
        return new avcodec_webcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_11__["default"]({
            onError: (error) => {
                common_util_logger__WEBPACK_IMPORTED_MODULE_9__.error(`audio decode error, taskId: ${task.taskId}, error: ${error}`, cheap__fileName__0, 86);
                if (task.openReject) {
                    task.openReject(avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                    task.openReject = null;
                }
            },
            onReceiveFrame(audioData) {
                const avframe = (0,avutil_function_audioData2AVFrame__WEBPACK_IMPORTED_MODULE_15__.audioData2AVFrame)(audioData, task.avframePool.alloc());
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avframe + 104, (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_16__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avframe + 104), avutil_constant__WEBPACK_IMPORTED_MODULE_17__.AV_TIME_BASE_Q, task.timeBase));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 124, task.timeBase.den);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 120, task.timeBase.num);
                task.frameCaches.push(avframe);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](task.stats + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.stats + 56) + BigInt(1));
                if (task.lastDecodeTimestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](task.stats + 240, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_14__["default"])() - task.lastDecodeTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 240)));
                }
                task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_14__["default"])();
                audioData.close();
            }
        });
    }
    createWasmcodecDecoder(task, resource) {
        return new avcodec_wasmcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_8__["default"]({
            resource: resource,
            onError: (error) => {
                common_util_logger__WEBPACK_IMPORTED_MODULE_9__.error(`audio decode error, taskId: ${task.taskId}, error: ${error}`, cheap__fileName__0, 117);
                if (task.openReject) {
                    task.openReject(avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                    task.openReject = null;
                }
            },
            onReceiveFrame(frame) {
                task.frameCaches.push(frame);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](task.stats + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.stats + 56) + BigInt(1));
                if (task.lastDecodeTimestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](task.stats + 240, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_14__["default"])() - task.lastDecodeTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 240)));
                }
                task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_14__["default"])();
            },
            avframePool: task.avframePool
        });
    }
    createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__["default"](options.leftPort);
        const rightIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__["default"](options.rightPort);
        const frameCaches = [];
        const avframePool = new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_10__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__["default"]), options.avframeListMutex);
        const task = {
            ...options,
            frameCaches,
            inputEnd: false,
            decoder: null,
            parameters: 0,
            lastDecodeTimestamp: 0,
            avframePool,
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_12__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__["default"]), options.avpacketListMutex),
            openReject: null
        };
        if (options.resource) {
            task.decoder = this.createWasmcodecDecoder(task, options.resource);
        }
        else {
            task.decoder = this.createWebcodecDecoder(task);
        }
        this.tasks.set(options.taskId, task);
        rightIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__.REQUEST, async (request) => {
            switch (request.method) {
                case 'pull': {
                    if (frameCaches.length) {
                        const frame = frameCaches.shift();
                        rightIPCPort.reply(request, frame);
                        break;
                    }
                    else if (!task.inputEnd) {
                        while (true) {
                            if (frameCaches.length) {
                                const frame = frameCaches.shift();
                                rightIPCPort.reply(request, frame);
                                break;
                            }
                            const avpacket = await leftIPCPort.request('pull');
                            if (avpacket === -1048576 /* IOError.END */) {
                                await task.decoder.flush();
                                task.inputEnd = true;
                                if (frameCaches.length) {
                                    const frame = frameCaches.shift();
                                    rightIPCPort.reply(request, frame);
                                    break;
                                }
                                else {
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_9__.info(`audio decoder ended, taskId: ${task.taskId}`, cheap__fileName__0, 198);
                                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                                    break;
                                }
                            }
                            else if (avpacket > 0) {
                                const ret = task.decoder.decode(avpacket, (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_16__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_17__.AV_TIME_BASE_Q));
                                task.avpacketPool.release(avpacket);
                                if (ret < 0) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](task.stats + 48, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 48) + 1);
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_9__.error(`audio decode error, taskId: ${options.taskId}, ret: ${ret}`, cheap__fileName__0, 211);
                                }
                                continue;
                            }
                            else {
                                common_util_logger__WEBPACK_IMPORTED_MODULE_9__.error(`audio decode pull avpacket error, taskId: ${options.taskId}, ret: ${avpacket}`, cheap__fileName__0, 216);
                                rightIPCPort.reply(request, avpacket);
                                break;
                            }
                        }
                        break;
                    }
                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                    break;
                }
            }
        });
        return 0;
    }
    async open(taskId, parameters, wasmDecoderOptions = {}) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.wasmDecoderOptions = wasmDecoderOptions;
            return new Promise(async (resolve, reject) => {
                task.openReject = resolve;
                try {
                    await task.decoder.open(parameters, task.wasmDecoderOptions);
                    task.parameters = parameters;
                }
                catch (error) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_9__.error(`open audio decoder failed, error: ${error}`, cheap__fileName__0, 243);
                    resolve(avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                    return;
                }
                resolve(0);
            });
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_9__.fatal('task not found', cheap__fileName__0, 250);
    }
    async reopenDecoder(taskId, parameters, resource, wasmDecoderOptions) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (wasmDecoderOptions) {
                task.wasmDecoderOptions = wasmDecoderOptions;
            }
            let decoder;
            if (resource) {
                decoder = this.createWasmcodecDecoder(task, resource);
            }
            else {
                decoder = this.createWebcodecDecoder(task);
            }
            return new Promise(async (resolve, reject) => {
                task.openReject = resolve;
                try {
                    await decoder.open(parameters);
                    task.parameters = parameters;
                    task.decoder.close();
                    task.decoder = decoder;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_9__.debug(`reopen audio decoder, taskId: ${task.taskId}`, cheap__fileName__0, 274);
                }
                catch (error) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_9__.error(`reopen audio decoder failed, error: ${error}`, cheap__fileName__0, 277);
                    resolve(avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                    return;
                }
                resolve(0);
            });
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_9__.fatal('task not found', cheap__fileName__0, 284);
    }
    async resetTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.decoder) {
                await task.decoder.flush();
            }
            common_util_array__WEBPACK_IMPORTED_MODULE_13__.each(task.frameCaches, (frame) => {
                task.avframePool.release(frame);
            });
            task.frameCaches.length = 0;
            task.inputEnd = false;
            task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_14__["default"])();
            common_util_logger__WEBPACK_IMPORTED_MODULE_9__.info(`reset audio decoder, taskId: ${task.taskId}`, cheap__fileName__0, 300);
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_6__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.rightPort.close();
            task.leftPort.close();
            task.decoder.close();
            task.frameCaches.forEach((frame) => {
                task.avframePool.release(frame);
            });
            this.tasks.delete(taskId);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/AudioRenderPipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/AudioRenderPipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioRenderPipeline)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/collection/List */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var audioresample_Resampler__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! audioresample/Resampler */ "./src/audioresample/Resampler.ts");
/* harmony import */ var avutil_struct_avpcmbuffer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! avutil/struct/avpcmbuffer */ "./src/avutil/struct/avpcmbuffer.ts");
/* harmony import */ var avutil_implement_AVPCMBufferPoolImpl__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/implement/AVPCMBufferPoolImpl */ "./src/avutil/implement/AVPCMBufferPoolImpl.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var audiostretchpitch_StretchPitcher__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! audiostretchpitch/StretchPitcher */ "./src/audiostretchpitch/StretchPitcher.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
var cheap__fileName__5 = "src\\avpipeline\\AudioRenderPipeline.ts";







/*
 * libmedia AudioRenderPipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



















class AudioRenderPipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_7__["default"] {
    avPCMBufferPool;
    avPCMBufferList;
    avPCMBufferListMutex;
    constructor() {
        super();
        this.avPCMBufferList = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_1__["default"])((_cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__["default"]));
        this.avPCMBufferListMutex = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_1__["default"])(cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_11__.Mutex);
        this.avPCMBufferPool = new avutil_implement_AVPCMBufferPoolImpl__WEBPACK_IMPORTED_MODULE_15__["default"](this.avPCMBufferList, this.avPCMBufferListMutex[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
    }
    async createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_9__["default"](options.leftPort);
        const rightIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_9__["default"](options.rightPort);
        const controlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_9__["default"](options.controlPort);
        const task = {
            ...options,
            leftIPCPort,
            rightIPCPort,
            controlIPCPort,
            resampler: null,
            stretchpitcher: new Map(),
            outPCMBuffer: null,
            waitPCMBuffer: 0,
            waitAVFrame: 0,
            waitPCMBufferPos: 0,
            frameEnded: false,
            stretchpitcherEnded: false,
            playRate: 1,
            playTempo: 1,
            playPitch: 1,
            useStretchpitcher: false,
            lastNotifyPTS: BigInt(0),
            currentPTS: avutil_constant__WEBPACK_IMPORTED_MODULE_20__.NOPTS_VALUE_BIGINT,
            firstPlayed: false,
            seeking: false,
            pausing: false,
            seekSync: null,
            receivePCMSync: null,
            paddingAVFrame: 0,
            fakePlayStartTimestamp: 0,
            fakePlaySamples: BigInt(0),
            fakePlayTimer: null,
            fakePlay: false,
            lastRenderTimestamp: 0,
            avframePool: new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_12__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__["default"]), options.avframeListMutex)
        };
        task.startPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(task.startPTS, task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q);
        for (let i = 0; i < options.playChannels; i++) {
            const stretchpitcher = new audiostretchpitch_StretchPitcher__WEBPACK_IMPORTED_MODULE_17__["default"]({
                resource: options.stretchpitcherResource
            });
            task.stretchpitcher.set(i, stretchpitcher);
            await stretchpitcher.open({
                sampleRate: options.playSampleRate,
                channels: 1
            });
            stretchpitcher.setTempo(task.playTempo);
            stretchpitcher.setPitch(task.playPitch);
            stretchpitcher.setRate(task.playRate);
        }
        const me = this;
        async function pullNewAudioFrame() {
            let audioFrame;
            if (task.paddingAVFrame) {
                audioFrame = task.paddingAVFrame;
                task.paddingAVFrame = 0;
            }
            else {
                audioFrame = await task.leftIPCPort.request('pull');
            }
            if (audioFrame === -1048576 /* IOError.END */) {
                for (let i = 0; i < task.playChannels; i++) {
                    const stretchpitcher = task.stretchpitcher.get(i);
                    stretchpitcher.flush();
                }
                common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`audio render ended, taskId: ${task.taskId}`, cheap__fileName__5, 203);
                return -1048576 /* IOError.END */;
            }
            else if (audioFrame < 0) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`pull audio frame failed, taskId: ${task.taskId}`, cheap__fileName__5, 207);
                return audioFrame;
            }
            else {
                if (task.playRate !== 1
                    || task.playTempo !== 1
                    || task.playPitch !== 1
                    || task.enableJitterBuffer) {
                    task.useStretchpitcher = true;
                }
                else {
                    task.useStretchpitcher = false;
                }
                if (!task.firstPlayed) {
                    const start = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](audioFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q);
                    task.firstPlayed = true;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`got first audio frame, pts: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](audioFrame + 104)}(${start}ms), taskId: ${task.taskId}`, cheap__fileName__5, 229);
                }
                task.currentPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](audioFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](task.stats + 72, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](task.stats + 72) + BigInt(1));
                if (task.lastRenderTimestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.stats + 244, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])() - task.lastRenderTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 244)));
                }
                task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
                let releaseAudioFrame = true;
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 152) !== task.playSampleRate
                    || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 80) !== task.playFormat
                    || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 292) !== task.playChannels) {
                    if (task.resampler) {
                        const current = task.resampler.getInputPCMParameters();
                        if (current.format !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 80) || current.sampleRate !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 152)) {
                            task.resampler.close();
                            task.resampler = null;
                        }
                    }
                    if (!task.resampler) {
                        task.resampler = new audioresample_Resampler__WEBPACK_IMPORTED_MODULE_13__["default"]({
                            resource: task.resamplerResource
                        });
                        await task.resampler.open({
                            sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 152),
                            format: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 80),
                            channels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 292)
                        }, {
                            sampleRate: task.playSampleRate,
                            format: task.playFormat,
                            channels: task.playChannels
                        });
                    }
                    let pcmBuffer = me.avPCMBufferPool.alloc();
                    let ret = task.resampler.resample(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](audioFrame + 64), pcmBuffer, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 76));
                    if (ret < 0) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`resample error, ret: ${ret}, taskId: ${task.taskId}`, cheap__fileName__5, 277);
                        return ret;
                    }
                    if (!task.useStretchpitcher) {
                        task.waitPCMBuffer = pcmBuffer;
                        task.waitPCMBufferPos = 0;
                    }
                    else {
                        for (let i = 0; i < task.playChannels; i++) {
                            const stretchpitcher = task.stretchpitcher.get(i);
                            stretchpitcher.sendSamples(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pcmBuffer) + (i * 4)), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](pcmBuffer + 8));
                        }
                        me.avPCMBufferPool.release(pcmBuffer);
                    }
                }
                else {
                    if (!task.useStretchpitcher) {
                        let pcmBuffer = me.avPCMBufferPool.alloc();
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](pcmBuffer + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 76));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](pcmBuffer + 12, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 76));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](pcmBuffer + 20, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 152));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](pcmBuffer + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 292));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[20](pcmBuffer, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](audioFrame + 64));
                        task.waitAVFrame = audioFrame;
                        task.waitPCMBuffer = pcmBuffer;
                        task.waitPCMBufferPos = 0;
                        releaseAudioFrame = false;
                    }
                    else {
                        for (let i = 0; i < task.playChannels; i++) {
                            const stretchpitcher = task.stretchpitcher.get(i);
                            stretchpitcher.sendSamples(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](audioFrame + 64) + (i * 4)), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 76));
                        }
                    }
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.stats + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 152));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.stats, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 292));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.stats + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 76));
                if (releaseAudioFrame) {
                    task.avframePool.release(audioFrame);
                }
            }
            return 0;
        }
        async function receiveToPCMBuffer(pcmBuffer) {
            let receive = 0;
            if (task.seeking) {
                await new Promise((resolve) => {
                    task.receivePCMSync = resolve;
                });
            }
            if (task.enableJitterBuffer) {
                let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 32) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 236) * 1000;
                if (buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.jitterBuffer)) {
                    me.setPlayRate(task.taskId, 1);
                }
            }
            if (task.frameEnded && task.useStretchpitcher) {
                let ret = 0;
                for (let i = 0; i < task.playChannels; i++) {
                    const stretchpitcher = task.stretchpitcher.get(i);
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pcmBuffer) + (i * 4))) {
                        ret = stretchpitcher.receiveSamples(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + (receive * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](pcmBuffer + 12) - receive);
                    }
                }
                if (receive + ret < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](pcmBuffer + 12)) {
                    task.stretchpitcherEnded = true;
                    for (let i = 0; i < task.playChannels; i++) {
                        // 将不足的置为 0 
                        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_18__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + receive, 0, (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](pcmBuffer + 12) - receive) * 4);
                    }
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](pcmBuffer + 8, receive);
                return 0;
            }
            while (receive < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](pcmBuffer + 12)) {
                let len = 0;
                if (!task.useStretchpitcher) {
                    if (task.waitPCMBuffer) {
                        len = Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.waitPCMBuffer + 8) - task.waitPCMBufferPos, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](pcmBuffer + 12) - receive);
                        if (len) {
                            for (let i = 0; i < task.playChannels; i++) {
                                (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_18__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + receive * 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](task.waitPCMBuffer) + (i * 4)) + task.waitPCMBufferPos * 4, len * 4);
                            }
                            task.waitPCMBufferPos += len;
                        }
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.waitPCMBuffer + 8) === task.waitPCMBufferPos) {
                            if (task.waitAVFrame) {
                                // data 是 avframe 的引用，这里需要置空，防止 waitPCMBuffer 释放的时候将 avframe 的内存释放了
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[20](task.waitPCMBuffer, 0);
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.waitPCMBuffer + 12, 0);
                                task.avframePool.release(task.waitAVFrame);
                                task.waitAVFrame = 0;
                            }
                            me.avPCMBufferPool.release(task.waitPCMBuffer);
                            task.waitPCMBuffer = 0;
                        }
                    }
                }
                else {
                    for (let i = 0; i < task.playChannels; i++) {
                        const stretchpitcher = task.stretchpitcher.get(i);
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pcmBuffer) + (i * 4))) {
                            len = stretchpitcher.receiveSamples(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + (receive * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](pcmBuffer + 12) - receive);
                        }
                    }
                }
                receive += len;
                if (receive < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](pcmBuffer + 12)) {
                    let ret = await pullNewAudioFrame();
                    if (ret === -1048576 /* IOError.END */) {
                        task.frameEnded = true;
                        if (task.useStretchpitcher) {
                            for (let i = 0; i < task.playChannels; i++) {
                                const stretchpitcher = task.stretchpitcher.get(i);
                                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pcmBuffer) + (i * 4))) {
                                    stretchpitcher.flush();
                                    ret = stretchpitcher.receiveSamples(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + (receive * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](pcmBuffer + 12) - receive);
                                }
                            }
                            if (receive + ret < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](pcmBuffer + 12)) {
                                task.stretchpitcherEnded = true;
                                for (let i = 0; i < task.playChannels; i++) {
                                    // 将不足的置为 0 
                                    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_18__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + receive, 0, (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](pcmBuffer + 12) - receive) * 4);
                                }
                            }
                            receive += ret;
                        }
                        break;
                    }
                    else if (ret < 0) {
                        return ret;
                    }
                }
            }
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](pcmBuffer + 8, receive);
            const latency = (((task.useStretchpitcher ? task.stretchpitcher.get(0).getLatency() : 0)
                // 双缓冲，假定后缓冲播放到中间
                + (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](pcmBuffer + 12) * 3 >>> 1)) / task.playSampleRate * 1000) >>> 0;
            const currentPts = common_util_bigint__WEBPACK_IMPORTED_MODULE_23__.max(task.currentPTS - BigInt(Math.floor(latency)), BigInt(0));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](task.stats + 312, currentPts);
            if (task.currentPTS - task.lastNotifyPTS >= BigInt(1000)) {
                task.lastNotifyPTS = task.currentPTS;
                task.controlIPCPort.notify('syncPts', {
                    pts: currentPts
                });
            }
            if (task.seekSync) {
                task.seekSync();
                task.seekSync = null;
            }
            return 0;
        }
        rightIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_9__.REQUEST, async (request) => {
            switch (request.method) {
                case 'pull': {
                    if (task.fakePlay) {
                        task.fakePlay = false;
                        if (task.fakePlayTimer) {
                            clearTimeout(task.fakePlayTimer);
                            task.fakePlayTimer = null;
                        }
                        task.fakePlaySamples = BigInt(0);
                        task.fakePlayStartTimestamp = 0;
                    }
                    if (task.frameEnded && (task.stretchpitcherEnded || !task.useStretchpitcher)) {
                        rightIPCPort.reply(request, -1048576 /* IOError.END */);
                        return;
                    }
                    const pcmBuffer = request.params.buffer;
                    const ret = await receiveToPCMBuffer(pcmBuffer);
                    rightIPCPort.reply(request, ret);
                    break;
                }
                case 'pullBuffer': {
                    if (task.fakePlay) {
                        task.fakePlay = false;
                        if (task.fakePlayTimer) {
                            clearTimeout(task.fakePlayTimer);
                            task.fakePlayTimer = null;
                        }
                        task.fakePlaySamples = BigInt(0);
                        task.fakePlayStartTimestamp = 0;
                    }
                    if (task.frameEnded && (task.stretchpitcherEnded || !task.useStretchpitcher)) {
                        rightIPCPort.reply(request, -1048576 /* IOError.END */);
                        return;
                    }
                    const nbSamples = request.params.nbSamples;
                    if (!task.outPCMBuffer || task.outPCMBuffer.maxnbSamples !== nbSamples) {
                        if (task.outPCMBuffer) {
                            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avFreep)(task.outPCMBuffer.data);
                            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avFreep)(task.outPCMBuffer[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
                            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_6__["default"])(task.outPCMBuffer);
                        }
                        task.outPCMBuffer = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_1__["default"])(avutil_struct_avpcmbuffer__WEBPACK_IMPORTED_MODULE_14__["default"]);
                        task.outPCMBuffer.data = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avMalloc)(4 * task.playChannels);
                        const data = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avMallocz)(nbSamples * 4 * task.playChannels);
                        for (let i = 0; i < task.playChannels; i++) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[20](task.outPCMBuffer.data + (i * 4), data + nbSamples * 4 * i);
                        }
                        task.outPCMBuffer.maxnbSamples = nbSamples;
                    }
                    const ret = await receiveToPCMBuffer(task.outPCMBuffer[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
                    if (ret < 0) {
                        rightIPCPort.reply(request, ret);
                        return;
                    }
                    const pcm = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_18__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](task.outPCMBuffer.data), task.outPCMBuffer.nbSamples * 4 * task.playChannels).slice();
                    rightIPCPort.reply(request, pcm.buffer, null, [pcm.buffer]);
                    break;
                }
            }
        });
        this.tasks.set(options.taskId, task);
        return 0;
    }
    checkUseStretchpitcher(task) {
        const use = task.playRate !== 1
            || task.playTempo !== 1
            || task.playPitch !== 1
            || task.enableJitterBuffer;
        if (task.useStretchpitcher && !use) {
            for (let i = 0; i < task.playChannels; i++) {
                task.stretchpitcher.get(i).flush();
            }
        }
    }
    setPlayRate(taskId, rate) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.enableJitterBuffer) {
                let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 32) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 236) * 1000;
                if (buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.jitterBuffer)) {
                    rate = 1;
                }
            }
            task.playRate = rate;
            for (let i = 0; i < task.playChannels; i++) {
                task.stretchpitcher.get(i).setRate(rate);
            }
            this.checkUseStretchpitcher(task);
        }
    }
    async setPlayTempo(taskId, tempo) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.playTempo = tempo;
            for (let i = 0; i < task.playChannels; i++) {
                task.stretchpitcher.get(i).setTempo(tempo);
            }
            this.checkUseStretchpitcher(task);
        }
    }
    setPlayPitch(taskId, pitch) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.playPitch = pitch;
            for (let i = 0; i < task.playChannels; i++) {
                task.stretchpitcher.get(i).setPitch(pitch);
            }
            this.checkUseStretchpitcher(task);
        }
    }
    async beforeSeek(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (!task.fakePlay && !task.pausing) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`wait current pull front frame before seek, taskId: ${task.taskId}`, cheap__fileName__5, 609);
                await new Promise((resolve) => {
                    task.seekSync = resolve;
                });
            }
            else {
                if (task.fakePlayTimer) {
                    clearTimeout(task.fakePlayTimer);
                    task.fakePlayTimer = null;
                }
            }
            task.seeking = true;
            if (task.stretchpitcher.size) {
                for (const key of task.stretchpitcher.keys()) {
                    task.stretchpitcher.get(key).clear();
                }
            }
            if (task.waitPCMBuffer) {
                if (task.waitAVFrame) {
                    // data 是 avframe 的引用，这里需要置空，防止 waitPCMBuffer 释放的时候将 avframe 的内存释放了
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[20](task.waitPCMBuffer, 0);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.waitPCMBuffer + 12, 0);
                    task.avframePool.release(task.waitAVFrame);
                    task.waitAVFrame = 0;
                }
                this.avPCMBufferPool.release(task.waitPCMBuffer);
                task.waitPCMBuffer = 0;
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`before seek end, taskId: ${task.taskId}`, cheap__fileName__5, 640);
        }
    }
    async syncSeekTime(taskId, timestamp, maxQueueLength) {
        const task = this.tasks.get(taskId);
        if (task) {
            let videoEnded = false;
            while (true) {
                let now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
                let videoPacketQueueLength = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 120);
                while (!videoEnded && maxQueueLength && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 120) > maxQueueLength) {
                    await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_22__["default"](0);
                    // 检查 videoPacketQueueLength 200ms 内没有变化说明 video 已经 sync 完成
                    // 否则某些条件下会卡主
                    if ((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])() - now > 200 && videoPacketQueueLength === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 120)) {
                        videoEnded = true;
                    }
                    if (videoPacketQueueLength !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 120)) {
                        videoPacketQueueLength = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 120);
                        now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
                    }
                }
                let audioFrame = await task.leftIPCPort.request('pull');
                if (audioFrame < 0) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`pull audio frame end after seek, taskId: ${taskId}`, cheap__fileName__5, 670);
                    task.frameEnded = true;
                    break;
                }
                if (timestamp < BigInt(0)) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`use the first audio frame because of the seek time${timestamp} < 0`, cheap__fileName__5, 676);
                    break;
                }
                const pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](audioFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q);
                if (pts - task.startPTS >= timestamp) {
                    task.paddingAVFrame = audioFrame;
                    task.frameEnded = false;
                    task.lastNotifyPTS = pts;
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](task.stats + 312, pts);
                    break;
                }
                else {
                    task.avframePool.release(audioFrame);
                }
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`sync seek time end, taskId: ${task.taskId}`, cheap__fileName__5, 701);
        }
    }
    async afterSeek(taskId, timestamp) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.seeking = false;
            if (task.receivePCMSync) {
                task.receivePCMSync();
                task.receivePCMSync = null;
            }
            if (!task.pausing) {
                if (task.fakePlay) {
                    task.fakePlayStartTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
                    task.fakePlaySamples = BigInt(0);
                    this.fakePlayNext(task);
                }
                task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`after seek end, taskId: ${task.taskId}`, cheap__fileName__5, 723);
        }
    }
    async restart(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.lastNotifyPTS = BigInt(0);
            task.frameEnded = false;
            task.firstPlayed = false;
            task.stretchpitcherEnded = false;
            if (task.stretchpitcher?.size) {
                for (let i = 0; i < task.playChannels; i++) {
                    task.stretchpitcher.get(i)?.clear();
                }
            }
            if (task.fakePlayTimer) {
                clearTimeout(task.fakePlayTimer);
            }
            task.fakePlaySamples = BigInt(0);
            task.fakePlayStartTimestamp = 0;
            task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`restart task, taskId: ${task.taskId}`, cheap__fileName__5, 746);
        }
    }
    async fakePlayNext(task) {
        const audioFrame = await task.leftIPCPort.request('pull');
        if (audioFrame < 0) {
            task.frameEnded = true;
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`audio fake render ended, taskId: ${task.taskId}`, cheap__fileName__5, 757);
            task.controlIPCPort.notify('ended');
            return;
        }
        if (!task.fakePlay || task.pausing) {
            task.avframePool.release(audioFrame);
            return;
        }
        let next = (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 152) * 1000) >>> 0;
        next /= (task.playRate * task.playTempo);
        const targetSamples = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])() - task.fakePlayStartTimestamp)) * BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 152) >>> 0) / BigInt(1000);
        const diff = Number(targetSamples - task.fakePlaySamples);
        next -= (diff / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 152) * 1000) >>> 0;
        task.fakePlaySamples += BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](audioFrame + 76) >>> 0);
        task.avframePool.release(audioFrame);
        task.fakePlayTimer = setTimeout(() => {
            task.fakePlayTimer = null;
            this.fakePlayNext(task);
        }, next);
    }
    async fakePlay(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.fakePlayStartTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
            task.fakePlay = true;
            task.fakePlaySamples = BigInt(0);
            this.fakePlayNext(task);
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`start fake play, taskId: ${task.taskId}`, cheap__fileName__5, 795);
        }
    }
    async pause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.pausing = true;
            if (task.fakePlay) {
                if (task.fakePlayTimer) {
                    clearTimeout(task.fakePlayTimer);
                    task.fakePlayTimer = null;
                }
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`task paused, taskId: ${task.taskId}`, cheap__fileName__5, 810);
        }
    }
    async unpause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.pausing = false;
            if (task.fakePlay) {
                task.fakePlayStartTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
                task.fakePlaySamples = BigInt(0);
                task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
                this.fakePlayNext(task);
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`task unpaused, taskId: ${task.taskId}`, cheap__fileName__5, 825);
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_8__.INVALID_OPERATE;
        }
        return await this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.resampler) {
                task.resampler.close();
            }
            if (task.stretchpitcher.size) {
                for (const key of task.stretchpitcher.keys()) {
                    task.stretchpitcher.get(key).close();
                }
                task.stretchpitcher.clear();
            }
            if (task.outPCMBuffer) {
                (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avFreep)(task.outPCMBuffer.data);
                (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avFreep)(task.outPCMBuffer[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
                (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_6__["default"])(task.outPCMBuffer);
            }
            if (task.waitPCMBuffer) {
                if (task.waitAVFrame) {
                    // data 是 avframe 的引用，这里需要置空，防止 waitPCMBuffer 释放的时候将 avframe 的内存释放了
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[20](task.waitPCMBuffer, 0);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.waitPCMBuffer + 12, 0);
                    task.avframePool.release(task.waitAVFrame);
                }
                this.avPCMBufferPool.release(task.waitPCMBuffer);
                task.waitPCMBuffer = 0;
            }
            if (task.paddingAVFrame) {
                task.avframePool.release(task.paddingAVFrame);
            }
            task.leftIPCPort.destroy();
            task.rightIPCPort.destroy();
            this.tasks.delete(taskId);
        }
    }
    async clear() {
        await super.clear();
        this.avPCMBufferList.clear((buffer) => {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buffer)) {
                (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buffer));
                (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avFreep)(buffer);
            }
        }, 20);
        (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_6__["default"])(this.avPCMBufferList);
        (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_6__["default"])(this.avPCMBufferListMutex);
    }
}


/***/ }),

/***/ "./src/avpipeline/DemuxPipeline.ts":
/*!*****************************************!*\
  !*** ./src/avpipeline/DemuxPipeline.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DemuxPipeline)
/* harmony export */ });
/* unused harmony export STREAM_INDEX_ALL */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./..\cheap\std\collection\List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avformat/AVFormatContext */ "./src/avformat/AVFormatContext.ts");
/* harmony import */ var common_io_IOReader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/io/IOReader */ "./src/common/io/IOReader.ts");
/* harmony import */ var avformat_demux__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avformat/demux */ "./src/avformat/demux.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_std_buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! cheap/std/buffer/SafeUint8Array */ "./src/cheap/std/buffer/SafeUint8Array.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/timer/LoopTask */ "./src/common/timer/LoopTask.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
var cheap__fileName__2 = "src\\avpipeline\\DemuxPipeline.ts";
























const STREAM_INDEX_ALL = -1;
class DemuxPipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_6__["default"] {
    constructor() {
        super();
    }
    async judgeFormat(ioReader, defaultFormat = -1 /* AVFormat.UNKNOWN */) {
        let signature = await ioReader.peekString(8);
        if (/^FLV/.test(signature)) {
            return 0 /* AVFormat.FLV */;
        }
        else if (/^DKIF/.test(signature)) {
            return 4 /* AVFormat.IVF */;
        }
        else if (/^ftyp/.test(signature.slice(4, 8))) {
            return 1 /* AVFormat.MP4 */;
        }
        else if (/^OggS/.test(signature)) {
            return 3 /* AVFormat.OGGS */;
        }
        else if (/^ID3/.test(signature)) {
            return 11 /* AVFormat.MP3 */;
        }
        else if (/^fLaC/.test(signature)) {
            return 14 /* AVFormat.FLAC */;
        }
        else if (/^RIFF/.test(signature)) {
            const dataType = (await ioReader.peekString(12)).slice(8);
            if (/^WAVE/.test(dataType)) {
                return 13 /* AVFormat.WAV */;
            }
        }
        else if ((await ioReader.peekUint32()) === 0x1A45DFA3) {
            return 5 /* AVFormat.MATROSKA */;
        }
        return defaultFormat;
    }
    createTask(options) {
        let leftIPCPort;
        let controlIPCPort;
        if (options.mainTaskId) {
            const mainTask = this.tasks.get(options.mainTaskId);
            leftIPCPort = mainTask.leftIPCPort;
            controlIPCPort = mainTask.controlIPCPort;
        }
        else {
            leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_8__["default"](options.leftPort);
            if (options.controlPort) {
                controlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_8__["default"](options.controlPort);
            }
        }
        const bufferLength = options.bufferLength || 1048576;
        const buf = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_12__.avMalloc)(bufferLength);
        if (!buf) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_7__.NO_MEMORY;
        }
        const buffer = new cheap_std_buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_13__["default"](buf, bufferLength);
        const ioReader = new common_io_IOReader__WEBPACK_IMPORTED_MODULE_10__["default"](bufferLength, true, buffer);
        if (!options.isLive) {
            ioReader.flags |= 1 /* IOFlags.SEEKABLE */;
        }
        if (options.flags) {
            ioReader.flags |= options.flags;
        }
        ioReader.onFlush = async (buffer) => {
            const params = {
                pointer: buffer.byteOffset,
                length: buffer.length
            };
            if (options.ioloaderOptions) {
                params.ioloaderOptions = options.ioloaderOptions;
            }
            try {
                const len = await leftIPCPort.request('read', params);
                return len;
            }
            catch (error) {
                return -1048574 /* IOError.INVALID_OPERATION */;
            }
        };
        ioReader.onSeek = async (pos) => {
            try {
                const params = {
                    pos
                };
                if (options.ioloaderOptions) {
                    params.ioloaderOptions = options.ioloaderOptions;
                }
                await leftIPCPort.request('seek', params);
                return 0;
            }
            catch (error) {
                return -1048574 /* IOError.INVALID_OPERATION */;
            }
        };
        ioReader.onSize = async () => {
            try {
                return await leftIPCPort.request('size');
            }
            catch (error) {
                return BigInt(-1048574 /* IOError.INVALID_OPERATION */);
            }
        };
        const formatContext = (0,avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_9__.createAVIFormatContext)();
        formatContext.ioReader = ioReader;
        formatContext.getDecoderResource = async (mediaType, codecId) => {
            if (!controlIPCPort) {
                return;
            }
            return controlIPCPort.request('getDecoderResource', {
                codecId,
                mediaType
            });
        };
        this.tasks.set(options.taskId, {
            ...options,
            leftIPCPort,
            rightIPCPorts: new Map(),
            controlIPCPort,
            formatContext,
            ioReader,
            buffer: buf,
            cacheAVPackets: new Map(),
            cacheRequests: new Map(),
            streamIndexFlush: new Map(),
            realFormat: -1 /* AVFormat.UNKNOWN */,
            demuxEnded: false,
            loop: null,
            gopCounter: 0,
            lastKeyFramePts: BigInt(0),
            lastAudioDts: BigInt(0),
            lastVideoDts: BigInt(0),
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_15__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_1__["default"]), options.avpacketListMutex)
        });
        return 0;
    }
    async openStream(taskId, maxProbeDuration = 3000) {
        const task = this.tasks.get(taskId);
        if (task) {
            await task.leftIPCPort.request('open');
            let format;
            try {
                format = await this.judgeFormat(task.ioReader, task.format);
                task.format = format;
            }
            catch (error) {
                return avutil_error__WEBPACK_IMPORTED_MODULE_7__.DATA_INVALID;
            }
            let iformat;
            switch (format) {
                case 0 /* AVFormat.FLV */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IFlvFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IFlvFormat */ "./src/avformat/formats/IFlvFormat.ts"))).default);
                    }
                    break;
                case 1 /* AVFormat.MP4 */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IMovFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMovFormat */ "./src/avformat/formats/IMovFormat.ts"))).default);
                    }
                    break;
                case 2 /* AVFormat.MPEGTS */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IMpegtsFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMpegtsFormat */ "./src/avformat/formats/IMpegtsFormat.ts"))).default);
                    }
                    break;
                case 4 /* AVFormat.IVF */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IIvfFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IIvfFormat */ "./src/avformat/formats/IIvfFormat.ts"))).default);
                    }
                    break;
                case 3 /* AVFormat.OGGS */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IOggsFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IOggsFormat */ "./src/avformat/formats/IOggsFormat.ts"))).default);
                    }
                    break;
                case 11 /* AVFormat.MP3 */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IMp3Format_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMp3Format */ "./src/avformat/formats/IMp3Format.ts"))).default);
                    }
                    break;
                case 5 /* AVFormat.MATROSKA */:
                case 6 /* AVFormat.WEBM */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IMatroskaFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMatroskaFormat */ "./src/avformat/formats/IMatroskaFormat.ts"))).default));
                    }
                    break;
                case 12 /* AVFormat.AAC */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IAacFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IAacFormat */ "./src/avformat/formats/IAacFormat.ts"))).default));
                    }
                    break;
                case 14 /* AVFormat.FLAC */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IFlacFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IFlacFormat */ "./src/avformat/formats/IFlacFormat.ts"))).default));
                    }
                    break;
                case 13 /* AVFormat.WAV */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IWavFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IWavFormat */ "./src/avformat/formats/IWavFormat.ts"))).default));
                    }
                    break;
                case 15 /* AVFormat.WEBVTT */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IWebVttFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IWebVttFormat */ "./src/avformat/formats/IWebVttFormat.ts"))).default));
                    }
                    break;
                case 16 /* AVFormat.SUBRIP */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_ISubRipFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/ISubRipFormat */ "./src/avformat/formats/ISubRipFormat.ts"))).default));
                    }
                    break;
                case 17 /* AVFormat.ASS */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IAssFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IAssFormat */ "./src/avformat/formats/IAssFormat.ts"))).default));
                    }
                    break;
                case 18 /* AVFormat.TTML */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_ITtmlFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/ITtmlFormat */ "./src/avformat/formats/ITtmlFormat.ts"))).default));
                    }
                    break;
                case 8 /* AVFormat.H264 */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IH264Format_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IH264Format */ "./src/avformat/formats/IH264Format.ts"))).default));
                    }
                    break;
                case 9 /* AVFormat.HEVC */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IHevcFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IHevcFormat */ "./src/avformat/formats/IHevcFormat.ts"))).default));
                    }
                    break;
                case 10 /* AVFormat.VVC */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IVvcFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IVvcFormat */ "./src/avformat/formats/IVvcFormat.ts"))).default));
                    }
                    break;
                default:
                    common_util_logger__WEBPACK_IMPORTED_MODULE_14__.error('format not support', cheap__fileName__2, 439);
                    return avutil_error__WEBPACK_IMPORTED_MODULE_7__.FORMAT_NOT_SUPPORT;
            }
            task.realFormat = format;
            task.formatContext.iformat = iformat;
            return avformat_demux__WEBPACK_IMPORTED_MODULE_11__.open(task.formatContext, {
                maxAnalyzeDuration: maxProbeDuration,
                fastOpen: task.isLive
            });
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.fatal('task not found', cheap__fileName__2, 454);
        }
    }
    async getFormat(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            return task.realFormat;
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.fatal('task not found', cheap__fileName__2, 464);
        }
    }
    async analyzeStreams(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.analyzeStreams(task.formatContext);
            const streams = [];
            for (let i = 0; i < task.formatContext.streams.length; i++) {
                const stream = task.formatContext.streams[i];
                streams.push({
                    index: stream.index,
                    id: stream.id,
                    codecpar: stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    nbFrames: stream.nbFrames,
                    metadata: stream.metadata,
                    duration: stream.duration,
                    startTime: stream.startTime,
                    disposition: stream.disposition,
                    timeBase: stream.timeBase[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]
                });
            }
            return {
                metadata: task.formatContext.metadata,
                format: task.realFormat,
                chapters: task.formatContext.chapters,
                streams
            };
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.fatal('task not found', cheap__fileName__2, 497);
        }
    }
    async connectStreamTask(taskId, streamIndex, port) {
        const task = this.tasks.get(taskId);
        if (task) {
            const ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_8__["default"](port);
            task.cacheAVPackets.set(streamIndex, []);
            ipcPort.streamIndex = streamIndex;
            ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_8__.REQUEST, async (request) => {
                switch (request.method) {
                    case 'pull': {
                        const cacheAVPackets = task.cacheAVPackets.get(ipcPort.streamIndex);
                        if (cacheAVPackets.length) {
                            const avpacket = cacheAVPackets.shift();
                            if (task.stats !== 0) {
                                if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](task.stats + 32) - 1);
                                }
                                else if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 120, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](task.stats + 120) - 1);
                                }
                            }
                            ipcPort.reply(request, avpacket);
                        }
                        else {
                            if (task.demuxEnded) {
                                ipcPort.reply(request, -1048576 /* IOError.END */);
                            }
                            else {
                                task.cacheRequests.set(ipcPort.streamIndex, request);
                                if (task.loop && task.loop.isStarted()) {
                                    task.loop.resetInterval();
                                }
                            }
                        }
                        break;
                    }
                }
            });
            task.rightIPCPorts.set(streamIndex, ipcPort);
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.debug(`connect stream ${streamIndex}, taskId: ${task.taskId}`, cheap__fileName__2, 542);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.fatal('task not found', cheap__fileName__2, 545);
        }
    }
    async changeConnectStream(taskId, newStreamIndex, oldStreamIndex, force = true) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (newStreamIndex === oldStreamIndex) {
                return;
            }
            const cache = task.cacheAVPackets.get(oldStreamIndex);
            const ipcPort = task.rightIPCPorts.get(oldStreamIndex);
            const request = task.cacheRequests.get(oldStreamIndex);
            if (!cache) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_14__.warn(`oldStreamIndex ${oldStreamIndex} not found`, cheap__fileName__2, 563);
            }
            await task.loop.stopBeforeNextTick();
            if (force) {
                common_util_array__WEBPACK_IMPORTED_MODULE_17__.each(cache, (avpacket) => {
                    task.avpacketPool.release(avpacket);
                });
                cache.length = 0;
            }
            else {
                task.streamIndexFlush.set(newStreamIndex, true);
            }
            ipcPort.streamIndex = newStreamIndex;
            task.cacheAVPackets.set(newStreamIndex, cache);
            task.rightIPCPorts.set(newStreamIndex, ipcPort);
            task.cacheAVPackets.delete(oldStreamIndex);
            task.rightIPCPorts.delete(oldStreamIndex);
            if (request) {
                task.cacheRequests.set(newStreamIndex, request);
                task.cacheRequests.delete(oldStreamIndex);
            }
            if (!force) {
                task.loop.start();
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.debug(`changed connect stream, new ${newStreamIndex}, old: ${oldStreamIndex}, force: ${force}, taskId: ${task.taskId}`, cheap__fileName__2, 595);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.fatal('task not found', cheap__fileName__2, 598);
        }
    }
    async startDemux(taskId, isLive, minQueueLength) {
        const task = this.tasks.get(taskId);
        if (task) {
            // mpegts 最小 20
            minQueueLength = Math.max(minQueueLength, task.format === 2 /* AVFormat.MPEGTS */ ? 20 : 10);
            if (task.loop) {
                task.loop.destroy();
            }
            task.loop = new common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_16__["default"](async () => {
                if (!isLive) {
                    let canDo = false;
                    task.cacheAVPackets.forEach((list, streamIndex) => {
                        const stream = task.formatContext.streams.find((stream) => {
                            return stream.index === streamIndex;
                        });
                        if (list.length < minQueueLength
                            && (stream.codecpar.codecType !== 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */
                                || task.cacheAVPackets.size === 1)) {
                            canDo = true;
                        }
                    });
                    if (!canDo) {
                        task.loop.emptyTask();
                        return;
                    }
                }
                const avpacket = task.avpacketPool.alloc();
                let ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.readAVPacket(task.formatContext, avpacket);
                if (!ret) {
                    const streamIndex = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 32);
                    if (task.stats !== 0) {
                        if (task.formatContext.streams[streamIndex].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                            && task.cacheAVPackets.has(streamIndex)) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](task.stats + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 24) + BigInt(1));
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](task.stats + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 16) + BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 28) >>> 0));
                            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 24) > 1 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16) > task.lastAudioDts) {
                                const list = task.cacheAVPackets.get(streamIndex);
                                if (list && list.length) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 236, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 72)
                                        / ((Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](list[0] + 16) & 0xffffffffn) >> 0) / list.length)));
                                }
                                else {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 236, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 72)
                                        / (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16) - task.lastAudioDts & 0xffffffffn) >> 0)));
                                }
                            }
                            task.lastAudioDts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16);
                        }
                        else if (task.formatContext.streams[streamIndex].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */
                            && task.cacheAVPackets.has(streamIndex)) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](task.stats + 112, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 112) + BigInt(1));
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](task.stats + 104, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 104) + BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 28) >>> 0));
                            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](task.stats + 176, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 176) + BigInt(1));
                                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 176) > 1 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 8) > task.lastKeyFramePts) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 96, task.gopCounter);
                                    task.gopCounter = 1;
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 92, (Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_18__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 8) - task.lastKeyFramePts, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q) & 0xffffffffn) >> 0));
                                }
                                task.lastKeyFramePts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 8);
                            }
                            else {
                                task.gopCounter++;
                            }
                            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 112) > 1 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16) > task.lastVideoDts) {
                                const list = task.cacheAVPackets.get(streamIndex);
                                if (list && list.length) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 224, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 72)
                                        / ((Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](list[0] + 16) & 0xffffffffn) >> 0) / list.length)));
                                }
                                else {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 224, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 72)
                                        / (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16) - task.lastVideoDts & 0xffffffffn) >> 0)));
                                }
                            }
                            task.lastVideoDts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16);
                        }
                    }
                    if (task.streamIndexFlush.get(streamIndex)) {
                        const stream = task.formatContext.streams.find((stream) => {
                            return stream.index === streamIndex;
                        });
                        const ele = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_21__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */);
                        if (!ele && stream && stream.codecpar.extradataSize) {
                            const data = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_12__.avMalloc)(stream.codecpar.extradataSize);
                            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_22__.memcpy)(data, stream.codecpar.extradata, stream.codecpar.extradataSize);
                            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_21__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, data, stream.codecpar.extradataSize);
                        }
                        task.streamIndexFlush.set(streamIndex, false);
                    }
                    if (task.cacheRequests.has(streamIndex)) {
                        task.rightIPCPorts.get(streamIndex).reply(task.cacheRequests.get(streamIndex), avpacket);
                        task.cacheRequests.delete(streamIndex);
                    }
                    else {
                        if (task.cacheAVPackets.has(streamIndex)) {
                            task.cacheAVPackets.get(streamIndex).push(avpacket);
                            if (task.stats !== 0) {
                                if (task.formatContext.streams[streamIndex].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](task.stats + 32) + 1);
                                }
                                else if (task.formatContext.streams[streamIndex].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 120, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](task.stats + 120) + 1);
                                }
                            }
                            if (task.formatContext.streams[streamIndex].codecpar.codecType === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */) {
                                if (task.cacheAVPackets.get(streamIndex).length > minQueueLength) {
                                    task.avpacketPool.release(task.cacheAVPackets.get(streamIndex).shift());
                                }
                            }
                        }
                        else {
                            if (task.rightIPCPorts.has(STREAM_INDEX_ALL)) {
                                if (task.cacheRequests.has(STREAM_INDEX_ALL)) {
                                    task.rightIPCPorts.get(STREAM_INDEX_ALL).reply(task.cacheRequests.get(STREAM_INDEX_ALL), avpacket);
                                    task.cacheRequests.delete(STREAM_INDEX_ALL);
                                }
                                else {
                                    task.cacheAVPackets.get(STREAM_INDEX_ALL).push(avpacket);
                                }
                            }
                            else {
                                task.avpacketPool.release(avpacket);
                            }
                        }
                    }
                }
                else {
                    task.avpacketPool.release(avpacket);
                    if (ret !== -1048576 /* IOError.END */) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_14__.error(`demux error, ret: ${ret}, taskId: ${taskId}`, cheap__fileName__2, 758);
                    }
                    task.demuxEnded = true;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_14__.info(`demuxer ended, taskId: ${task.taskId}`, cheap__fileName__2, 763);
                    for (let streamIndex of task.cacheRequests.keys()) {
                        const cacheAVPackets = task.cacheAVPackets.get(streamIndex);
                        if (!cacheAVPackets.length) {
                            task.rightIPCPorts.get(streamIndex).reply(task.cacheRequests.get(streamIndex), -1048576 /* IOError.END */);
                            task.cacheRequests.delete(streamIndex);
                        }
                    }
                    task.loop.stop();
                }
            }, 0, 0, true, false);
            task.loop.start();
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.debug(`start demux loop, taskId: ${task.taskId}`, cheap__fileName__2, 778);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.fatal('task not found', cheap__fileName__2, 781);
        }
    }
    async seek(taskId, timestamp, flags, streamIndex = -1) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.loop) {
                await task.loop.stopBeforeNextTick();
                let ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.seek(task.formatContext, streamIndex, timestamp, flags);
                if (ret >= BigInt(0)) {
                    task.cacheAVPackets.forEach((list) => {
                        common_util_array__WEBPACK_IMPORTED_MODULE_17__.each(list, (avpacket) => {
                            task.avpacketPool.release(avpacket);
                        });
                        list.length = 0;
                    });
                    if (task.stats !== 0) {
                        // 判断当前 task 处理的 stream 来重置
                        task.cacheAVPackets.forEach((list, streamIndex) => {
                            const stream = task.formatContext.streams.find((stream) => {
                                return stream.index === streamIndex;
                            });
                            if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 32, 0);
                            }
                            else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 120, 0);
                            }
                        });
                    }
                    const avpacket = task.avpacketPool.alloc();
                    while (true) {
                        ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.readAVPacket(task.formatContext, avpacket);
                        if (ret < 0 || task.cacheAVPackets.has(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 32))) {
                            break;
                        }
                    }
                    if (ret >= 0) {
                        task.demuxEnded = false;
                        const streamIndex = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 32);
                        task.cacheAVPackets.get(streamIndex).push(avpacket);
                        if (task.stats !== 0) {
                            if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](task.stats + 32) + 1);
                            }
                            else if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 120, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](task.stats + 120) + 1);
                            }
                        }
                        task.loop.start();
                        let duration = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 8);
                        if (task.formatContext.streams[streamIndex].startTime !== avutil_constant__WEBPACK_IMPORTED_MODULE_19__.NOPTS_VALUE_BIGINT) {
                            duration -= task.formatContext.streams[streamIndex].startTime;
                        }
                        else {
                            duration -= task.formatContext.streams[streamIndex].firstDTS;
                        }
                        return (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_18__.avRescaleQ)(common_util_bigint__WEBPACK_IMPORTED_MODULE_20__.max(duration, BigInt(0)), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q);
                    }
                    else {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_14__.warn(`got first packet failed after seek, taskId: ${task.taskId}`, cheap__fileName__2, 849);
                        task.avpacketPool.release(avpacket);
                        task.demuxEnded = true;
                        return timestamp;
                    }
                }
                return ret;
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_14__.info('seek before demux loop start', cheap__fileName__2, 860);
                let ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.seek(task.formatContext, -1, timestamp, flags);
                if (ret < 0) {
                    return ret;
                }
                return timestamp;
            }
        }
    }
    /**
     * 裁剪 avpacket 队列大小
     *
     * @param taskId
     * @param max （毫秒）
     */
    async croppingAVPacketQueue(taskId, max) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.cacheAVPackets.forEach((list, streamIndex) => {
                const lastDts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](list[list.length - 1] + 16);
                let i = list.length - 2;
                for (i = list.length - 2; i >= 0; i--) {
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](list[i] + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                        if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_18__.avRescaleQ)(lastDts - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](list[i] + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__["default"])(list[i] + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q) >= max) {
                            break;
                        }
                    }
                }
                if (i > 0) {
                    list.splice(0, i).forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                    if (task.stats !== 0) {
                        if (task.formatContext.streams[streamIndex].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 32, list.length);
                        }
                        else if (task.formatContext.streams[streamIndex].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 120, list.length);
                        }
                    }
                }
            });
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_7__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.loop) {
                await task.loop.stopBeforeNextTick();
                task.loop.destroy();
            }
            task.leftIPCPort.destroy();
            task.rightIPCPorts.forEach((ipcPort) => {
                ipcPort.destroy();
            });
            task.rightIPCPorts.clear();
            task.formatContext.destroy();
            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_12__.avFree)(task.buffer);
            task.cacheAVPackets.forEach((list) => {
                list.forEach((avpacket) => {
                    task.avpacketPool.release(avpacket);
                });
            });
            this.tasks.delete(taskId);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/IOPipeline.ts":
/*!**************************************!*\
  !*** ./src/avpipeline/IOPipeline.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOPipeline)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avnetwork_ioLoader_FetchIOLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avnetwork/ioLoader/FetchIOLoader */ "./src/avnetwork/ioLoader/FetchIOLoader.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avnetwork_ioLoader_FileIOLoader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avnetwork/ioLoader/FileIOLoader */ "./src/avnetwork/ioLoader/FileIOLoader.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avpipeline\\IOPipeline.ts";










class IOPipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super();
    }
    async createTask(options) {
        let ioLoader;
        switch (options.type) {
            case 0 /* IOType.Fetch */:
                ioLoader = new avnetwork_ioLoader_FetchIOLoader__WEBPACK_IMPORTED_MODULE_3__["default"](options.options);
                break;
            case 1 /* IOType.File */:
                ioLoader = new avnetwork_ioLoader_FileIOLoader__WEBPACK_IMPORTED_MODULE_7__["default"](options.options);
                break;
            case 2 /* IOType.HLS */:
                {
                    ioLoader = new (await __webpack_require__.e(/*! import() */ "src_avnetwork_ioLoader_HlsIOLoader_ts").then(__webpack_require__.bind(__webpack_require__, /*! avnetwork/ioLoader/HlsIOLoader */ "./src/avnetwork/ioLoader/HlsIOLoader.ts"))).default(options.options);
                }
                break;
            case 3 /* IOType.DASH */:
                {
                    ioLoader = new (await __webpack_require__.e(/*! import() */ "src_avnetwork_ioLoader_DashIOLoader_ts").then(__webpack_require__.bind(__webpack_require__, /*! avnetwork/ioLoader/DashIOLoader */ "./src/avnetwork/ioLoader/DashIOLoader.ts"))).default(options.options);
                }
                break;
        }
        if (!ioLoader) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_4__.INVALID_ARGUMENT;
        }
        const ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__["default"](options.rightPort);
        const task = {
            ...options,
            ioLoader,
            ipcPort
        };
        ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__.REQUEST, async (request) => {
            switch (request.method) {
                case 'open': {
                    try {
                        await ioLoader.open(options.info, options.range);
                        ipcPort.reply(request, {});
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_8__.error(`loader open error, ${error}, taskId: ${options.taskId}`, cheap__fileName__0, 118);
                        ipcPort.reply(request, null, error);
                    }
                    break;
                }
                case 'read': {
                    const pointer = request.params.pointer;
                    const length = request.params.length;
                    const ioloaderOptions = request.params.ioloaderOptions;
                    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapSafeUint8Array)(pointer, length);
                    try {
                        const len = await ioLoader.read(buffer, ioloaderOptions);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](task.stats + 192, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.stats + 192) + BigInt(len >>> 0));
                        ipcPort.reply(request, len);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_8__.error(`loader read error, ${error}, taskId: ${options.taskId}`, cheap__fileName__0, 139);
                        ipcPort.reply(request, avutil_error__WEBPACK_IMPORTED_MODULE_4__.DATA_INVALID);
                    }
                    break;
                }
                case 'seek': {
                    const pos = request.params.pos;
                    const ioloaderOptions = request.params.ioloaderOptions;
                    try {
                        await ioLoader.seek(pos, ioloaderOptions);
                        ipcPort.reply(request);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_8__.error(`loader seek error, ${error}, taskId: ${options.taskId}`, cheap__fileName__0, 157);
                        ipcPort.reply(request, null, error);
                    }
                    break;
                }
                case 'size': {
                    ipcPort.reply(request, await ioLoader.size());
                    break;
                }
            }
        });
        this.tasks.set(options.taskId, task);
        return 0;
    }
    async open(id) {
        const task = this.tasks.get(id);
        if (task) {
            await task.ioLoader.open(task.info, task.range);
            return 0;
        }
    }
    async getDuration(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 2 /* IOType.HLS */ || task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getDuration();
                }
            }
            return 0;
        }
    }
    async hasAudio(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.hasAudio();
                }
            }
            return false;
        }
    }
    async hasVideo(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.hasVideo();
                }
            }
            return false;
        }
    }
    async hasSubtitle(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.hasSubtitle();
                }
            }
            return false;
        }
    }
    async getVideoList(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getVideoList();
                }
                else if (task.type === 2 /* IOType.HLS */) {
                    return task.ioLoader.getVideoList();
                }
            }
            return {
                list: [],
                selectedIndex: 0
            };
        }
    }
    async getAudioList(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getAudioList();
                }
            }
            return {
                list: [],
                selectedIndex: 0
            };
        }
    }
    async getSubtitleList(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getSubtitleList();
                }
            }
            return {
                list: [],
                selectedIndex: 0
            };
        }
    }
    async selectVideo(taskId, index) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    task.ioLoader.selectVideo(index);
                }
                else if (task.type === 2 /* IOType.HLS */) {
                    return task.ioLoader.selectVideo(index);
                }
            }
        }
    }
    async selectAudio(taskId, index) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    task.ioLoader.selectAudio(index);
                }
            }
        }
    }
    async selectSubtitle(taskId, index) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    task.ioLoader.selectSubtitle(index);
                }
            }
        }
    }
    async getMinBuffer(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getMinBuffer();
                }
            }
            {
                if (task.type === 2 /* IOType.HLS */) {
                    return task.ioLoader.getMinBuffer();
                }
            }
            return 0;
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_4__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(id) {
        const task = this.tasks.get(id);
        if (task) {
            await task.ioLoader.stop();
            task.ipcPort.destroy();
            this.tasks.delete(id);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/Pipeline.ts":
/*!************************************!*\
  !*** ./src/avpipeline/Pipeline.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Pipeline)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/*
 * libmedia abstract Pipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class Pipeline {
    tasks;
    constructor() {
        this.tasks = new Map();
    }
    async clear() {
        if (this.tasks.size) {
            for (const key of this.tasks.keys()) {
                await this.unregisterTask(key);
            }
        }
    }
    async setLogLevel(level) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.setLevel(level);
    }
    async getTaskCount() {
        return this.tasks.size;
    }
}


/***/ }),

/***/ "./src/avpipeline/VideoDecodePipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/VideoDecodePipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoDecodePipeline)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\cheap\std\collection\List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avcodec/wasmcodec/VideoDecoder */ "./src/avcodec/wasmcodec/VideoDecoder.ts");
/* harmony import */ var avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avcodec/webcodec/VideoDecoder */ "./src/avcodec/webcodec/VideoDecoder.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");
var cheap__fileName__0 = "src\\avpipeline\\VideoDecodePipeline.ts";





/*
 * libmedia VideoDecodePipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


















class VideoDecodePipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor() {
        super();
    }
    createWebcodecDecoder(task, enableHardwareAcceleration = true) {
        return new avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__["default"]({
            onError: (error) => {
                if (task.hardwareRetryCount > 3 || !task.firstDecoded) {
                    if (task.targetDecoder === task.hardwareDecoder) {
                        task.targetDecoder = task.softwareDecoder;
                        task.hardwareDecoder.close();
                        task.hardwareDecoder = null;
                        task.decoderReady = this.openSoftwareDecoder(task);
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`video decode error width hardware(${task.hardwareRetryCount}), taskId: ${task.taskId}, error: ${error}, try to fallback to software decoder`, cheap__fileName__0, 121);
                    }
                }
                else {
                    task.hardwareRetryCount++;
                    try {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`retry open hardware decoder(${task.hardwareRetryCount}), taskId: ${task.taskId}`, cheap__fileName__0, 127);
                        task.decoderReady = task.hardwareDecoder.open(task.parameters);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`retry open hardware decoder failed, fallback to software decoder, taskId: ${task.taskId}`, cheap__fileName__0, 131);
                    }
                }
                task.needKeyFrame = true;
                task.leftIPCPort.request('requestKeyframe');
            },
            onReceiveFrame(frame) {
                task.firstDecoded = true;
                task.frameCaches.push(frame);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](task.stats + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.stats + 144) + BigInt(1));
                if (task.lastDecodeTimestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](task.stats + 248, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])() - task.lastDecodeTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 248)));
                }
                task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])();
            },
            enableHardwareAcceleration
        });
    }
    createWasmcodecDecoder(task, resource) {
        return new avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_8__["default"]({
            resource: resource,
            onError: (error) => {
                common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`video decode error, taskId: ${task.taskId}, error: ${error}`, cheap__fileName__0, 157);
                if (task.openReject) {
                    task.openReject(avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                    task.openReject = null;
                }
            },
            onReceiveFrame(frame) {
                task.firstDecoded = true;
                task.frameCaches.push(frame);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](task.stats + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.stats + 144) + BigInt(1));
                if (task.lastDecodeTimestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](task.stats + 248, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])() - task.lastDecodeTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 248)));
                }
                task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])();
            },
            avframePool: task.avframePool
        });
    }
    createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__["default"](options.leftPort);
        const rightIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__["default"](options.rightPort);
        const frameCaches = [];
        const avframePool = new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_11__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__["default"]), options.avframeListMutex);
        const task = {
            ...options,
            leftIPCPort,
            rightIPCPort,
            softwareDecoder: null,
            hardwareDecoder: null,
            frameCaches,
            inputEnd: false,
            targetDecoder: null,
            needKeyFrame: true,
            parameters: 0,
            hardwareRetryCount: 0,
            lastDecodeTimestamp: 0,
            firstDecoded: false,
            decoderReady: null,
            softwareDecoderOpened: false,
            avframePool,
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_15__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__["default"]), options.avpacketListMutex)
        };
        task.softwareDecoder = options.resource
            ? this.createWasmcodecDecoder(task, task.resource)
            : (common_util_support__WEBPACK_IMPORTED_MODULE_20__["default"].videoDecoder ? this.createWebcodecDecoder(task, false) : null);
        if (!task.softwareDecoder) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error('software decoder not support', cheap__fileName__0, 216);
            return avutil_error__WEBPACK_IMPORTED_MODULE_6__.INVALID_OPERATE;
        }
        if (common_util_support__WEBPACK_IMPORTED_MODULE_20__["default"].videoDecoder && options.enableHardware) {
            task.hardwareDecoder = this.createWebcodecDecoder(task);
        }
        task.targetDecoder = task.hardwareDecoder || task.softwareDecoder;
        this.tasks.set(options.taskId, task);
        rightIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__.REQUEST, async (request) => {
            switch (request.method) {
                case 'pull': {
                    if (frameCaches.length) {
                        const frame = frameCaches.shift();
                        rightIPCPort.reply(request, frame, null, ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_21__["default"])(frame) || common_util_is__WEBPACK_IMPORTED_MODULE_12__.number(frame)) ? null : [frame]);
                        break;
                    }
                    else if (!task.inputEnd) {
                        while (true) {
                            if (frameCaches.length) {
                                const frame = frameCaches.shift();
                                rightIPCPort.reply(request, frame, null, ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_21__["default"])(frame) || common_util_is__WEBPACK_IMPORTED_MODULE_12__.number(frame)) ? null : [frame]);
                                break;
                            }
                            if (task.decoderReady) {
                                await task.decoderReady;
                                task.decoderReady = null;
                            }
                            const avpacket = await leftIPCPort.request('pull');
                            if (avpacket === -1048576 /* IOError.END */) {
                                if (task.targetDecoder === task.hardwareDecoder) {
                                    // 硬解的 flush 有时会卡主，这里设置 2 秒超时，若超时只能丢弃还未 flush 出来的帧了
                                    let ret = await Promise.race([
                                        new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_14__["default"](2),
                                        task.targetDecoder.flush()
                                    ]);
                                    if (common_util_is__WEBPACK_IMPORTED_MODULE_12__.number(ret)) {
                                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`video hardware decoder flush failed, ignore it, taskId: ${task.taskId}`, cheap__fileName__0, 259);
                                    }
                                }
                                else {
                                    await task.targetDecoder.flush();
                                }
                                task.inputEnd = true;
                                // 等待 flush 出的帧入队
                                if (task.targetDecoder === task.hardwareDecoder) {
                                    await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_14__["default"](0);
                                }
                                if (frameCaches.length) {
                                    const frame = frameCaches.shift();
                                    rightIPCPort.reply(request, frame, null, task.targetDecoder === task.hardwareDecoder ? [frame] : null);
                                    break;
                                }
                                else {
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`video decoder ended, taskId: ${task.taskId}`, cheap__fileName__0, 276);
                                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                                    break;
                                }
                            }
                            else if (avpacket > 0) {
                                if (task.needKeyFrame) {
                                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                                        task.needKeyFrame = false;
                                    }
                                    else {
                                        task.avpacketPool.release(avpacket);
                                        continue;
                                    }
                                }
                                let ret = task.targetDecoder.decode(avpacket);
                                if (ret < 0) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](task.stats + 136, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 136) + 1);
                                    // 硬解或者 webcodecs 软解失败
                                    if ((task.targetDecoder instanceof avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__["default"]) && task.softwareDecoder) {
                                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`video decode error width hardware, taskId: ${task.taskId}, error: ${ret}, try to fallback to software decoder`, cheap__fileName__0, 303);
                                        if (task.targetDecoder === task.hardwareDecoder) {
                                            task.hardwareDecoder.close();
                                            task.hardwareDecoder = null;
                                        }
                                        else if (task.resource) {
                                            task.softwareDecoder.close();
                                            task.softwareDecoder = this.createWasmcodecDecoder(task, task.resource);
                                        }
                                        else {
                                            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`cannot fallback to wasm video decoder because of resource not found , taskId: ${options.taskId}`, cheap__fileName__0, 314);
                                            rightIPCPort.reply(request, avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                                            break;
                                        }
                                        try {
                                            await this.openSoftwareDecoder(task);
                                            task.targetDecoder = task.softwareDecoder;
                                        }
                                        catch (error) {
                                            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`video software decoder open error, taskId: ${options.taskId}`, cheap__fileName__0, 324);
                                            rightIPCPort.reply(request, avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                                            break;
                                        }
                                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                                            ret = task.targetDecoder.decode(avpacket);
                                            if (ret >= 0) {
                                                task.avpacketPool.release(avpacket);
                                                continue;
                                            }
                                            // webcodecs 软解失败，回退到 wasm 软解
                                            if ((task.targetDecoder instanceof avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__["default"]) && task.resource) {
                                                common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`video decode error width webcodecs soft decoder, taskId: ${task.taskId}, error: ${ret}, try to fallback to wasm software decoder`, cheap__fileName__0, 338);
                                                task.softwareDecoder.close();
                                                task.softwareDecoder = this.createWasmcodecDecoder(task, task.resource);
                                                task.softwareDecoderOpened = false;
                                                try {
                                                    await this.openSoftwareDecoder(task);
                                                    task.targetDecoder = task.softwareDecoder;
                                                }
                                                catch (error) {
                                                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`video wasm software decoder open error, taskId: ${options.taskId}`, cheap__fileName__0, 348);
                                                    rightIPCPort.reply(request, avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                                                    break;
                                                }
                                                ret = task.targetDecoder.decode(avpacket);
                                                if (ret >= 0) {
                                                    task.avpacketPool.release(avpacket);
                                                    continue;
                                                }
                                            }
                                        }
                                        else {
                                            task.avpacketPool.release(avpacket);
                                            task.needKeyFrame = true;
                                            task.leftIPCPort.request('requestKeyframe');
                                            continue;
                                        }
                                    }
                                    task.avpacketPool.release(avpacket);
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`video decode error, taskId: ${options.taskId}, ret: ${ret}`, cheap__fileName__0, 367);
                                    rightIPCPort.reply(request, ret);
                                    break;
                                }
                                task.avpacketPool.release(avpacket);
                                // WebVideoDecoder 队列中的 EncodedVideoChunk 过多会导致内存占用激增，这里控制一下
                                while (task.targetDecoder instanceof avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__["default"]
                                    && task.targetDecoder.getQueueLength() > 20) {
                                    await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_14__["default"](0);
                                }
                                continue;
                            }
                            else {
                                common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`video decode pull avpacket error, taskId: ${options.taskId}, ret: ${avpacket}`, cheap__fileName__0, 381);
                                rightIPCPort.reply(request, avpacket);
                                break;
                            }
                        }
                        break;
                    }
                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`video decoder ended, taskId: ${task.taskId}`, cheap__fileName__0, 388);
                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                    break;
                }
            }
        });
        return 0;
    }
    async openSoftwareDecoder(task) {
        if (task.softwareDecoder && !task.softwareDecoderOpened) {
            const parameters = task.parameters;
            let threadCount = 1;
            if ((0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_16__["default"])()) {
                let pixels = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 56) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 60);
                let framerate = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(parameters + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational));
                if (pixels >= 2073600 && pixels <= 2211840) {
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                        threadCount = 2;
                    }
                    if (framerate > 30) {
                        threadCount = 2;
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                            threadCount = 4;
                        }
                    }
                    else if (framerate > 60) {
                        threadCount = 4;
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                            threadCount = 6;
                        }
                    }
                }
                else if (pixels > 2211840 && pixels <= 8294400) {
                    threadCount = 4;
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                        threadCount = 6;
                    }
                }
                else if (pixels > 8294400) {
                    threadCount = 6;
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                        threadCount = 8;
                    }
                }
                threadCount = Math.min(threadCount, navigator.hardwareConcurrency);
            }
            try {
                await task.softwareDecoder.open(parameters, threadCount, task.wasmDecoderOptions);
            }
            catch (error) {
                if ((task.softwareDecoder instanceof avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__["default"]) && task.resource) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`webcodecs software decoder open failed, ${error}, try to fallback to wasm software decoder`, cheap__fileName__0, 459);
                    task.softwareDecoder.close();
                    task.softwareDecoder = this.createWasmcodecDecoder(task, task.resource);
                    await task.softwareDecoder.open(parameters, threadCount);
                    task.targetDecoder = task.softwareDecoder;
                }
                else {
                    throw error;
                }
            }
            task.softwareDecoderOpened = true;
        }
    }
    async reopenDecoder(taskId, parameters, resource, wasmDecoderOptions) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (wasmDecoderOptions) {
                task.wasmDecoderOptions = wasmDecoderOptions;
            }
            let softwareDecoder;
            if (task.preferWebCodecs && common_util_support__WEBPACK_IMPORTED_MODULE_20__["default"].videoDecoder && avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__["default"].isSupported(parameters, false)) {
                softwareDecoder = this.createWebcodecDecoder(task, false);
            }
            else {
                softwareDecoder = resource
                    ? this.createWasmcodecDecoder(task, resource)
                    : (common_util_support__WEBPACK_IMPORTED_MODULE_20__["default"].videoDecoder ? this.createWebcodecDecoder(task, false) : null);
            }
            let hardwareDecoder = (common_util_support__WEBPACK_IMPORTED_MODULE_20__["default"].videoDecoder && task.enableHardware)
                ? this.createWebcodecDecoder(task, true)
                : null;
            return new Promise(async (resolve, reject) => {
                task.openReject = resolve;
                if (task.softwareDecoder) {
                    task.softwareDecoder.close();
                }
                if (task.hardwareDecoder) {
                    task.hardwareDecoder.close();
                }
                task.softwareDecoder = softwareDecoder;
                task.hardwareDecoder = hardwareDecoder;
                task.targetDecoder = task.hardwareDecoder || task.softwareDecoder;
                task.hardwareRetryCount = 0;
                if (task.hardwareDecoder) {
                    try {
                        await task.hardwareDecoder.open(parameters);
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`reopen video hardware decoder, taskId: ${task.taskId}`, cheap__fileName__0, 514);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`cannot reopen hardware decoder, ${error}, taskId: ${task.taskId}`, cheap__fileName__0, 517);
                        task.hardwareDecoder.close();
                        task.hardwareDecoder = null;
                        task.targetDecoder = task.softwareDecoder;
                    }
                }
                task.parameters = parameters;
                if (task.targetDecoder === task.softwareDecoder) {
                    try {
                        await this.openSoftwareDecoder(task);
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`reopen video soft decoder, taskId: ${task.taskId}`, cheap__fileName__0, 530);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`reopen video software decoder failed, error: ${error}`, cheap__fileName__0, 533);
                        if (!task.hardwareDecoder) {
                            resolve(avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                            return;
                        }
                    }
                }
                resolve(0);
            });
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.fatal('task not found', cheap__fileName__0, 543);
    }
    async open(taskId, parameters, wasmDecoderOptions = {}) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.wasmDecoderOptions = wasmDecoderOptions;
            if (task.preferWebCodecs
                && common_util_support__WEBPACK_IMPORTED_MODULE_20__["default"].videoDecoder
                && avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__["default"].isSupported(parameters, false)
                && task.softwareDecoder instanceof avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_8__["default"]) {
                task.softwareDecoder.close();
                const softwareDecoder = this.createWebcodecDecoder(task, false);
                if (task.softwareDecoder === task.targetDecoder) {
                    task.targetDecoder = softwareDecoder;
                }
                task.softwareDecoder = softwareDecoder;
            }
            return new Promise(async (resolve, reject) => {
                task.openReject = resolve;
                if (task.hardwareDecoder) {
                    try {
                        await task.hardwareDecoder.open(parameters);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`cannot open hardware decoder, ${error}`, cheap__fileName__0, 570);
                        task.hardwareDecoder.close();
                        task.hardwareDecoder = null;
                        task.targetDecoder = task.softwareDecoder;
                    }
                }
                task.parameters = parameters;
                if (task.targetDecoder === task.softwareDecoder) {
                    try {
                        await this.openSoftwareDecoder(task);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`open video software decoder failed, error: ${error}`, cheap__fileName__0, 584);
                        if (!task.hardwareDecoder) {
                            resolve(avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                            return;
                        }
                    }
                }
                resolve(0);
            });
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.fatal('task not found', cheap__fileName__0, 594);
    }
    async setPlayRate(taskId, rate) {
        const task = this.tasks.get(taskId);
        if (task && task.softwareDecoder) {
            let discard = -16 /* AVDiscard.AVDISCARD_NONE */;
            let framerate = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(task.parameters + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational));
            if (framerate >= 120) {
                if (rate <= 1) {
                    discard = -16 /* AVDiscard.AVDISCARD_NONE */;
                }
                else if (rate < 1.5) {
                    discard = 8 /* AVDiscard.AVDISCARD_NONREF */;
                }
                else if (rate < 3) {
                    // 跳过所有帧间编码帧
                    discard = 8 /* AVDiscard.AVDISCARD_NONREF */;
                }
                else {
                    // 跳过所有帧间编码帧
                    discard = 32 /* AVDiscard.AVDISCARD_NONKEY */;
                }
            }
            else if (framerate >= 60) {
                if (rate < 1.5) {
                    discard = -16 /* AVDiscard.AVDISCARD_NONE */;
                }
                else if (rate < 3) {
                    discard = 8 /* AVDiscard.AVDISCARD_NONREF */;
                }
                else if (rate < 8) {
                    discard = 24 /* AVDiscard.AVDISCARD_NONINTRA */;
                }
                else {
                    discard = 32 /* AVDiscard.AVDISCARD_NONKEY */;
                }
            }
            else {
                discard = -16 /* AVDiscard.AVDISCARD_NONE */;
            }
            task.softwareDecoder.setSkipFrameDiscard(discard);
        }
    }
    async resetTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.targetDecoder === task.softwareDecoder) {
                await task.targetDecoder.flush();
            }
            // webcodec flush 有可能会卡主，这里重新创建解码器
            else if (task.targetDecoder === task.hardwareDecoder) {
                task.hardwareDecoder.close();
                task.hardwareDecoder = this.createWebcodecDecoder(task);
                await task.hardwareDecoder.open(task.parameters);
                task.targetDecoder = task.hardwareDecoder;
            }
            common_util_array__WEBPACK_IMPORTED_MODULE_13__.each(task.frameCaches, (frame) => {
                if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_21__["default"])(frame)) {
                    task.avframePool.release(frame);
                }
                else {
                    frame.close();
                }
            });
            task.frameCaches.length = 0;
            task.needKeyFrame = true;
            task.inputEnd = false;
            task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_18__["default"])();
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`reset video decoder, taskId: ${task.taskId}`, cheap__fileName__0, 665);
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_6__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.rightPort.close();
            task.leftPort.close();
            if (task.softwareDecoder) {
                task.softwareDecoder.close();
            }
            if (task.hardwareDecoder) {
                task.hardwareDecoder.close();
            }
            task.frameCaches.forEach((frame) => {
                if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_21__["default"])(frame)) {
                    task.avframePool.release(frame);
                }
                else {
                    frame.close();
                }
            });
            this.tasks.delete(taskId);
        }
    }
    async getTasksInfo() {
        const info = [];
        this.tasks.forEach((task) => {
            info.push({
                codecId: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.parameters + 4),
                width: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.parameters + 56),
                height: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.parameters + 60),
                framerate: (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(task.parameters + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational)),
                hardware: task.targetDecoder === task.hardwareDecoder
            });
        });
        return info;
    }
}


/***/ }),

/***/ "./src/avpipeline/VideoRenderPipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/VideoRenderPipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoRenderPipeline)
/* harmony export */ });
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./..\cheap\std\collection\List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/timer/LoopTask */ "./src/common/timer/LoopTask.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
/* harmony import */ var avrender_image_Canvas2dRender__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! avrender/image/Canvas2dRender */ "./src/avrender/image/Canvas2dRender.ts");
/* harmony import */ var avrender_image_WebGPUExternalRender__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! avrender/image/WebGPUExternalRender */ "./src/avrender/image/WebGPUExternalRender.ts");
/* harmony import */ var avrender_image_WebGLYUV8Render__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! avrender/image/WebGLYUV8Render */ "./src/avrender/image/WebGLYUV8Render.ts");
/* harmony import */ var avrender_image_WebGLRGB8Render__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! avrender/image/WebGLRGB8Render */ "./src/avrender/image/WebGLRGB8Render.ts");
/* harmony import */ var avrender_image_WebGLYUV16Render__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! avrender/image/WebGLYUV16Render */ "./src/avrender/image/WebGLYUV16Render.ts");
/* harmony import */ var avrender_image_WebGPUYUV8Render__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! avrender/image/WebGPUYUV8Render */ "./src/avrender/image/WebGPUYUV8Render.ts");
/* harmony import */ var avrender_image_WebGPURGB8Render__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! avrender/image/WebGPURGB8Render */ "./src/avrender/image/WebGPURGB8Render.ts");
/* harmony import */ var avrender_image_WebGPUYUV16Render__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! avrender/image/WebGPUYUV16Render */ "./src/avrender/image/WebGPUYUV16Render.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var common_function_nextTick__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! common/function/nextTick */ "./src/common/function/nextTick.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");
var cheap__fileName__2 = "src\\avpipeline\\VideoRenderPipeline.ts";




/*
 * libmedia VideoRenderPipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


























const WebGPURenderList =  true ? [
    avrender_image_WebGPUYUV8Render__WEBPACK_IMPORTED_MODULE_23__["default"],
    avrender_image_WebGPURGB8Render__WEBPACK_IMPORTED_MODULE_24__["default"]
] : 0;
{
    WebGPURenderList.push(avrender_image_WebGPUYUV16Render__WEBPACK_IMPORTED_MODULE_25__["default"]);
}
const WebGLRenderList = [
    avrender_image_WebGLYUV8Render__WEBPACK_IMPORTED_MODULE_20__["default"],
    avrender_image_WebGLRGB8Render__WEBPACK_IMPORTED_MODULE_21__["default"]
];
{
    WebGLRenderList.push(avrender_image_WebGLYUV16Render__WEBPACK_IMPORTED_MODULE_22__["default"]);
}
var AdjustStatus;
(function (AdjustStatus) {
    AdjustStatus[AdjustStatus["None"] = 0] = "None";
    AdjustStatus[AdjustStatus["Accelerate"] = 1] = "Accelerate";
    AdjustStatus[AdjustStatus["Decelerate"] = 2] = "Decelerate";
})(AdjustStatus || (AdjustStatus = {}));
const HHRPrimaries = ['bt2020', 'bt2100', 'st2048', 'p3-dcl', 'hlg'];
function isHDR(primaries) {
    return common_util_array__WEBPACK_IMPORTED_MODULE_8__.has(HHRPrimaries, primaries);
}
class VideoRenderPipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_4__["default"] {
    constructor() {
        super();
    }
    async createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__["default"](options.leftPort);
        const controlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__["default"](options.controlPort);
        const task = {
            ...options,
            leftIPCPort,
            controlIPCPort,
            render: null,
            currentPTS: avutil_constant__WEBPACK_IMPORTED_MODULE_14__.NOPTS_VALUE_BIGINT,
            firstPTS: BigInt(0),
            startTimestamp: BigInt(0),
            playRate: BigInt(100),
            targetRate: BigInt(100),
            frontFrame: null,
            backFrame: null,
            renderFrame: null,
            renderFrameCount: BigInt(0),
            loop: null,
            renderRedyed: false,
            adjust: AdjustStatus.None,
            adjustDiff: BigInt(0),
            lastAdjustTimestamp: BigInt(0),
            firstRendered: false,
            canvasUpdated: false,
            renderCreating: false,
            pauseTimestamp: 0,
            pauseCurrentPts: BigInt(0),
            lastNotifyPTS: BigInt(0),
            skipRender: false,
            isSupport: () => false,
            frontBuffered: false,
            ended: false,
            seeking: false,
            seekSync: null,
            afterPullResolver: null,
            pausing: false,
            lastRenderTimestamp: 0,
            avframePool: new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_9__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_0__["default"]), options.avframeListMutex)
        };
        task.startPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)(task.startPTS, task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_14__.AV_MILLI_TIME_BASE_Q);
        controlIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__.NOTIFY, async (request) => {
            switch (request.method) {
                case 'syncPts': {
                    const targetPTS = request.params.pts;
                    const diff = Math.abs(Number(targetPTS - task.currentPTS));
                    if (diff > 100 && task.currentPTS > BigInt(0)) {
                        if (targetPTS > task.currentPTS) {
                            task.adjust = AdjustStatus.Accelerate;
                            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`video render sync pts accelerate, targetPTS: ${targetPTS}, currentPTS: ${task.currentPTS}, diff: ${diff}, taskId: ${task.taskId}`, cheap__fileName__2, 234);
                        }
                        else {
                            task.adjust = AdjustStatus.Decelerate;
                            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`video render sync pts decelerate, targetPTS: ${targetPTS}, currentPTS: ${task.currentPTS}, diff: ${diff} taskId: ${task.taskId}`, cheap__fileName__2, 238);
                        }
                        task.adjustDiff = BigInt(Math.floor(diff));
                    }
                    break;
                }
                case 'skipRender': {
                    task.skipRender = request.params.skipRender;
                    break;
                }
            }
        });
        this.tasks.set(options.taskId, task);
        return 0;
    }
    swap(task) {
        if (task.seeking) {
            return;
        }
        if (task.backFrame) {
            if (!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.backFrame)) {
                task.backFrame.close();
            }
            else {
                task.avframePool.release(task.backFrame);
            }
        }
        task.backFrame = null;
        if (task.frontBuffered) {
            task.backFrame = task.frontFrame;
            task.frontFrame = null;
        }
        else {
            return false;
        }
        if (task.ended) {
            return;
        }
        task.frontBuffered = false;
        const now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])();
        task.leftIPCPort.request('pull').then((frame) => {
            if (task.afterPullResolver) {
                task.afterPullResolver();
            }
            if (common_util_is__WEBPACK_IMPORTED_MODULE_7__.number(frame) && frame < 0) {
                task.ended = true;
                task.frontFrame = null;
                return;
            }
            const cost = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])() - now;
            // 超过 1 秒认为是网卡了（断点暂停），对齐一下时间
            if (cost > 1000) {
                task.startTimestamp += BigInt(Math.floor(cost));
            }
            task.frontFrame = frame;
            task.frontBuffered = true;
            if (task.seekSync) {
                task.seekSync();
                task.seekSync = null;
                return;
            }
            if (!task.backFrame) {
                this.swap(task);
            }
        });
        return true;
    }
    async createRender(task, frame) {
        if (task.renderCreating) {
            return;
        }
        task.renderCreating = true;
        task.renderRedyed = false;
        if (task.render) {
            task.render.destroy();
        }
        if (!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(frame)) {
            if ( true && task.enableWebGPU
                && common_util_support__WEBPACK_IMPORTED_MODULE_10__["default"].webgpu
                && (
                // chrome116+ webgpu 可以导入 VideoFrame 作为纹理
                (common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].chrome || common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].newEdge) && common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].majorVersion, '116', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].majorVersion, '17.4', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].majorVersion, '129', true))
                && !isHDR(frame.colorSpace.primaries)) {
                // WebGPUExternalRender 性能最优
                task.render = new avrender_image_WebGPUExternalRender__WEBPACK_IMPORTED_MODULE_19__["default"](task.canvas, {
                    devicePixelRatio: task.devicePixelRatio,
                    renderMode: task.renderMode,
                    onRenderContextLost: () => {
                        task.canvasUpdated = false;
                        task.renderRedyed = false;
                        common_util_logger__WEBPACK_IMPORTED_MODULE_16__.warn('render context lost', cheap__fileName__2, 341);
                        task.controlIPCPort.notify('updateCanvas');
                    }
                });
                task.isSupport = avrender_image_WebGPUExternalRender__WEBPACK_IMPORTED_MODULE_19__["default"].isSupport;
            }
            else {
                // CanvasImageRender 支持 hdr 视频渲染
                task.render = new avrender_image_Canvas2dRender__WEBPACK_IMPORTED_MODULE_18__["default"](task.canvas, {
                    devicePixelRatio: task.devicePixelRatio,
                    renderMode: task.renderMode
                });
                task.isSupport = avrender_image_Canvas2dRender__WEBPACK_IMPORTED_MODULE_18__["default"].isSupport;
            }
        }
        else {
            // 优先使用 webgpu，webgpu 性能优于 webgl
            if ( true && task.enableWebGPU && common_util_support__WEBPACK_IMPORTED_MODULE_10__["default"].webgpu) {
                common_util_array__WEBPACK_IMPORTED_MODULE_8__.each(WebGPURenderList, (RenderFactory) => {
                    if (RenderFactory.isSupport(frame)) {
                        task.render = new RenderFactory(task.canvas, {
                            devicePixelRatio: task.devicePixelRatio,
                            renderMode: task.renderMode,
                            onRenderContextLost: () => {
                                task.canvasUpdated = false;
                                task.renderRedyed = false;
                                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.warn('render context lost', cheap__fileName__2, 367);
                                task.controlIPCPort.notify('updateCanvas');
                            }
                        });
                        task.isSupport = RenderFactory.isSupport;
                        return false;
                    }
                });
            }
            else {
                common_util_array__WEBPACK_IMPORTED_MODULE_8__.each(WebGLRenderList, (RenderFactory) => {
                    if (RenderFactory.isSupport(frame)) {
                        task.render = new RenderFactory(task.canvas, {
                            devicePixelRatio: task.devicePixelRatio,
                            renderMode: task.renderMode,
                            onRenderContextLost: () => {
                                task.canvasUpdated = false;
                                task.renderRedyed = false;
                                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.warn('render context lost', cheap__fileName__2, 385);
                                task.controlIPCPort.notify('updateCanvas');
                            }
                        });
                        task.isSupport = RenderFactory.isSupport;
                        return false;
                    }
                });
            }
        }
        if (!task.render) {
            task.renderCreating = false;
            return;
        }
        await task.render.init();
        task.render.viewport(task.viewportWidth, task.viewportHeight);
        task.render.clear();
        task.render.setRotate(task.renderRotate ?? 0);
        task.render.enableHorizontalFlip(task.flipHorizontal ?? false);
        task.render.enableVerticalFlip(task.flipVertical ?? false);
        task.renderRedyed = true;
        task.renderCreating = false;
    }
    async play(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.fatal('task has already call play', cheap__fileName__2, 414);
            }
            task.backFrame = await task.leftIPCPort.request('pull');
            if (common_util_is__WEBPACK_IMPORTED_MODULE_7__.number(task.backFrame) && task.backFrame < 0) {
                task.backFrame = 0;
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.info(`video render ended, taskId: ${task.taskId}`, cheap__fileName__2, 421);
                task.controlIPCPort.notify('ended');
                return;
            }
            task.frontFrame = await task.leftIPCPort.request('pull');
            task.frontBuffered = true;
            task.ended = false;
            if (common_util_is__WEBPACK_IMPORTED_MODULE_7__.number(task.frontFrame) && task.frontFrame < 0) {
                task.ended = true;
                task.frontBuffered = false;
                task.frontFrame = 0;
            }
            const me = this;
            await this.createRender(task, task.backFrame);
            task.firstPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)((!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_14__.AV_MILLI_TIME_BASE_Q);
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`got first video frame, pts: ${!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.backFrame)
                ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104)}(${task.firstPTS}ms), taskId: ${task.taskId}`, cheap__fileName__2, 447);
            // 当第一个帧的 pts 大于 1000ms 时判定不是从 0 开始，这里做一下对其
            if (task.firstPTS < BigInt(1000)) {
                task.firstPTS = BigInt(0);
            }
            task.currentPTS = task.firstPTS;
            task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - task.firstPTS * BigInt(100) / task.playRate;
            const inWorker = (0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_26__["default"])();
            const interval = (inWorker && common_util_support__WEBPACK_IMPORTED_MODULE_10__["default"].shareArrayBuffer) ? 0 : 10;
            task.loop = new common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_11__["default"](() => {
                if (!task.backFrame) {
                    if (!task.ended) {
                        task.loop.emptyTask();
                    }
                    else {
                        if (task.render && task.renderRedyed) {
                            task.render.clear();
                        }
                        task.loop.stop();
                        task.adjust = AdjustStatus.None;
                        common_util_logger__WEBPACK_IMPORTED_MODULE_16__.info(`video render ended, taskId: ${task.taskId}`, cheap__fileName__2, 475);
                        task.controlIPCPort.notify('ended');
                    }
                    return;
                }
                if (!task.isSupport(task.backFrame)) {
                    if (task.render) {
                        task.renderRedyed = false;
                        task.renderFrame = task.backFrame;
                        task.controlIPCPort.notify('updateCanvas');
                        return;
                    }
                    else {
                        this.createRender(task, task.backFrame);
                    }
                }
                const pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)((!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_14__.AV_MILLI_TIME_BASE_Q);
                if (pts < task.currentPTS) {
                    // 差值大于 5s 认为从头开始了
                    if (task.currentPTS - pts > BigInt(5000)) {
                        task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - (pts * BigInt(100) / task.targetRate);
                    }
                    else {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_16__.warn(`dropping frame with pts ${pts}, which is earlier then the last rendered frame(${task.currentPTS}), taskId: ${task.taskId}`, cheap__fileName__2, 505);
                        this.swap(task);
                        return;
                    }
                }
                // 差值大于 5s 认为从某一处开始了
                else if (pts - task.currentPTS > BigInt(5000)) {
                    task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - (pts * BigInt(100) / task.targetRate);
                }
                if (task.adjust === AdjustStatus.Accelerate) {
                    if (task.adjustDiff <= 0) {
                        task.adjust = AdjustStatus.None;
                        task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - (pts * BigInt(100) / task.targetRate);
                        task.lastAdjustTimestamp = BigInt(0);
                    }
                    else {
                        if (BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - task.lastAdjustTimestamp >= BigInt(200)) {
                            const sub = task.adjustDiff <= BigInt(100)
                                ? task.adjustDiff
                                : common_util_bigint__WEBPACK_IMPORTED_MODULE_17__.min(task.adjustDiff, BigInt(100)) * BigInt(100) / task.targetRate;
                            task.startTimestamp -= sub;
                            task.adjustDiff -= sub;
                            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`video render accelerate startTimestamp sub: ${sub}, taskId: ${task.taskId}`, cheap__fileName__2, 530);
                            task.lastAdjustTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])()));
                        }
                    }
                }
                else if (task.adjust === AdjustStatus.Decelerate) {
                    if (task.adjustDiff <= 0) {
                        task.adjust = AdjustStatus.None;
                        task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - (pts * BigInt(100) / task.targetRate);
                        task.lastAdjustTimestamp = BigInt(0);
                    }
                    else {
                        if (BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - task.lastAdjustTimestamp >= BigInt(300)) {
                            const add = task.adjustDiff < BigInt(50)
                                ? task.adjustDiff
                                : common_util_bigint__WEBPACK_IMPORTED_MODULE_17__.min(task.adjustDiff, BigInt(50)) * BigInt(100) / task.targetRate;
                            task.startTimestamp += add;
                            task.adjustDiff -= add;
                            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`video render decelerate startTimestamp add: ${add}, taskId: ${task.taskId}`, cheap__fileName__2, 551);
                            task.lastAdjustTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])()));
                        }
                    }
                }
                if (task.enableJitterBuffer) {
                    let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 120) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 224) * 1000;
                    if (buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.jitterBuffer)) {
                        me.setPlayRate(task.taskId, 1);
                    }
                }
                const diff = pts * BigInt(100) / task.playRate + task.startTimestamp - BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])()));
                if (diff <= 0) {
                    // 太晚的帧跳过渲染
                    if (task.renderRedyed
                        && !task.skipRender
                        && (inWorker || (-diff < BigInt(100)) || (task.renderFrameCount & BigInt(0x01)))) {
                        task.render.render(task.backFrame);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 320, pts);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 160, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.stats + 160) + BigInt(1));
                        if (task.lastRenderTimestamp) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 252, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])() - task.lastRenderTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 252)));
                        }
                        task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])();
                    }
                    else {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 168, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 168) + 1);
                    }
                    task.renderFrameCount++;
                    if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.backFrame)) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 84, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.backFrame + 68));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 88, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.backFrame + 72));
                    }
                    else {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 84, task.backFrame.displayWidth);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 88, task.backFrame.displayHeight);
                    }
                    if (!task.firstRendered) {
                        task.controlIPCPort.notify(task.canvasUpdated ? 'firstRenderedAfterUpdateCanvas' : 'firstRendered');
                        task.firstRendered = true;
                        task.canvasUpdated = false;
                    }
                    if (task.playRate !== task.targetRate) {
                        task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - (pts * BigInt(100) / task.targetRate);
                        task.playRate = task.targetRate;
                    }
                    task.currentPTS = pts;
                    if (pts - task.lastNotifyPTS >= BigInt(1000)) {
                        task.lastNotifyPTS = pts;
                        task.controlIPCPort.notify('syncPts', {
                            pts
                        });
                    }
                    this.swap(task);
                }
                else {
                    task.loop.emptyTask();
                }
            }, 0, interval);
            task.loop.start();
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.fatal('task not found', cheap__fileName__2, 623);
        }
    }
    async restart(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (!task.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.fatal('task has not played', cheap__fileName__2, 631);
            }
            if (task.loop.isStarted()) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.fatal('task has already run', cheap__fileName__2, 635);
            }
            if (task.backFrame) {
                if (!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.backFrame)) {
                    task.backFrame.close();
                }
                else {
                    task.avframePool.release(task.backFrame);
                }
            }
            if (task.frontFrame) {
                if (!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.frontFrame)) {
                    task.frontFrame.close();
                }
                else {
                    task.avframePool.release(task.frontFrame);
                }
            }
            task.backFrame = await task.leftIPCPort.request('pull');
            task.frontFrame = await task.leftIPCPort.request('pull');
            task.frontBuffered = true;
            task.ended = false;
            task.adjust = AdjustStatus.None;
            task.lastNotifyPTS = avutil_constant__WEBPACK_IMPORTED_MODULE_14__.NOPTS_VALUE_BIGINT;
            task.firstRendered = false;
            task.firstPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)((!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_14__.AV_MILLI_TIME_BASE_Q);
            task.currentPTS = task.firstPTS;
            // 当第一个帧的 pts 大于 1000ms 时判定不是从 0 开始，这里做一下对其
            if (task.firstPTS < BigInt(1000)) {
                task.firstPTS = BigInt(0);
            }
            task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - task.firstPTS * BigInt(100) / task.playRate;
            task.loop.start();
        }
    }
    async pause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (!task.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.fatal('task has not played', cheap__fileName__2, 686);
            }
            task.pauseTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])();
            task.pauseCurrentPts = task.currentPTS;
            task.loop.stop();
            task.pausing = true;
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.info(`task paused, taskId: ${task.taskId}`, cheap__fileName__2, 693);
        }
    }
    async unpause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.seeking) {
                return;
            }
            if (!task.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.fatal('task has not played', cheap__fileName__2, 704);
            }
            task.startTimestamp += BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])() - task.pauseTimestamp));
            task.startTimestamp -= task.currentPTS - task.pauseCurrentPts;
            if (!task.seeking) {
                task.loop.start();
            }
            task.pausing = false;
            task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])();
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.info(`task unpaused, taskId: ${task.taskId}`, cheap__fileName__2, 714);
        }
    }
    async updateCanvas(taskId, canvas) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.canvas = canvas;
            if (task.render) {
                task.render.destroy();
                task.render = null;
            }
            task.isSupport = () => false;
            task.canvasUpdated = true;
            task.firstRendered = false;
            task.renderRedyed = false;
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.fatal('task not found', cheap__fileName__2, 732);
        }
    }
    async setPlayRate(taskId, rate) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.enableJitterBuffer) {
                let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 120) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 224) * 1000;
                if (buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.jitterBuffer)) {
                    rate = 1;
                }
            }
            task.targetRate = BigInt(Math.floor(Math.floor(rate * 100)));
        }
    }
    async setRenderMode(taskId, mode) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.render) {
                task.renderMode = mode;
                task.render.setRenderMode(mode);
                (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_27__["default"])(() => {
                    if (task.pausing && task.backFrame && task.render) {
                        task.render.render(task.backFrame);
                    }
                });
            }
        }
    }
    async setRenderRotate(taskId, rotate) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.render) {
                task.renderRotate = rotate;
                task.render.setRotate(rotate);
                (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_27__["default"])(() => {
                    if (task.pausing && task.backFrame && task.render) {
                        task.render.render(task.backFrame);
                    }
                });
            }
        }
    }
    async enableHorizontalFlip(taskId, enable) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.render) {
                task.flipHorizontal = enable;
                task.render.enableHorizontalFlip(enable);
                (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_27__["default"])(() => {
                    if (task.pausing && task.backFrame && task.render) {
                        task.render.render(task.backFrame);
                    }
                });
            }
        }
    }
    async enableVerticalFlip(taskId, enable) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.render) {
                task.flipVertical = enable;
                task.render.enableVerticalFlip(enable);
                (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_27__["default"])(() => {
                    if (task.pausing && task.backFrame && task.render) {
                        task.render.render(task.backFrame);
                    }
                });
            }
        }
    }
    async resize(taskId, width, height) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.render) {
                task.render.viewport(width, height);
                (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_27__["default"])(() => {
                    if (task.pausing && task.backFrame && task.render) {
                        task.render.render(task.backFrame);
                    }
                });
            }
        }
    }
    async setSkipRender(taskId, skip) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.skipRender = skip;
        }
    }
    async beforeSeek(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            // 当前正在 pull frontFrame，等待其结束
            if (!task.ended && !task.frontBuffered) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`wait current pull front frame before seek, taskId: ${task.taskId}`, cheap__fileName__2, 835);
                await new Promise((resolve) => {
                    task.seekSync = resolve;
                });
            }
            task.seeking = true;
            task.loop.stop();
            if (task.backFrame) {
                if (!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.backFrame)) {
                    task.backFrame.close();
                }
                else {
                    task.avframePool.release(task.backFrame);
                }
            }
            if (task.frontFrame) {
                if (!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.frontFrame)) {
                    task.frontFrame.close();
                }
                else {
                    task.avframePool.release(task.frontFrame);
                }
            }
            task.frontFrame = null;
            task.backFrame = null;
            task.currentPTS = avutil_constant__WEBPACK_IMPORTED_MODULE_14__.NOPTS_VALUE_BIGINT;
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`before seek end, taskId: ${task.taskId}`, cheap__fileName__2, 863);
        }
    }
    async syncSeekTime(taskId, timestamp, maxQueueLength) {
        const task = this.tasks.get(taskId);
        if (task) {
            while (true) {
                task.backFrame = await task.leftIPCPort.request('pull');
                if (common_util_is__WEBPACK_IMPORTED_MODULE_7__.number(task.backFrame) && task.backFrame < 0) {
                    task.ended = true;
                    task.seeking = false;
                    task.adjust = AdjustStatus.None;
                    task.backFrame = null;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_16__.warn(`pull video frame end after seek, taskId: ${taskId}`, cheap__fileName__2, 879);
                    task.controlIPCPort.notify('ended');
                    return;
                }
                if (timestamp < BigInt(0)) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_16__.info(`use the first video frame because of the seek time${timestamp} < 0`, cheap__fileName__2, 885);
                    break;
                }
                const pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)((!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_14__.AV_MILLI_TIME_BASE_Q);
                if (pts - task.startPTS >= timestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 320, pts);
                    break;
                }
                if (!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.backFrame)) {
                    task.backFrame.close();
                }
                else {
                    task.avframePool.release(task.backFrame);
                }
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`sync seek time end, taskId: ${task.taskId}`, cheap__fileName__2, 913);
        }
    }
    async afterSeek(taskId, timestamp) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.ended) {
                return;
            }
            task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - (timestamp + task.startPTS) * BigInt(100) / task.playRate;
            task.frontFrame = await task.leftIPCPort.request('pull');
            if (common_util_is__WEBPACK_IMPORTED_MODULE_7__.number(task.frontFrame) && task.frontFrame < 0) {
                task.frontFrame = null;
                task.frontBuffered = false;
                task.ended = true;
            }
            else {
                task.frontBuffered = true;
            }
            task.ended = false;
            task.adjust = AdjustStatus.None;
            task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])();
            task.currentPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)((!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_14__.AV_MILLI_TIME_BASE_Q);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 320, task.currentPTS);
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`got first video frame, pts: ${!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.backFrame)
                ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104)}(${task.currentPTS}ms), taskId: ${task.taskId}`, cheap__fileName__2, 948);
            task.seeking = false;
            if (!task.pausing) {
                task.loop.start();
            }
            else if (task.backFrame) {
                task.render.render(task.backFrame);
                // reset pause time
                task.pauseCurrentPts = task.currentPTS;
                task.pauseTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])();
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`after seek end, taskId: ${task.taskId}`, cheap__fileName__2, 964);
        }
    }
    async renderNextFrame(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.backFrame) {
                const pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)((!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_14__.AV_MILLI_TIME_BASE_Q);
                task.render.render(task.backFrame);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 320, pts);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 160, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.stats + 160) + BigInt(1));
                task.currentPTS = pts;
                this.swap(task);
            }
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_5__.INVALID_OPERATE;
        }
        return await this.createTask(options);
    }
    async unregisterTask(id) {
        const task = this.tasks.get(id);
        if (task) {
            const started = !!task.loop;
            if (task.loop) {
                await task.loop.stopBeforeNextTick();
                task.loop.destroy();
                task.loop = null;
            }
            if (started && !task.ended && !task.frontFrame) {
                await new Promise((resolve) => {
                    task.afterPullResolver = resolve;
                });
            }
            if (task.render) {
                task.render.destroy();
                task.render = null;
            }
            if (task.backFrame) {
                if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.backFrame) && task.backFrame > 0) {
                    task.avframePool.release(task.backFrame);
                }
                else {
                    task.backFrame.close();
                }
                task.backFrame = null;
            }
            if (task.frontFrame) {
                if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(task.frontFrame) && task.frontFrame > 0) {
                    task.avframePool.release(task.frontFrame);
                }
                else {
                    task.frontFrame.close();
                }
                task.frontFrame = null;
            }
            task.leftIPCPort.destroy();
            task.controlIPCPort.destroy();
            this.tasks.delete(id);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/struct/jitter.ts":
/*!*****************************************!*\
  !*** ./src/avpipeline/struct/jitter.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JitterBuffer: () => (/* binding */ JitterBuffer)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia jitter buffer struct defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class JitterBuffer {
    min;
    max;
}
(function (prototype) {
    var map = new Map();
    map.set("min", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("max", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(JitterBuffer.prototype);


/***/ }),

/***/ "./src/avpipeline/struct/stats.ts":
/*!****************************************!*\
  !*** ./src/avpipeline/struct/stats.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Stats)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia stats struct defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class Stats {
    /**
     * 音频通道数
     */
    channels;
    /**
     * 音频采样率
     */
    sampleRate;
    /**
     * 音频帧大小
     */
    audioFrameSize;
    /**
     * 音频包总字节数
     */
    audioPacketBytes;
    /**
     * 音频包总数
     */
    audioPacketCount;
    /**
     * 当前音频包队列长度
     */
    audioPacketQueueLength;
    /**
     * 音频包丢弃总数
     */
    audioDropPacketCount;
    /**
     * 音频解码错误包总数
     */
    audioDecodeErrorPacketCount;
    /**
     * 音频编码错误帧总数
     */
    audioEncodeErrorFrameCount;
    /**
     * 音频解码帧总数
     */
    audioFrameDecodeCount;
    /**
     * 音频编码包总数
     */
    audioPacketEncodeCount;
    /**
     * 音频渲染帧总数
     */
    audioFrameRenderCount;
    /**
     * 音频帧丢弃总数
     */
    audioFrameDropCount;
    /**
     * 视频宽度
     */
    width;
    /**
     * 视频高度
     */
    height;
    /**
     * 视频关键帧间隔
     */
    keyFrameInterval;
    /**
     * 视频 gop 长度
     */
    gop;
    /**
     * 视频包总字节数
     */
    videoPacketBytes;
    /**
     * 视频包总数
     */
    videoPacketCount;
    /**
     * 当前视频包队列总数
     */
    videoPacketQueueLength;
    /**
     * 视频包丢弃总数
     */
    videoDropPacketCount;
    /**
     * 视频包解码错误总数
     */
    videoDecodeErrorPacketCount;
    /**
     * 视频编码错误帧总数
     */
    videoEncodeErrorFrameCount;
    /**
     * 视频解码帧总数
     */
    videoFrameDecodeCount;
    /**
     * 视频编码包总数
     */
    videoPacketEncodeCount;
    /**
     * 视频渲染帧总数
     */
    videoFrameRenderCount;
    /**
     * 视频帧丢弃总数（解码未渲染）
     */
    videoFrameDropCount;
    /**
     * 视频关键帧总数
     */
    keyFrameCount;
    /**
     * buffer 丢弃总字节数
     */
    bufferDropBytes;
    /**
     * buffer 接收总字节数
     */
    bufferReceiveBytes;
    /**
     * buffer 总输出字节数
     *
     */
    bufferOutputBytes;
    /**
     * 音频码率
     */
    audioBitrate;
    /**
     * 视频码率
     */
    videoBitrate;
    /**
     * 视频解码帧率
     */
    videoDecodeFramerate;
    /**
     * 视频渲染帧率
     */
    videoRenderFramerate;
    /**
     * 视频编码帧率（根据 dts 计算）
     */
    videoEncodeFramerate;
    /**
     * 音频解码帧率
     */
    audioDecodeFramerate;
    /**
     * 音频渲染帧率
     */
    audioRenderFramerate;
    /**
     * 音视频编码帧率（根据 dts 计算）
     */
    audioEncodeFramerate;
    /**
     * 音频最大解码帧间隔（毫秒）
     */
    audioFrameDecodeIntervalMax;
    /**
     * 音频最大渲染帧间隔（毫秒）
     */
    audioFrameRenderIntervalMax;
    /**
     * 视频最大解码帧间隔（毫秒）
     */
    videoFrameDecodeIntervalMax;
    /**
     * 视频最大渲染帧间隔（毫秒）
     */
    videoFrameRenderIntervalMax;
    /**
     * 接收带宽
     */
    bandwidth;
    /**
     * 抖动指标
     */
    jitter;
    /**
     * 音频卡顿次数
     */
    audioStutter;
    /**
     * 视频卡顿次数
     */
    videoStutter;
    /**
     * 音频 codec string
     */
    audiocodec;
    /**
     * 视频 codec string
     */
    videocodec;
    /**
     * 首个 audio mux dts
     */
    firstAudioMuxDts;
    /**
     * 上一次 audio mux dts
     */
    lastAudioMuxDts;
    /**
     * 首个 audio mux dts
     */
    firstVideoMuxDts;
    /**
     * 上一次 video mux dts
     */
    lastVideoMuxDts;
    /**
     * 当前音频播放时间戳
     */
    audioCurrentTime;
    /**
     * 当前视频播放时间戳
     */
    videoCurrentTime;
}
(function (prototype) {
    var map = new Map();
    map.set("channels", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("sampleRate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("audioFrameSize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("audioPacketBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("audioPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("audioPacketQueueLength", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    map.set("audioDropPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 40, 8: 0 });
    map.set("audioDecodeErrorPacketCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 48, 8: 0 });
    map.set("audioEncodeErrorFrameCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 52, 8: 0 });
    map.set("audioFrameDecodeCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 56, 8: 0 });
    map.set("audioPacketEncodeCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("audioFrameRenderCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("audioFrameDropCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    map.set("width", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 84, 8: 0 });
    map.set("height", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 88, 8: 0 });
    map.set("keyFrameInterval", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 92, 8: 0 });
    map.set("gop", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 96, 8: 0 });
    map.set("videoPacketBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 104, 8: 0 });
    map.set("videoPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 112, 8: 0 });
    map.set("videoPacketQueueLength", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 120, 8: 0 });
    map.set("videoDropPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 128, 8: 0 });
    map.set("videoDecodeErrorPacketCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 136, 8: 0 });
    map.set("videoEncodeErrorFrameCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 140, 8: 0 });
    map.set("videoFrameDecodeCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 144, 8: 0 });
    map.set("videoPacketEncodeCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 152, 8: 0 });
    map.set("videoFrameRenderCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 160, 8: 0 });
    map.set("videoFrameDropCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 168, 8: 0 });
    map.set("keyFrameCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 176, 8: 0 });
    map.set("bufferDropBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 184, 8: 0 });
    map.set("bufferReceiveBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 192, 8: 0 });
    map.set("bufferOutputBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 200, 8: 0 });
    map.set("audioBitrate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 208, 8: 0 });
    map.set("videoBitrate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 212, 8: 0 });
    map.set("videoDecodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 216, 8: 0 });
    map.set("videoRenderFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 220, 8: 0 });
    map.set("videoEncodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 224, 8: 0 });
    map.set("audioDecodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 228, 8: 0 });
    map.set("audioRenderFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 232, 8: 0 });
    map.set("audioEncodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 236, 8: 0 });
    map.set("audioFrameDecodeIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 240, 8: 0 });
    map.set("audioFrameRenderIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 244, 8: 0 });
    map.set("videoFrameDecodeIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 248, 8: 0 });
    map.set("videoFrameRenderIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 252, 8: 0 });
    map.set("bandwidth", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 256, 8: 0 });
    map.set("jitter", { 0: 19, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 264, 8: 0 });
    map.set("audioStutter", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 272, 8: 0 });
    map.set("videoStutter", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 276, 8: 0 });
    map.set("firstAudioMuxDts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 280, 8: 0 });
    map.set("lastAudioMuxDts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 288, 8: 0 });
    map.set("firstVideoMuxDts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 296, 8: 0 });
    map.set("lastVideoMuxDts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 304, 8: 0 });
    map.set("audioCurrentTime", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 312, 8: 0 });
    map.set("videoCurrentTime", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 320, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 328);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(Stats.prototype);


/***/ }),

/***/ "./src/avplayer/AVPlayer.ts":
/*!**********************************!*\
  !*** ./src/avplayer/AVPlayer.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVPlayer)
/* harmony export */ });
/* unused harmony export AVPlayerSupportedCodecs */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\cheap\std\collection\List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _avpipeline_struct_jitter_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./..\avpipeline\struct\jitter.ts */ "./src/avpipeline/struct/jitter.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _avutil_struct_avcodecparameters_ts__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./..\avutil\struct\avcodecparameters.ts */ "./src/avutil/struct/avcodecparameters.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var avpipeline_IOPipeline__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avpipeline/IOPipeline */ "./src/avpipeline/IOPipeline.ts");
/* harmony import */ var avpipeline_DemuxPipeline__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avpipeline/DemuxPipeline */ "./src/avpipeline/DemuxPipeline.ts");
/* harmony import */ var avpipeline_VideoDecodePipeline__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avpipeline/VideoDecodePipeline */ "./src/avpipeline/VideoDecodePipeline.ts");
/* harmony import */ var avpipeline_AudioDecodePipeline__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! avpipeline/AudioDecodePipeline */ "./src/avpipeline/AudioDecodePipeline.ts");
/* harmony import */ var cheap_thread_thread__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! cheap/thread/thread */ "./src/cheap/thread/thread.ts");
/* harmony import */ var common_event_Emitter__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/event/Emitter */ "./src/common/event/Emitter.ts");
/* harmony import */ var common_function_generateUUID__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! common/function/generateUUID */ "./src/common/function/generateUUID.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! cheap/webassembly/compiler */ "./src/cheap/webassembly/compiler.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avpipeline_AudioRenderPipeline__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! avpipeline/AudioRenderPipeline */ "./src/avpipeline/AudioRenderPipeline.ts");
/* harmony import */ var avpipeline_VideoRenderPipeline__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! avpipeline/VideoRenderPipeline */ "./src/avpipeline/VideoRenderPipeline.ts");
/* harmony import */ var common_util_url__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! common/util/url */ "./src/common/util/url.ts");
/* harmony import */ var cheap_config__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! cheap/config */ "./src/cheap/config.ts");
/* harmony import */ var avrender_pcm_audioWorklet_base_registerProcessor__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! avrender/pcm/audioWorklet/base/registerProcessor */ "./src/avrender/pcm/audioWorklet/base/registerProcessor.ts");
/* harmony import */ var avrender_pcm_AudioSourceWorkletNode__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! avrender/pcm/AudioSourceWorkletNode */ "./src/avrender/pcm/AudioSourceWorkletNode.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var _Controller__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./Controller */ "./src/avplayer/Controller.ts");
/* harmony import */ var _eventType__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var _function_supportOffscreenCanvas__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./function/supportOffscreenCanvas */ "./src/avplayer/function/supportOffscreenCanvas.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var avrender_pcm_AudioSourceBufferNode__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! avrender/pcm/AudioSourceBufferNode */ "./src/avrender/pcm/AudioSourceBufferNode.ts");
/* harmony import */ var common_function_restrain__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! common/function/restrain */ "./src/common/function/restrain.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avpipeline_struct_stats__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! avpipeline/struct/stats */ "./src/avpipeline/struct/stats.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! avutil/function/createMessageChannel */ "./src/avutil/function/createMessageChannel.ts");
/* harmony import */ var avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! avcodec/function/getVideoCodec */ "./src/avcodec/function/getVideoCodec.ts");
/* harmony import */ var avrender_track_function_getVideoMimeType__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! avrender/track/function/getVideoMimeType */ "./src/avrender/track/function/getVideoMimeType.ts");
/* harmony import */ var avrender_track_function_getAudioMimeType__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! avrender/track/function/getAudioMimeType */ "./src/avrender/track/function/getAudioMimeType.ts");
/* harmony import */ var _mse_MSEPipeline__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./mse/MSEPipeline */ "./src/avplayer/mse/MSEPipeline.ts");
/* harmony import */ var avcodec_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! avcodec/function/getHardwarePreference */ "./src/avcodec/function/getHardwarePreference.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var _StatsController__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./StatsController */ "./src/avplayer/StatsController.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
/* harmony import */ var _function_getMediaSource__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./function/getMediaSource */ "./src/avplayer/function/getMediaSource.ts");
/* harmony import */ var _JitterBufferController__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./JitterBufferController */ "./src/avplayer/JitterBufferController.ts");
/* harmony import */ var avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! avcodec/function/getAudioCodec */ "./src/avcodec/function/getAudioCodec.ts");
/* harmony import */ var avutil_stringEnum__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! avutil/stringEnum */ "./src/avutil/stringEnum.ts");
/* harmony import */ var avformat_dump__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! avformat/dump */ "./src/avformat/dump.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_function_isHdr__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! avutil/function/isHdr */ "./src/avutil/function/isHdr.ts");
/* harmony import */ var avutil_function_hasAlphaChannel__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! avutil/function/hasAlphaChannel */ "./src/avutil/function/hasAlphaChannel.ts");
/* harmony import */ var _subtitle_SubtitleRender__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./subtitle/SubtitleRender */ "./src/avplayer/subtitle/SubtitleRender.ts");
var cheap__fileName__15 = "src\\avplayer\\AVPlayer.ts";





























































const ObjectFitMap = {
    [1 /* RenderMode.FILL */]: 'cover',
    [0 /* RenderMode.FIT */]: 'contain'
};
const AVPlayerSupportedCodecs = [
    27 /* AVCodecID.AV_CODEC_ID_H264 */,
    173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
    196 /* AVCodecID.AV_CODEC_ID_VVC */,
    225 /* AVCodecID.AV_CODEC_ID_AV1 */,
    139 /* AVCodecID.AV_CODEC_ID_VP8 */,
    167 /* AVCodecID.AV_CODEC_ID_VP9 */,
    30 /* AVCodecID.AV_CODEC_ID_THEORA */,
    86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
    86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
    86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
    86051 /* AVCodecID.AV_CODEC_ID_SPEEX */,
    86021 /* AVCodecID.AV_CODEC_ID_VORBIS */,
    86019 /* AVCodecID.AV_CODEC_ID_AC3 */,
    86056 /* AVCodecID.AV_CODEC_ID_EAC3 */,
    86020 /* AVCodecID.AV_CODEC_ID_DTS */,
    94226 /* AVCodecID.AV_CODEC_ID_WEBVTT */,
    94225 /* AVCodecID.AV_CODEC_ID_SUBRIP */,
    94230 /* AVCodecID.AV_CODEC_ID_ASS */,
    94212 /* AVCodecID.AV_CODEC_ID_SSA */,
    94232 /* AVCodecID.AV_CODEC_ID_TTML */,
    94213 /* AVCodecID.AV_CODEC_ID_MOV_TEXT */,
    94210 /* AVCodecID.AV_CODEC_ID_TEXT */
];
const defaultAVPlayerOptions = {
    enableHardware: true,
    enableWebGPU: true,
    loop: false,
    jitterBufferMax: 10,
    jitterBufferMin: 4,
    lowLatency: false,
    preLoadTime: 4
};
class AVPlayerGlobalData {
    avpacketList;
    avframeList;
    avpacketListMutex;
    avframeListMutex;
    jitterBuffer;
}
(function (prototype) {
    var map = new Map();
    map.set("avpacketList", { 0: _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__["default"], 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("avframeList", { 0: _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__["default"], 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("avpacketListMutex", { 0: _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("avframeListMutex", { 0: _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    map.set("jitterBuffer", { 0: _avpipeline_struct_jitter_ts__WEBPACK_IMPORTED_MODULE_4__.JitterBuffer, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 40);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVPlayerGlobalData.prototype);
class AVPlayer extends common_event_Emitter__WEBPACK_IMPORTED_MODULE_16__["default"] {
    static level = common_util_logger__WEBPACK_IMPORTED_MODULE_33__.INFO;
    static DemuxThreadReady;
    static AudioThreadReady;
    static VideoThreadReady;
    static MSEThreadReady;
    // 下面的线程所有 AVPlayer 实例共享
    static IOThread;
    static DemuxerThread;
    static AudioDecoderThread;
    static AudioRenderThread;
    static VideoRenderThread;
    static MSEThread;
    static audioContext;
    static Resource = new Map();
    // 解码线程每个 player 独占一个
    // TODO 若需要同时播放大量视频，可以考虑实现一个 VideoDecoderThreadPool
    // 来根据各个视频规格做线程解码任务调度，降低系统线程切换开销，这里就不实现了
    VideoDecoderThread;
    // AVPlayer 各个线程间共享的数据
    GlobalData;
    taskId;
    subTaskId;
    subtitleTaskId;
    ext;
    source;
    options;
    ioloader2DemuxerChannel;
    demuxer2VideoDecoderChannel;
    demuxer2AudioDecoderChannel;
    videoDecoder2VideoRenderChannel;
    audioDecoder2AudioRenderChannel;
    audioRender2AudioWorkletChannel;
    audioSourceNode;
    gainNode;
    formatContext;
    canvas;
    updateCanvas;
    video;
    audio;
    controller;
    volume;
    playRate;
    renderMode;
    renderRotate;
    flipHorizontal;
    flipVertical;
    useMSE;
    audioEnded;
    videoEnded;
    status;
    lastStatus;
    stats;
    statsController;
    jitterBufferController;
    selectedVideoStream;
    selectedAudioStream;
    selectedSubtitleStream;
    lastSelectedInnerSubtitleStreamIndex;
    subtitleRender;
    externalSubtitleTasks;
    constructor(options) {
        super(true);
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_19__.extend({}, defaultAVPlayerOptions, options);
        this.taskId = (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_17__["default"])();
        this.status = 0 /* AVPlayerStatus.STOPPED */;
        this.volume = 1;
        this.playRate = 1;
        this.renderMode = 0 /* RenderMode.FIT */;
        this.renderRotate = 0;
        this.flipHorizontal = false;
        this.flipVertical = false;
        this.stats = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_5__["default"])(avpipeline_struct_stats__WEBPACK_IMPORTED_MODULE_40__["default"]);
        this.statsController = new _StatsController__WEBPACK_IMPORTED_MODULE_49__["default"](this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
        this.externalSubtitleTasks = [];
        this.lastSelectedInnerSubtitleStreamIndex = -1;
        this.GlobalData = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_5__["default"])(AVPlayerGlobalData);
        _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.init(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24);
        _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.init(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28);
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`create player, taskId: ${this.taskId}`, cheap__fileName__15, 340);
    }
    /**
     * 当前播放时间戳（毫秒）
     */
    get currentTime() {
        if (this.useMSE) {
            return BigInt(Math.floor((((this.video || this.audio)?.currentTime || 0) * 1000)));
        }
        if (this.selectedAudioStream) {
            return this.stats.audioCurrentTime;
        }
        else if (this.selectedVideoStream) {
            return this.stats.videoCurrentTime;
        }
        return BigInt(0);
    }
    isCodecIdSupported(codecId) {
        if (codecId > 65536 /* AVCodecID.AV_CODEC_ID_FIRST_AUDIO */ && codecId <= 65572 /* AVCodecID.AV_CODEC_ID_PCM_SGA */) {
            return true;
        }
        return common_util_array__WEBPACK_IMPORTED_MODULE_56__.has(AVPlayerSupportedCodecs, codecId);
    }
    findBestStream(streams, mediaType) {
        if (this.options.findBestStream) {
            return this.options.findBestStream(streams, mediaType);
        }
        const ss = streams.filter((stream) => {
            return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar) === mediaType;
        });
        if (ss.length) {
            if (ss.length === 1) {
                return ss[0];
            }
            const defaultStream = ss.find((stream) => !!(stream.disposition & 1 /* AVDisposition.DEFAULT */));
            if (defaultStream && this.isCodecIdSupported(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](defaultStream.codecpar + 4))) {
                return defaultStream;
            }
            return ss.find((stream) => this.isCodecIdSupported(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar + 4))) || ss[0];
        }
    }
    async checkUseMSE() {
        {
            if (!common_util_support__WEBPACK_IMPORTED_MODULE_34__["default"].mse) {
                return false;
            }
            // 不支持 wasm
            if (!common_util_support__WEBPACK_IMPORTED_MODULE_34__["default"].wasmBaseSupported) {
                return true;
            }
            const videoStream = this.findBestStream(this.formatContext.streams, 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
            const audioStream = this.findBestStream(this.formatContext.streams, 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
            // 检查音视频在 MediaSource 里面是否支持，不支持的只能使用 wasm 软解了
            if (videoStream && !(0,_function_getMediaSource__WEBPACK_IMPORTED_MODULE_51__["default"])().isTypeSupported((0,avrender_track_function_getVideoMimeType__WEBPACK_IMPORTED_MODULE_44__["default"])(videoStream.codecpar))) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn(`can not support mse for codec: ${(0,avrender_track_function_getVideoMimeType__WEBPACK_IMPORTED_MODULE_44__["default"])(videoStream.codecpar)}, taskId: ${this.taskId}`, cheap__fileName__15, 401);
                return false;
            }
            if (audioStream && !(0,_function_getMediaSource__WEBPACK_IMPORTED_MODULE_51__["default"])().isTypeSupported((0,avrender_track_function_getAudioMimeType__WEBPACK_IMPORTED_MODULE_45__["default"])(audioStream.codecpar))) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn(`can not support mse for codec: ${(0,avrender_track_function_getAudioMimeType__WEBPACK_IMPORTED_MODULE_45__["default"])(audioStream.codecpar)}, taskId: ${this.taskId}`, cheap__fileName__15, 405);
                return false;
            }
            if (this.options.checkUseMES) {
                return this.options.checkUseMES(this.formatContext.streams);
            }
            if (videoStream) {
                // 目前 canvas 还不能渲染 hdr 视频，hdr 先使用 mse 播放
                // TODO 未来 canvas 支持 hdr 渲染之后去掉
                if ((0,avutil_function_isHdr__WEBPACK_IMPORTED_MODULE_57__["default"])(videoStream.codecpar)) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`use mse because of hdr`, cheap__fileName__15, 417);
                    return true;
                }
                // 1080p 以上使用 mse
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar + 56) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar + 60) > 2073600) {
                    // 不支持 webcodec
                    if (!common_util_support__WEBPACK_IMPORTED_MODULE_34__["default"].videoDecoder) {
                        return true;
                    }
                    let extradata = null;
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[20](videoStream.codecpar + 12) !== 0) {
                        extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_41__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[20](videoStream.codecpar + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar + 16));
                    }
                    // 检查视频格式是否支持硬解，不支持使用 mse
                    const isWebcodecSupport = await VideoDecoder.isConfigSupported({
                        codec: (0,avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_43__["default"])(videoStream.codecpar),
                        codedWidth: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar + 56),
                        codedHeight: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar + 60),
                        description: extradata,
                        hardwareAcceleration: (0,avcodec_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_47__.getHardwarePreference)(true)
                    });
                    if (!isWebcodecSupport.supported) {
                        return true;
                    }
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar + 56) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar + 60) === 2073600) {
                    // safari 1080p@30fps 无法在 worker 中解码
                    if (common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].version, '16.1', true) && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_38__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(videoStream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_7__.Rational)) > 30) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    createCanvas() {
        const canvas = document.createElement('canvas');
        canvas.id = 'avplayer-canvas-' + (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_17__["default"])();
        canvas.className = 'avplayer-canvas';
        canvas.width = this.options.container.offsetWidth * devicePixelRatio;
        canvas.height = this.options.container.offsetHeight * devicePixelRatio;
        canvas.style.cssText = `
      width: 100%;
      height: 100%;
    `;
        canvas.ondragstart = () => false;
        Object.defineProperty(canvas, 'currentTime', {
            enumerable: true,
            configurable: false,
            get: () => {
                return Number(this.currentTime) / 1000;
            },
            set: (time) => {
                this.seek(BigInt(Math.floor(Math.floor(time * 1000))));
            }
        });
        return canvas;
    }
    createVideo() {
        if (this.video) {
            this.options.container.removeChild(this.video);
        }
        const video = document.createElement('video');
        video.autoplay = true;
        video.className = 'avplayer-video';
        video.style.cssText = `
      width: 100%;
      height: 100%;
    `;
        this.options.container.appendChild(video);
        this.video = video;
    }
    createAudio() {
        if (this.audio) {
            this.options.container.removeChild(this.audio);
        }
        const audio = document.createElement('audio');
        audio.autoplay = true;
        audio.className = 'avplayer-audio';
        this.options.container.appendChild(audio);
        this.audio = audio;
    }
    handleTimeupdate(element) {
        let lastNotifyTime = 0;
        element.ontimeupdate = () => {
            const time = element.currentTime;
            if (Math.abs(time - lastNotifyTime) >= 1) {
                if (this.status === 6 /* AVPlayerStatus.PLAYED */) {
                    this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.TIME, [this.currentTime]);
                    AVPlayer.MSEThread.setCurrentTime(this.taskId, time);
                }
                lastNotifyTime = time;
            }
        };
        element.onended = () => {
            this.audioEnded = true;
            this.videoEnded = true;
            this.handleEnded();
        };
        element.onwaiting = () => {
            if (this.audio === element) {
                this.stats.audioStutter++;
            }
            else {
                this.stats.audioStutter++;
                this.stats.videoStutter++;
            }
        };
        element.oncanplay = () => {
            if (this.status === 6 /* AVPlayerStatus.PLAYED */) {
                element.play();
            }
        };
    }
    async handleEnded() {
        if (this.audioEnded && this.videoEnded) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`player ended, taskId: ${this.taskId}`, cheap__fileName__15, 546);
            if (this.options.loop && !this.options.isLive) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`loop play, taskId: ${this.taskId}`, cheap__fileName__15, 550);
                if ( true && this.isHls()) {
                    await AVPlayer.DemuxerThread.seek(this.taskId, BigInt(0), 16 /* AVSeekFlags.TIMESTAMP */);
                }
                else if ( true && this.isDash()) {
                    await AVPlayer.DemuxerThread.seek(this.taskId, BigInt(0), 16 /* AVSeekFlags.TIMESTAMP */);
                    if ( true && this.subTaskId) {
                        await AVPlayer.DemuxerThread.seek(this.subTaskId, BigInt(0), 16 /* AVSeekFlags.TIMESTAMP */);
                    }
                    if (( true) && this.subtitleTaskId) {
                        await AVPlayer.DemuxerThread.seek(this.subtitleTaskId, BigInt(0), 16 /* AVSeekFlags.TIMESTAMP */);
                    }
                }
                else {
                    await AVPlayer.DemuxerThread.seek(this.taskId, BigInt(0), 8 /* AVSeekFlags.FRAME */);
                }
                for (let i = 0; i < this.externalSubtitleTasks.length; i++) {
                    await AVPlayer.DemuxerThread.seek(this.externalSubtitleTasks[0].taskId, BigInt(0), 8 /* AVSeekFlags.FRAME */);
                }
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.TIME, [BigInt(0)]);
                if ( true && this.useMSE) {
                    if ((this.video || this.audio)?.src) {
                        URL.revokeObjectURL((this.video || this.audio).src);
                    }
                    await AVPlayer.MSEThread.restart(this.taskId);
                    const mediaSource = await AVPlayer.MSEThread.getMediaSource(this.taskId);
                    if (mediaSource) {
                        if (common_util_support__WEBPACK_IMPORTED_MODULE_34__["default"].workerMSE && mediaSource instanceof MediaSourceHandle) {
                            (this.video || this.audio).srcObject = mediaSource;
                        }
                        else {
                            (this.video || this.audio).src = URL.createObjectURL(mediaSource);
                        }
                        if (this.video) {
                            this.video.currentTime = 0;
                            this.video.playbackRate = this.playRate;
                        }
                        else if (this.audio) {
                            this.audio.currentTime = 0;
                            this.audio.playbackRate = this.playRate;
                        }
                        await Promise.all([
                            this.video?.play(),
                            this.audio?.play()
                        ]);
                    }
                }
                else {
                    if (this.audioDecoder2AudioRenderChannel) {
                        await AVPlayer.AudioDecoderThread.resetTask(this.taskId);
                        await AVPlayer.AudioRenderThread.restart(this.taskId);
                    }
                    if (this.audioSourceNode) {
                        await this.audioSourceNode.request('restart');
                        if (AVPlayer.audioContext.state === 'suspended') {
                            await AVPlayer.AudioRenderThread.fakePlay(this.taskId);
                        }
                        this.audioEnded = false;
                    }
                    if (this.videoDecoder2VideoRenderChannel) {
                        await this.VideoDecoderThread.resetTask(this.taskId);
                        await AVPlayer.VideoRenderThread.restart(this.taskId);
                        this.videoEnded = false;
                    }
                }
                if (this.subtitleRender) {
                    this.subtitleRender.reset();
                    this.subtitleRender.start();
                }
            }
            else {
                if ((this.video || this.audio)?.src) {
                    URL.revokeObjectURL((this.video || this.audio).src);
                }
                if (this.video) {
                    this.options.container.removeChild(this.video);
                    this.video = null;
                }
                if (this.audio) {
                    this.options.container.removeChild(this.audio);
                    this.audio = null;
                }
                if (this.canvas) {
                    this.options.container.removeChild(this.canvas);
                    this.canvas = null;
                }
                await this.stop();
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.ENDED);
            }
        }
    }
    /**
     * 当前播放的源是否是 hls
     *
     * @returns
     */
    isHls() {
        return this.ext === 'm3u8' || this.ext === 'm3u';
    }
    /**
     * 当前播放的源是否是 dash
     *
     * @returns
     */
    isDash() {
        return this.ext === 'mpd';
    }
    async getResource(type, codecId, mediaType) {
        const key = codecId != null ? `${type}-${codecId}` : type;
        if (AVPlayer.Resource.has(key)) {
            return AVPlayer.Resource.get(key);
        }
        const wasmUrl = this.options.getWasm(type, codecId, mediaType);
        let resource;
        if (wasmUrl) {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_18__.string(wasmUrl) || common_util_is__WEBPACK_IMPORTED_MODULE_18__.arrayBuffer(wasmUrl)) {
                resource = await (0,cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_20__["default"])({
                    source: wasmUrl
                });
                if (cheap_config__WEBPACK_IMPORTED_MODULE_26__.USE_THREADS && true && mediaType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    resource.threadModule = await (0,cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_20__["default"])({
                        // firefox 使用 arraybuffer 会卡主
                        source: common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].firefox ? wasmUrl : resource.buffer
                    }, {
                        child: true
                    });
                }
                delete resource.buffer;
            }
            else {
                resource = wasmUrl;
            }
            AVPlayer.Resource.set(key, resource);
            return resource;
        }
    }
    createSubtitleRender(subtitleStream, taskId) {
        this.subtitleRender = new _subtitle_SubtitleRender__WEBPACK_IMPORTED_MODULE_59__["default"]({
            dom: this.canvas || this.video || this.options.container,
            getCurrentTime: () => {
                return this.currentTime;
            },
            avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
            avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
            codecpar: subtitleStream.codecpar,
            container: this.options.container,
            videoWidth: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](this.selectedVideoStream?.codecpar + 56) ?? 0,
            videoHeight: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](this.selectedVideoStream?.codecpar + 60) ?? 0
        });
        this.subtitleRender.setDemuxTask(taskId);
        this.selectedSubtitleStream = subtitleStream;
        if (taskId === this.taskId) {
            this.lastSelectedInnerSubtitleStreamIndex = subtitleStream.index;
        }
        AVPlayer.DemuxerThread.connectStreamTask.transfer(this.subtitleRender.getDemuxerPort(taskId))
            .invoke(taskId, subtitleStream.index, this.subtitleRender.getDemuxerPort(taskId));
    }
    /**
     * 加载外挂字幕
     *
     * @param externalSubtitle
     * @returns
     */
    async loadExternalSubtitle(externalSubtitle) {
        if (this.status === 1 /* AVPlayerStatus.DESTROYING */ || this.status === 2 /* AVPlayerStatus.DESTROYED */) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal('player has already destroyed', cheap__fileName__15, 743);
        }
        if (!externalSubtitle.source) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal('external subtitle must has source', cheap__fileName__15, 747);
        }
        if (this.externalSubtitleTasks.some((task) => task.source === externalSubtitle.source)) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn('external subtitle has already loaded', cheap__fileName__15, 751);
            return;
        }
        const taskId = (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_17__["default"])();
        const ioloader2DemuxerChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_42__["default"])();
        const externalSubtitleTask = common_util_object__WEBPACK_IMPORTED_MODULE_19__.extend({
            taskId,
            streamId: -1,
            ioloader2DemuxerChannel
        }, externalSubtitle);
        let ext = '';
        let ret = 0;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_18__.string(externalSubtitle.source)) {
            ext = common_util_url__WEBPACK_IMPORTED_MODULE_25__.parse(externalSubtitle.source).file.split('.').pop();
            ret = await AVPlayer.IOThread.registerTask
                .transfer(ioloader2DemuxerChannel.port1)
                .invoke({
                type: 0 /* IOType.Fetch */,
                info: {
                    url: externalSubtitle.source
                },
                range: {
                    from: -1,
                    to: -1
                },
                taskId: taskId,
                options: {
                    isLive: this.options.isLive
                },
                rightPort: ioloader2DemuxerChannel.port1,
                stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]
            });
        }
        else {
            ext = externalSubtitle.source.name.split('.').pop();
            ret = await AVPlayer.IOThread.registerTask
                .transfer(ioloader2DemuxerChannel.port1)
                .invoke({
                type: 1 /* IOType.File */,
                info: {
                    file: externalSubtitle.source
                },
                range: {
                    from: -1,
                    to: -1
                },
                taskId: taskId,
                options: {
                    isLive: this.options.isLive
                },
                rightPort: ioloader2DemuxerChannel.port1,
                stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]
            });
        }
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`register io task failed, ret: ${ret}, taskId: ${this.taskId}`, cheap__fileName__15, 812);
        }
        await AVPlayer.DemuxerThread.registerTask.transfer(ioloader2DemuxerChannel.port2)
            .invoke({
            taskId: taskId,
            leftPort: ioloader2DemuxerChannel.port2,
            format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_54__.Ext2Format[ext],
            stats: 0,
            isLive: false,
            flags: 0,
            avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
            avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
        });
        ret = await AVPlayer.DemuxerThread.openStream(taskId);
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`open external subtitle failed, ret: ${ret}, taskId: ${taskId}`, cheap__fileName__15, 829);
        }
        let formatContext = await AVPlayer.DemuxerThread.analyzeStreams(taskId);
        if (common_util_is__WEBPACK_IMPORTED_MODULE_18__.number(formatContext) || !formatContext.streams.length) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`analyze stream failed, ret: ${formatContext}`, cheap__fileName__15, 833);
        }
        const stream = formatContext.streams[0];
        this.formatContext.streams.push(stream);
        externalSubtitleTask.streamId = stream.id;
        if (externalSubtitle.lang) {
            stream.metadata['language'] = externalSubtitle.lang;
        }
        if (externalSubtitle.title) {
            stream.metadata['title'] = externalSubtitle.title;
        }
        const handleStatus = this.status === 7 /* AVPlayerStatus.PAUSED */
            || this.status === 6 /* AVPlayerStatus.PLAYED */
            || this.status === 8 /* AVPlayerStatus.SEEKING */
            || this.status === 9 /* AVPlayerStatus.CHANGING */;
        if (handleStatus) {
            await AVPlayer.DemuxerThread.seek(taskId, this.currentTime, 8 /* AVSeekFlags.FRAME */);
        }
        if (handleStatus && !this.subtitleRender) {
            this.createSubtitleRender(stream, taskId);
            this.subtitleRender.start();
        }
        else if (this.subtitleRender) {
            await AVPlayer.DemuxerThread.connectStreamTask.transfer(this.subtitleRender.getDemuxerPort(taskId))
                .invoke(taskId, stream.index, this.subtitleRender.getDemuxerPort(taskId));
        }
        await AVPlayer.DemuxerThread.startDemux(taskId, false, 10);
        this.externalSubtitleTasks.push(externalSubtitleTask);
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.STREAM_UPDATE);
        return 0;
    }
    /**
     * 加载媒体源，分析流信息
     *
     * @param source 媒体源，支持 url 和 文件
     * @param externalSubtitles 外挂字幕源
     */
    async load(source, externalSubtitles = []) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`call load, taskId: ${this.taskId}`, cheap__fileName__15, 883);
        this.status = 3 /* AVPlayerStatus.LOADING */;
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.LOADING);
        this.controller = new _Controller__WEBPACK_IMPORTED_MODULE_30__["default"](this);
        this.ioloader2DemuxerChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_42__["default"])();
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_41__.memset)(this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress], 0, 328);
        this.externalSubtitleTasks.length = 0;
        await AVPlayer.startDemuxPipeline();
        let ret = 0;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_18__.string(source)) {
            this.ext = common_util_url__WEBPACK_IMPORTED_MODULE_25__.parse(source).file.split('.').pop();
            // 注册一个 url io 任务
            ret = await AVPlayer.IOThread.registerTask
                .transfer(this.ioloader2DemuxerChannel.port1)
                .invoke({
                type: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_54__.Ext2IOLoader[this.ext] ?? 0 /* IOType.Fetch */,
                info: {
                    url: source
                },
                range: {
                    from: -1,
                    to: -1
                },
                taskId: this.taskId,
                options: {
                    isLive: this.options.isLive
                },
                rightPort: this.ioloader2DemuxerChannel.port1,
                stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]
            });
        }
        else {
            this.options.isLive = false;
            this.ext = source.name.split('.').pop();
            // 注册一个文件 io 任务
            ret = await AVPlayer.IOThread.registerTask
                .transfer(this.ioloader2DemuxerChannel.port1)
                .invoke({
                type: 1 /* IOType.File */,
                info: {
                    file: source
                },
                range: {
                    from: -1,
                    to: -1
                },
                taskId: this.taskId,
                options: {
                    isLive: false
                },
                rightPort: this.ioloader2DemuxerChannel.port1,
                stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]
            });
        }
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`register io task failed, ret: ${ret}, taskId: ${this.taskId}`, cheap__fileName__15, 944);
        }
        if ( true && this.isDash()) {
            await AVPlayer.IOThread.open(this.taskId);
            const hasAudio = await AVPlayer.IOThread.hasAudio(this.taskId);
            const hasVideo = await AVPlayer.IOThread.hasVideo(this.taskId);
            if (hasAudio && hasVideo) {
                // dash 因为音视频各自独立，因此这里注册两个解封装任务
                this.subTaskId = (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_17__["default"])();
                await AVPlayer.DemuxerThread.registerTask
                    .transfer(this.ioloader2DemuxerChannel.port2, this.controller.getDemuxerControlPort())
                    .invoke({
                    taskId: this.taskId,
                    leftPort: this.ioloader2DemuxerChannel.port2,
                    controlPort: this.controller.getDemuxerControlPort(),
                    format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_54__.Ext2Format[this.ext],
                    stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    isLive: this.options.isLive,
                    flags: 2 /* IOFlags.SLICE */,
                    ioloaderOptions: {
                        mediaType: 'audio'
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
                });
                await AVPlayer.DemuxerThread.registerTask({
                    taskId: this.subTaskId,
                    mainTaskId: this.taskId,
                    flags: 2 /* IOFlags.SLICE */,
                    format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_54__.Ext2Format[this.ext],
                    stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    isLive: this.options.isLive,
                    ioloaderOptions: {
                        mediaType: 'video'
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
                });
            }
            else {
                // dash 只有一个媒体类型
                await AVPlayer.DemuxerThread.registerTask
                    .transfer(this.ioloader2DemuxerChannel.port2, this.controller.getDemuxerControlPort())
                    .invoke({
                    taskId: this.taskId,
                    leftPort: this.ioloader2DemuxerChannel.port2,
                    controlPort: this.controller.getDemuxerControlPort(),
                    format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_54__.Ext2Format[this.ext],
                    stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    isLive: this.options.isLive,
                    flags: 2 /* IOFlags.SLICE */,
                    ioloaderOptions: {
                        mediaType: hasAudio ? 'audio' : 'video'
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
                });
            }
        }
        else {
            await AVPlayer.DemuxerThread.registerTask
                .transfer(this.ioloader2DemuxerChannel.port2, this.controller.getDemuxerControlPort())
                .invoke({
                taskId: this.taskId,
                leftPort: this.ioloader2DemuxerChannel.port2,
                controlPort: this.controller.getDemuxerControlPort(),
                format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_54__.Ext2Format[this.ext],
                stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                isLive: this.options.isLive,
                flags: this.isHls() ? 2 /* IOFlags.SLICE */ : 0,
                avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
            });
        }
        if ( true && this.isDash() ||  true && this.isHls()) {
            const hasSubtitle = await AVPlayer.IOThread.hasSubtitle(this.taskId);
            if (hasSubtitle) {
                // dash 和 hls 的字幕
                this.subtitleTaskId = (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_17__["default"])();
                await AVPlayer.DemuxerThread.registerTask({
                    taskId: this.subtitleTaskId,
                    mainTaskId: this.taskId,
                    flags: 2 /* IOFlags.SLICE */,
                    format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_54__.Ext2Format[this.ext],
                    stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    isLive: this.options.isLive,
                    ioloaderOptions: {
                        mediaType: 'subtitle'
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
                });
            }
        }
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.PROGRESS, [0 /* AVPlayerProgress.OPEN_FILE */]);
        ret = await AVPlayer.DemuxerThread.openStream(this.taskId);
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`open stream failed, ret: ${ret}, taskId: ${this.taskId}`, cheap__fileName__15, 1045);
        }
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.PROGRESS, [1 /* AVPlayerProgress.ANALYZE_FILE */, this.ext]);
        let formatContext = await AVPlayer.DemuxerThread.analyzeStreams(this.taskId);
        if (common_util_is__WEBPACK_IMPORTED_MODULE_18__.number(formatContext) || !formatContext.streams.length) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`analyze stream failed, ret: ${formatContext}`, cheap__fileName__15, 1052);
        }
        if ( true && this.subTaskId) {
            ret = await AVPlayer.DemuxerThread.openStream(this.subTaskId);
            if (ret < 0) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`open stream failed, ret: ${ret}, taskId: ${this.subTaskId}`, cheap__fileName__15, 1058);
            }
            const subFormatContext = await AVPlayer.DemuxerThread.analyzeStreams(this.subTaskId);
            if (common_util_is__WEBPACK_IMPORTED_MODULE_18__.number(subFormatContext) || !subFormatContext.streams.length) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`analyze stream failed, ret: ${subFormatContext}`, cheap__fileName__15, 1062);
            }
            formatContext.streams = formatContext.streams.concat(subFormatContext.streams);
        }
        if (( true) && this.subtitleTaskId) {
            ret = await AVPlayer.DemuxerThread.openStream(this.subtitleTaskId);
            if (ret < 0) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`open subtitle stream failed, ret: ${ret}, taskId: ${this.subtitleTaskId}`, cheap__fileName__15, 1070);
            }
            const subFormatContext = await AVPlayer.DemuxerThread.analyzeStreams(this.subtitleTaskId);
            if (common_util_is__WEBPACK_IMPORTED_MODULE_18__.number(subFormatContext) || !subFormatContext.streams.length) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`analyze subtitle stream failed, ret: ${subFormatContext}`, cheap__fileName__15, 1074);
            }
            formatContext.streams = formatContext.streams.concat(subFormatContext.streams);
        }
        this.formatContext = formatContext;
        this.source = source;
        for (let i = 0; i < externalSubtitles.length; i++) {
            await this.loadExternalSubtitle(externalSubtitles[i]);
        }
        formatContext.streams.forEach((stream) => {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                this.stats.audiocodec = (0,avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_53__["default"])(stream.codecpar);
            }
            else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                this.stats.videocodec = (0,avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_43__["default"])(stream.codecpar);
            }
        });
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info('\n' + (0,avformat_dump__WEBPACK_IMPORTED_MODULE_55__["default"])([formatContext], [{
                from: common_util_is__WEBPACK_IMPORTED_MODULE_18__.string(source) ? source : source.name,
                tag: 'Input'
            }]), cheap__fileName__15, 1095);
        {
            // m3u8 和 dash 的 duration 来自于协议本身
            if (this.isHls() || this.isDash()) {
                const duration = (await AVPlayer.IOThread.getDuration(this.taskId)) * 1000;
                if (duration > 0) {
                    for (let i = 0; i < this.formatContext.streams.length; i++) {
                        this.formatContext.streams[i].duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_38__.avRescaleQ)(BigInt(Math.floor(duration)), avutil_constant__WEBPACK_IMPORTED_MODULE_39__.AV_MILLI_TIME_BASE_Q, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(this.formatContext.streams[i].timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_7__.Rational));
                    }
                }
            }
        }
        if (this.options.isLive && this.options.lowLatency) {
            const min = Math.max(await AVPlayer.IOThread.getMinBuffer(this.taskId), this.options.jitterBufferMin);
            let max = this.options.jitterBufferMax;
            if (max <= min) {
                max = min + ((this.isHls() || this.isDash()) ? min : 1);
            }
            this.jitterBufferController = new _JitterBufferController__WEBPACK_IMPORTED_MODULE_52__["default"]({
                stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                jitterBuffer: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32,
                lowLatencyStart: !(this.isHls() || this.isDash()),
                useMse: this.useMSE,
                max,
                min,
                observer: {
                    onCroppingBuffer: (max) => {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.debug(`cropping buffer by jitter buffer, max: ${max}, taskId: ${this.taskId}`, cheap__fileName__15, 1131);
                        AVPlayer.DemuxerThread?.croppingAVPacketQueue(this.taskId, BigInt(max >>> 0));
                    },
                    onSetPlayRate: (rate) => {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.debug(`set play rate by jitter buffer, rate: ${rate}, taskId: ${this.taskId}`, cheap__fileName__15, 1135);
                        if ( true && this.useMSE) {
                            AVPlayer.MSEThread.setPlayRate(this.taskId, rate);
                            if (this.video) {
                                this.video.playbackRate = rate;
                            }
                            else if (this.audio) {
                                this.audio.playbackRate = rate;
                            }
                        }
                        else {
                            if (this.audioDecoder2AudioRenderChannel) {
                                AVPlayer.AudioRenderThread.setPlayTempo(this.taskId, rate);
                            }
                            if (this.videoDecoder2VideoRenderChannel) {
                                AVPlayer.VideoRenderThread.setPlayRate(this.taskId, rate);
                            }
                        }
                    }
                }
            });
        }
        this.status = 4 /* AVPlayerStatus.LOADED */;
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.LOADED);
    }
    /**
     * 播放
     *
     * @param options
     * @returns
     */
    async play(options = {
        audio: true,
        video: true,
        subtitle: true
    }) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`call play, options: ${JSON.stringify(options)}, status: ${this.status} taskId: ${this.taskId}`, cheap__fileName__15, 1188);
        if (this.status === 6 /* AVPlayerStatus.PLAYED */) {
            return;
        }
        if (!options.audio && !options.video) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn(`video and audio must play one, ignore options, we will try to play video and audio, taskId: ${this.taskId}`, cheap__fileName__15, 1195);
            options.audio = true;
            options.video = true;
        }
        const promises = [];
        if (this.status === 7 /* AVPlayerStatus.PAUSED */) {
            // 逐帧播放之后视频与音频相差可能过大，这里同步一下
            if (this.selectedAudioStream && this.selectedVideoStream && (this.stats.videoCurrentTime - this.stats.audioCurrentTime > BigInt(400))) {
                await AVPlayer.AudioRenderThread.syncSeekTime(this.taskId, this.stats.videoCurrentTime);
            }
            if ( true && this.useMSE) {
                promises.push(AVPlayer.MSEThread.unpause(this.taskId));
                if (this.audio) {
                    this.audio.play();
                }
                else if (this.video) {
                    this.video.play();
                }
            }
            else {
                if (this.audioSourceNode) {
                    promises.push(this.audioSourceNode.request('unpause'));
                    promises.push(AVPlayer.AudioRenderThread.unpause(this.taskId));
                }
                if (this.videoDecoder2VideoRenderChannel) {
                    promises.push(AVPlayer.VideoRenderThread.unpause(this.taskId));
                }
            }
            return Promise.all(promises).then(() => {
                this.status = 6 /* AVPlayerStatus.PLAYED */;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.PLAYED);
                if (this.jitterBufferController) {
                    this.jitterBufferController.start();
                }
                if (this.subtitleRender) {
                    this.subtitleRender.start();
                }
            });
        }
        this.status = 5 /* AVPlayerStatus.PLAYING */;
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.PLAYING);
        this.useMSE = await this.checkUseMSE();
        this.audioEnded = true;
        this.videoEnded = true;
        if ( true && this.useMSE) {
            await AVPlayer.startMSEPipeline();
            const videoStream = this.findBestStream(this.formatContext.streams, 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
            const audioStream = this.findBestStream(this.formatContext.streams, 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
            let hasVideo = false;
            // 注册一个 mse 处理任务
            await AVPlayer.MSEThread.registerTask.transfer(this.controller.getMuxerControlPort())
                .invoke({
                taskId: this.taskId,
                stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                format: await AVPlayer.DemuxerThread.getFormat(this.taskId),
                controlPort: this.controller.getMuxerControlPort(),
                isLive: this.options.isLive,
                avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
                enableJitterBuffer: !!this.jitterBufferController,
                jitterBuffer: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32
            });
            if (videoStream && options.video) {
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.PROGRESS, [3 /* AVPlayerProgress.LOAD_VIDEO_DECODER */, videoStream]);
                hasVideo = true;
                this.selectedVideoStream = videoStream;
                this.videoEnded = false;
                this.demuxer2VideoDecoderChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_42__["default"])();
                await AVPlayer.DemuxerThread.connectStreamTask
                    .transfer(this.demuxer2VideoDecoderChannel.port1)
                    .invoke(this.subTaskId || this.taskId, videoStream.index, this.demuxer2VideoDecoderChannel.port1);
                await AVPlayer.MSEThread.addStream.transfer(this.demuxer2VideoDecoderChannel.port2)
                    .invoke(this.taskId, videoStream.index, videoStream.codecpar, videoStream.timeBase, videoStream.startTime, this.demuxer2VideoDecoderChannel.port2);
            }
            if (audioStream && options.audio) {
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.PROGRESS, [2 /* AVPlayerProgress.LOAD_AUDIO_DECODER */, audioStream]);
                this.selectedAudioStream = audioStream;
                this.audioEnded = false;
                this.demuxer2AudioDecoderChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_42__["default"])();
                await AVPlayer.DemuxerThread.connectStreamTask
                    .transfer(this.demuxer2AudioDecoderChannel.port1)
                    .invoke(this.taskId, audioStream.index, this.demuxer2AudioDecoderChannel.port1);
                await AVPlayer.MSEThread.addStream.transfer(this.demuxer2AudioDecoderChannel.port2)
                    .invoke(this.taskId, audioStream.index, audioStream.codecpar, audioStream.timeBase, audioStream.startTime, this.demuxer2AudioDecoderChannel.port2);
            }
            if (hasVideo) {
                this.createVideo();
            }
            else {
                this.createAudio();
            }
            const mediaSource = await AVPlayer.MSEThread.getMediaSource(this.taskId);
            if (mediaSource) {
                if (common_util_support__WEBPACK_IMPORTED_MODULE_34__["default"].workerMSE && mediaSource instanceof MediaSourceHandle) {
                    (this.video || this.audio).srcObject = mediaSource;
                }
                else {
                    (this.video || this.audio).src = URL.createObjectURL(mediaSource);
                }
                this.handleTimeupdate(this.video || this.audio);
            }
        }
        else {
            let audioStartTime = BigInt(0);
            let videoStartTime = BigInt(0);
            const videoStream = this.findBestStream(this.formatContext.streams, 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
            const audioStream = this.findBestStream(this.formatContext.streams, 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
            if (videoStream && options.video) {
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.PROGRESS, [3 /* AVPlayerProgress.LOAD_VIDEO_DECODER */, videoStream]);
                this.selectedVideoStream = videoStream;
                await this.createVideoDecoderThread();
                await AVPlayer.startVideoRenderPipeline();
                videoStartTime = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_38__.avRescaleQ)(videoStream.startTime, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(videoStream.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_7__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_39__.AV_MILLI_TIME_BASE_Q);
                this.demuxer2VideoDecoderChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_42__["default"])();
                this.videoDecoder2VideoRenderChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_42__["default"])();
                let resource = await this.getResource('decoder', cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar));
                if (!resource) {
                    if (common_util_support__WEBPACK_IMPORTED_MODULE_34__["default"].videoDecoder) {
                        const isSupport = await VideoDecoder.isConfigSupported({
                            codec: (0,avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_43__["default"])(videoStream.codecpar)
                        });
                        if (!isSupport.supported) {
                            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`${(0,avformat_dump__WEBPACK_IMPORTED_MODULE_55__.dumpCodecName)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar + 4))} codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar + 4)} not support`, cheap__fileName__15, 1352);
                        }
                    }
                    else {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`${(0,avformat_dump__WEBPACK_IMPORTED_MODULE_55__.dumpCodecName)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar + 4))} codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar + 4)} not support`, cheap__fileName__15, 1356);
                    }
                }
                // 注册一个视频解码任务
                await this.VideoDecoderThread.registerTask
                    .transfer(this.demuxer2VideoDecoderChannel.port2, this.videoDecoder2VideoRenderChannel.port1)
                    .invoke({
                    taskId: this.taskId,
                    resource,
                    leftPort: this.demuxer2VideoDecoderChannel.port2,
                    rightPort: this.videoDecoder2VideoRenderChannel.port1,
                    stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    enableHardware: this.options.enableHardware,
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
                    avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 12,
                    avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28,
                    preferWebCodecs: !(0,avutil_function_isHdr__WEBPACK_IMPORTED_MODULE_57__["default"])(videoStream.codecpar) && !(0,avutil_function_hasAlphaChannel__WEBPACK_IMPORTED_MODULE_58__["default"])(videoStream.codecpar)
                });
                let ret = await this.VideoDecoderThread.open(this.taskId, videoStream.codecpar);
                if (ret < 0) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`cannot open video ${(0,avformat_dump__WEBPACK_IMPORTED_MODULE_55__.dumpCodecName)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](videoStream.codecpar + 4))} decoder`, cheap__fileName__15, 1379);
                }
                await AVPlayer.DemuxerThread.connectStreamTask
                    .transfer(this.demuxer2VideoDecoderChannel.port1)
                    .invoke(this.subTaskId || this.taskId, videoStream.index, this.demuxer2VideoDecoderChannel.port1);
            }
            if (audioStream && options.audio) {
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.PROGRESS, [2 /* AVPlayerProgress.LOAD_AUDIO_DECODER */, audioStream]);
                this.selectedAudioStream = audioStream;
                await AVPlayer.startAudioPipeline();
                if (AVPlayer.audioContext.state === 'suspended') {
                    await Promise.race([
                        AVPlayer.audioContext.resume(),
                        new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_48__["default"](0.1)
                    ]);
                }
                audioStartTime = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_38__.avRescaleQ)(audioStream.startTime, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(audioStream.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_7__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_39__.AV_MILLI_TIME_BASE_Q);
                this.demuxer2AudioDecoderChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_42__["default"])();
                this.audioDecoder2AudioRenderChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_42__["default"])();
                let resource = await this.getResource('decoder', cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](audioStream.codecpar + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](audioStream.codecpar));
                if (!resource) {
                    if (common_util_support__WEBPACK_IMPORTED_MODULE_34__["default"].audioDecoder) {
                        const isSupport = await AudioDecoder.isConfigSupported({
                            codec: (0,avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_53__["default"])(audioStream.codecpar),
                            sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](audioStream.codecpar + 136),
                            numberOfChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](audioStream.codecpar + 116)
                        });
                        if (!isSupport.supported) {
                            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`${(0,avformat_dump__WEBPACK_IMPORTED_MODULE_55__.dumpCodecName)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](audioStream.codecpar), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](audioStream.codecpar + 4))} codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](audioStream.codecpar + 4)} not support`, cheap__fileName__15, 1413);
                        }
                    }
                    else {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`${(0,avformat_dump__WEBPACK_IMPORTED_MODULE_55__.dumpCodecName)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](audioStream.codecpar), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](audioStream.codecpar + 4))} codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](audioStream.codecpar + 4)} not support`, cheap__fileName__15, 1417);
                    }
                }
                // 注册一个音频解码任务
                await AVPlayer.AudioDecoderThread.registerTask
                    .transfer(this.demuxer2AudioDecoderChannel.port2, this.audioDecoder2AudioRenderChannel.port1)
                    .invoke({
                    taskId: this.taskId,
                    resource,
                    leftPort: this.demuxer2AudioDecoderChannel.port2,
                    rightPort: this.audioDecoder2AudioRenderChannel.port1,
                    stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    timeBase: {
                        num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](audioStream.timeBase),
                        den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](audioStream.timeBase + 4),
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
                    avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 12,
                    avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28
                });
                let ret = await AVPlayer.AudioDecoderThread.open(this.taskId, audioStream.codecpar);
                if (ret < 0) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal(`cannot open audio ${(0,avformat_dump__WEBPACK_IMPORTED_MODULE_55__.dumpCodecName)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](audioStream.codecpar), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](audioStream.codecpar + 4))} decoder`, cheap__fileName__15, 1442);
                }
                await AVPlayer.DemuxerThread.connectStreamTask
                    .transfer(this.demuxer2AudioDecoderChannel.port1)
                    .invoke(this.taskId, audioStream.index, this.demuxer2AudioDecoderChannel.port1);
            }
            if (this.videoDecoder2VideoRenderChannel) {
                this.canvas = this.createCanvas();
                this.options.container.appendChild(this.canvas);
                const canvas = ((0,_function_supportOffscreenCanvas__WEBPACK_IMPORTED_MODULE_32__["default"])() && cheap_config__WEBPACK_IMPORTED_MODULE_26__.USE_THREADS && true)
                    ? this.canvas.transferControlToOffscreen()
                    : this.canvas;
                const stream = this.formatContext.streams.find((stream) => {
                    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */;
                });
                // 注册一个视频渲染任务
                await AVPlayer.VideoRenderThread.registerTask
                    .transfer(this.videoDecoder2VideoRenderChannel.port2, this.controller.getVideoRenderControlPort(), canvas)
                    .invoke({
                    taskId: this.taskId,
                    leftPort: this.videoDecoder2VideoRenderChannel.port2,
                    controlPort: this.controller.getVideoRenderControlPort(),
                    canvas,
                    renderMode: this.renderMode,
                    renderRotate: this.renderRotate,
                    flipHorizontal: this.flipHorizontal,
                    flipVertical: this.flipVertical,
                    timeBase: {
                        num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.timeBase),
                        den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.timeBase + 4),
                    },
                    viewportWidth: this.options.container.offsetWidth,
                    viewportHeight: this.options.container.offsetHeight,
                    devicePixelRatio: devicePixelRatio,
                    stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    enableWebGPU: this.options.enableWebGPU,
                    startPTS: stream.startTime,
                    avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 12,
                    avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28,
                    enableJitterBuffer: !!this.jitterBufferController && !this.audioDecoder2AudioRenderChannel,
                    jitterBuffer: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32
                });
                this.videoEnded = false;
                await AVPlayer.VideoRenderThread.setPlayRate(this.taskId, this.playRate);
                promises.push(AVPlayer.VideoRenderThread.play(this.taskId));
            }
            if (this.audioDecoder2AudioRenderChannel) {
                const stream = this.formatContext.streams.find((stream) => {
                    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */;
                });
                this.audioRender2AudioWorkletChannel = new MessageChannel();
                const playChannels = Math.max(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar + 116), Math.min(AVPlayer.audioContext.destination.channelCount, 2));
                let resamplerResource = await this.getResource('resampler');
                let stretchpitcherResource = await this.getResource('stretchpitcher');
                if (!resamplerResource) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal('resampler not found', cheap__fileName__15, 1511);
                }
                if (!stretchpitcherResource) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_33__.fatal('stretch pitcher not found', cheap__fileName__15, 1514);
                }
                // 注册一个音频渲染任务
                await AVPlayer.AudioRenderThread.registerTask
                    .transfer(this.audioDecoder2AudioRenderChannel.port2, this.audioRender2AudioWorkletChannel.port1, this.controller.getAudioRenderControlPort())
                    .invoke({
                    taskId: this.taskId,
                    leftPort: this.audioDecoder2AudioRenderChannel.port2,
                    rightPort: this.audioRender2AudioWorkletChannel.port1,
                    controlPort: this.controller.getAudioRenderControlPort(),
                    playFormat: 8 /* AVSampleFormat.AV_SAMPLE_FMT_FLTP */,
                    playSampleRate: AVPlayer.audioContext.sampleRate,
                    playChannels: playChannels,
                    resamplerResource,
                    stretchpitcherResource,
                    stats: this.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    timeBase: {
                        num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.timeBase),
                        den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.timeBase + 4),
                    },
                    startPTS: stream.startTime,
                    avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 12,
                    avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28,
                    enableJitterBuffer: !!this.jitterBufferController,
                    jitterBuffer: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32
                });
                // 创建一个音频源节点
                let AudioSource;
                if (common_util_support__WEBPACK_IMPORTED_MODULE_34__["default"].audioWorklet) {
                    AudioSource = avrender_pcm_AudioSourceWorkletNode__WEBPACK_IMPORTED_MODULE_28__["default"];
                }
                else {
                    AudioSource = avrender_pcm_AudioSourceBufferNode__WEBPACK_IMPORTED_MODULE_35__["default"];
                }
                this.audioSourceNode = new AudioSource(AVPlayer.audioContext, {
                    onEnded: () => {
                        this.onAudioEnded();
                    },
                    onFirstRendered: () => {
                        this.onFirstAudioRendered();
                    },
                    onStutter: () => {
                        this.onStutter();
                    }
                }, {
                    numberOfInputs: 1,
                    numberOfOutputs: 1,
                    outputChannelCount: [playChannels]
                });
                if (cheap_config__WEBPACK_IMPORTED_MODULE_26__.USE_THREADS
                    && true
                    && common_util_support__WEBPACK_IMPORTED_MODULE_34__["default"].audioWorklet
                    && (!common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].safari || common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].version, '16.1', true))) {
                    await this.audioSourceNode.request('init', {
                        memory: cheap_heap__WEBPACK_IMPORTED_MODULE_29__.Memory
                    });
                }
                await AVPlayer.AudioRenderThread.setPlayTempo(this.taskId, this.playRate);
                this.gainNode = AVPlayer.audioContext.createGain();
                this.gainNode.connect(AVPlayer.audioContext.destination);
                this.audioSourceNode.connect(this.gainNode);
                this.setVolume(this.volume);
                this.audioEnded = false;
                promises.push(this.audioSourceNode.request('start', {
                    port: this.audioRender2AudioWorkletChannel.port2,
                    channels: playChannels
                }, [this.audioRender2AudioWorkletChannel.port2]));
            }
            if (this.audioDecoder2AudioRenderChannel) {
                this.controller.setTimeUpdateListenType(1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
            }
            else if (this.videoDecoder2VideoRenderChannel) {
                this.controller.setTimeUpdateListenType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
            }
            // 开始时间戳超过 10 秒不对齐就不再同步音视频了
            // 这种情况下可视为音频和视频本身就是独立的，各自播放
            if (this.videoDecoder2VideoRenderChannel
                && this.audioDecoder2AudioRenderChannel
                && common_util_bigint__WEBPACK_IMPORTED_MODULE_50__.abs(videoStartTime - audioStartTime) > BigInt(10000)) {
                this.controller.setEnableAudioVideoSync(false);
            }
        }
        const subtitleStream = this.findBestStream(this.formatContext.streams, 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */);
        if (subtitleStream && options.subtitle && this.isCodecIdSupported(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](subtitleStream.codecpar + 4))) {
            const externalTask = this.externalSubtitleTasks.find((task) => {
                return task.streamId === subtitleStream.id;
            });
            this.createSubtitleRender(subtitleStream, externalTask ? externalTask.taskId : (this.subtitleTaskId || this.taskId));
        }
        if (this.subtitleRender && this.externalSubtitleTasks.length) {
            for (let i = 0; i < this.externalSubtitleTasks.length; i++) {
                const stream = this.formatContext.streams.find((s => s.id === this.externalSubtitleTasks[i].streamId));
                await AVPlayer.DemuxerThread.connectStreamTask.transfer(this.subtitleRender.getDemuxerPort(this.externalSubtitleTasks[i].taskId))
                    .invoke(this.externalSubtitleTasks[i].taskId, stream.index, this.subtitleRender.getDemuxerPort(this.externalSubtitleTasks[i].taskId));
            }
        }
        let minQueueLength = 10;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_18__.string(this.source) && !this.options.isLive) {
            this.formatContext.streams.forEach((stream) => {
                minQueueLength = Math.max(Math.ceil((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_38__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(stream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_7__.Rational)) * this.options.preLoadTime), minQueueLength);
            });
        }
        promises.push(AVPlayer.DemuxerThread.startDemux(this.taskId, this.options.isLive, minQueueLength));
        if ( true && this.subTaskId) {
            promises.push(AVPlayer.DemuxerThread.startDemux(this.subTaskId, this.options.isLive, minQueueLength));
        }
        if (( true) && this.subtitleTaskId) {
            promises.push(AVPlayer.DemuxerThread.startDemux(this.subtitleTaskId, this.options.isLive, minQueueLength));
        }
        return Promise.all(promises).then(async () => {
            this.status = 6 /* AVPlayerStatus.PLAYED */;
            if ( true && this.useMSE) {
                await Promise.all([
                    this.video?.play(),
                    this.audio?.play()
                ]).catch((error) => {
                    if (this.video) {
                        this.video.muted = true;
                        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.RESUME);
                        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn('the audioContext was not started. It must be resumed after a user gesture', cheap__fileName__15, 1656);
                        return this.video.play();
                    }
                    else {
                        throw error;
                    }
                });
            }
            else {
                if (this.audioSourceNode && AVPlayer.audioContext.state === 'suspended') {
                    if (AVPlayer.audioContext.state === 'suspended') {
                        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.RESUME);
                        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn('the audioContext was not started. It must be resumed after a user gesture', cheap__fileName__15, 1668);
                    }
                    if (this.videoDecoder2VideoRenderChannel) {
                        AVPlayer.AudioRenderThread.fakePlay(this.taskId);
                        this.controller.setTimeUpdateListenType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
                    }
                    else {
                        // 只有音频无法播放时直接抛错，和 mse 行为保持一致
                        throw new Error('the audioContext was not started. It must be resumed after a user gesture');
                    }
                }
            }
            this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.PLAYED);
            this.statsController.start();
            if (this.jitterBufferController) {
                this.jitterBufferController.start();
            }
            if (this.subtitleRender) {
                this.subtitleRender.start();
            }
        });
    }
    /**
     * 暂停播放
     */
    async pause() {
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`call pause, taskId: ${this.taskId}`, cheap__fileName__15, 1696);
        if (!this.options.isLive) {
            const promises = [];
            if ( true && this.useMSE) {
                if (this.audio) {
                    this.audio.pause();
                }
                if (this.video) {
                    this.video.pause();
                }
                promises.push(AVPlayer.MSEThread.pause(this.taskId));
            }
            else {
                if (this.audioSourceNode) {
                    promises.push(this.audioSourceNode.request('pause'));
                    // stop fake play
                    promises.push(AVPlayer.AudioRenderThread.pause(this.taskId));
                }
                if (this.videoDecoder2VideoRenderChannel) {
                    promises.push(AVPlayer.VideoRenderThread.pause(this.taskId));
                }
            }
            return Promise.all(promises).then(() => {
                if (this.status === 8 /* AVPlayerStatus.SEEKING */) {
                    this.lastStatus = 7 /* AVPlayerStatus.PAUSED */;
                }
                else {
                    this.status = 7 /* AVPlayerStatus.PAUSED */;
                }
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.PAUSED);
                if (this.jitterBufferController) {
                    this.jitterBufferController.stop();
                }
                if (this.subtitleRender) {
                    this.subtitleRender.pause();
                }
            });
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn(`pause can only used in vod, taskId: ${this.taskId}`, cheap__fileName__15, 1736);
        }
    }
    async doSeek(timestamp, streamIndex, options = {}) {
        if ( true && this.useMSE) {
            await AVPlayer.MSEThread.beforeSeek(this.taskId);
        }
        else {
            await Promise.all([
                AVPlayer.AudioRenderThread?.beforeSeek(this.taskId),
                AVPlayer.VideoRenderThread?.beforeSeek(this.taskId)
            ]);
        }
        if (options.onBeforeSeek) {
            await options.onBeforeSeek();
        }
        let seekedTimestamp = -BigInt(1);
        if ( true && this.isHls()) {
            seekedTimestamp = await AVPlayer.DemuxerThread.seek(this.taskId, timestamp, 16 /* AVSeekFlags.TIMESTAMP */);
        }
        else if ( true && this.isDash()) {
            seekedTimestamp = await AVPlayer.DemuxerThread.seek(this.taskId, timestamp, 16 /* AVSeekFlags.TIMESTAMP */);
            if (this.subTaskId) {
                await AVPlayer.DemuxerThread.seek(this.subTaskId, timestamp, 16 /* AVSeekFlags.TIMESTAMP */);
            }
        }
        else {
            seekedTimestamp = await AVPlayer.DemuxerThread.seek(this.taskId, timestamp, 8 /* AVSeekFlags.FRAME */, streamIndex);
        }
        if (( true) && this.subtitleTaskId) {
            await AVPlayer.DemuxerThread.seek(this.subtitleTaskId, timestamp, 16 /* AVSeekFlags.TIMESTAMP */);
        }
        if (seekedTimestamp >= BigInt(0)) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.debug(`seeked to packet timestamp: ${seekedTimestamp}, taskId: ${this.taskId}`, cheap__fileName__15, 1778);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.error(`demuxer seek failed, code: ${seekedTimestamp}, taskId: ${this.taskId}`, cheap__fileName__15, 1781);
        }
        for (let i = 0; i < this.externalSubtitleTasks.length; i++) {
            await AVPlayer.DemuxerThread.seek(this.externalSubtitleTasks[i].taskId, timestamp, 8 /* AVSeekFlags.FRAME */);
        }
        if (this.subtitleRender) {
            this.subtitleRender.reset();
        }
        if ( true && this.useMSE) {
            if (seekedTimestamp >= BigInt(0)) {
                const time = await AVPlayer.MSEThread.afterSeek(this.taskId, seekedTimestamp > timestamp ? seekedTimestamp : timestamp);
                if (this.video) {
                    this.video.currentTime = time;
                }
                else if (this.audio) {
                    this.audio.currentTime = time;
                }
            }
            else {
                await AVPlayer.MSEThread.afterSeek(this.taskId, avutil_constant__WEBPACK_IMPORTED_MODULE_39__.NOPTS_VALUE_BIGINT);
            }
        }
        else {
            let maxQueueLength = 20;
            this.formatContext.streams.forEach((stream) => {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    maxQueueLength = Math.max(Math.ceil((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_38__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(stream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_7__.Rational))), maxQueueLength);
                }
            });
            if (seekedTimestamp >= BigInt(0)) {
                await Promise.all([
                    AVPlayer.AudioDecoderThread?.resetTask(this.taskId),
                    this.VideoDecoderThread?.resetTask(this.taskId)
                ]);
                await Promise.all([
                    AVPlayer.AudioRenderThread?.syncSeekTime(this.taskId, seekedTimestamp > timestamp ? seekedTimestamp : timestamp, maxQueueLength),
                    AVPlayer.VideoRenderThread?.syncSeekTime(this.taskId, seekedTimestamp > timestamp ? seekedTimestamp : timestamp, maxQueueLength),
                ]);
                await Promise.all([
                    AVPlayer.AudioRenderThread?.afterSeek(this.taskId, seekedTimestamp > timestamp ? seekedTimestamp : timestamp),
                    AVPlayer.VideoRenderThread?.afterSeek(this.taskId, seekedTimestamp > timestamp ? seekedTimestamp : timestamp),
                ]);
            }
            else {
                await Promise.all([
                    AVPlayer.AudioRenderThread?.syncSeekTime(this.taskId, avutil_constant__WEBPACK_IMPORTED_MODULE_39__.NOPTS_VALUE_BIGINT, maxQueueLength),
                    AVPlayer.VideoRenderThread?.syncSeekTime(this.taskId, avutil_constant__WEBPACK_IMPORTED_MODULE_39__.NOPTS_VALUE_BIGINT, maxQueueLength),
                ]);
                await Promise.all([
                    AVPlayer.AudioRenderThread?.afterSeek(this.taskId, avutil_constant__WEBPACK_IMPORTED_MODULE_39__.NOPTS_VALUE_BIGINT),
                    AVPlayer.VideoRenderThread?.afterSeek(this.taskId, avutil_constant__WEBPACK_IMPORTED_MODULE_39__.NOPTS_VALUE_BIGINT),
                ]);
            }
            if (this.jitterBufferController) {
                this.jitterBufferController.reset();
            }
        }
    }
    /**
     * 跳转到指定时间戳位置播放（只支持点播）
     * 某些文件可能不会 seek 成功
     *
     * @param timestamp 毫秒
     */
    async seek(timestamp) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`call seek, timestamp: ${timestamp}, taskId: ${this.taskId}`, cheap__fileName__15, 1859);
        if (!this.formatContext.streams.length) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.error(`cannot found any stream to seek, taskId: ${this.taskId}`, cheap__fileName__15, 1862);
            return;
        }
        if (this.status === 8 /* AVPlayerStatus.SEEKING */) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn(`player is seeking now, taskId: ${this.taskId}`, cheap__fileName__15, 1867);
            return;
        }
        if (!this.options.isLive) {
            this.lastStatus = this.status;
            this.status = 8 /* AVPlayerStatus.SEEKING */;
            this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.SEEKING);
            let streamIndex = -1;
            if (this.selectedVideoStream) {
                streamIndex = this.selectedVideoStream.index;
            }
            else if (this.selectedAudioStream) {
                streamIndex = this.selectedAudioStream.index;
            }
            await this.doSeek(timestamp, streamIndex);
            this.status = this.lastStatus;
            this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.SEEKED);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn(`seek can only used in vod, taskId: ${this.taskId}`, cheap__fileName__15, 1892);
        }
    }
    /**
     * 获取流信息
     *
     * @returns
     */
    getStreams() {
        return this.formatContext.streams.map((stream) => {
            return {
                ...stream,
                /**
                 * 媒体类型
                 */
                mediaType: (0,avformat_dump__WEBPACK_IMPORTED_MODULE_55__.dumpKey)(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_54__.mediaType2AVMediaType, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar)),
                codecparProxy: (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(stream.codecpar, _avutil_struct_avcodecparameters_ts__WEBPACK_IMPORTED_MODULE_9__["default"]),
                timeBaseProxy: (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(stream.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_7__.Rational)
            };
        });
    }
    /**
     * 获取当前选择播放的视频流 id
     *
     * @returns
     */
    getSelectedVideoStreamId() {
        if (this.selectedVideoStream) {
            return this.selectedVideoStream.id;
        }
        return -1;
    }
    /**
     * 获取当前选择播放的音频流 id
     *
     * @returns
     */
    getSelectedAudioStreamId() {
        if (this.selectedAudioStream) {
            return this.selectedAudioStream.id;
        }
        return -1;
    }
    /**
     * 获取当前选择播放的字幕流 id
     *
     * @returns
     */
    getSelectedSubtitleStreamId() {
        if (this.selectedSubtitleStream) {
            return this.selectedSubtitleStream.id;
        }
        return -1;
    }
    /**
     * 获取章节信息
     *
     * @returns
     */
    getChapters() {
        return this.formatContext.chapters;
    }
    /**
     * 获取总时长（毫秒）
     *
     * @returns
     */
    getDuration() {
        if (!this.options.isLive) {
            let max = BigInt(0);
            this.formatContext.streams.forEach((stream) => {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                    || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    const duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_38__.avRescaleQ)(stream.duration, {
                        den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.timeBase + 4),
                        num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.timeBase)
                    }, avutil_constant__WEBPACK_IMPORTED_MODULE_39__.AV_MILLI_TIME_BASE_Q);
                    if (duration > max) {
                        max = duration;
                    }
                }
            });
            return max;
        }
        return BigInt(0);
    }
    /**
     * 停止播放
     *
     * @returns
     */
    async stop() {
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`call stop, taskId: ${this.taskId}`, cheap__fileName__15, 1997);
        if (this.status === 0 /* AVPlayerStatus.STOPPED */) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn(`player has already stopped, taskId: ${this.taskId}`, cheap__fileName__15, 2000);
            return;
        }
        if (this.audioSourceNode) {
            await this.audioSourceNode.request('stop');
            this.audioSourceNode.disconnect();
            this.audioSourceNode = null;
        }
        if (AVPlayer.VideoRenderThread) {
            await AVPlayer.VideoRenderThread.unregisterTask(this.taskId);
        }
        if (AVPlayer.AudioRenderThread) {
            await AVPlayer.AudioRenderThread.unregisterTask(this.taskId);
        }
        if (this.VideoDecoderThread) {
            await this.VideoDecoderThread.unregisterTask(this.taskId);
        }
        if (AVPlayer.AudioDecoderThread) {
            await AVPlayer.AudioDecoderThread.unregisterTask(this.taskId);
        }
        if (AVPlayer.MSEThread) {
            await AVPlayer.MSEThread.unregisterTask(this.taskId);
        }
        if (AVPlayer.DemuxerThread) {
            await AVPlayer.DemuxerThread.unregisterTask(this.taskId);
            if ( true && this.subTaskId) {
                await AVPlayer.DemuxerThread.unregisterTask(this.subTaskId);
            }
            if (( true) && this.subtitleTaskId) {
                await AVPlayer.DemuxerThread.unregisterTask(this.subtitleTaskId);
            }
        }
        if (AVPlayer.IOThread) {
            await AVPlayer.IOThread.unregisterTask(this.taskId);
        }
        for (let i = 0; i < this.externalSubtitleTasks.length; i++) {
            await AVPlayer.DemuxerThread.unregisterTask(this.externalSubtitleTasks[i].taskId);
            await AVPlayer.IOThread.unregisterTask(this.externalSubtitleTasks[i].taskId);
        }
        if (this.subtitleRender) {
            this.subtitleRender.destroy();
            this.subtitleRender = null;
        }
        if (this.gainNode) {
            this.gainNode.disconnect();
            this.gainNode = null;
        }
        if (this.controller) {
            this.controller.destroy();
        }
        if ((this.video || this.audio)?.src) {
            URL.revokeObjectURL((this.video || this.audio).src);
        }
        if (this.video) {
            this.options.container.removeChild(this.video);
            this.video = null;
        }
        if (this.audio) {
            this.options.container.removeChild(this.audio);
            this.audio = null;
        }
        if (this.canvas) {
            this.options.container.removeChild(this.canvas);
            this.canvas = null;
        }
        this.ioloader2DemuxerChannel = null;
        this.demuxer2VideoDecoderChannel = null;
        this.demuxer2AudioDecoderChannel = null;
        this.videoDecoder2VideoRenderChannel = null;
        this.audioDecoder2AudioRenderChannel = null;
        this.audioRender2AudioWorkletChannel = null;
        this.selectedAudioStream = null;
        this.selectedVideoStream = null;
        this.selectedSubtitleStream = null;
        this.lastSelectedInnerSubtitleStreamIndex = -1;
        this.source = null;
        this.ext = '';
        this.statsController.stop();
        if (this.jitterBufferController) {
            this.jitterBufferController.stop();
            this.jitterBufferController = null;
        }
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.STOPPED);
        this.status = 0 /* AVPlayerStatus.STOPPED */;
    }
    /*
    * 设置播放速率（只支持点播）
    *
    * @param rate
    */
    setPlaybackRate(rate) {
        if (!this.options.isLive) {
            this.playRate = (0,common_function_restrain__WEBPACK_IMPORTED_MODULE_36__["default"])(rate, 0.5, 2);
            if ( true && this.useMSE) {
                AVPlayer.MSEThread.setPlayRate(this.taskId, this.playRate);
                if (this.video) {
                    this.video.playbackRate = this.playRate;
                }
                else if (this.audio) {
                    this.audio.playbackRate = this.playRate;
                }
            }
            else {
                AVPlayer.AudioRenderThread?.setPlayTempo(this.taskId, this.playRate);
                AVPlayer.VideoRenderThread?.setPlayRate(this.taskId, this.playRate);
                this.VideoDecoderThread?.setPlayRate(this.taskId, this.playRate);
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`player call setPlaybackRate, set ${this.playRate}, taskId: ${this.taskId}`, cheap__fileName__15, 2117);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn(`setPlaybackRate can only used in playback, taskId: ${this.taskId}`, cheap__fileName__15, 2120);
        }
    }
    /**
     * 获取倍数值
     *
     * @returns
     */
    getPlaybackRate() {
        return this.playRate;
    }
    /**
     * resume 音频
     */
    async resume() {
        if (AVPlayer.audioContext?.state === 'suspended') {
            await Promise.race([
                AVPlayer.audioContext.resume(),
                new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_48__["default"](0.1)
            ]);
            if (AVPlayer.audioContext.state === 'suspended') {
                common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn('the audioContext was not allowed to start. It must be resumed after a user gesture', cheap__fileName__15, 2143);
            }
            else {
                if (this.audioSourceNode) {
                    this.controller.setTimeUpdateListenType(1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
                }
                if (this.video) {
                    this.video.muted = false;
                }
            }
        }
        if (this.video) {
            this.video.muted = false;
            if (!this.video.played) {
                await this.video.play();
            }
        }
        else if (this.audio) {
            this.audio.muted = false;
            if (!this.audio.played) {
                await this.audio.play();
            }
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`call resume, taskId: ${this.taskId}`, cheap__fileName__15, 2167);
    }
    /**
     * 获取播放音量
     *
     * @returns
     */
    getVolume() {
        return this.volume;
    }
    /**
     * 设置播放音量
     *
     * @param volume [0, 3]
     *
     */
    setVolume(volume, force = false) {
        this.volume = (0,common_function_restrain__WEBPACK_IMPORTED_MODULE_36__["default"])(volume, 0, 3);
        if (this.gainNode && AVPlayer.audioContext) {
            this.gainNode.gain.cancelScheduledValues(AVPlayer.audioContext.currentTime);
            if (common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].firefox && !force) {
                this.gainNode.gain.setValueAtTime(this.volume, AVPlayer.audioContext.currentTime + 1);
            }
            else {
                if (this.gainNode.gain.value === 0 || this.volume === 0 || force) {
                    this.gainNode.gain.value = this.volume;
                }
                else {
                    this.gainNode.gain.exponentialRampToValueAtTime(this.volume, AVPlayer.audioContext.currentTime + 1);
                }
            }
        }
        else if (this.video) {
            this.video.volume = this.volume;
        }
        else if (this.audio) {
            this.audio.volume = this.volume;
        }
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.VOLUME_CHANGE, [this.volume]);
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`player call setVolume, set ${volume}, used ${this.volume}, taskId: ${this.taskId}`, cheap__fileName__15, 2211);
    }
    /**
     *
     * 获取渲染模式
     *
     * @param mode
     * @returns
     */
    getRenderMode() {
        return this.renderMode;
    }
    /**
     * 设置画面填充模式
     *
     * - 0 自适应
     * - 1 填充
     *
     * @param mode
     */
    setRenderMode(mode) {
        this.renderMode = mode;
        if ( true && this.useMSE && this.video) {
            this.video.style['object-fit'] = ObjectFitMap[this.renderMode];
        }
        else {
            AVPlayer.VideoRenderThread?.setRenderMode(this.taskId, mode);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`player call setRenderMode, mode: ${mode}, taskId: ${this.taskId}`, cheap__fileName__15, 2241);
    }
    getVideoTransformContext() {
        let text = '';
        if (this.renderRotate !== 0) {
            text += `rotateZ(${this.renderRotate}deg)`;
        }
        if (this.flipHorizontal) {
            text += `${text.length ? ' ' : ''}scaleX(-1)`;
        }
        if (this.flipVertical) {
            text += `${text.length ? ' ' : ''}scaleY(-1)`;
        }
        return text;
    }
    /**
     * 设置视频渲染旋转角度
     *
     * @param angle
     */
    setRotate(angle) {
        this.renderRotate = angle;
        if ( true && this.useMSE && this.video) {
            this.video.style.transform = this.getVideoTransformContext();
        }
        else {
            AVPlayer.VideoRenderThread?.setRenderRotate(this.taskId, angle);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`player call setRotate, angle: ${angle}, taskId: ${this.taskId}`, cheap__fileName__15, 2271);
    }
    enableHorizontalFlip(enable) {
        this.flipHorizontal = enable;
        if ( true && this.useMSE && this.video) {
            this.video.style.transform = this.getVideoTransformContext();
        }
        else {
            AVPlayer.VideoRenderThread?.enableHorizontalFlip(this.taskId, enable);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`player call enableHorizontalFlip, enable: ${enable}, taskId: ${this.taskId}`, cheap__fileName__15, 2282);
    }
    enableVerticalFlip(enable) {
        this.flipVertical = enable;
        if ( true && this.useMSE && this.video) {
            this.video.style.transform = this.getVideoTransformContext();
        }
        else {
            AVPlayer.VideoRenderThread?.enableVerticalFlip(this.taskId, enable);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`player call enableVerticalFlip, enable: ${enable}, taskId: ${this.taskId}`, cheap__fileName__15, 2293);
    }
    /**
     * 设置是否循环播放
     *
     * @param enable
     */
    setLoop(enable) {
        this.options.loop = enable;
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`call setLoop, enable: ${enable}, taskId: ${this.taskId}`, cheap__fileName__15, 2305);
    }
    /**
     *
     * 设置字幕延时（毫秒）
     *
     * @param delay
     */
    setSubTitleDelay(delay) {
        if (this.subtitleRender) {
            this.subtitleRender.setDelay(BigInt(delay >>> 0));
        }
    }
    /**
     * 设置是否开启字幕显示
     *
     * @param enable
     */
    setSubtitleEnable(enable) {
        if (this.subtitleRender && this.selectedSubtitleStream) {
            if (enable) {
                const externalTask = this.externalSubtitleTasks.find((task) => {
                    return task.streamId === this.selectedSubtitleStream.id;
                });
                if (externalTask) {
                    AVPlayer.DemuxerThread.seek(externalTask.taskId, this.currentTime, 8 /* AVSeekFlags.FRAME */);
                }
                this.subtitleRender.reset();
                this.subtitleRender.start();
            }
            else {
                this.subtitleRender.stop();
            }
        }
    }
    /**
     * 重置渲染视图大小
     *
     * @param width
     * @param height
     */
    resize(width, height) {
        if (!this.useMSE) {
            AVPlayer.VideoRenderThread?.resize(this.taskId, width, height);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`player call resize, width: ${width}, height: ${height}, taskId: ${this.taskId}`, cheap__fileName__15, 2353);
    }
    /**
     * 当前是否是 mse 播放模式
     *
     * @returns
     */
    isMSE() {
        return this.useMSE;
    }
    /**
     * 当前是否是 live 模式
     *
     * @returns
     */
    isLive() {
        return this.options.isLive;
    }
    /**
     * 获取视频列表（ dash 使用）
     *
     * @returns
     */
    async getVideoList() {
        return AVPlayer.IOThread?.getVideoList(this.taskId);
    }
    /**
     * 获取音频列表（ dash 使用）
     *
     * @returns
     */
    async getAudioList() {
        return AVPlayer.IOThread?.getAudioList(this.taskId);
    }
    /**
     * 获取字幕列表（ dash 使用）
     *
     * @returns
     */
    async getSubtitleList() {
        return AVPlayer.IOThread?.getSubtitleList(this.taskId);
    }
    /**
     * 获取 status 状态
     *
     * @returns
     */
    getStatus() {
        return this.status;
    }
    /**
    * 是否播放了音频
    *
    * @returns
    */
    hasAudio() {
        return !!this.selectedAudioStream;
    }
    /**
     * 是否播放了视频
     *
     * @returns
     */
    hasVideo() {
        return !!this.selectedVideoStream;
    }
    /**
     * 是否播放了字幕
     *
     * @returns
     */
    hasSubtitle() {
        return !!this.selectedSubtitleStream;
    }
    /**
     * 获取当前的播放源
     *
     * @returns
     */
    getSource() {
        return this.source;
    }
    /**
     * 获取 formatContext 对象
     *
     * @returns
     */
    getFormatContext() {
        return this.formatContext;
    }
    /**
     * 获取当前加载的外挂字幕
     *
     * @returns
     */
    getExternalSubtitle() {
        return this.externalSubtitleTasks.map((task) => {
            return {
                source: task.source,
                lang: task.lang,
                title: task.title
            };
        });
    }
    /**
     * 获取 AVPlayerOptions
     *
     * @returns
     */
    getOptions() {
        return this.options;
    }
    /**
     * 重新设置是否是直播，load 之前调用
     *
     * @param is
     */
    setIsLive(is) {
        this.options.isLive = is;
    }
    /**
     * 获取 audioContext 声音输出 Node，可拿给外部去处理
     */
    getAudioOutputNode() {
        return this.gainNode;
    }
    /**
     * 判断是否处于画中画状态
     *
     * @returns
     */
    isPictureInPicture() {
        if (this.useMSE) {
            return this.video && document.pictureInPictureElement === this.video;
        }
        else if (this.canvas && typeof documentPictureInPicture === 'object') {
            return documentPictureInPicture.window
                && documentPictureInPicture.window.document.body.querySelector('#' + this.canvas.id) === this.canvas;
        }
        return false;
    }
    /**
     * 设置播放视频轨道
     *
     * @param id 流 id，dash 传 getVideoList 列表中的 index
     * @returns
     */
    async selectVideo(id) {
        if ( true && this.isHls() ||  true && this.isDash()) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`call IOThread selectVideo, index: ${id}, taskId: ${this.taskId}`, cheap__fileName__15, 2518);
            return AVPlayer.IOThread?.selectVideo(this.taskId, id);
        }
        else {
            const stream = this.formatContext.streams.find((stream) => stream.id === id);
            if (this.selectedVideoStream && stream && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */ && stream !== this.selectedVideoStream) {
                if (this.status === 9 /* AVPlayerStatus.CHANGING */) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn(`player is changing now, taskId: ${this.taskId}`, cheap__fileName__15, 2526);
                    return;
                }
                this.lastStatus = this.status;
                this.status = 9 /* AVPlayerStatus.CHANGING */;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.CHANGING, [0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */, stream.id, this.selectedVideoStream.id]);
                if (this.useMSE) {
                    await this.doSeek(this.currentTime, stream.index, {
                        onBeforeSeek: async () => {
                            await AVPlayer.DemuxerThread.changeConnectStream(this.taskId, stream.index, this.selectedVideoStream.index);
                            await AVPlayer.MSEThread.reAddStream(this.taskId, stream.index, stream.codecpar, stream.timeBase, stream.startTime);
                        }
                    });
                }
                else {
                    await this.doSeek(this.currentTime, stream.index, {
                        onBeforeSeek: async () => {
                            await AVPlayer.DemuxerThread.changeConnectStream(this.taskId, stream.index, this.selectedVideoStream.index);
                            await this.VideoDecoderThread.reopenDecoder(this.taskId, stream.codecpar, await this.getResource('decoder', cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar + 4), 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */));
                        }
                    });
                }
                common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`changed selected video stream, from ${this.selectedVideoStream.id} to ${stream.id}, taskId: ${this.taskId}`, cheap__fileName__15, 2554);
                this.selectedVideoStream = stream;
                if (this.subtitleRender) {
                    this.subtitleRender.updateVideoResolution(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar + 56), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar + 60));
                }
                this.status = this.lastStatus;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.CHANGED, [0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */, stream.id, this.selectedVideoStream.id]);
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_33__.error(`call selectVideo failed, id: ${id}, taskId: ${this.taskId}`, cheap__fileName__15, 2565);
            }
        }
    }
    /**
     * 设置播放音频轨道
     *
     * @param id 流 id，dash 传 getAudioList 列表中的 index
     * @returns
     */
    async selectAudio(id) {
        if ( true && this.isHls() ||  true && this.isDash()) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`call IOThread selectAudio, index: ${id}, taskId: ${this.taskId}`, cheap__fileName__15, 2578);
            return AVPlayer.IOThread?.selectAudio(this.taskId, id);
        }
        else {
            const stream = this.formatContext.streams.find((stream) => stream.id === id);
            if (this.selectedAudioStream && stream && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */ && stream !== this.selectedAudioStream) {
                if (this.status === 9 /* AVPlayerStatus.CHANGING */) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn(`player is changing now, taskId: ${this.taskId}`, cheap__fileName__15, 2585);
                    return;
                }
                this.lastStatus = this.status;
                this.status = 9 /* AVPlayerStatus.CHANGING */;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.CHANGING, [1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */, stream.id, this.selectedAudioStream.id]);
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar + 4) !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](this.selectedAudioStream.codecpar + 4)
                    || this.useMSE
                        && (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar + 136) !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](this.selectedAudioStream.codecpar + 136)
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar + 116) !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](this.selectedAudioStream.codecpar + 116))) {
                    let seekStreamId = stream.index;
                    if (this.selectedVideoStream) {
                        seekStreamId = this.selectedVideoStream.index;
                    }
                    if (this.useMSE) {
                        await this.doSeek(this.currentTime, seekStreamId, {
                            onBeforeSeek: async () => {
                                await AVPlayer.DemuxerThread.changeConnectStream(this.taskId, stream.index, this.selectedAudioStream.index);
                                await AVPlayer.MSEThread.reAddStream(this.taskId, stream.index, stream.codecpar, stream.timeBase, stream.startTime);
                            }
                        });
                    }
                    else {
                        await this.doSeek(this.currentTime, seekStreamId, {
                            onBeforeSeek: async () => {
                                await AVPlayer.DemuxerThread.changeConnectStream(this.taskId, stream.index, this.selectedAudioStream.index);
                                await AVPlayer.AudioDecoderThread.reopenDecoder(this.taskId, stream.codecpar, await this.getResource('decoder', cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar + 4), 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */));
                            }
                        });
                    }
                }
                else {
                    await AVPlayer.DemuxerThread.changeConnectStream(this.taskId, stream.index, this.selectedAudioStream.index, false);
                }
                common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`changed selected audio stream, from ${this.selectedAudioStream.id} to ${stream.id}, taskId: ${this.taskId}`, cheap__fileName__15, 2626);
                this.selectedAudioStream = stream;
                this.status = this.lastStatus;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.CHANGED, [1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */, stream.id, this.selectedAudioStream.id]);
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_33__.error(`call selectAudio failed, id: ${id}, taskId: ${this.taskId}`, cheap__fileName__15, 2635);
            }
        }
    }
    /**
     * 设置播放字幕轨道
     *
     * @param id 流 id，dash 传 getSubtitleList 列表中的 index
     * @returns
     */
    async selectSubtitle(id) {
        if ( true && this.isHls() ||  true && this.isDash()) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`call IOThread selectSubtitle, index: ${id}, taskId: ${this.taskId}`, cheap__fileName__15, 2648);
            await AVPlayer.IOThread?.selectSubtitle(this.taskId, id);
            if (this.subtitleTaskId) {
                await AVPlayer.DemuxerThread.seek(this.subtitleTaskId, this.currentTime, 16 /* AVSeekFlags.TIMESTAMP */);
            }
            if (this.subtitleRender) {
                this.subtitleRender.reset();
                this.subtitleRender.start();
            }
        }
        else {
            const stream = this.formatContext.streams.find((stream) => stream.id === id);
            if (this.selectedSubtitleStream && stream && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](stream.codecpar) === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */ && stream !== this.selectedSubtitleStream) {
                if (this.status === 9 /* AVPlayerStatus.CHANGING */) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn(`player is changing now, taskId: ${this.taskId}`, cheap__fileName__15, 2662);
                    return;
                }
                this.lastStatus = this.status;
                this.status = 9 /* AVPlayerStatus.CHANGING */;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.CHANGING, [3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */, stream.id, this.selectedSubtitleStream.id]);
                this.subtitleRender.reopenDecoder(stream.codecpar);
                const externalTask = this.externalSubtitleTasks.find((task) => {
                    return task.streamId === stream.id;
                });
                if (externalTask) {
                    this.subtitleRender.setDemuxTask(externalTask.taskId);
                    this.subtitleRender.reset();
                    await AVPlayer.DemuxerThread.seek(externalTask.taskId, this.currentTime, 8 /* AVSeekFlags.FRAME */, stream.index);
                }
                else {
                    this.subtitleRender.setDemuxTask(this.taskId);
                    if (this.lastSelectedInnerSubtitleStreamIndex === -1) {
                        await AVPlayer.DemuxerThread.connectStreamTask.transfer(this.subtitleRender.getDemuxerPort(this.taskId))
                            .invoke(this.taskId, stream.index, this.subtitleRender.getDemuxerPort(this.taskId));
                    }
                    else {
                        await AVPlayer.DemuxerThread.changeConnectStream(this.taskId, stream.index, this.lastSelectedInnerSubtitleStreamIndex, false);
                    }
                    const lastExternalTask = this.externalSubtitleTasks.find((task) => {
                        return task.streamId === this.selectedSubtitleStream.id;
                    });
                    if (lastExternalTask) {
                        this.subtitleRender.reset();
                    }
                    this.lastSelectedInnerSubtitleStreamIndex = stream.index;
                }
                if (this.subtitleRender) {
                    this.subtitleRender.start();
                }
                common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`changed selected subtitle stream, from ${this.selectedSubtitleStream.id} to ${stream.id}, taskId: ${this.taskId}`, cheap__fileName__15, 2701);
                this.selectedSubtitleStream = stream;
                this.status = this.lastStatus;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.CHANGED, [3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */, stream.id, this.selectedSubtitleStream.id]);
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_33__.error(`call selectSubtitle failed, id: ${id}, taskId: ${this.taskId}`, cheap__fileName__15, 2709);
            }
        }
    }
    /**
     * 播放视频下一帧，可用于逐帧播放，暂停状态下使用（不支持 mse 模式）
     */
    async playNextFrame() {
        if (!this.useMSE && this.status === 7 /* AVPlayerStatus.PAUSED */ && this.selectedVideoStream) {
            await AVPlayer.VideoRenderThread.renderNextFrame(this.taskId);
        }
    }
    /**
     * 全屏
     */
    enterFullscreen() {
        const element = this.options.container;
        if (element.requestFullscreen) {
            element.requestFullscreen();
        }
        else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        }
        else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
        }
        else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`player call enterFullscreen, taskId: ${this.taskId}`, cheap__fileName__15, 2740);
    }
    /**
     * 退出全屏
     */
    exitFullscreen() {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
        else if (document.mozExitFullScreen) {
            document.mozExitFullScreen();
        }
        else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`player call exitFullscreen, taskId: ${this.taskId}`, cheap__fileName__15, 2756);
    }
    /**
     * 获取截图
     *
     * @param type 生成图片格式
     * @param quality 生成图片质量
     */
    snapshot(type = 'png', quality = 1) {
        if ( true && this.useMSE && this.video) {
            const canvas = document.createElement('canvas');
            canvas.width = this.video.videoWidth;
            canvas.height = this.video.videoHeight;
            const context = canvas.getContext('2d');
            context.drawImage(this.video, 0, 0);
            return canvas.toDataURL(`image/${type}`, quality);
        }
        else if (this.canvas) {
            return this.canvas.toDataURL(`image/${type}`, quality);
        }
    }
    /**
     * 获取统计数据
     *
     * @returns
     */
    getStats() {
        return this.stats;
    }
    /**
     * 销毁播放器
     *
     * @returns
     */
    async destroy() {
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`call destroy, taskId: ${this.taskId}`, cheap__fileName__15, 2795);
        if (this.status === 2 /* AVPlayerStatus.DESTROYED */) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_33__.warn(`player has already destroyed, taskId: ${this.taskId}`, cheap__fileName__15, 2798);
            return;
        }
        await this.stop();
        (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_10__["default"])(this.stats);
        this.stats = null;
        if (this.VideoDecoderThread) {
            await this.VideoDecoderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_15__.closeThread)(this.VideoDecoderThread);
            this.VideoDecoderThread = null;
        }
        if (this.GlobalData) {
            this.GlobalData.avframeList.clear((avframe) => {
                (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_21__.unrefAVFrame)(avframe);
            }, 20);
            this.GlobalData.avpacketList.clear((avpacket) => {
                (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_22__.unrefAVPacket)(avpacket);
            }, 20);
            _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.destroy(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24);
            _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.destroy(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28);
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_10__["default"])(this.GlobalData);
            this.GlobalData = null;
        }
        this.status = 2 /* AVPlayerStatus.DESTROYED */;
    }
    /**
     * @internal
     */
    onVideoEnded() {
        this.videoEnded = true;
        this.handleEnded();
    }
    /**
     * @internal
     */
    onAudioEnded() {
        this.audioEnded = true;
        this.handleEnded();
    }
    /**
     * @internal
     */
    onCanvasUpdated() {
        this.updateCanvas = this.createCanvas();
        const canvas = ((0,_function_supportOffscreenCanvas__WEBPACK_IMPORTED_MODULE_32__["default"])() && cheap_config__WEBPACK_IMPORTED_MODULE_26__.USE_THREADS && true)
            ? this.updateCanvas.transferControlToOffscreen()
            : this.updateCanvas;
        AVPlayer.VideoRenderThread.updateCanvas
            .transfer(canvas)
            .invoke(this.taskId, canvas);
    }
    /**
     * @internal
     */
    async onGetDecoderResource(mediaType, codecId) {
        return this.getResource('decoder', codecId, mediaType);
    }
    /**
     * @internal
     */
    onFirstVideoRendered() {
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`first video frame rendered, taskId: ${this.taskId}`, cheap__fileName__15, 2870);
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.FIRST_VIDEO_RENDERED);
    }
    /**
     * @internal
     */
    onFirstAudioRendered() {
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`first audio frame rendered, taskId: ${this.taskId}`, cheap__fileName__15, 2878);
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.FIRST_AUDIO_RENDERED);
    }
    /**
     * @internal
     */
    onStutter() {
        this.stats.audioStutter++;
    }
    /**
     * @internal
     */
    onFirstVideoRenderedAfterUpdateCanvas() {
        if (this.updateCanvas) {
            if (this.canvas) {
                this.options.container.removeChild(this.canvas);
            }
            this.canvas = this.updateCanvas;
            this.options.container.appendChild(this.canvas);
            this.updateCanvas = null;
        }
    }
    /**
     * @internal
     */
    onTimeUpdate(pts) {
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_31__.TIME, [pts]);
    }
    /**
     * @internal
     */
    onMSESeek(time) {
        if (this.audio) {
            this.audio.currentTime = time;
        }
        else if (this.video) {
            this.video.currentTime = time;
        }
    }
    async createVideoDecoderThread() {
        if (this.VideoDecoderThread) {
            return;
        }
        this.VideoDecoderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_15__.createThreadFromClass)(avpipeline_VideoDecodePipeline__WEBPACK_IMPORTED_MODULE_13__["default"], {
            name: 'VideoDecoderThread',
            disableWorker: common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].version, '16.1', true)
        }, /*require.resolve*/(/*! ./..\avpipeline\VideoDecodePipeline.ts */ "./src/avpipeline/VideoDecodePipeline.ts")).run();
        this.VideoDecoderThread.setLogLevel(AVPlayer.level);
    }
    static async startDemuxPipeline() {
        if (AVPlayer.DemuxThreadReady) {
            return AVPlayer.DemuxThreadReady;
        }
        return AVPlayer.DemuxThreadReady = new Promise(async (resolve) => {
            AVPlayer.IOThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_15__.createThreadFromClass)(avpipeline_IOPipeline__WEBPACK_IMPORTED_MODULE_11__["default"], {
                name: 'IOThread'
            }, /*require.resolve*/(/*! ./..\avpipeline\IOPipeline.ts */ "./src/avpipeline/IOPipeline.ts")).run();
            AVPlayer.IOThread.setLogLevel(AVPlayer.level);
            AVPlayer.DemuxerThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_15__.createThreadFromClass)(avpipeline_DemuxPipeline__WEBPACK_IMPORTED_MODULE_12__["default"], {
                name: 'DemuxerThread'
            }, /*require.resolve*/(/*! ./..\avpipeline\DemuxPipeline.ts */ "./src/avpipeline/DemuxPipeline.ts")).run();
            AVPlayer.DemuxerThread.setLogLevel(AVPlayer.level);
            resolve();
        });
    }
    static async startAudioPipeline() {
        if (AVPlayer.AudioThreadReady) {
            return AVPlayer.AudioThreadReady;
        }
        return AVPlayer.AudioThreadReady = new Promise(async (resolve) => {
            AVPlayer.audioContext = new (AudioContext || webkitAudioContext)();
            if (common_util_support__WEBPACK_IMPORTED_MODULE_34__["default"].audioWorklet) {
                await (0,avrender_pcm_audioWorklet_base_registerProcessor__WEBPACK_IMPORTED_MODULE_27__["default"])(AVPlayer.audioContext,  true && cheap_config__WEBPACK_IMPORTED_MODULE_26__.USE_THREADS && (!common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].safari || common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].version, '16.1', true))
                    ? /*require.resolve*/(/*! avrender/pcm/AudioSourceWorkletProcessor2 */ "./src/avrender/pcm/AudioSourceWorkletProcessor2.ts")
                    : /*require.resolve*/(/*! avrender/pcm/AudioSourceWorkletProcessor */ "./src/avrender/pcm/AudioSourceWorkletProcessor.ts"));
            }
            AVPlayer.AudioDecoderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_15__.createThreadFromClass)(avpipeline_AudioDecodePipeline__WEBPACK_IMPORTED_MODULE_14__["default"], {
                name: 'AudioDecoderThread',
                disableWorker: common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].version, '16.1', true)
            }, /*require.resolve*/(/*! ./..\avpipeline\AudioDecodePipeline.ts */ "./src/avpipeline/AudioDecodePipeline.ts")).run();
            AVPlayer.AudioDecoderThread.setLogLevel(AVPlayer.level);
            AVPlayer.AudioRenderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_15__.createThreadFromClass)(avpipeline_AudioRenderPipeline__WEBPACK_IMPORTED_MODULE_23__["default"], {
                name: 'AudioRenderThread',
                disableWorker: common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_37__["default"].version, '16.1', true)
            }, /*require.resolve*/(/*! ./..\avpipeline\AudioRenderPipeline.ts */ "./src/avpipeline/AudioRenderPipeline.ts")).run();
            AVPlayer.AudioRenderThread.setLogLevel(AVPlayer.level);
            resolve();
        });
    }
    static async startVideoRenderPipeline() {
        if (AVPlayer.VideoThreadReady) {
            return AVPlayer.VideoThreadReady;
        }
        return AVPlayer.VideoThreadReady = new Promise(async (resolve) => {
            AVPlayer.VideoRenderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_15__.createThreadFromClass)(avpipeline_VideoRenderPipeline__WEBPACK_IMPORTED_MODULE_24__["default"], {
                name: 'VideoRenderThread',
                disableWorker: !(0,_function_supportOffscreenCanvas__WEBPACK_IMPORTED_MODULE_32__["default"])()
            }, /*require.resolve*/(/*! ./..\avpipeline\VideoRenderPipeline.ts */ "./src/avpipeline/VideoRenderPipeline.ts")).run();
            AVPlayer.VideoRenderThread.setLogLevel(AVPlayer.level);
            resolve();
        });
    }
    static async startMSEPipeline() {
        {
            if (AVPlayer.MSEThreadReady) {
                return AVPlayer.MSEThreadReady;
            }
            return AVPlayer.MSEThreadReady = new Promise(async (resolve) => {
                AVPlayer.MSEThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_15__.createThreadFromClass)(_mse_MSEPipeline__WEBPACK_IMPORTED_MODULE_46__["default"], {
                    name: 'MSEThread',
                    disableWorker: !common_util_support__WEBPACK_IMPORTED_MODULE_34__["default"].workerMSE
                }, /*require.resolve*/(/*! ./mse\MSEPipeline.ts */ "./src/avplayer/mse/MSEPipeline.ts")).run();
                AVPlayer.MSEThread.setLogLevel(AVPlayer.level);
                resolve();
            });
        }
    }
    /**
     * 提前运行所有管线
     */
    static async startPipelines() {
        await AVPlayer.startDemuxPipeline();
        await AVPlayer.startAudioPipeline();
        await AVPlayer.startVideoRenderPipeline();
        await AVPlayer.startMSEPipeline();
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info('AVPlayer pipelines started', cheap__fileName__15, 3024);
    }
    /**
     * 停止所有管线
     */
    static async stopPipelines() {
        if (AVPlayer.VideoRenderThread) {
            await AVPlayer.VideoRenderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_15__.closeThread)(AVPlayer.VideoRenderThread);
        }
        if (AVPlayer.AudioRenderThread) {
            await AVPlayer.AudioRenderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_15__.closeThread)(AVPlayer.AudioRenderThread);
        }
        if (AVPlayer.AudioDecoderThread) {
            await AVPlayer.AudioDecoderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_15__.closeThread)(AVPlayer.AudioDecoderThread);
        }
        if (AVPlayer.DemuxerThread) {
            await AVPlayer.DemuxerThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_15__.closeThread)(AVPlayer.DemuxerThread);
        }
        if (AVPlayer.IOThread) {
            await AVPlayer.IOThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_15__.closeThread)(AVPlayer.IOThread);
        }
        {
            if (AVPlayer.MSEThread) {
                await AVPlayer.MSEThread.clear();
                (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_15__.closeThread)(AVPlayer.MSEThread);
            }
        }
        AVPlayer.AudioDecoderThread = null;
        AVPlayer.DemuxerThread = null;
        AVPlayer.IOThread = null;
        AVPlayer.audioContext = null;
        AVPlayer.MSEThread = null;
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info('AVPlayer pipelines stopped', cheap__fileName__15, 3064);
    }
    /**
     * 设置日志等级
     *
     * @param level
     */
    static setLogLevel(level) {
        AVPlayer.level = level;
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.setLevel(level);
        if (AVPlayer.IOThread) {
            AVPlayer.IOThread.setLogLevel(level);
        }
        if (AVPlayer.DemuxerThread) {
            AVPlayer.DemuxerThread.setLogLevel(level);
        }
        if (AVPlayer.AudioDecoderThread) {
            AVPlayer.AudioDecoderThread.setLogLevel(level);
        }
        if (AVPlayer.AudioRenderThread) {
            AVPlayer.AudioRenderThread.setLogLevel(level);
        }
        if (AVPlayer.VideoRenderThread) {
            AVPlayer.VideoRenderThread.setLogLevel(level);
        }
        if (AVPlayer.MSEThread) {
            AVPlayer.MSEThread.setLogLevel(level);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_33__.info(`set log level: ${level}`, cheap__fileName__15, 3096);
    }
    on(event, listener, options = {}) {
        super.on(event, common_util_object__WEBPACK_IMPORTED_MODULE_19__.extend({
            fn: listener
        }, options));
        return this;
    }
    one(event, listener, options = {}) {
        super.on(event, common_util_object__WEBPACK_IMPORTED_MODULE_19__.extend({
            fn: listener,
            max: 1
        }, options));
        return this;
    }
}


/***/ }),

/***/ "./src/avplayer/Controller.ts":
/*!************************************!*\
  !*** ./src/avplayer/Controller.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Controller)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/function/createMessageChannel */ "./src/avutil/function/createMessageChannel.ts");
/*
 * libmedia AVPlayer Controller
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class Controller {
    videoRenderControlChannel;
    audioRenderControlChannel;
    muxerControlChannel;
    demuxerControlChannel;
    videoRenderControlIPCPort;
    audioRenderControlIPCPort;
    muxerControlIPCPort;
    demuxerControlIPCPort;
    observer;
    visibilityHidden;
    onVisibilityChange;
    timeUpdateListenType;
    enableAudioVideoSync;
    constructor(observer) {
        this.observer = observer;
        this.videoRenderControlChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_1__["default"])();
        this.audioRenderControlChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_1__["default"])();
        this.muxerControlChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_1__["default"])();
        this.demuxerControlChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_1__["default"])();
        this.videoRenderControlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](this.videoRenderControlChannel.port2);
        this.audioRenderControlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](this.audioRenderControlChannel.port2);
        this.muxerControlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](this.muxerControlChannel.port2);
        this.demuxerControlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](this.demuxerControlChannel.port2);
        this.enableAudioVideoSync = true;
        this.videoRenderControlIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.NOTIFY, (request) => {
            switch (request.method) {
                case 'ended':
                    this.observer.onVideoEnded();
                    break;
                case 'updateCanvas':
                    this.observer.onCanvasUpdated();
                    break;
                case 'firstRendered':
                    this.observer.onFirstVideoRendered();
                    break;
                case 'firstRenderedAfterUpdateCanvas':
                    this.observer.onFirstVideoRenderedAfterUpdateCanvas();
                    break;
                case 'syncPts':
                    if (this.timeUpdateListenType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                        this.observer.onTimeUpdate(request.params.pts);
                    }
                    break;
            }
        });
        this.audioRenderControlIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.NOTIFY, (request) => {
            switch (request.method) {
                case 'syncPts':
                    if (this.enableAudioVideoSync) {
                        this.videoRenderControlIPCPort.notify('syncPts', request.params);
                    }
                    if (this.timeUpdateListenType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                        this.observer.onTimeUpdate(request.params.pts);
                    }
                    break;
                case 'ended':
                    this.observer.onAudioEnded();
                    break;
            }
        });
        this.muxerControlIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.NOTIFY, (request) => {
            switch (request.method) {
                case 'seek':
                    this.observer.onMSESeek(request.params.time);
                    break;
            }
        });
        this.demuxerControlIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.REQUEST, async (request) => {
            switch (request.method) {
                case 'getDecoderResource':
                    this.demuxerControlIPCPort.reply(request, await this.observer.onGetDecoderResource(request.params.mediaType, request.params.codecId));
                    break;
            }
        });
        this.onVisibilityChange = (event) => {
            this.visibilityHidden = document.visibilityState === 'hidden' && !this.observer.isPictureInPicture();
            this.videoRenderControlIPCPort.notify('skipRender', {
                skipRender: this.visibilityHidden
            });
        };
        this.visibilityHidden = document.visibilityState === 'hidden' && !this.observer.isPictureInPicture();
        document.addEventListener('visibilitychange', this.onVisibilityChange);
    }
    getVideoRenderControlPort() {
        return this.videoRenderControlChannel.port1;
    }
    getAudioRenderControlPort() {
        return this.audioRenderControlChannel.port1;
    }
    getMuxerControlPort() {
        return this.muxerControlChannel.port1;
    }
    getDemuxerControlPort() {
        return this.demuxerControlChannel.port1;
    }
    setTimeUpdateListenType(type) {
        this.timeUpdateListenType = type;
    }
    setEnableAudioVideoSync(enable) {
        this.enableAudioVideoSync = enable;
    }
    destroy() {
        if (this.videoRenderControlIPCPort) {
            this.videoRenderControlIPCPort.destroy();
        }
        if (this.audioRenderControlIPCPort) {
            this.audioRenderControlIPCPort.destroy();
        }
        if (this.muxerControlIPCPort) {
            this.muxerControlIPCPort.destroy();
        }
        if (this.demuxerControlIPCPort) {
            this.demuxerControlIPCPort.destroy();
        }
        if (this.onVisibilityChange) {
            document.removeEventListener('visibilitychange', this.onVisibilityChange);
            this.onVisibilityChange = null;
        }
        this.videoRenderControlIPCPort = this.audioRenderControlIPCPort = this.muxerControlIPCPort = this.videoRenderControlChannel = this.audioRenderControlChannel = this.demuxerControlChannel = this.muxerControlChannel = null;
    }
}


/***/ }),

/***/ "./src/avplayer/JitterBufferController.ts":
/*!************************************************!*\
  !*** ./src/avplayer/JitterBufferController.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JitterBufferController)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_timer_Timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/timer/Timer */ "./src/common/timer/Timer.ts");
/* harmony import */ var common_timer_WorkerTimer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/timer/WorkerTimer */ "./src/common/timer/WorkerTimer.ts");




const QUEUE_MAX = 10;
const BUFFER_STEP = 200;
const RATE_STEP = 0.01;
class JitterBufferController {
    timer;
    interval;
    data;
    lastIncomingPacketCount;
    shutterCount;
    lastShutterCount;
    isFirst;
    max;
    min;
    targetPlaybackRate;
    currentPlaybackRate;
    playbackRateTimer;
    options;
    constructor(options) {
        this.options = options;
        this.interval = 1000;
        this.isFirst = true;
        this.data = [];
        this.lastIncomingPacketCount = BigInt(0);
        this.shutterCount = 0;
        this.lastShutterCount = 0;
        this.max = (options.max * 1000) >>> 0;
        this.min = (options.min * 1000) >>> 0;
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer, this.min);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, this.max);
        if (options.lowLatencyStart) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, this.min + BUFFER_STEP);
        }
        this.targetPlaybackRate = 1;
        this.currentPlaybackRate = 1;
        this.playbackRateTimer = new common_timer_Timer__WEBPACK_IMPORTED_MODULE_2__["default"](() => {
            if (this.currentPlaybackRate > this.targetPlaybackRate) {
                const rate = Math.max(this.targetPlaybackRate, this.currentPlaybackRate - RATE_STEP);
                this.options.observer.onSetPlayRate(rate);
                this.currentPlaybackRate = rate;
            }
            else if (this.currentPlaybackRate < this.targetPlaybackRate) {
                const rate = Math.min(this.targetPlaybackRate, this.currentPlaybackRate + RATE_STEP);
                this.options.observer.onSetPlayRate(rate);
                this.currentPlaybackRate = rate;
            }
            else {
                this.playbackRateTimer.stop();
            }
        }, 0, 200);
        this.timer = new common_timer_WorkerTimer__WEBPACK_IMPORTED_MODULE_3__["default"](this.onTimer.bind(this), 1000, this.interval);
    }
    start() {
        this.timer.start();
        this.isFirst = true;
        this.lastIncomingPacketCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.options.stats + 24) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.options.stats + 112);
        this.shutterCount = 0;
        this.lastShutterCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 276) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 272);
        this.computePlayRate();
    }
    stop() {
        this.timer.stop();
        this.data.length = 0;
        this.isFirst = true;
        if (this.playbackRateTimer.isStarted()) {
            this.playbackRateTimer.stop();
            this.targetPlaybackRate = this.currentPlaybackRate = 1;
            this.options.observer.onSetPlayRate(1);
        }
    }
    reset() {
        this.data.length = 0;
        this.isFirst = true;
        this.lastIncomingPacketCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.options.stats + 24) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.options.stats + 112);
        this.shutterCount = 0;
        this.lastShutterCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 276) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 272);
        this.targetPlaybackRate = this.currentPlaybackRate = 1;
    }
    setPlayRate(rate) {
        this.targetPlaybackRate = rate;
        if (this.options.useMse) {
            this.options.observer.onSetPlayRate(this.targetPlaybackRate);
            this.currentPlaybackRate = this.targetPlaybackRate;
        }
        else {
            if (this.currentPlaybackRate !== rate && !this.playbackRateTimer.isStarted()) {
                this.playbackRateTimer.start();
            }
        }
    }
    computePlayRate() {
        let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 236) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 32) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 236) * 1000)
            : (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 224) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 120) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 224) * 1000)
                : 0);
        if ((buffer < (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) >> 1)) && buffer < 2) {
            this.setPlayRate(0.8);
        }
        else if ((buffer < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) - BUFFER_STEP) && buffer < 2) {
            this.setPlayRate(0.95);
        }
        else if (buffer > cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4) + BUFFER_STEP) {
            this.setPlayRate(1.05);
        }
        else {
            this.setPlayRate(1);
        }
        if (buffer > (this.max << 1)) {
            this.options.observer.onCroppingBuffer(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4));
        }
    }
    process() {
        const average = this.data.reduce((prev, value, index) => {
            return prev + value * (index + 1);
        }, 0) / (QUEUE_MAX * (QUEUE_MAX + 1) / 2);
        const variance = this.data.reduce((pre, value) => {
            return pre + Math.pow(value - average, 2);
        }, 0) / this.data.length;
        const jitter = Math.sqrt(variance);
        const incomingFramerate = Math.round(average / (this.interval / 1000));
        const needFramerate = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 224) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 236);
        if ((incomingFramerate < (needFramerate >> 1)) || this.shutterCount > 3) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) * 2, this.max - BUFFER_STEP));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4) * 2, this.max));
        }
        else if (incomingFramerate >= needFramerate && jitter < 50) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer, Math.max(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) - BUFFER_STEP, this.min));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, Math.max(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4) - BUFFER_STEP, this.min + BUFFER_STEP));
        }
        else if (jitter > 100) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) + BUFFER_STEP, this.max - BUFFER_STEP));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4) + BUFFER_STEP, this.max));
        }
        else if (jitter < 20) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) === this.min) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, Math.max(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4) - BUFFER_STEP, this.min + BUFFER_STEP));
            }
            else {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer, Math.max(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) - BUFFER_STEP, this.min));
            }
        }
        else {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4) === this.max) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) + BUFFER_STEP, this.max - BUFFER_STEP));
            }
            else {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4) + BUFFER_STEP, this.max));
            }
        }
        this.computePlayRate();
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[19](this.options.stats + 264, jitter);
    }
    onTimer() {
        const count = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.options.stats + 24) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.options.stats + 112);
        if (this.isFirst) {
            this.isFirst = false;
        }
        else {
            this.data.push((Number(count - this.lastIncomingPacketCount & 0xffffffffn) >> 0));
        }
        this.lastIncomingPacketCount = count;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 276) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 272) > this.lastShutterCount) {
            this.shutterCount++;
        }
        else {
            this.shutterCount = 0;
        }
        this.lastShutterCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 276) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 272);
        if (this.data.length > QUEUE_MAX) {
            this.data.shift();
        }
        if (this.data.length === QUEUE_MAX) {
            this.process();
        }
    }
}


/***/ }),

/***/ "./src/avplayer/StatsController.ts":
/*!*****************************************!*\
  !*** ./src/avplayer/StatsController.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StatsController)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_timer_Timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/timer/Timer */ "./src/common/timer/Timer.ts");



class StatsController {
    stats;
    timer;
    videoFrameRenderCount;
    videoFrameDecodeCount;
    audioFrameRenderCount;
    audioFrameDecodeCount;
    videoPacketBytes;
    audioPacketBytes;
    bufferReceiveBytes;
    constructor(stats) {
        this.stats = stats;
        this.timer = new common_timer_Timer__WEBPACK_IMPORTED_MODULE_2__["default"](this.onTimer.bind(this), 1000, 1000);
    }
    reset() {
        this.videoFrameRenderCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 160);
        this.videoFrameDecodeCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 144);
        this.audioFrameRenderCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 72);
        this.audioFrameDecodeCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 56);
        this.videoPacketBytes = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 104);
        this.audioPacketBytes = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 16);
        this.bufferReceiveBytes = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 192);
    }
    start() {
        this.reset();
        this.timer.start();
    }
    stop() {
        this.timer.stop();
    }
    onTimer() {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 240, 0);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 244, 0);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 248, 0);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 252, 0);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 220, (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 160) - this.videoFrameRenderCount & 0xffffffffn) >> 0));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 216, (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 144) - this.videoFrameDecodeCount & 0xffffffffn) >> 0));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 232, (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 72) - this.audioFrameRenderCount & 0xffffffffn) >> 0));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 228, (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 56) - this.audioFrameDecodeCount & 0xffffffffn) >> 0));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 212, (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 104) - this.videoPacketBytes & 0xffffffffn) >> 0));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 208, (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 16) - this.audioPacketBytes & 0xffffffffn) >> 0));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 256, (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 192) - this.bufferReceiveBytes & 0xffffffffn) >> 0));
        if (document.visibilityState === 'visible'
            && (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.stats + 220) < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.stats + 224) * 0.5
                || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.stats + 252) > 6000 / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.stats + 224))) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 276, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.stats + 276) + 1);
        }
        this.reset();
    }
}


/***/ }),

/***/ "./src/avplayer/eventType.ts":
/*!***********************************!*\
  !*** ./src/avplayer/eventType.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CHANGED: () => (/* binding */ CHANGED),
/* harmony export */   CHANGING: () => (/* binding */ CHANGING),
/* harmony export */   ENDED: () => (/* binding */ ENDED),
/* harmony export */   FIRST_AUDIO_RENDERED: () => (/* binding */ FIRST_AUDIO_RENDERED),
/* harmony export */   FIRST_VIDEO_RENDERED: () => (/* binding */ FIRST_VIDEO_RENDERED),
/* harmony export */   LOADED: () => (/* binding */ LOADED),
/* harmony export */   LOADING: () => (/* binding */ LOADING),
/* harmony export */   PAUSED: () => (/* binding */ PAUSED),
/* harmony export */   PLAYED: () => (/* binding */ PLAYED),
/* harmony export */   PLAYING: () => (/* binding */ PLAYING),
/* harmony export */   PROGRESS: () => (/* binding */ PROGRESS),
/* harmony export */   RESUME: () => (/* binding */ RESUME),
/* harmony export */   SEEKED: () => (/* binding */ SEEKED),
/* harmony export */   SEEKING: () => (/* binding */ SEEKING),
/* harmony export */   STOPPED: () => (/* binding */ STOPPED),
/* harmony export */   STREAM_UPDATE: () => (/* binding */ STREAM_UPDATE),
/* harmony export */   TIME: () => (/* binding */ TIME),
/* harmony export */   VOLUME_CHANGE: () => (/* binding */ VOLUME_CHANGE)
/* harmony export */ });
/* unused harmony exports TIMEOUT, ERROR */
/*
 * libmedia AVPlayer eventType
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const LOADING = 'loading';
const LOADED = 'loaded';
const PLAYING = 'playing';
const PLAYED = 'played';
const PAUSED = 'paused';
const STOPPED = 'stopped';
const ENDED = 'ended';
const SEEKING = 'seeking';
const SEEKED = 'seeked';
const CHANGING = 'changing';
const CHANGED = 'changed';
const TIMEOUT = 'timeout';
const ERROR = 'error';
const TIME = 'time';
const RESUME = 'resume';
const FIRST_AUDIO_RENDERED = 'firstAudioRendered';
const FIRST_VIDEO_RENDERED = 'firstVideoRendered';
const STREAM_UPDATE = 'streamUpdate';
const PROGRESS = 'progress';
const VOLUME_CHANGE = 'volumeChange';


/***/ }),

/***/ "./src/avplayer/function/getMediaSource.ts":
/*!*************************************************!*\
  !*** ./src/avplayer/function/getMediaSource.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getMediaSource)
/* harmony export */ });
/*
 * libmedia get MediaSource
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function getMediaSource() {
    if (typeof MediaSource === 'function') {
        return MediaSource;
    }
    else if (typeof ManagedMediaSource === 'function') {
        return ManagedMediaSource;
    }
    else {
        throw new Error('not support mse');
    }
}


/***/ }),

/***/ "./src/avplayer/function/supportOffscreenCanvas.ts":
/*!*********************************************************!*\
  !*** ./src/avplayer/function/supportOffscreenCanvas.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ supportOffscreenCanvas)
/* harmony export */ });
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var common_util_os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/os */ "./src/common/util/os.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/*
 * libmedia support OffscreenCanvas
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function supportOffscreenCanvas() {
    let result = common_util_support__WEBPACK_IMPORTED_MODULE_0__["default"].offscreenCanvas;
    // webgl with offscreencanvas only supported for Safari 17+ on Mac OS Sonoma
    if (common_util_os__WEBPACK_IMPORTED_MODULE_1__["default"].mac && common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].safari && (common_util_os__WEBPACK_IMPORTED_MODULE_1__["default"].version < '12' || common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].version < '17')) {
        result = false;
    }
    return result;
}


/***/ }),

/***/ "./src/avplayer/mse/MSEPipeline.ts":
/*!*****************************************!*\
  !*** ./src/avplayer/mse/MSEPipeline.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MSEPipeline)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./..\..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./..\..\cheap\std\collection\List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avformat/AVFormatContext */ "./src/avformat/AVFormatContext.ts");
/* harmony import */ var avpipeline_Pipeline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avpipeline/Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_io_IOWriterSync__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/io/IOWriterSync */ "./src/common/io/IOWriterSync.ts");
/* harmony import */ var avformat_mux__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avformat/mux */ "./src/avformat/mux.ts");
/* harmony import */ var avformat_formats_OMovFormat__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! avformat/formats/OMovFormat */ "./src/avformat/formats/OMovFormat.ts");
/* harmony import */ var avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/util/codecparameters */ "./src/avutil/util/codecparameters.ts");
/* harmony import */ var common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/timer/LoopTask */ "./src/common/timer/LoopTask.ts");
/* harmony import */ var avrender_track_Track__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! avrender/track/Track */ "./src/avrender/track/Track.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var avrender_track_function_getAudioMimeType__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! avrender/track/function/getAudioMimeType */ "./src/avrender/track/function/getAudioMimeType.ts");
/* harmony import */ var avrender_track_function_getVideoMimeType__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! avrender/track/function/getVideoMimeType */ "./src/avrender/track/function/getVideoMimeType.ts");
/* harmony import */ var common_io_SeekableWriteBufferQueue__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! common/io/SeekableWriteBufferQueue */ "./src/common/io/SeekableWriteBufferQueue.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var avutil_util_common__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! avutil/util/common */ "./src/avutil/util/common.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
/* harmony import */ var avformat_function_mktag__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! avformat/function/mktag */ "./src/avformat/function/mktag.ts");
/* harmony import */ var _function_getMediaSource__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../function/getMediaSource */ "./src/avplayer/function/getMediaSource.ts");
/* harmony import */ var avutil_util_intread__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! avutil/util/intread */ "./src/avutil/util/intread.ts");
/* harmony import */ var avformat_codecs_h264__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! avformat/codecs/h264 */ "./src/avformat/codecs/h264.ts");
/* harmony import */ var avformat_codecs_hevc__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! avformat/codecs/hevc */ "./src/avformat/codecs/hevc.ts");
var cheap__fileName__19 = "src\\avplayer\\mse\\MSEPipeline.ts";







/*
 * libmedia MSEPipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */






























const BUFFER_MIN = 0.5;
const BUFFER_MAX = 1;
function checkExtradataChanged(old, oldSize, newer, newSize) {
    if (oldSize !== newSize) {
        return true;
    }
    let change = false;
    for (let i = 0; i < oldSize; i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[2](old + i) !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[2](newer + i)) {
            change = true;
            break;
        }
    }
    return change;
}
class MSEPipeline extends avpipeline_Pipeline__WEBPACK_IMPORTED_MODULE_8__["default"] {
    constructor() {
        super();
    }
    async syncToKeyframe(task) {
        let firstIsKeyframe = true;
        if (task.video) {
            // 寻找下一个关键帧
            while (true) {
                task.video.backPacket = await this.pullAVPacket(task.video, task);
                if (task.video.backPacket < 0) {
                    task.video.packetEnded = true;
                    task.video.backPacket = 0;
                    break;
                }
                // 跳过 pts 小于当前视频 pts 的音频 packet
                if (task.audio
                    && !task.audio.packetEnded
                    && (!task.audio.backPacket
                        || (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.audio.backPacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.audio.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q)
                            < (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.video.backPacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.video.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q))) {
                    while (true) {
                        if (task.audio.backPacket > 0) {
                            task.avpacketPool.release(task.audio.backPacket);
                        }
                        task.audio.backPacket = await this.pullAVPacket(task.audio, task);
                        if (task.audio.backPacket < 0) {
                            task.audio.packetEnded = true;
                            task.audio.backPacket = 0;
                            break;
                        }
                        if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.audio.backPacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.audio.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q)
                            > (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.video.backPacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.video.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q)) {
                            break;
                        }
                    }
                }
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.video.backPacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                    break;
                }
                firstIsKeyframe = false;
                task.avpacketPool.release(task.video.backPacket);
            }
        }
        return firstIsKeyframe;
    }
    getSourceOpenHandler(task) {
        return async () => {
            await this.syncToKeyframe(task);
            const promises = [];
            if (task.audio) {
                task.audio.track.setSourceBuffer(this.createSourceBuffer(task.mediaSource, task.audio.oformatContext.streams[0].codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress]));
                if (!task.audio.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.open(task.audio.oformatContext, {
                        paddingZero: false
                    });
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.writeHeader(task.audio.oformatContext);
                }
                promises.push(this.startMux(task.audio, task));
            }
            if (task.video) {
                task.video.track.setSourceBuffer(this.createSourceBuffer(task.mediaSource, task.video.oformatContext.streams[0].codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress]));
                if (!task.video.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.open(task.video.oformatContext, {
                        paddingZero: false
                    });
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.writeHeader(task.video.oformatContext);
                }
                promises.push(this.startMux(task.video, task));
            }
            await Promise.all(promises);
            let startAudioLoop = false;
            let startVideoLoop = false;
            if (task.audio) {
                task.audio.backPacket = await this.pullAVPacket(task.audio, task);
                if (task.audio.backPacket > 0) {
                    startAudioLoop = true;
                    task.audio.frontPacket = await this.pullAVPacket(task.audio, task);
                    if (task.audio.frontPacket > 0) {
                        task.audio.frontBuffered = true;
                    }
                    else {
                        task.audio.frontPacket = 0;
                        task.audio.packetEnded = true;
                    }
                }
                else {
                    task.audio.packetEnded = true;
                }
                if (!task.audio.enableRawMpeg) {
                    task.audio.oformatContext.ioWriter.flush();
                }
                task.audio.track.addBuffer(task.audio.bufferQueue.flush());
            }
            if (task.video) {
                task.video.backPacket = await this.pullAVPacket(task.video, task);
                if (task.video.backPacket > 0) {
                    startVideoLoop = true;
                    task.video.frontPacket = await this.pullAVPacket(task.video, task);
                    if (task.video.frontPacket > 0) {
                        task.video.frontBuffered = true;
                    }
                    else {
                        task.video.frontPacket = 0;
                        task.video.packetEnded = true;
                    }
                }
                else {
                    task.video.packetEnded = true;
                }
                if (!task.video.enableRawMpeg) {
                    task.video.oformatContext.ioWriter.flush();
                }
                task.video.track.addBuffer(task.video.bufferQueue.flush());
            }
            if (task.audio) {
                if (startAudioLoop) {
                    this.createLoop(task.audio, task);
                    task.audio.loop.start();
                }
                else {
                    task.audio.track.end();
                }
            }
            if (task.video) {
                if (startVideoLoop) {
                    this.createLoop(task.video, task);
                    task.video.loop.start();
                }
                else {
                    task.video.track.end();
                }
            }
            // 等待一定的缓冲
            await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_29__["default"](0.1);
            let min = 0;
            if (task.audio) {
                if (task.video) {
                    min = Math.max(task.audio.track.getBufferedStart(), task.video.track.getBufferedStart());
                }
                else {
                    min = task.audio.track.getBufferedStart();
                }
            }
            else if (task.video) {
                min = task.video.track.getBufferedStart();
            }
            // safari 播放某些视频会卡主，开始时间不是从 0 开始的 seek 到 min buffer 处
            if (common_util_browser__WEBPACK_IMPORTED_MODULE_27__["default"].safari || min > 0.1) {
                task.controlIPCPort.notify('seek', {
                    time: min
                });
            }
        };
    }
    getMimeType(codecpar) {
        let mimeType = '';
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
            mimeType = (0,avrender_track_function_getAudioMimeType__WEBPACK_IMPORTED_MODULE_22__["default"])(codecpar);
        }
        else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
            mimeType = (0,avrender_track_function_getVideoMimeType__WEBPACK_IMPORTED_MODULE_23__["default"])(codecpar);
        }
        if (!mimeType) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('invalid stream', cheap__fileName__19, 345);
        }
        return mimeType;
    }
    createSourceBuffer(mediaSource, codecpar) {
        return mediaSource.addSourceBuffer(this.getMimeType(codecpar));
    }
    // TODO avpacket extradata 混入码流
    mixExtradata(avpacket, resource, extradata, extradataSize) {
        const codecId = resource.oformatContext.streams[0].codecpar.codecId;
        if (codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */
            || codecId === 173 /* AVCodecID.AV_CODEC_ID_H265 */
            || codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */) {
        }
        const codecpar = resource.oformatContext.streams[0].codecpar;
        if (codecpar.extradata) {
            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_26__.avFree)(codecpar.extradata);
        }
        codecpar.extradata = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_26__.avMalloc)(extradataSize);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(codecpar.extradata, extradata, extradataSize);
        codecpar.extradataSize = extradataSize;
    }
    async pullAVPacket(resource, task) {
        const pullQueue = resource.pullQueue;
        if (pullQueue.ended && !pullQueue.queue.length) {
            return -1048576 /* IOError.END */;
        }
        const avpacket = pullQueue.queue.length
            ? pullQueue.queue.shift()
            : (await resource.pullIPC.request('pull'));
        if (avpacket < 0) {
            pullQueue.ended = true;
            return -1048576 /* IOError.END */;
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16) < pullQueue.lastDTS) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.warn(`got packet with dts ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16)}, which is earlier then the last packet(${pullQueue.lastDTS})`, cheap__fileName__19, 392);
        }
        // 音频直接让 pts 等于 dts，dts 是递增的可以保证 mse 不会卡主（但声音可能会出现嗒嗒声）
        if (resource.type === 'audio' && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16) > 0) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](avpacket + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16));
        }
        // 某些视频关键帧的 pts 会倒退，这里纠正一下（特别是 m3u8 和 dash 切片转 mp4 flv 格式的视频容易出现）
        // TODO 若是非关键帧出现 pts 不对的情况可能需要其他手段去纠正，否则 mse 因为 duration 不对会卡主
        // 对于没有 B 帧的编码格式可以让 pts 等于 dts，当有 B 帧时可以根据帧类型得到一个最短 pts 递增序列来纠正 pts
        // 直播我们就不去纠正了，一般这种错误出现在老旧视频文件里面，直播不太可能出现，真出现了那也是直播流服务器的问题，应该去修改服务器的问题
        else if (resource.type === 'video' && !task.isLive) {
            if ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)
                && ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.video.codecpar + 4) === 27 /* AVCodecID.AV_CODEC_ID_H264 */
                    && avformat_codecs_h264__WEBPACK_IMPORTED_MODULE_34__.isIDR(avpacket, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](task.video.codecpar + 12) ? (avutil_util_intread__WEBPACK_IMPORTED_MODULE_33__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](task.video.codecpar + 12) + 4) & 4)
                        : 4))
                    || (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.video.codecpar + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                        && avformat_codecs_hevc__WEBPACK_IMPORTED_MODULE_35__.isIDR(avpacket, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](task.video.codecpar + 12) ? (avutil_util_intread__WEBPACK_IMPORTED_MODULE_33__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](task.video.codecpar + 12) + 21) & 4)
                            : 4)))) {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8) < pullQueue.lastPTS) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_11__.warn(`got packet with pts ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8)}, which is earlier then the last packet(${pullQueue.lastPTS}), try to fix it!`, cheap__fileName__19, 425);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](avpacket + 8, pullQueue.lastPTS + (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16) - pullQueue.lastDTS));
                    const next = await resource.pullIPC.request('pull');
                    if (next < 0) {
                        pullQueue.ended = true;
                    }
                    else {
                        pullQueue.queue.push(next);
                        // 判断下一个 gop pts 是否需要整体往后移
                        // 找到下一个最短递增序列的最小 pts
                        let nextMinPts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](next + 8);
                        // I 帧后面的的 P 帧 一定是下一个最短递增序列的最大 pts
                        const max = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](next + 8);
                        while (true) {
                            const next2 = await resource.pullIPC.request('pull');
                            if (next2 < 0) {
                                pullQueue.ended = true;
                                break;
                            }
                            pullQueue.queue.push(next2);
                            // 当前的 pts 比最大 pts 都大了说明当前的最短递增序列已结束
                            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](next2 + 8) > max) {
                                break;
                            }
                            nextMinPts = common_util_bigint__WEBPACK_IMPORTED_MODULE_30__.min(nextMinPts, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](next2 + 8));
                        }
                        if (nextMinPts < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8)) {
                            pullQueue.diff = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16) - pullQueue.lastDTS;
                        }
                    }
                }
                else {
                    pullQueue.diff = BigInt(0);
                }
            }
            else {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](avpacket + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8) + pullQueue.diff);
            }
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8) > pullQueue.lastPTS) {
            pullQueue.lastPTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8);
        }
        pullQueue.lastDTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16);
        // 使用 sampleRate 作为时间基
        // 这里需要根据当前已经处理的 samples count 调整时间基
        // 并将 avpacket 的时间基调整为采样率
        if (resource.type === 'audio' && pullQueue.useSampleRateTimeBase) {
            if (pullQueue.frameCount === avutil_constant__WEBPACK_IMPORTED_MODULE_19__.NOPTS_VALUE_BIGINT) {
                pullQueue.frameCount = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), resource.oformatContext.streams[0].timeBase);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](avpacket + 16, pullQueue.frameCount), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](avpacket + 8, pullQueue.frameCount);
            }
            else {
                pullQueue.frameCount = pullQueue.frameCount + BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](resource.codecpar + 144) >>> 0);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](avpacket + 16, pullQueue.frameCount), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](avpacket + 8, pullQueue.frameCount);
            }
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(avpacket + 72, resource.oformatContext.streams[0].timeBase[cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress], 8);
        }
        return avpacket;
    }
    writeAVPacket(avpacket, resource, flush = false) {
        if (resource.enableRawMpeg) {
            if (!resource.timestampOffsetUpdated) {
                const offset = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q);
                resource.track.updateTimestampOffset((Number(offset & 0xffffffffn) >> 0) / 1000);
                resource.timestampOffsetUpdated = true;
            }
            resource.bufferQueue.push((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 28)).slice());
        }
        else {
            avformat_mux__WEBPACK_IMPORTED_MODULE_13__.writeAVPacket(resource.oformatContext, avpacket);
            if (flush) {
                resource.oformatContext.ioWriter.flush();
            }
        }
    }
    swap(resource, task) {
        if (resource.backPacket) {
            task.avpacketPool.release(resource.backPacket);
        }
        resource.backPacket = 0;
        if (resource.frontBuffered) {
            resource.backPacket = resource.frontPacket;
            resource.frontPacket = 0;
        }
        else {
            return false;
        }
        resource.frontBuffered = false;
        const now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
        this.pullAVPacket(resource, task).then((packet) => {
            if (packet < 0) {
                resource.packetEnded = true;
                resource.frontPacket = 0;
                return;
            }
            const cost = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])() - now;
            // 超过 5 毫秒认为是网卡了，对齐一下时间
            if (cost > 5) {
                resource.startTimestamp += BigInt(Math.floor(cost));
            }
            resource.frontPacket = packet;
            resource.frontBuffered = true;
            if (resource.seekSync) {
                resource.seekSync();
                resource.seekSync = null;
            }
            if (!resource.backPacket) {
                this.swap(resource, task);
            }
        });
        return true;
    }
    createLoop(resource, task) {
        resource.loop = new common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_16__["default"](() => {
            const canPlayBufferTime = resource.track.getBufferedEnd() - (task.currentTime + ((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])() - task.currentTimeNTP) / 1000);
            if (canPlayBufferTime > BUFFER_MAX * (task.playRate > BigInt(100) ? (Number(task.playRate) / 100) : 1)) {
                resource.loop.emptyTask();
                return;
            }
            if (!resource.backPacket) {
                if (resource.packetEnded && !resource.frontPacket) {
                    resource.ended = true;
                    resource.loop.stop();
                    if (!resource.enableRawMpeg) {
                        avformat_mux__WEBPACK_IMPORTED_MODULE_13__.writeTrailer(resource.oformatContext);
                        avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(resource.oformatContext);
                    }
                    if (resource.bufferQueue.size) {
                        resource.track.addBuffer(resource.bufferQueue.flush());
                    }
                    resource.track.end();
                }
                else {
                    resource.loop.emptyTask();
                }
                return;
            }
            let avpacket = resource.backPacket;
            const dts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q);
            if (task.enableJitterBuffer) {
                let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 236) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 32) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 236) * 1000)
                    : (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 224) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 120) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 224) * 1000)
                        : 0);
                if (buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.jitterBuffer)) {
                    this.setPlayRate(task.taskId, 1);
                }
            }
            const diff = dts * BigInt(100) / task.playRate + resource.startTimestamp - BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])()));
            if (diff <= 0 || canPlayBufferTime < BUFFER_MIN * (task.playRate > BigInt(100) ? (Number(task.playRate) / 100) : 1)) {
                if (resource.track.isPaused()) {
                    resource.track.enqueue();
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](avpacket + 32, resource.oformatContext.streams[0].index);
                const extradata = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_25__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */);
                if (extradata && checkExtradataChanged(resource.oformatContext.streams[0].codecpar.extradata, resource.oformatContext.streams[0].codecpar.extradataSize, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](extradata), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](extradata + 4))) {
                    this.mixExtradata(avpacket, resource, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](extradata), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](extradata + 4));
                }
                this.writeAVPacket(avpacket, resource, true);
                resource.track.addBuffer(resource.bufferQueue.flush());
                const codecType = resource.oformatContext.streams[0].codecpar.codecType;
                if (codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](task.stats + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.stats + 144) + BigInt(1));
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](task.stats + 160, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.stats + 160) + BigInt(1));
                }
                else if (codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](task.stats + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.stats + 56) + BigInt(1));
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](task.stats + 72, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.stats + 72) + BigInt(1));
                }
                if (task.playRate !== task.targetRate) {
                    resource.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])())) - (dts * BigInt(100) / task.targetRate);
                    task.playRate = task.targetRate;
                }
                if (resource.packetEnded && !resource.frontPacket) {
                    resource.ended = true;
                    resource.loop.stop();
                    if (!resource.enableRawMpeg) {
                        avformat_mux__WEBPACK_IMPORTED_MODULE_13__.writeTrailer(resource.oformatContext);
                        avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(resource.oformatContext);
                    }
                    if (resource.bufferQueue.size) {
                        resource.track.addBuffer(resource.bufferQueue.flush());
                    }
                    resource.track.end();
                    return;
                }
                this.swap(resource, task);
            }
            else {
                resource.loop.emptyTask();
            }
        }, 0, 0);
    }
    async startMux(resource, task) {
        let startDTS = avutil_constant__WEBPACK_IMPORTED_MODULE_19__.NOPTS_VALUE_BIGINT;
        let startPTS = avutil_constant__WEBPACK_IMPORTED_MODULE_19__.NOPTS_VALUE_BIGINT;
        let lastDTS = BigInt(0);
        let avpacket;
        const timeBase = resource.oformatContext.streams[0].timeBase;
        if (resource.backPacket > 0) {
            startDTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](resource.backPacket + 16);
            startPTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](resource.backPacket + 8);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](resource.backPacket + 32, resource.oformatContext.streams[0].index);
            this.writeAVPacket(resource.backPacket, resource);
            task.avpacketPool.release(resource.backPacket);
            resource.backPacket = 0;
        }
        while (startDTS < BigInt(0) || (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)((lastDTS - startDTS), timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q) < task.cacheDuration) {
            avpacket = await this.pullAVPacket(resource, task);
            if (avpacket < 0) {
                resource.packetEnded = true;
                break;
            }
            lastDTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16);
            if (startDTS < BigInt(0)) {
                startDTS = lastDTS;
                startPTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8);
            }
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8) < startPTS) {
                startPTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8);
            }
            if (task.video && task.video.streamIndex === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 32)) {
                const extradata = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_25__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */);
                if (extradata && checkExtradataChanged(resource.oformatContext.streams[0].codecpar.extradata, resource.oformatContext.streams[0].codecpar.extradataSize, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](extradata), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](extradata + 4))) {
                    this.mixExtradata(avpacket, resource, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](extradata), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](extradata + 4));
                }
            }
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](avpacket + 32, resource.oformatContext.streams[0].index);
            this.writeAVPacket(avpacket, resource);
            task.avpacketPool.release(avpacket);
        }
        if (startPTS !== avutil_constant__WEBPACK_IMPORTED_MODULE_19__.NOPTS_VALUE_BIGINT && resource.startPTS <= BigInt(0)) {
            resource.startPTS = startPTS;
        }
        resource.pullQueue.diff = BigInt(0);
        task.currentTimeNTP = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
        task.currentTime = 0;
        resource.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])())) - (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)(lastDTS, timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q) * BigInt(100) / task.playRate;
    }
    resetResource(resource, task) {
        resource.bufferQueue.flush();
        const oformat = new avformat_formats_OMovFormat__WEBPACK_IMPORTED_MODULE_14__["default"]({
            fragmentMode: 1 /* FragmentMode.FRAME */,
            fragment: true,
            fastOpen: true,
            movMode: 0 /* MovMode.MP4 */,
            defaultBaseIsMoof: true
        });
        resource.oformatContext.oformat = oformat;
        const track = new avrender_track_Track__WEBPACK_IMPORTED_MODULE_17__["default"]();
        track.onQuotaExceededError = () => {
            resource.startTimestamp -= BigInt(100);
        };
        track.onEnded = () => {
            if ((!task.audio || task.audio.ended) && (!task.video || task.video.ended)) {
                task.mediaSource.endOfStream();
                common_util_logger__WEBPACK_IMPORTED_MODULE_11__.info(`muxer ended, taskId: ${task.taskId}`, cheap__fileName__19, 743);
            }
        };
        resource.track = track;
        resource.packetEnded = false;
        resource.ended = false;
        resource.startTimestamp = BigInt(0);
        resource.frontBuffered = false;
        resource.seekSync = null;
        if (resource.loop) {
            resource.loop.destroy();
            resource.loop = null;
        }
        if (resource.frontPacket) {
            task.avpacketPool.release(resource.frontPacket);
            resource.frontPacket = 0;
        }
        if (resource.backPacket) {
            task.avpacketPool.release(resource.backPacket);
            resource.backPacket = 0;
        }
        resource.pullQueue.ended = false;
        resource.pullQueue.index = 0;
        resource.pullQueue.frameCount = avutil_constant__WEBPACK_IMPORTED_MODULE_19__.NOPTS_VALUE_BIGINT;
        resource.pullQueue.lastPTS = BigInt(0);
        resource.pullQueue.lastDTS = BigInt(0);
        resource.pullQueue.diff = BigInt(0);
    }
    async addStream(taskId, streamIndex, codecpar, timeBase, startPTS, pullIPCPort) {
        const task = this.tasks.get(taskId);
        if (task) {
            const ioWriter = new common_io_IOWriterSync__WEBPACK_IMPORTED_MODULE_12__["default"](1048576);
            const oformatContext = (0,avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_7__.createAVOFormatContext)();
            const oformat = new avformat_formats_OMovFormat__WEBPACK_IMPORTED_MODULE_14__["default"]({
                fragmentMode: 1 /* FragmentMode.FRAME */,
                fragment: true,
                fastOpen: true,
                movMode: 0 /* MovMode.MP4 */,
                defaultBaseIsMoof: true
            });
            const bufferQueue = new common_io_SeekableWriteBufferQueue__WEBPACK_IMPORTED_MODULE_24__["default"]();
            ioWriter.onFlush = (buffer) => {
                bufferQueue.push(buffer.slice());
                return 0;
            };
            ioWriter.onSeek = (pos) => {
                return bufferQueue.seek(pos) ? 0 : avutil_error__WEBPACK_IMPORTED_MODULE_9__.INVALID_OPERATE;
            };
            const stream = oformatContext.createStream();
            (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_15__.copyCodecParameters)(stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress], codecpar);
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 4) === 86017 /* AVCodecID.AV_CODEC_ID_MP3 */) {
                stream.codecpar.codecTag = (0,avformat_function_mktag__WEBPACK_IMPORTED_MODULE_31__["default"])('.mp3');
            }
            const useSampleRateTimeBase = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 144)
                && !task.isLive
                && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avQ2D2)(timeBase) > (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avQ2D)({ num: 1, den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 136) });
            // 点播 frameSize 有并且时间基精度小于采样率精度则使用 sampleRate 作为时间基
            // 避免一些 mp4 ts 转为 flv 因为时间基精度损失导致的 pts 抖动
            // 当 pts 抖动时 mse 播放会有颤音
            if (useSampleRateTimeBase) {
                stream.timeBase.den = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 136);
                stream.timeBase.num = 1;
            }
            else {
                stream.timeBase.den = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](timeBase + 4);
                stream.timeBase.num = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](timeBase);
            }
            oformatContext.oformat = oformat;
            oformatContext.ioWriter = ioWriter;
            const track = new avrender_track_Track__WEBPACK_IMPORTED_MODULE_17__["default"]();
            const resource = {
                type: 'audio',
                codecpar,
                ioWriter,
                oformatContext,
                oformat,
                track,
                bufferQueue,
                streamIndex,
                pullIPC: new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_10__["default"](pullIPCPort),
                loop: null,
                frontPacket: 0,
                backPacket: 0,
                frontBuffered: false,
                startTimestamp: BigInt(0),
                packetEnded: false,
                ended: false,
                seekSync: null,
                startPTS,
                pullQueue: {
                    queue: [],
                    index: 0,
                    frameCount: avutil_constant__WEBPACK_IMPORTED_MODULE_19__.NOPTS_VALUE_BIGINT,
                    diff: BigInt(0),
                    lastPTS: BigInt(0),
                    lastDTS: BigInt(0),
                    ended: false,
                    useSampleRateTimeBase
                },
                enableRawMpeg: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 4) === 86017 /* AVCodecID.AV_CODEC_ID_MP3 */ && !common_util_browser__WEBPACK_IMPORTED_MODULE_27__["default"].firefox,
                timestampOffsetUpdated: false
            };
            track.onQuotaExceededError = () => {
                resource.startTimestamp -= BigInt(100);
            };
            track.onEnded = () => {
                if ((!task.audio || task.audio.ended) && (!task.video || task.video.ended)) {
                    task.mediaSource.endOfStream();
                    common_util_logger__WEBPACK_IMPORTED_MODULE_11__.info(`muxer ended, taskId: ${task.taskId}`, cheap__fileName__19, 876);
                }
            };
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                task.audio = resource;
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.stats + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 136));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.stats, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 116));
            }
            else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                resource.type = 'video';
                task.video = resource;
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.stats + 84, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 56));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.stats + 88, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 60));
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 84) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 88) > 8294400 && common_util_browser__WEBPACK_IMPORTED_MODULE_27__["default"].safari) {
                    task.cacheDuration = common_util_bigint__WEBPACK_IMPORTED_MODULE_30__.max(BigInt(3000), task.cacheDuration);
                }
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task not found', cheap__fileName__19, 897);
        }
    }
    async reAddStream(taskId, streamIndex, codecpar, timeBase, startPTS) {
        const task = this.tasks.get(taskId);
        if (task) {
            const resource = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */ ? task.audio : task.video;
            if (resource) {
                resource.bufferQueue.flush();
                // 等待 track abort
                await new Promise((resolve) => {
                    resource.track.removeAllBuffer(() => {
                        resolve();
                    });
                });
                resource.track.reset();
                const oformat = new avformat_formats_OMovFormat__WEBPACK_IMPORTED_MODULE_14__["default"]({
                    fragmentMode: 1 /* FragmentMode.FRAME */,
                    fragment: true,
                    fastOpen: true,
                    movMode: 0 /* MovMode.MP4 */,
                    defaultBaseIsMoof: true
                });
                resource.oformatContext.oformat = oformat;
                resource.codecpar = codecpar;
                resource.streamIndex = streamIndex;
                resource.startPTS = startPTS;
                const stream = resource.oformatContext.streams[0];
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_15__.copyCodecParameters)(stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress], codecpar);
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 4) === 86017 /* AVCodecID.AV_CODEC_ID_MP3 */) {
                    stream.codecpar.codecTag = (0,avformat_function_mktag__WEBPACK_IMPORTED_MODULE_31__["default"])('.mp3');
                }
                const useSampleRateTimeBase = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                    && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 144)
                    && !task.isLive
                    && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avQ2D2)(timeBase) > (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avQ2D)({ num: 1, den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 136) });
                // 点播 frameSize 有并且时间基精度小于采样率精度则使用 sampleRate 作为时间基
                // 避免一些 mp4 ts 转为 flv 因为时间基精度损失导致的 pts 抖动
                // 当 pts 抖动时 mse 播放会有颤音
                if (useSampleRateTimeBase) {
                    stream.timeBase.den = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 136);
                    stream.timeBase.num = 1;
                }
                else {
                    stream.timeBase.den = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](timeBase + 4);
                    stream.timeBase.num = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](timeBase);
                }
                resource.track.changeMimeType(this.getMimeType(stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress]));
                if (!resource.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.open(resource.oformatContext, {
                        paddingZero: false
                    });
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.writeHeader(resource.oformatContext);
                }
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task not found', cheap__fileName__19, 970);
        }
    }
    async pause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (!task.audio?.loop && !task.video?.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task has not played', cheap__fileName__19, 978);
            }
            task.pausing = true;
            task.pauseTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
            task.audio?.loop.stop();
            task.video?.loop.stop();
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task not found', cheap__fileName__19, 986);
        }
    }
    async unpause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (!task.audio?.loop && !task.video?.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task has not played', cheap__fileName__19, 994);
            }
            task.pausing = false;
            if (!task.seeking) {
                if (task.audio) {
                    task.audio.startTimestamp += BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])() - task.pauseTimestamp));
                    task.audio.loop.start();
                }
                if (task.video) {
                    task.video.startTimestamp += BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])() - task.pauseTimestamp));
                    task.video.loop.start();
                }
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task not found', cheap__fileName__19, 1011);
        }
    }
    async beforeSeek(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            // 当前正在 pull frontFrame，等待其结束
            const promise = [];
            if (task.audio) {
                if (!task.audio.ended && !task.audio.frontBuffered) {
                    promise.push(new Promise((resolve) => {
                        task.audio.seekSync = resolve;
                    }));
                }
            }
            if (task.video) {
                if (!task.video.ended && !task.video.frontBuffered) {
                    promise.push(new Promise((resolve) => {
                        task.video.seekSync = resolve;
                    }));
                }
            }
            await Promise.all(promise);
            task.seeking = true;
            task.audio?.loop.stop();
            task.video?.loop.stop();
            if (task.audio) {
                if (!task.audio.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(task.audio.oformatContext);
                }
                task.audio.bufferQueue.flush();
                if (common_util_browser__WEBPACK_IMPORTED_MODULE_27__["default"].safari) {
                    await new Promise((resolve) => {
                        task.audio.track.removeAllBuffer(() => {
                            resolve();
                        });
                    });
                }
                task.audio.track.reset();
                task.audio.packetEnded = false;
                task.audio.timestampOffsetUpdated = false;
                if (task.audio.backPacket) {
                    task.avpacketPool.release(task.audio.backPacket);
                    task.audio.backPacket = 0;
                }
                if (task.audio.frontPacket) {
                    task.avpacketPool.release(task.audio.frontPacket);
                    task.audio.frontPacket = 0;
                }
                if (task.audio.pullQueue.queue.length) {
                    task.audio.pullQueue.queue.forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                }
                task.audio.pullQueue.queue.length = 0;
                task.audio.pullQueue.ended = false;
                task.audio.pullQueue.index = 0;
                task.audio.pullQueue.lastPTS = BigInt(0);
                task.audio.pullQueue.lastDTS = BigInt(0);
                task.audio.pullQueue.diff = BigInt(0);
                task.audio.pullQueue.frameCount = avutil_constant__WEBPACK_IMPORTED_MODULE_19__.NOPTS_VALUE_BIGINT;
            }
            if (task.video) {
                if (!task.video.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(task.video.oformatContext);
                }
                task.video.bufferQueue.flush();
                if (common_util_browser__WEBPACK_IMPORTED_MODULE_27__["default"].safari) {
                    await new Promise((resolve) => {
                        task.video.track.removeAllBuffer(() => {
                            resolve();
                        });
                    });
                }
                task.video.track.reset();
                task.video.packetEnded = false;
                task.video.timestampOffsetUpdated = false;
                if (task.video.backPacket) {
                    task.avpacketPool.release(task.video.backPacket);
                    task.video.backPacket = 0;
                }
                if (task.video.frontPacket) {
                    task.avpacketPool.release(task.video.frontPacket);
                    task.video.frontPacket = 0;
                }
                if (task.video.pullQueue.queue.length) {
                    task.video.pullQueue.queue.forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                }
                task.video.pullQueue.queue.length = 0;
                task.video.pullQueue.ended = false;
                task.video.pullQueue.index = 0;
                task.video.pullQueue.diff = BigInt(0);
                task.video.pullQueue.lastPTS = BigInt(0);
                task.video.pullQueue.lastDTS = BigInt(0);
            }
        }
    }
    async afterSeek(taskId, timestamp) {
        const task = this.tasks.get(taskId);
        if (task) {
            let audioRealTimestamp = timestamp;
            let videoRealTimestamp = timestamp;
            let firstIsKeyframe = await this.syncToKeyframe(task);
            if (task.audio && task.audio.backPacket > 0) {
                if (!firstIsKeyframe || timestamp < BigInt(0)) {
                    audioRealTimestamp = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.audio.backPacket + 8) - task.audio.startPTS, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.audio.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q);
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.audio.backPacket + 32, task.audio.oformatContext.streams[0].index);
                this.writeAVPacket(task.audio.backPacket, task.audio);
                task.avpacketPool.release(task.audio.backPacket);
                task.audio.backPacket = 0;
            }
            if (task.video && task.video.backPacket > 0) {
                if (!firstIsKeyframe || timestamp < BigInt(0)) {
                    videoRealTimestamp = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.video.backPacket + 8) - task.video.startPTS, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.video.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q);
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.video.backPacket + 32, task.video.oformatContext.streams[0].index);
                this.writeAVPacket(task.video.backPacket, task.video);
                task.avpacketPool.release(task.video.backPacket);
                task.video.backPacket = 0;
            }
            const realTimestamp = common_util_bigint__WEBPACK_IMPORTED_MODULE_30__.max(audioRealTimestamp, videoRealTimestamp);
            // 缓存一定的 buffer
            while (true) {
                if (task.audio && !task.audio.packetEnded) {
                    task.audio.backPacket = await this.pullAVPacket(task.audio, task);
                    if (task.audio.backPacket < 0) {
                        task.audio.packetEnded = true;
                        task.audio.backPacket = 0;
                        if (!task.video || task.video.packetEnded) {
                            break;
                        }
                    }
                    if (audioRealTimestamp < BigInt(0)) {
                        audioRealTimestamp = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.audio.backPacket + 8) - task.audio.startPTS, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.audio.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q);
                    }
                    if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.audio.backPacket + 8) - task.audio.startPTS), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.audio.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q)
                        < realTimestamp + task.cacheDuration) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.audio.backPacket + 32, task.audio.oformatContext.streams[0].index);
                        this.writeAVPacket(task.audio.backPacket, task.audio);
                        if (!task.audio.enableRawMpeg) {
                            avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(task.audio.oformatContext);
                        }
                        task.audio.track.addBuffer(task.audio.bufferQueue.flush());
                        task.avpacketPool.release(task.audio.backPacket);
                        task.audio.backPacket = 0;
                    }
                    else {
                        break;
                    }
                }
                if (task.video && !task.video.packetEnded) {
                    task.video.backPacket = await this.pullAVPacket(task.video, task);
                    if (task.video.backPacket < 0) {
                        task.video.packetEnded = true;
                        task.video.backPacket = 0;
                        if (!task.audio || task.audio.packetEnded) {
                            break;
                        }
                    }
                    if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.video.backPacket + 8) - task.video.startPTS, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.video.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q)
                        < realTimestamp + task.cacheDuration) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.video.backPacket + 32, task.video.oformatContext.streams[0].index);
                        this.writeAVPacket(task.video.backPacket, task.video);
                        if (!task.video.enableRawMpeg) {
                            avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(task.video.oformatContext);
                        }
                        task.video.track.addBuffer(task.video.bufferQueue.flush());
                        task.avpacketPool.release(task.video.backPacket);
                        task.video.backPacket = 0;
                    }
                    else {
                        break;
                    }
                }
            }
            const promises = [];
            if (task.audio) {
                if (!task.audio.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(task.audio.oformatContext);
                }
                promises.push(new Promise((resolve) => {
                    task.audio.track.addBuffer(task.audio.bufferQueue.flush(), () => {
                        resolve();
                    });
                }));
            }
            if (task.video) {
                if (!task.video.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(task.video.oformatContext);
                }
                promises.push(new Promise((resolve) => {
                    task.video.track.addBuffer(task.video.bufferQueue.flush(), () => {
                        resolve();
                    });
                }));
            }
            await Promise.all(promises);
            if (task.audio && !task.audio.packetEnded) {
                if (task.audio.backPacket <= 0) {
                    task.audio.backPacket = await this.pullAVPacket(task.audio, task);
                    if (task.audio.backPacket < 0) {
                        task.audio.packetEnded = true;
                        task.audio.backPacket = 0;
                    }
                }
                if (!task.audio.packetEnded) {
                    task.audio.frontPacket = await this.pullAVPacket(task.audio, task);
                    if (task.audio.frontPacket < 0) {
                        task.audio.frontPacket = 0;
                        task.audio.packetEnded = true;
                        task.audio.frontBuffered = false;
                    }
                    else {
                        task.audio.packetEnded = false;
                        task.audio.frontBuffered = true;
                    }
                    task.audio.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])())) - (audioRealTimestamp + task.cacheDuration + (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)(task.audio.startPTS, task.audio.oformatContext.streams[0].timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q)) * BigInt(100) / task.playRate;
                    if (task.pausing) {
                        task.pauseTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
                    }
                    else {
                        task.audio.loop.start();
                    }
                }
            }
            if (task.video && !task.video.packetEnded) {
                if (task.video.backPacket <= 0) {
                    task.video.backPacket = await this.pullAVPacket(task.video, task);
                    if (task.video.backPacket < 0) {
                        task.video.packetEnded = true;
                        task.video.backPacket = 0;
                    }
                }
                if (!task.video.packetEnded) {
                    task.video.frontPacket = await this.pullAVPacket(task.video, task);
                    if (task.video.frontPacket < 0) {
                        task.video.packetEnded = true;
                        task.video.frontBuffered = false;
                        task.video.frontPacket = 0;
                    }
                    else {
                        task.video.packetEnded = false;
                        task.video.frontBuffered = true;
                    }
                    task.video.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])())) - (videoRealTimestamp + task.cacheDuration + (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_20__.avRescaleQ)(task.video.startPTS, task.video.oformatContext.streams[0].timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q)) * BigInt(100) / task.playRate;
                    if (task.pausing) {
                        task.pauseTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
                    }
                    else {
                        task.video.loop.start();
                    }
                }
            }
            if (!firstIsKeyframe) {
                await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_29__["default"](0.5);
            }
            let min = 0;
            let max = 0;
            if (task.audio) {
                if (task.video) {
                    min = Math.max(task.audio.track.getBufferedStart(), task.video.track.getBufferedStart());
                    max = Math.min(task.audio.track.getBufferedEnd(), task.video.track.getBufferedEnd());
                }
                else {
                    min = task.audio.track.getBufferedStart();
                    max = task.audio.track.getBufferedEnd();
                }
            }
            else if (task.video) {
                min = task.video.track.getBufferedStart();
                max = task.video.track.getBufferedEnd();
            }
            let seekTime = (0,avutil_util_common__WEBPACK_IMPORTED_MODULE_28__.milliSecond2Second)(realTimestamp);
            if (!(seekTime >= min && seekTime <= max)) {
                seekTime = Math.abs(seekTime - min) > Math.abs(seekTime - max) ? max : min;
            }
            task.currentTimeNTP = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
            task.currentTime = seekTime;
            task.seeking = false;
            return seekTime;
        }
        return 0;
    }
    async setPlayRate(taskId, rate) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.enableJitterBuffer) {
                let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 236) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 32) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 236) * 1000)
                    : (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 224) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 120) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 224) * 1000)
                        : 0);
                if (buffer && buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.jitterBuffer)) {
                    rate = 1;
                }
            }
            task.targetRate = BigInt(Math.floor(Math.floor(rate * 100)));
            if (!task.enableJitterBuffer) {
                if (task.audio && task.audio.loop) {
                    task.audio.loop.resetInterval();
                }
                if (task.video && task.video.loop) {
                    task.video.loop.resetInterval();
                }
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task not found', cheap__fileName__19, 1372);
        }
    }
    async restart(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.audio) {
                this.resetResource(task.audio, task);
            }
            if (task.video) {
                this.resetResource(task.video, task);
            }
            const mediaSource = new ((0,_function_getMediaSource__WEBPACK_IMPORTED_MODULE_32__["default"])())();
            mediaSource.onsourceopen = this.getSourceOpenHandler(task);
            task.mediaSource = mediaSource;
        }
    }
    async setCurrentTime(taskId, time) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.audio) {
                task.audio.track.removeBuffer(time);
            }
            if (task.video) {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 92) > 0) {
                    task.video.track.setMediaBufferMax(Math.max(task.video.track.getMediaBufferMax(), Math.ceil(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 92) / 1000 * 1.5), 10));
                    task.video.track.removeBuffer(time);
                }
            }
            task.currentTime = time;
            task.currentTimeNTP = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task not found', cheap__fileName__19, 1414);
        }
    }
    async getMediaSource(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.mediaSource.handle) {
                // @ts-ignore
                this.getMediaSource.transfer.push(task.mediaSource.handle);
                return task.mediaSource.handle;
            }
            else {
                return task.mediaSource;
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task not found', cheap__fileName__19, 1431);
        }
    }
    createTask(options) {
        const controlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_10__["default"](options.controlPort);
        const mediaSource = new MediaSource() || new ManagedMediaSource();
        const task = {
            ...options,
            mediaSource,
            audio: null,
            video: null,
            playRate: BigInt(100),
            targetRate: BigInt(100),
            pauseTimestamp: 0,
            seeking: false,
            pausing: false,
            controlIPCPort,
            currentTime: 0,
            currentTimeNTP: 0,
            cacheDuration: BigInt(Math.floor(BUFFER_MIN * 1000)),
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_18__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_6__["default"]), options.avpacketListMutex)
        };
        this.tasks.set(options.taskId, task);
        mediaSource.onsourceopen = this.getSourceOpenHandler(task);
        return 0;
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_9__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(id) {
        const task = this.tasks.get(id);
        if (task) {
            if (task.audio) {
                if (task.audio.loop) {
                    task.audio.oformatContext.destroy();
                    task.audio.loop.destroy();
                }
                if (task.audio.pullIPC) {
                    task.audio.pullIPC.destroy();
                }
                if (task.audio.pullQueue.queue.length) {
                    task.audio.pullQueue.queue.forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                    task.audio.pullQueue.queue.length = 0;
                }
            }
            if (task.video) {
                if (task.video.loop) {
                    task.video.oformatContext.destroy();
                    task.video.loop.destroy();
                }
                if (task.video.pullIPC) {
                    task.video.pullIPC.destroy();
                }
                if (task.video.pullQueue.queue.length) {
                    task.video.pullQueue.queue.forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                    task.video.pullQueue.queue.length = 0;
                }
            }
            if (task.controlIPCPort) {
                task.controlIPCPort.destroy();
            }
            this.tasks.delete(id);
        }
    }
}


/***/ }),

/***/ "./src/avplayer/subtitle/AssRender.ts":
/*!********************************************!*\
  !*** ./src/avplayer/subtitle/AssRender.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AssRender)
/* harmony export */ });
/* unused harmony export defaultStyle */
/* harmony import */ var assjs_src_renderer_animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! assjs/src/renderer/animation */ "./node_modules/assjs/src/renderer/animation.js");
/* harmony import */ var assjs_src_renderer_font_size__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! assjs/src/renderer/font-size */ "./node_modules/assjs/src/renderer/font-size.js");
/* harmony import */ var assjs_src_internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! assjs/src/internal */ "./node_modules/assjs/src/internal.js");
/* harmony import */ var assjs_src_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! assjs/src/utils */ "./node_modules/assjs/src/utils.js");
/* harmony import */ var common_function_generateUUID__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/function/generateUUID */ "./src/common/function/generateUUID.ts");
/* harmony import */ var ass_compiler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ass-compiler */ "./node_modules/ass-compiler/dist/esm/ass-compiler.js");
/* harmony import */ var ass_compiler_src_compiler_dialogues__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ass-compiler/src/compiler/dialogues */ "./node_modules/ass-compiler/src/compiler/dialogues.js");
/* harmony import */ var ass_compiler_src_compiler_styles__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ass-compiler/src/compiler/styles */ "./node_modules/ass-compiler/src/compiler/styles.js");
/* harmony import */ var assjs_src_renderer_renderer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! assjs/src/renderer/renderer */ "./node_modules/assjs/src/renderer/renderer.js");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/*
 * libmedia ass render
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */










const GLOBAL_CSS = '.ASS-box{font-family:Arial;overflow:hidden;pointer-events:none;position:absolute}.ASS-dialogue{font-size:0;position:absolute;z-index:0}.ASS-dialogue span{display:inline-block}.ASS-dialogue [data-text]{display:inline-block;color:var(--ass-fill-color);font-size:calc(var(--ass-scale)*var(--ass-real-fs)*1px);line-height:calc(var(--ass-scale)*var(--ass-tag-fs)*1px);letter-spacing:calc(var(--ass-scale)*var(--ass-tag-fsp)*1px)}.ASS-dialogue [data-wrap-style="0"],.ASS-dialogue [data-wrap-style="3"]{text-wrap:balance}.ASS-dialogue [data-wrap-style="1"]{word-break:break-word;white-space:normal}.ASS-dialogue [data-wrap-style="2"]{word-break:normal;white-space:nowrap}.ASS-dialogue [data-border-style="1"]{position:relative}.ASS-dialogue [data-border-style="1"]::after,.ASS-dialogue [data-border-style="1"]::before{content:attr(data-text);position:absolute;top:0;left:0;z-index:-1;filter:blur(calc(var(--ass-tag-blur)*1px))}.ASS-dialogue [data-border-style="1"]::before{color:var(--ass-shadow-color);transform:translate(calc(var(--ass-scale-stroke)*var(--ass-tag-xshad)*1px),calc(var(--ass-scale-stroke)*var(--ass-tag-yshad)*1px));-webkit-text-stroke:var(--ass-border-width) var(--ass-shadow-color);text-shadow:var(--ass-shadow-delta);opacity:var(--ass-shadow-opacity)}.ASS-dialogue [data-border-style="1"]::after{color:transparent;-webkit-text-stroke:var(--ass-border-width) var(--ass-border-color);text-shadow:var(--ass-border-delta);opacity:var(--ass-border-opacity)}.ASS-dialogue [data-border-style="3"]{padding:calc(var(--ass-scale-stroke)*var(--ass-tag-xbord)*1px) calc(var(--ass-scale-stroke)*var(--ass-tag-ybord)*1px);position:relative;filter:blur(calc(var(--ass-tag-blur)*1px))}.ASS-dialogue [data-border-style="3"]::after,.ASS-dialogue [data-border-style="3"]::before{content:"";width:100%;height:100%;position:absolute;z-index:-1}.ASS-dialogue [data-border-style="3"]::before{background-color:var(--ass-shadow-color);left:calc(var(--ass-scale-stroke)*var(--ass-tag-xshad)*1px);top:calc(var(--ass-scale-stroke)*var(--ass-tag-yshad)*1px)}.ASS-dialogue [data-border-style="3"]::after{background-color:var(--ass-border-color);left:0;top:0}@container style(--ass-tag-xbord: 0) and style(--ass-tag-ybord: 0){.ASS-dialogue [data-border-style="3"]::after{background-color:transparent}}@container style(--ass-tag-xshad: 0) and style(--ass-tag-yshad: 0){.ASS-dialogue [data-border-style="3"]::before{background-color:transparent}}.ASS-dialogue [data-rotate]{transform:perspective(312.5px) rotateY(calc(var(--ass-tag-fry)*1deg)) rotateX(calc(var(--ass-tag-frx)*1deg)) rotateZ(calc(var(--ass-tag-frz)*-1deg))}.ASS-dialogue [data-text][data-rotate]{transform-style:preserve-3d;word-break:normal;white-space:nowrap}.ASS-dialogue [data-scale],.ASS-dialogue [data-skew]{display:inline-block;transform:scale(var(--ass-tag-fscx),var(--ass-tag-fscy)) skew(calc(var(--ass-tag-fax)*1rad),calc(var(--ass-tag-fay)*1rad));transform-origin:var(--ass-align-h) var(--ass-align-v)}.ASS-fix-font-size{font-size:2048px;font-family:Arial;line-height:normal;width:0;height:0;position:absolute;visibility:hidden;overflow:hidden}.ASS-clip-area,.ASS-fix-font-size span{position:absolute}.ASS-clip-area{width:100%;height:100%;top:0;left:0}.ASS-scroll-area{position:absolute;width:100%;overflow:hidden}';
function addGlobalStyle(container) {
    const rootNode = container.getRootNode() || document;
    let isDocument = rootNode instanceof Document;
    if (!isDocument && typeof documentPictureInPicture === 'object' && documentPictureInPicture.window) {
        isDocument = rootNode === documentPictureInPicture.window.document;
    }
    const styleRoot = isDocument ? rootNode.head : rootNode;
    let $style = styleRoot.querySelector('#ASS-global-style');
    if (!$style) {
        $style = document.createElement('style');
        $style.type = 'text/css';
        $style.id = 'ASS-global-style';
        $style.append(document.createTextNode(GLOBAL_CSS));
        styleRoot.append($style);
    }
    if (!document.head.querySelector('#ASS-global-style')) {
        $style = document.createElement('style');
        $style.type = 'text/css';
        $style.id = 'ASS-global-style';
        $style.append(document.createTextNode(GLOBAL_CSS));
        document.head.append($style);
    }
}
const defaultStyle = {
    Name: 'Default',
    Fontname: 'Arial',
    Fontsize: '16',
    PrimaryColour: '&Hffffff',
    SecondaryColour: '&Hffffff',
    OutlineColour: '&H0',
    BackColour: '&H0',
    Bold: '0',
    Italic: '0',
    Underline: '0',
    StrikeOut: '0',
    ScaleX: '100',
    ScaleY: '100',
    Spacing: '0',
    Angle: '0',
    BorderStyle: '1',
    Outline: '1',
    Shadow: '0',
    Alignment: '2',
    MarginL: '10',
    MarginR: '10',
    MarginV: '10',
    Encoding: '0',
};
class AssRender {
    store;
    resampling_ = 'video_height';
    resize_;
    options;
    constructor(dom, options = { container: dom.parentNode }) {
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend({}, options);
        this.store = {
            video: dom,
            box: document.createElement('div'),
            svg: (0,assjs_src_utils__WEBPACK_IMPORTED_MODULE_3__.createSVGEl)('svg'),
            defs: (0,assjs_src_utils__WEBPACK_IMPORTED_MODULE_3__.createSVGEl)('defs'),
            observer: null,
            scale: 1,
            width: 0,
            height: 0,
            scriptRes: {
                width: options.videoWidth || dom.clientWidth,
                height: options.videoHeight || dom.clientHeight
            },
            layoutRes: {
                width: options.videoWidth || dom.clientWidth,
                height: options.videoHeight || dom.clientHeight
            },
            resampledRes: {
                width: 0,
                height: 0
            },
            sbas: true,
            styles: null,
            space: [],
            actives: [],
            delay: 0,
            index: 0,
            dialogues: []
        };
        if (options.videoWidth == null) {
            // @ts-ignore
            dom.videoWidth = options.videoWidth;
        }
        if (options.videoHeight == null) {
            // @ts-ignore
            dom.videoHeight = options.videoHeight;
        }
        if (!options.container) {
            throw new Error('Missing container.');
        }
        this.resize_ = (0,assjs_src_internal__WEBPACK_IMPORTED_MODULE_2__.createResize)(this, this.store);
        this.updateHeader(options.header);
        options.container.append(assjs_src_renderer_font_size__WEBPACK_IMPORTED_MODULE_1__.$fixFontSize);
        const { svg, defs, scriptRes, box } = this.store;
        svg.setAttributeNS(null, 'viewBox', `0 0 ${scriptRes.width} ${scriptRes.height}`);
        svg.append(defs);
        options.container.append(svg);
        box.className = 'ASS-box';
        options.container.append(box);
        addGlobalStyle(options.container);
        this.resampling_ = options.resampling || 'video_height';
        const observer = new ResizeObserver(this.resize.bind(this));
        observer.observe(dom);
        this.store.observer = observer;
        return this;
    }
    framing(dialogue) {
        const dia = (0,assjs_src_renderer_renderer__WEBPACK_IMPORTED_MODULE_8__.renderer)(dialogue, this.store);
        (0,assjs_src_utils__WEBPACK_IMPORTED_MODULE_3__.batchAnimate)(dia, 'play');
        dia.__dialogue = dialogue;
        this.store.actives.push(dia);
    }
    updateHeader(header) {
        if (header) {
            const { info, width, height, styles } = (0,ass_compiler__WEBPACK_IMPORTED_MODULE_5__.compile)(header, {
                defaultStyle
            });
            this.store.sbas = /yes/i.test(info.ScaledBorderAndShadow);
            this.store.layoutRes = {
                width: +info.LayoutResX || this.options.videoWidth || this.store.video.clientWidth,
                height: +info.LayoutResY || this.options.videoHeight || this.store.video.clientHeight,
            };
            this.store.scriptRes = {
                width: width || this.store.layoutRes.width,
                height: height || this.store.layoutRes.height,
            };
            this.store.styles = styles;
        }
        else {
            this.store.styles = (0,ass_compiler_src_compiler_styles__WEBPACK_IMPORTED_MODULE_7__.compileStyles)({
                info: {
                    WrapStyle: ''
                },
                style: [],
                defaultStyle
            });
            this.store.scriptRes = {
                width: 384,
                height: 288
            };
        }
        this.resize_();
        this.options.header = header;
    }
    updateVideoResolution(videoWidth, videoHeight) {
        if (this.options.header) {
            const { info, width, height } = (0,ass_compiler__WEBPACK_IMPORTED_MODULE_5__.compile)(this.options.header, {
                defaultStyle
            });
            this.store.layoutRes = {
                width: +info.LayoutResX || videoWidth || this.store.video.clientWidth,
                height: +info.LayoutResY || videoHeight || this.store.video.clientHeight,
            };
            this.store.scriptRes = {
                width: width || this.store.layoutRes.width,
                height: height || this.store.layoutRes.height,
            };
        }
        else {
            this.store.layoutRes = {
                width: videoWidth,
                height: videoHeight
            };
        }
    }
    render(event) {
        if (event.type === 1 /* AssEventType.Dialogue */) {
            // @ts-ignore
            event.Start = Number(event.Start) / 1000;
            // @ts-ignore
            event.End = Number(event.End) / 1000;
            const dialogue = (0,ass_compiler_src_compiler_dialogues__WEBPACK_IMPORTED_MODULE_6__.compileDialogues)({
                styles: this.store.styles,
                dialogues: [event]
            })[0];
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(dialogue, {
                d: `ASS-${(0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_4__["default"])()}`,
                align: {
                    h: (dialogue.alignment + 2) % 3,
                    v: Math.trunc((dialogue.alignment - 1) / 3)
                }
            });
            (0,assjs_src_renderer_animation__WEBPACK_IMPORTED_MODULE_0__.setKeyframes)(dialogue, this.store);
            this.framing(dialogue);
        }
    }
    clear(pts) {
        const now = (Number(pts & 0xffffffffn) >> 0) / 1000;
        for (let i = this.store.actives.length - 1; i >= 0; i -= 1) {
            const dia = this.store.actives[i];
            const { end } = dia;
            if (end < now) {
                dia.$div.remove();
                this.store.actives.splice(i, 1);
            }
        }
    }
    clearAll() {
        for (let i = this.store.actives.length - 1; i >= 0; i -= 1) {
            const dia = this.store.actives[i];
            dia.$div.remove();
        }
        this.store.actives.length = 0;
        this.store.space.length = 0;
    }
    resize() {
        const actions = this.store.actives.slice();
        this.resize_();
        for (let i = 0; i < actions.length; i++) {
            this.framing(actions[i].__dialogue);
        }
    }
    destroy() {
        const { video, box, svg, observer } = this.store;
        (0,assjs_src_internal__WEBPACK_IMPORTED_MODULE_2__.clear)(this.store);
        assjs_src_renderer_font_size__WEBPACK_IMPORTED_MODULE_1__.$fixFontSize.remove();
        svg.remove();
        box.remove();
        observer.unobserve(video);
        this.store.styles = {};
        return this;
    }
    show() {
        this.store.box.style.visibility = 'visible';
        return this;
    }
    hide() {
        this.store.box.style.visibility = 'hidden';
        return this;
    }
    get resampling() {
        return this.resampling_;
    }
    set resampling(r) {
        if (r === this.resampling_) {
            return;
        }
        if (/^(video|script)_(width|height)$/.test(r)) {
            this.resampling_ = r;
            this.resize();
        }
    }
}


/***/ }),

/***/ "./src/avplayer/subtitle/SubtitleRender.ts":
/*!*************************************************!*\
  !*** ./src/avplayer/subtitle/SubtitleRender.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SubtitleRender)
/* harmony export */ });
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./..\..\cheap\std\collection\List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./..\..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var avcodec_subtitle_SubtitleDecoder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avcodec/subtitle/SubtitleDecoder */ "./src/avcodec/subtitle/SubtitleDecoder.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/timer/LoopTask */ "./src/common/timer/LoopTask.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _AssRender__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./AssRender */ "./src/avplayer/subtitle/AssRender.ts");
/* harmony import */ var avutil_struct_avsubtitle__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/struct/avsubtitle */ "./src/avutil/struct/avsubtitle.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avformat_formats_ass_iass__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avformat/formats/ass/iass */ "./src/avformat/formats/ass/iass.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
var cheap__fileName__6 = "src\\avplayer\\subtitle\\SubtitleRender.ts";





/*
 * libmedia subtitle render
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */














const WebVttReplace = [
    {
        reg: /<i>/g,
        value: '{\\i1}'
    },
    {
        reg: /<\/i>/g,
        value: '{\\i0}'
    },
    {
        reg: /<b>/g,
        value: '{\\b1}'
    },
    {
        reg: /<\/b>/g,
        value: '{\\b0}'
    },
    {
        reg: /<u>/g,
        value: '{\\u1}'
    },
    {
        reg: /<\/u>/g,
        value: '{\\u0}'
    },
    {
        reg: /{/g,
        value: '\\{'
    },
    {
        reg: /}/g,
        value: '\\}'
    },
    {
        reg: /&gt;/g,
        value: '>'
    },
    {
        reg: /&lt;/g,
        value: '<'
    },
    {
        reg: /&lrm;/g,
        value: ''
    },
    {
        reg: /&rlm;/g,
        value: ''
    },
    {
        reg: /&amp;/g,
        value: '&'
    },
    {
        reg: /&nbsp;/g,
        value: '\\h'
    },
    {
        reg: /(<br\s*\/?>)|\n>/g,
        value: '\\N'
    }
];
class SubtitleRender {
    decoder;
    loop;
    demuxer2SubtitleRenderChannels;
    leftPorts;
    currentPort;
    render;
    queue;
    ended;
    options;
    pulling;
    formats;
    avpacketPool;
    delay;
    enable;
    constructor(options) {
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_17__.extend({}, options);
        this.ended = false;
        this.pulling = false;
        this.queue = [];
        this.delay = BigInt(0);
        this.demuxer2SubtitleRenderChannels = new Map();
        this.leftPorts = new Map();
        if (options.avpacketList) {
            this.avpacketPool = new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_14__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_0__["default"]), options.avpacketListMutex);
        }
        this.createDecoder();
        this.render = new _AssRender__WEBPACK_IMPORTED_MODULE_9__["default"](this.options.dom, {
            header: this.getAssHeader(this.options.codecpar),
            container: this.options.container,
            videoWidth: this.options.videoWidth,
            videoHeight: this.options.videoHeight
        });
        this.loop = new common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_7__["default"](() => {
            if (!this.queue.length && this.ended) {
                this.loop.stop();
            }
            if (this.queue.length < 6 && !this.ended) {
                this.pull();
            }
            const currentTime = this.options.getCurrentTime() - this.delay;
            this.render.clear(currentTime);
            while (this.queue.length) {
                const event = this.queue[0];
                if (event.Start > currentTime) {
                    break;
                }
                if (event.End > currentTime) {
                    this.render.render(event);
                }
                this.queue.shift();
            }
        }, 0, 50, false);
    }
    getAssHeader(codecpar) {
        let header = '';
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 4) === 94230 /* AVCodecID.AV_CODEC_ID_ASS */ && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 16)) {
            header = common_util_text__WEBPACK_IMPORTED_MODULE_11__.decode((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_12__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](codecpar + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 16)));
            const lines = header.split(/\r?\n/);
            let hasEvent = false;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '[Events]') {
                    hasEvent = true;
                }
                if (/^Format:/.test(line) && hasEvent) {
                    this.formats = avformat_formats_ass_iass__WEBPACK_IMPORTED_MODULE_13__.parseEventFormat(line.trim());
                }
            }
        }
        return header;
    }
    createDecoder() {
        if (this.decoder) {
            this.decoder.close();
        }
        this.decoder = new avcodec_subtitle_SubtitleDecoder__WEBPACK_IMPORTED_MODULE_5__["default"]({
            onReceiveSubtitle: (subtitle) => {
                for (let i = 0; i < subtitle.rects.length; i++) {
                    const rect = subtitle.rects[i];
                    if (rect.type === avutil_struct_avsubtitle__WEBPACK_IMPORTED_MODULE_10__.AVSubtitleType.SUBTITLE_ASS) {
                        const event = avformat_formats_ass_iass__WEBPACK_IMPORTED_MODULE_13__.parseEvent(this.formats, rect.text);
                        if (event.Start == null) {
                            event.Start = subtitle.pts;
                        }
                        if (event.End == null) {
                            event.End = subtitle.pts + subtitle.duration;
                        }
                        this.queue.push(event);
                    }
                    else if (rect.type === avutil_struct_avsubtitle__WEBPACK_IMPORTED_MODULE_10__.AVSubtitleType.SUBTITLE_WEBVTT) {
                        this.queue.push(this.webvtt2AssEvent(rect.text, subtitle.pts, subtitle.pts + subtitle.duration));
                    }
                    else {
                        this.queue.push(this.text2AssEvent(rect.text, subtitle.pts, subtitle.pts + subtitle.duration));
                    }
                }
            }
        });
        this.decoder.open(this.options.codecpar);
    }
    text2AssEvent(text, start, end) {
        return {
            type: 1 /* AssEventType.Dialogue */,
            ReadOrder: 0,
            Layer: 0,
            Start: start,
            End: end,
            Style: 'Default',
            Name: '',
            MarginL: 0,
            MarginR: 0,
            MarginV: 0,
            Text: {
                raw: text,
                combined: text,
                parsed: [
                    {
                        tags: [],
                        text: text,
                        drawing: []
                    }
                ]
            }
        };
    }
    webvtt2AssEvent(text, start, end) {
        for (let i = 0; i < WebVttReplace.length; i++) {
            text = text.replace(WebVttReplace[i].reg, WebVttReplace[i].value);
        }
        return this.text2AssEvent(text, start, end);
    }
    async pull() {
        if (this.pulling && !this.ended) {
            return;
        }
        this.pulling = true;
        const currentPort = this.currentPort;
        const avpacket = await this.leftPorts.get(this.currentPort).request('pull');
        if (avpacket === -1048576 /* IOError.END */) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_8__.debug(`SubtitleRender end`, cheap__fileName__6, 290);
            this.decoder.flush();
            this.ended = true;
        }
        else if (avpacket < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_8__.debug(`SubtitleRender pull avpacket error, ret: ${avpacket}`, cheap__fileName__6, 295);
            this.ended = true;
        }
        else if (this.loop && currentPort === this.currentPort) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](avpacket + 8, (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_16__.AV_MILLI_TIME_BASE_Q));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](avpacket + 48, (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 48), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_16__.AV_MILLI_TIME_BASE_Q));
            const ret = this.decoder.decode(avpacket);
            if (this.avpacketPool) {
                this.avpacketPool.release(avpacket);
            }
            else {
                (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_18__.destroyAVPacket)(avpacket);
            }
            if (ret < 0) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_8__.debug(`SubtitleRender decode avpacket error, ret: ${avpacket}`, cheap__fileName__6, 309);
                this.ended = true;
            }
        }
        else {
            if (this.avpacketPool) {
                this.avpacketPool.release(avpacket);
            }
            else {
                (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_18__.destroyAVPacket)(avpacket);
            }
        }
        this.pulling = false;
    }
    getDemuxerPort(taskId) {
        if (this.demuxer2SubtitleRenderChannels.has(taskId)) {
            return this.demuxer2SubtitleRenderChannels.get(taskId).port1;
        }
        const messageChannel = new MessageChannel();
        const ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__["default"](messageChannel.port2);
        this.demuxer2SubtitleRenderChannels.set(taskId, messageChannel);
        this.leftPorts.set(taskId, ipcPort);
        return messageChannel.port1;
    }
    start() {
        if (!this.loop.isStarted()) {
            this.loop.start();
        }
        this.ended = false;
    }
    stop() {
        this.loop.stop();
        this.render.clearAll();
    }
    pause() {
        this.loop.stop();
    }
    reset() {
        this.queue.length = 0;
        this.render.clearAll();
    }
    reopenDecoder(codecpar) {
        this.options.codecpar = codecpar;
        this.createDecoder();
        this.render.updateHeader(this.getAssHeader(codecpar));
    }
    updateVideoResolution(videoWidth, videoHeight) {
        if (videoWidth !== this.options.videoWidth || videoHeight !== this.options.videoHeight) {
            this.render.updateVideoResolution(videoWidth, videoHeight);
            this.options.videoWidth = videoWidth;
            this.options.videoHeight = videoHeight;
        }
    }
    setDemuxTask(taskId) {
        if (this.currentPort !== taskId) {
            this.pulling = false;
        }
        this.currentPort = taskId;
    }
    destroy() {
        this.loop.destroy();
        this.loop = null;
        this.leftPorts.clear();
        this.demuxer2SubtitleRenderChannels.clear();
        this.queue.length = 0;
        this.render.destroy();
        this.render = null;
        this.decoder.close();
        this.decoder = null;
    }
    setDelay(d) {
        this.delay = d;
    }
}


/***/ }),

/***/ "./src/avrender/image/Canvas2dRender.ts":
/*!**********************************************!*\
  !*** ./src/avrender/image/Canvas2dRender.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CanvasImageRender)
/* harmony export */ });
/* harmony import */ var _ImageRender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageRender */ "./src/avrender/image/ImageRender.ts");
/*
 * libmedia Canvas2dRender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class CanvasImageRender extends _ImageRender__WEBPACK_IMPORTED_MODULE_0__["default"] {
    context;
    paddingLeft;
    paddingTop;
    flipX;
    flipY;
    constructor(canvas, options) {
        super(canvas, options);
        this.paddingLeft = 0;
        this.paddingTop = 0;
        this.flipX = 1;
        this.flipY = 1;
    }
    async init() {
        this.context = this.canvas.getContext('2d');
    }
    clear() {
        const w = this.canvas.width >> 1;
        const h = this.canvas.height >> 1;
        if (this.rotate) {
            this.context.translate(w, h);
            this.context.rotate(-this.rotate * Math.PI / 180);
            this.context.translate(-w, -h);
        }
        this.context.clearRect(0, 0, this.canvasWidth * this.options.devicePixelRatio, this.canvasHeight * this.options.devicePixelRatio);
        if (this.rotate) {
            this.context.translate(w, h);
            this.context.rotate(this.rotate * Math.PI / 180);
            this.context.translate(-w, -h);
        }
    }
    checkFrame(frame) {
        if (frame.codedWidth !== this.textureWidth
            || frame.codedHeight !== this.videoHeight
            || frame.codedWidth !== this.videoWidth) {
            this.videoWidth = frame.codedWidth;
            this.videoHeight = frame.codedHeight;
            this.textureWidth = frame.codedWidth;
            this.layout();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        this.context.drawImage(frame, this.paddingLeft, this.paddingTop, this.canvasWidth * this.options.devicePixelRatio - 2 * this.paddingLeft, this.canvasHeight * this.options.devicePixelRatio - 2 * this.paddingTop);
    }
    layout() {
        let videoWidth = this.videoWidth;
        let videoHeight = this.videoHeight;
        let canvasWidth = this.canvasWidth;
        let canvasHeight = this.canvasHeight;
        let basePaddingLeft = 0;
        let basePaddingTop = 0;
        if (this.rotate === 90 || this.rotate === 270) {
            basePaddingTop = Math.floor((canvasHeight - canvasWidth) / 2);
            basePaddingLeft = Math.floor((canvasWidth - canvasHeight) / 2);
            canvasWidth = this.canvasHeight;
            canvasHeight = this.canvasWidth;
        }
        const scaleX = videoWidth / canvasWidth;
        const scaleY = videoHeight / canvasHeight;
        let isPaddingTop;
        if (scaleX > 1) {
            if (scaleX < scaleY) {
                isPaddingTop = false;
            }
            else {
                isPaddingTop = true;
            }
        }
        else {
            if (scaleX > scaleY) {
                isPaddingTop = true;
            }
            else {
                isPaddingTop = false;
            }
        }
        if (this.renderMode === 1 /* RenderMode.FILL */) {
            isPaddingTop = !isPaddingTop;
        }
        if (isPaddingTop) {
            const paddingTop = (canvasHeight - videoHeight * canvasWidth / videoWidth) / canvasHeight;
            this.paddingTop = (Math.floor(paddingTop / 2 * canvasHeight) + basePaddingTop) * this.options.devicePixelRatio;
            this.paddingLeft = basePaddingLeft * this.options.devicePixelRatio;
        }
        else {
            const paddingLeft = (canvasWidth - videoWidth * canvasHeight / videoHeight) / canvasWidth;
            this.paddingLeft = (Math.floor(paddingLeft / 2 * canvasWidth) + basePaddingLeft) * this.options.devicePixelRatio;
            this.paddingTop = basePaddingTop * this.options.devicePixelRatio;
        }
        if (this.context) {
            let flipX = 1;
            let flipY = 1;
            if (this.flipHorizontal) {
                flipX = -1;
            }
            if (this.flipVertical) {
                flipY = -1;
            }
            const w = this.canvas.width >> 1;
            const h = this.canvas.height >> 1;
            this.context.translate(w, h);
            if (flipX !== this.flipX) {
                this.context.scale(-1, 1);
            }
            if (flipY !== this.flipY) {
                this.context.scale(1, -1);
            }
            this.context.translate(-w, -h);
            this.flipX = flipX;
            this.flipY = flipY;
        }
    }
    setRotate(angle) {
        angle = angle % 360;
        if (angle === this.rotate) {
            return;
        }
        const w = this.canvas.width >> 1;
        const h = this.canvas.height >> 1;
        if (this.rotate) {
            this.context.translate(w, h);
            this.context.rotate(-this.rotate * Math.PI / 180);
            this.context.translate(-w, -h);
        }
        this.clear();
        this.rotate = angle;
        if (this.context) {
            this.context.translate(w, h);
            this.context.rotate(this.rotate * Math.PI / 180);
            this.context.translate(-w, -h);
        }
        this.layout();
    }
    destroy() {
        this.context = null;
        super.destroy();
    }
    static isSupport(frame) {
        // VideoFrame
        return frame instanceof VideoFrame || frame instanceof ImageBitmap;
    }
}


/***/ }),

/***/ "./src/avrender/image/ImageRender.ts":
/*!*******************************************!*\
  !*** ./src/avrender/image/ImageRender.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageRender)
/* harmony export */ });
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/*
 * libmedia ImageRender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class ImageRender {
    canvas;
    options;
    textureWidth;
    videoWidth;
    videoHeight;
    canvasWidth;
    canvasHeight;
    rotate;
    renderMode;
    format;
    lost;
    destroyed;
    srcColorSpace;
    dstColorSpace;
    flipHorizontal;
    flipVertical;
    constructor(canvas, options) {
        this.canvas = canvas;
        this.options = options;
        this.canvasWidth = canvas.width;
        this.canvasHeight = canvas.height;
        this.videoWidth = 0;
        this.videoHeight = 0;
        this.textureWidth = 0;
        this.rotate = 0;
        this.renderMode = options.renderMode;
        this.flipHorizontal = false;
        this.flipVertical = false;
        this.lost = false;
        this.destroyed = false;
        if (options.dstColorSpace) {
            this.dstColorSpace = options.dstColorSpace;
        }
        else {
            this.dstColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_0__["default"](1 /* AVColorSpace.AVCOL_SPC_BT709 */, 1 /* AVColorPrimaries.AVCOL_PRI_BT709 */, 1 /* AVColorTransferCharacteristic.AVCOL_TRC_BT709 */, 1 /* AVColorRange.AVCOL_RANGE_MPEG */);
        }
    }
    getRotateMatrix(angle) {
        angle = Math.PI * angle / 180;
        const s = Math.sin(angle);
        const c = Math.cos(angle);
        return [
            c, -s, 0, 0,
            s, c, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ];
    }
    setRenderMode(mode) {
        if (this.renderMode !== mode) {
            this.renderMode = mode;
            this.layout();
            this.clear();
        }
    }
    enableHorizontalFlip(enable) {
        if (this.flipHorizontal !== enable) {
            this.flipHorizontal = enable;
            this.layout();
            this.clear();
        }
    }
    enableVerticalFlip(enable) {
        if (this.flipVertical !== enable) {
            this.flipVertical = enable;
            this.layout();
            this.clear();
        }
    }
    viewport(width, height) {
        const devicePixelRatio = this.options.devicePixelRatio;
        this.canvasWidth = width;
        this.canvasHeight = height;
        this.canvas.width = width * devicePixelRatio;
        this.canvas.height = height * devicePixelRatio;
        if (this.videoWidth && this.videoHeight) {
            this.layout();
        }
    }
    getVideoWidth() {
        return this.videoWidth;
    }
    getVideoHeight() {
        return this.videoHeight;
    }
    destroy() {
        this.canvas = null;
        this.destroyed = true;
    }
    setDstColorSpace(space) {
        this.dstColorSpace = space;
    }
    static isSupport(frame) {
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLRGB8Render.ts":
/*!***********************************************!*\
  !*** ./src/avrender/image/WebGLRGB8Render.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLRGB8Render)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var _WebGLRGBRender__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WebGLRGBRender */ "./src/avrender/image/WebGLRGBRender.ts");
/* harmony import */ var _webgl_program_RGB8Program__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./webgl/program/RGB8Program */ "./src/avrender/image/webgl/program/RGB8Program.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");








class WebGLRGB8Render extends _WebGLRGBRender__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(canvas, options) {
        super(canvas, options);
    }
    generateFragmentSource(format, descriptor) {
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_3__["default"])(this.srcColorSpace, this.dstColorSpace, {
            bitDepth: 8,
            type: 0 /* GLType.kWebGL */,
            outputRGB: true
        });
        const map = ['r', 'g', 'b', 'a'];
        let r = `texture2D(rgb_Sampler, v_color.xy).${map[descriptor.comp[0].offset]}`;
        let g = `texture2D(rgb_Sampler, v_color.xy).${map[descriptor.comp[1].offset]}`;
        let b = `texture2D(rgb_Sampler, v_color.xy).${map[descriptor.comp[2].offset]}`;
        let alpha = '1.0';
        if ((descriptor.flags & 128 /* PixelFormatFlags.ALPHA */) && descriptor.nbComponents === 4) {
            alpha = `texture2D(rgb_Sampler, v_color.xy).${map[descriptor.comp[3].offset]}`;
        }
        this.fragmentSource = `
      precision highp float;
      varying vec4 v_color;
      uniform sampler2D rgb_Sampler;
      void main () {
        float r = ${r};
        float g = ${g};
        float b = ${b};
        float alpha = ${alpha};
        vec4 color = vec4(r, g, b, alpha);
        ${steps.reduce((pre, current) => pre + current, '')}
        gl_FragColor = color;
      }
    `;
    }
    checkFrame(frame) {
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68) !== this.videoWidth) {
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_4__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 220), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 212), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 216), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 208));
            this.generateFragmentSource(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80), descriptor);
            this.program = new _webgl_program_RGB8Program__WEBPACK_IMPORTED_MODULE_6__["default"](this.fragmentSource);
            this.useProgram();
            if (descriptor.nbComponents === 4) {
                this.rgbTexture.setFormat(this.gl.RGBA);
                this.rgbTexture.setInternalformat(this.gl.RGBA);
            }
            this.rgbTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72));
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32);
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80);
            this.layout();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        this.rgbTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame), this.rgbTexture.width * this.rgbTexture.height));
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
    static isSupport(frame) {
        if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_7__["default"])(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                return (info.flags & 32 /* PixelFormatFlags.RGB */) && ((info.comp[0].depth + 7) >>> 3) === 1;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLRGBRender.ts":
/*!**********************************************!*\
  !*** ./src/avrender/image/WebGLRGBRender.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLRGBRender)
/* harmony export */ });
/* harmony import */ var _WebGLRender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLRender */ "./src/avrender/image/WebGLRender.ts");
/* harmony import */ var _webgl_texture_RGBTexture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl/texture/RGBTexture */ "./src/avrender/image/webgl/texture/RGBTexture.ts");
/*
 * libmedia WebGLRGBRender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class WebGLRGBRender extends _WebGLRender__WEBPACK_IMPORTED_MODULE_0__["default"] {
    rgbTexture;
    constructor(canvas, options) {
        super(canvas, options);
    }
    useProgram() {
        super.useProgram();
        this.rgbTexture = new _webgl_texture_RGBTexture__WEBPACK_IMPORTED_MODULE_1__["default"](this.gl);
        this.rgbTexture.bind(0);
        this.rgbTexture.init();
        this.program.bindRGBTexture(0);
    }
    destroy() {
        if (this.rgbTexture) {
            this.rgbTexture.destroy();
            this.rgbTexture = null;
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLRender.ts":
/*!*******************************************!*\
  !*** ./src/avrender/image/WebGLRender.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLRender)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _ImageRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageRender */ "./src/avrender/image/ImageRender.ts");
/* harmony import */ var _function_flipVertex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./function/flipVertex */ "./src/avrender/image/function/flipVertex.ts");
var cheap__fileName__0 = "src\\avrender\\image\\WebGLRender.ts";
/*
 * libmedia WebGLRender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



class WebGLRender extends _ImageRender__WEBPACK_IMPORTED_MODULE_1__["default"] {
    gl;
    // 顶点缓冲区
    VAO;
    program;
    vertex;
    webglContextLostTimer;
    onWebglContextLost;
    onWebglContextRestored;
    fragmentSource;
    vertexSource;
    constructor(canvas, options) {
        super(canvas, options);
    }
    async init() {
        this.gl = this.canvas.getContext('webgl2', {
            alpha: false,
            antialias: false,
            preserveDrawingBuffer: this.options.preserveDrawingBuffer
        });
        if (!this.gl) {
            this.gl = this.canvas.getContext('webgl', {
                alpha: false,
                antialias: false,
                preserveDrawingBuffer: this.options.preserveDrawingBuffer
            });
        }
        if (!this.gl) {
            this.gl = this.canvas.getContext('experimental-webgl', {
                alpha: false,
                antialias: false,
                preserveDrawingBuffer: this.options.preserveDrawingBuffer
            });
        }
        if (!this.gl) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('can not support webgl, got WebGLRenderingContext failed', cheap__fileName__0, 96);
        }
        this.VAO = this.gl.createBuffer();
        if (!this.VAO) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('create vao buffer failed', cheap__fileName__0, 101);
        }
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VAO);
        this.gl.enable(this.gl.BLEND);
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
        this.gl.clearDepth(1.0);
        this.viewport(this.canvasWidth || this.canvas.width, this.canvasHeight || this.canvas.height);
        this.onWebglContextLost = (event) => {
            if (this.destroyed) {
                return;
            }
            this.webglContextLostTimer = setTimeout(() => {
                this.lost = true;
                this.webglContextLostTimer = null;
                common_util_logger__WEBPACK_IMPORTED_MODULE_0__.error('webgl context lost', cheap__fileName__0, 118);
                if (this.options.onRenderContextLost) {
                    this.options.onRenderContextLost();
                }
            }, 3000);
        };
        this.onWebglContextRestored = (event) => {
            if (this.webglContextLostTimer) {
                clearTimeout(this.webglContextLostTimer);
                this.webglContextLostTimer = null;
            }
        };
        this.canvas.addEventListener('webglcontextlost', this.onWebglContextLost);
        this.canvas.addEventListener('webglcontextrestored', this.onWebglContextRestored);
    }
    viewport(width, height) {
        this.gl.viewport(0, 0, width * this.options.devicePixelRatio, height * this.options.devicePixelRatio);
        super.viewport(width, height);
    }
    useProgram() {
        this.program.link(this.gl);
        this.program.bind();
        this.program.setRotateMatrix(this.getRotateMatrix(this.rotate));
    }
    clear() {
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    }
    layout() {
        let videoWidth = this.videoWidth;
        let videoHeight = this.videoHeight;
        let canvasWidth = this.canvasWidth;
        let canvasHeight = this.canvasHeight;
        if (this.rotate === 90 || this.rotate === 270) {
            /*
             * videoWidth = this.videoHeight
             * videoHeight = this.videoWidth
             */
            canvasWidth = this.canvasHeight;
            canvasHeight = this.canvasWidth;
        }
        const scaleX = videoWidth / canvasWidth;
        const scaleY = videoHeight / canvasHeight;
        let isPaddingTop;
        if (scaleX > 1) {
            if (scaleX < scaleY) {
                isPaddingTop = false;
            }
            else {
                isPaddingTop = true;
            }
        }
        else {
            if (scaleX > scaleY) {
                isPaddingTop = true;
            }
            else {
                isPaddingTop = false;
            }
        }
        if (this.renderMode === 1 /* RenderMode.FILL */) {
            isPaddingTop = !isPaddingTop;
        }
        let texturePadding = 0;
        if (this.textureWidth !== this.videoWidth) {
            texturePadding = (this.textureWidth - this.videoWidth) / this.textureWidth;
        }
        if (isPaddingTop) {
            const paddingTop = (canvasHeight - videoHeight * canvasWidth / videoWidth) / canvasHeight;
            this.vertex = [
                -1, 1 - paddingTop, 0, 0, 0, 0, 0,
                -1, -1 + paddingTop, 0, 0, 1, 0, 0,
                1, 1 - paddingTop, 0, 1 - texturePadding, 0, 0, 0,
                1, -1 + paddingTop, 0, 1 - texturePadding, 1, 0, 0
            ];
        }
        else {
            const paddingLeft = (canvasWidth - videoWidth * canvasHeight / videoHeight) / canvasWidth;
            this.vertex = [
                -1 + paddingLeft, 1, 0, 0, 0, 0, 0,
                -1 + paddingLeft, -1, 0, 0, 1, 0, 0,
                1 - paddingLeft, 1, 0, 1 - texturePadding, 0, 0, 0,
                1 - paddingLeft, -1, 0, 1 - texturePadding, 1, 0, 0
            ];
        }
        (0,_function_flipVertex__WEBPACK_IMPORTED_MODULE_2__["default"])(this.vertex, this.flipHorizontal, this.flipVertical);
        if (this.gl) {
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.vertex), this.gl.STATIC_DRAW);
        }
    }
    setRotate(angle) {
        angle = angle % 360;
        if (angle === this.rotate) {
            return;
        }
        this.rotate = angle;
        if (this.gl) {
            this.program.setRotateMatrix(this.getRotateMatrix(this.rotate));
        }
        this.layout();
        this.clear();
    }
    destroy() {
        if (this.program) {
            this.program.stop();
        }
        this.gl = null;
        this.VAO = null;
        this.vertex = null;
        if (this.onWebglContextLost) {
            this.canvas.removeEventListener('webglcontextlost', this.onWebglContextLost);
            this.onWebglContextLost = null;
        }
        if (this.onWebglContextRestored) {
            this.canvas.removeEventListener('webglcontextrestored', this.onWebglContextRestored);
            this.onWebglContextRestored = null;
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLYUV16Render.ts":
/*!************************************************!*\
  !*** ./src/avrender/image/WebGLYUV16Render.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLYUV16Render)
/* harmony export */ });
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var _WebGLYUVRender__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WebGLYUVRender */ "./src/avrender/image/WebGLYUVRender.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");
/* harmony import */ var _colorTransform_options__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./colorTransform/options */ "./src/avrender/image/colorTransform/options.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var _struct_HdrMetadata__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./struct/HdrMetadata */ "./src/avrender/image/struct/HdrMetadata.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var _webgl_program_YUV16Program__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./webgl/program/YUV16Program */ "./src/avrender/image/webgl/program/YUV16Program.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");













class WebGLYUV16Render extends _WebGLYUVRender__WEBPACK_IMPORTED_MODULE_5__["default"] {
    hdrMetadata;
    ext;
    constructor(canvas, options) {
        super(canvas, options);
        this.hdrMetadata = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_0__["default"])(_struct_HdrMetadata__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.hdrMetadata.multiplier = 1.0;
    }
    async init() {
        await super.init();
        this.ext = this.gl.getExtension('EXT_texture_norm16');
        if (!this.ext) {
            throw Error('not support');
        }
    }
    generateFragmentSource(format, descriptor, colorTransformOptions) {
        colorTransformOptions.outputRGB = true;
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_6__["default"])(this.srcColorSpace, this.dstColorSpace, colorTransformOptions);
        let y = 'texture2D(y_Sampler, v_color.xy).x';
        let u = 'texture2D(u_Sampler, v_color.xy).x';
        let v = 'texture2D(v_Sampler, v_color.xy).x';
        let alpha = '1.0';
        if (format === 23 /* AVPixelFormat.AV_PIX_FMT_NV12 */
            || format === 189 /* AVPixelFormat.AV_PIX_FMT_NV24 */) {
            u = 'texture2D(u_Sampler, v_color.xy).x';
            v = 'texture2D(u_Sampler, v_color.xy).y';
        }
        else if (format === 24 /* AVPixelFormat.AV_PIX_FMT_NV21 */
            || format === 190 /* AVPixelFormat.AV_PIX_FMT_NV42 */) {
            u = 'texture2D(u_Sampler, v_color.xy).y';
            v = 'texture2D(u_Sampler, v_color.xy).x';
        }
        if ((descriptor.flags & 128 /* PixelFormatFlags.ALPHA */) && descriptor.nbComponents === 4) {
            alpha = 'texture2D(a_Sampler, v_color.xy).x';
        }
        this.fragmentSource = `
      precision highp float;

      varying vec4 v_color;
      uniform sampler2D y_Sampler;
      uniform sampler2D u_Sampler;
      uniform sampler2D v_Sampler;
      
      uniform float v_max;

      uniform float offset;
      uniform float multiplier;
      uniform float pq_tonemap_a;
      uniform float pq_tonemap_b;
      uniform float hlg_ootf_gamma_minus_one;
      uniform float hlg_dst_max_luminance_relative;
      uniform float nits_to_sdr_relative_factor;
      uniform float sdr_relative_to_nits_factor;

      ${(descriptor.flags & 1 /* PixelFormatFlags.BIG_ENDIAN */) ? `
        float swap(float x) {
          int value = int(x * 65535.0);
          int low = value & 0xff;
          int high = (value >> 8) & 0xff;
          value = (low << 8) | high;
          return float(value) / v_max;
        }
      ` : ''}
      
      void main () {
      
        float y = ${y};
        float u = ${u};
        float v = ${v};
        float alpha = ${alpha};
        
        ${(descriptor.flags & 1 /* PixelFormatFlags.BIG_ENDIAN */) ? `
          y = swap(y);
          u = swap(u);
          v = swap(v);
        ` : `
          y = y * 65535.0 / v_max;
          u = u * 65535.0 / v_max;
          v = v * 65535.0 / v_max;
        `}
        
        vec4 color = vec4(y, u, v, alpha);

        if (color.a > 0.0) {
          color.r /= color.a;
          color.g /= color.a;
          color.b /= color.a;
        }
        color.r -= offset;
        color.g -= offset;
        color.b -= offset;

        color.r *= multiplier;
        color.g *= multiplier;
        color.b *= multiplier;
        
        ${steps.reduce((pre, current) => pre + current, '')}

        color.r *= color.a;
        color.g *= color.a;
        color.b *= color.a;

        gl_FragColor = color;
      }
    `;
    }
    checkFrame(frame) {
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        const bytesPerPixel = (descriptor.comp[0].depth + 7) >>> 3;
        if ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32) / bytesPerPixel) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 68) !== this.videoWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80) !== this.format) {
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_8__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 220), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 212), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 216), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 208));
            const colorTransformOptions = {
                type: 0 /* GLType.kWebGL */,
                bitDepth: descriptor.comp[0].depth,
                toneMapPQAndHlgToDst: true,
                metadata: this.hdrMetadata,
                dstSdrMaxLuminanceNits: _colorTransform_options__WEBPACK_IMPORTED_MODULE_7__.DefaultSDRWhiteLevel,
                dstMaxLuminanceRelative: 1.0
            };
            const sideData = (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_10__.getAVFrameSideData)(frame, 14 /* AVFrameSideDataType.AV_FRAME_DATA_CONTENT_LIGHT_LEVEL */);
            if (sideData) {
                const lightMetadata = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](sideData + 4);
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[8](lightMetadata) > 0) {
                    colorTransformOptions.maxContentLightLevel = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[8](lightMetadata);
                }
            }
            this.generateFragmentSource(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80), descriptor, colorTransformOptions);
            this.program = new _webgl_program_YUV16Program__WEBPACK_IMPORTED_MODULE_11__["default"](this.fragmentSource);
            this.useProgram();
            this.program.setMetaData(this.hdrMetadata);
            this.yTexture.setFormat(this.gl.RED);
            this.yTexture.setInternalformat(this.ext.R16_EXT);
            this.yTexture.setDataType(this.gl.UNSIGNED_SHORT);
            this.uTexture.setFormat(this.gl.RED);
            this.uTexture.setInternalformat(this.ext.R16_EXT);
            this.uTexture.setDataType(this.gl.UNSIGNED_SHORT);
            this.vTexture.setFormat(this.gl.RED);
            this.vTexture.setInternalformat(this.ext.R16_EXT);
            this.vTexture.setDataType(this.gl.UNSIGNED_SHORT);
            this.aTexture.setFormat(this.gl.RED);
            this.aTexture.setInternalformat(this.ext.R16_EXT);
            this.aTexture.setDataType(this.gl.UNSIGNED_SHORT);
            this.yTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 72));
            this.uTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32 + 4) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80)].log2ChromaH);
            if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
                this.vTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32 + 8) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80)].log2ChromaH);
            }
            if (descriptor.nbComponents === 4) {
                this.aTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32 + 12) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 72));
            }
            this.program.setMax((1 << descriptor.comp[0].depth) - 1);
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32) >>> 1;
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80);
            this.layout();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        this.yTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint16Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame), this.yTexture.width * this.yTexture.height));
        this.uTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint16Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 4), this.uTexture.width * this.uTexture.height));
        if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
            this.vTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint16Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 8), this.vTexture.width * this.vTexture.height));
        }
        if (descriptor.nbComponents === 4) {
            this.aTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint16Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 12), this.aTexture.width * this.aTexture.height));
        }
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
    destroy() {
        if (this.hdrMetadata) {
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_2__["default"])(this.hdrMetadata);
            this.hdrMetadata = null;
        }
        super.destroy();
    }
    static isSupport(frame) {
        if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_12__["default"])(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                if (info.flags & 32 /* PixelFormatFlags.RGB */) {
                    return false;
                }
                return (info.flags & 16 /* PixelFormatFlags.PLANER */) && ((info.comp[0].depth + 7) >>> 3) === 2;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLYUV8Render.ts":
/*!***********************************************!*\
  !*** ./src/avrender/image/WebGLYUV8Render.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLYUV8Render)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var _WebGLYUVRender__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WebGLYUVRender */ "./src/avrender/image/WebGLYUVRender.ts");
/* harmony import */ var _webgl_program_YUV8Program__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./webgl/program/YUV8Program */ "./src/avrender/image/webgl/program/YUV8Program.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");








class WebGLYUV8Render extends _WebGLYUVRender__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(canvas, options) {
        super(canvas, options);
    }
    generateFragmentSource(format, descriptor) {
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_5__["default"])(this.srcColorSpace, this.dstColorSpace, {
            bitDepth: 8,
            type: 0 /* GLType.kWebGL */,
            outputRGB: true
        });
        let y = 'texture2D(y_Sampler, v_color.xy).x';
        let u = 'texture2D(u_Sampler, v_color.xy).x';
        let v = 'texture2D(v_Sampler, v_color.xy).x';
        let alpha = '1.0';
        if (format === 23 /* AVPixelFormat.AV_PIX_FMT_NV12 */
            || format === 189 /* AVPixelFormat.AV_PIX_FMT_NV24 */) {
            u = 'texture2D(u_Sampler, v_color.xy).x';
            v = 'texture2D(u_Sampler, v_color.xy).y';
        }
        else if (format === 24 /* AVPixelFormat.AV_PIX_FMT_NV21 */
            || format === 190 /* AVPixelFormat.AV_PIX_FMT_NV42 */) {
            u = 'texture2D(u_Sampler, v_color.xy).y';
            v = 'texture2D(u_Sampler, v_color.xy).x';
        }
        if ((descriptor.flags & 128 /* PixelFormatFlags.ALPHA */) && descriptor.nbComponents === 4) {
            alpha = 'texture2D(a_Sampler, v_color.xy).x';
        }
        this.fragmentSource = `
      precision highp float;
      varying vec4 v_color;
      uniform sampler2D y_Sampler;
      uniform sampler2D u_Sampler;
      uniform sampler2D v_Sampler;
      uniform sampler2D a_Sampler;
      void main () {
        float y = ${y};
        float u = ${u};
        float v = ${v};
        float alpha = ${alpha};
        vec4 color = vec4(y, u, v, alpha);
        ${steps.reduce((pre, current) => pre + current, '')}
        gl_FragColor = color;
      }
    `;
    }
    checkFrame(frame) {
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68) !== this.videoWidth) {
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_6__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 220), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 212), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 216), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 208));
            this.generateFragmentSource(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80), descriptor);
            this.program = new _webgl_program_YUV8Program__WEBPACK_IMPORTED_MODULE_4__["default"](this.fragmentSource);
            this.useProgram();
            this.yTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72));
            this.uTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32 + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)].log2ChromaH);
            if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
                this.vTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32 + 8), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)].log2ChromaH);
            }
            if (descriptor.nbComponents === 4) {
                this.aTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32 + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72));
            }
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32);
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80);
            this.layout();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        this.yTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame), this.yTexture.width * this.yTexture.height));
        this.uTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame + 4), this.uTexture.width * this.uTexture.height));
        if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
            this.vTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame + 8), this.vTexture.width * this.vTexture.height));
        }
        if (descriptor.nbComponents === 4) {
            this.aTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame + 12), this.aTexture.width * this.aTexture.height));
        }
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
    static isSupport(frame) {
        if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_7__["default"])(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                if (info.flags & 32 /* PixelFormatFlags.RGB */) {
                    return false;
                }
                return (info.flags & 16 /* PixelFormatFlags.PLANER */) && ((info.comp[0].depth + 7) >>> 3) === 1;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLYUVRender.ts":
/*!**********************************************!*\
  !*** ./src/avrender/image/WebGLYUVRender.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLYUVRender)
/* harmony export */ });
/* harmony import */ var _webgl_texture_YUVTexture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl/texture/YUVTexture */ "./src/avrender/image/webgl/texture/YUVTexture.ts");
/* harmony import */ var _WebGLRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGLRender */ "./src/avrender/image/WebGLRender.ts");
/*
 * libmedia WebGLYUVRender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class WebGLYUVRender extends _WebGLRender__WEBPACK_IMPORTED_MODULE_1__["default"] {
    yTexture;
    uTexture;
    vTexture;
    aTexture;
    constructor(canvas, options) {
        super(canvas, options);
    }
    useProgram() {
        super.useProgram();
        this.yTexture = new _webgl_texture_YUVTexture__WEBPACK_IMPORTED_MODULE_0__["default"](this.gl);
        this.yTexture.bind(0);
        this.yTexture.init();
        this.program.bindYTexture(0);
        this.uTexture = new _webgl_texture_YUVTexture__WEBPACK_IMPORTED_MODULE_0__["default"](this.gl);
        this.uTexture.bind(1);
        this.uTexture.init();
        this.program.bindUTexture(1);
        this.vTexture = new _webgl_texture_YUVTexture__WEBPACK_IMPORTED_MODULE_0__["default"](this.gl);
        this.vTexture.bind(2);
        this.vTexture.init();
        this.program.bindVTexture(2);
        this.aTexture = new _webgl_texture_YUVTexture__WEBPACK_IMPORTED_MODULE_0__["default"](this.gl);
        this.aTexture.bind(3);
        this.aTexture.init();
        this.program.bindATexture(3);
    }
    destroy() {
        if (this.yTexture) {
            this.yTexture.destroy();
            this.yTexture = null;
        }
        if (this.uTexture) {
            this.uTexture.destroy();
            this.uTexture = null;
        }
        if (this.vTexture) {
            this.vTexture.destroy();
            this.vTexture = null;
        }
        if (this.aTexture) {
            this.aTexture.destroy();
            this.aTexture = null;
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPUExternalRender.ts":
/*!****************************************************!*\
  !*** ./src/avrender/image/WebGPUExternalRender.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPUExternalRender)
/* harmony export */ });
/* harmony import */ var _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgpu/wgsl/vertex.wgsl */ "./src/avrender/image/webgpu/wgsl/vertex.wgsl");
/* harmony import */ var _webgpu_wgsl_fragment_external_wgsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgpu/wgsl/fragment/external.wgsl */ "./src/avrender/image/webgpu/wgsl/fragment/external.wgsl");
/* harmony import */ var _WebGPURender__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebGPURender */ "./src/avrender/image/WebGPURender.ts");
/*
 * libmedia WebGPUExternalRender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



class WebGPUExternalRender extends _WebGPURender__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(canvas, options) {
        super(canvas, options);
        this.vertexSource = _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_0__["default"];
        this.fragmentSource = _webgpu_wgsl_fragment_external_wgsl__WEBPACK_IMPORTED_MODULE_1__["default"];
    }
    checkFrame(frame) {
        if (frame.codedWidth !== this.textureWidth
            || frame.codedHeight !== this.videoHeight
            || frame.codedWidth !== this.videoWidth) {
            this.videoWidth = frame.codedWidth;
            this.videoHeight = frame.codedHeight;
            this.textureWidth = frame.codedWidth;
            this.layout();
            this.generatePipeline();
        }
    }
    generateBindGroup() {
        this.bindGroupLayout = this.device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX,
                    buffer: {
                        type: 'uniform'
                    }
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    externalTexture: {}
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: {
                        type: 'filtering'
                    }
                }
            ]
        });
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        const bindGroup = this.device.createBindGroup({
            layout: this.renderPipeline.getBindGroupLayout(0),
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this.rotateMatrixBuffer,
                        size: Float32Array.BYTES_PER_ELEMENT * 16
                    }
                },
                {
                    binding: 1,
                    resource: this.device.importExternalTexture({
                        source: frame
                    })
                },
                {
                    binding: 2,
                    resource: this.sampler
                }
            ]
        });
        const commandEncoder = this.device.createCommandEncoder();
        const renderPassDescriptor = {
            colorAttachments: [
                {
                    view: this.context.getCurrentTexture().createView(),
                    clearValue: {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 1
                    },
                    loadOp: 'clear',
                    storeOp: 'store'
                }
            ],
        };
        const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor);
        renderPass.setPipeline(this.renderPipeline);
        renderPass.setBindGroup(0, bindGroup);
        renderPass.setVertexBuffer(0, this.vbo);
        renderPass.draw(4, 4, 0, 0);
        renderPass.end();
        this.device.queue.submit([commandEncoder.finish()]);
    }
    destroy() {
        super.destroy();
    }
    static isSupport(frame) {
        // VideoFrame
        return frame instanceof VideoFrame;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPURGB8Render.ts":
/*!************************************************!*\
  !*** ./src/avrender/image/WebGPURGB8Render.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPURGB8Render)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");
/* harmony import */ var _WebGPURGBRender__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WebGPURGBRender */ "./src/avrender/image/WebGPURGBRender.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");







class WebGPURGB8Render extends _WebGPURGBRender__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(canvas, options) {
        super(canvas, options);
    }
    generateFragmentSource(format, descriptor) {
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_4__["default"])(this.srcColorSpace, this.dstColorSpace, {
            bitDepth: 8,
            type: 1 /* GLType.kWebGPU */,
            outputRGB: true
        });
        const map = ['r', 'g', 'b', 'a'];
        let r = `textureSample(rgbTexture, in_texcoord.xy).${map[descriptor.comp[0].offset]}`;
        let g = `textureSample(rgbTexture, in_texcoord.xy).${map[descriptor.comp[1].offset]}`;
        let b = `textureSample(rgbTexture, in_texcoord.xy).${map[descriptor.comp[2].offset]}`;
        let alpha = '1.0';
        if ((descriptor.flags & 128 /* PixelFormatFlags.ALPHA */) && descriptor.nbComponents === 4) {
            alpha = `textureSample(rgbTexture, in_texcoord.xy).${map[descriptor.comp[3].offset]}`;
        }
        this.fragmentSource = `
      @group(0) @binding(1) var s: sampler;
      @group(0) @binding(2) var rgbTexture: texture_2d<f32>;
      
      @fragment
      fn main(@location(0) in_texcoord: vec4<f32>) -> @location(0) vec4<f32> {
        let r = ${r};
        let g = ${g};
        let b = ${b};
        let alpha = ${alpha};
        var color = vec4(r, g, b, alpha);
        ${steps.reduce((pre, current) => pre + current, '')}
        return color;
      }
    `;
    }
    checkFrame(frame) {
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_1__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68) !== this.videoWidth) {
            if (this.rgbTexture) {
                this.rgbTexture.destroy();
            }
            this.rgbTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72)],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                format: 'r8unorm'
            });
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_3__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 220), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 212), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 216), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 208));
            this.generateFragmentSource(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80), descriptor);
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32);
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80);
            this.layout();
            this.generatePipeline();
            this.generateRenderBundleEncoder();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        this.device.queue.writeTexture({
            texture: this.rgbTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame), this.rgbTexture.width * this.rgbTexture.height), {
            offset: 0,
            bytesPerRow: this.rgbTexture.width,
            rowsPerImage: this.rgbTexture.height
        }, {
            width: this.rgbTexture.width,
            height: this.rgbTexture.height,
            depthOrArrayLayers: 1
        });
        const commandEncoder = this.device.createCommandEncoder();
        const renderPass = commandEncoder.beginRenderPass({
            colorAttachments: [{
                    view: this.context.getCurrentTexture().createView(),
                    clearValue: {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 1
                    },
                    loadOp: 'clear',
                    storeOp: 'store'
                }]
        });
        renderPass.executeBundles([this.renderBundle]);
        renderPass.end();
        this.device.queue.submit([
            commandEncoder.finish()
        ]);
    }
    static isSupport(frame) {
        if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_6__["default"])(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_1__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                return (info.flags & 32 /* PixelFormatFlags.RGB */) && ((info.comp[0].depth + 7) >>> 3) === 1;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPURGBRender.ts":
/*!***********************************************!*\
  !*** ./src/avrender/image/WebGPURGBRender.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPURGBRender)
/* harmony export */ });
/* harmony import */ var _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgpu/wgsl/vertex.wgsl */ "./src/avrender/image/webgpu/wgsl/vertex.wgsl");
/* harmony import */ var _WebGPURender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGPURender */ "./src/avrender/image/WebGPURender.ts");
/*
 * libmedia WebGPURGBRender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class WebGPURGBRender extends _WebGPURender__WEBPACK_IMPORTED_MODULE_1__["default"] {
    rgbTexture;
    constructor(canvas, options) {
        super(canvas, options);
        this.vertexSource = _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_0__["default"];
    }
    generateBindGroup() {
        if (!this.rgbTexture) {
            return;
        }
        const bindGroupLayoutEntry = [
            {
                binding: 0,
                visibility: GPUShaderStage.VERTEX,
                buffer: {
                    type: 'uniform'
                }
            },
            {
                binding: 1,
                visibility: GPUShaderStage.FRAGMENT,
                sampler: {
                    type: 'filtering'
                }
            },
            {
                binding: 2,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            }
        ];
        this.bindGroupLayout = this.device.createBindGroupLayout({
            entries: bindGroupLayoutEntry
        });
        const bindGroupEntry = [
            {
                binding: 0,
                resource: {
                    buffer: this.rotateMatrixBuffer,
                    size: Float32Array.BYTES_PER_ELEMENT * 16
                }
            },
            {
                binding: 1,
                resource: this.sampler
            },
            {
                binding: 2,
                resource: this.rgbTexture.createView()
            }
        ];
        this.bindGroup = this.device.createBindGroup({
            layout: this.bindGroupLayout,
            entries: bindGroupEntry
        });
    }
    destroy() {
        if (this.rgbTexture) {
            this.rgbTexture.destroy();
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPURender.ts":
/*!********************************************!*\
  !*** ./src/avrender/image/WebGPURender.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPURender)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _ImageRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageRender */ "./src/avrender/image/ImageRender.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var _function_flipVertex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./function/flipVertex */ "./src/avrender/image/function/flipVertex.ts");
var cheap__fileName__0 = "src\\avrender\\image\\WebGPURender.ts";
/*
 * libmedia WebGPURender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class WebGPURender extends _ImageRender__WEBPACK_IMPORTED_MODULE_1__["default"] {
    adapter;
    device;
    context;
    vsModule;
    fsModule;
    rotateMatrixBuffer;
    renderPipeline;
    rotateMatrix;
    vbo;
    sampler;
    vertex;
    fragmentSource;
    vertexSource;
    renderBundleEncoder;
    renderBundle;
    bindGroupLayout;
    bindGroup;
    pipelineLayout;
    constructor(canvas, options) {
        super(canvas, options);
    }
    async init(requiredFeatures) {
        this.adapter = await navigator.gpu.requestAdapter({
            powerPreference: this.options.powerPreference ?? 'high-performance'
        });
        const canRequiredFeatures = [];
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(requiredFeatures, (feature) => {
            if (this.adapter.features.has(feature)) {
                canRequiredFeatures.push(feature);
            }
        });
        this.device = await this.adapter.requestDevice({
            requiredFeatures: canRequiredFeatures.length ? canRequiredFeatures : undefined
        });
        this.device.lost.then(() => {
            if (this.destroyed) {
                return;
            }
            this.lost = true;
            common_util_logger__WEBPACK_IMPORTED_MODULE_0__.error('gpu device lost', cheap__fileName__0, 101);
            if (this.options?.onRenderContextLost) {
                this.options.onRenderContextLost();
            }
        });
        this.context = this.canvas.getContext('webgpu');
        if (!this.context) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('can not support webgpu, got GPUCanvasContext failed', cheap__fileName__0, 110);
        }
        this.context.configure({
            device: this.device,
            format: navigator.gpu.getPreferredCanvasFormat(),
            alphaMode: 'premultiplied'
        });
        this.sampler = this.device.createSampler({
            magFilter: 'linear',
            minFilter: 'linear'
        });
        this.vbo = this.device.createBuffer({
            size: Float32Array.BYTES_PER_ELEMENT * 28,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
        });
        this.rotateMatrixBuffer = this.device.createBuffer({
            size: Float32Array.BYTES_PER_ELEMENT * 16,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.setRotateMatrix(this.getRotateMatrix(0));
    }
    generatePipeline() {
        this.generateBindGroup();
        this.pipelineLayout = this.device.createPipelineLayout({
            bindGroupLayouts: [this.bindGroupLayout]
        });
        this.vsModule = this.device.createShaderModule({
            code: this.vertexSource
        });
        this.fsModule = this.device.createShaderModule({
            code: this.fragmentSource
        });
        this.renderPipeline = this.device.createRenderPipeline({
            layout: this.pipelineLayout,
            vertex: {
                module: this.vsModule,
                entryPoint: 'main',
                buffers: [
                    {
                        arrayStride: 28,
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: 'float32x3'
                            },
                            {
                                shaderLocation: 1,
                                offset: 12,
                                format: 'float32x4'
                            }
                        ]
                    }
                ]
            },
            fragment: {
                module: this.fsModule,
                entryPoint: 'main',
                targets: [{
                        format: navigator.gpu.getPreferredCanvasFormat()
                    }]
            },
            primitive: {
                topology: 'triangle-strip'
            }
        });
    }
    generateRenderBundleEncoder() {
        if (!this.renderPipeline) {
            return;
        }
        this.renderBundleEncoder = this.device.createRenderBundleEncoder({
            colorFormats: [navigator.gpu.getPreferredCanvasFormat()]
        });
        this.renderBundleEncoder.setPipeline(this.renderPipeline);
        this.renderBundleEncoder.setBindGroup(0, this.bindGroup);
        this.renderBundleEncoder.setVertexBuffer(0, this.vbo);
        this.renderBundleEncoder.draw(4, 4, 0, 0);
        this.renderBundle = this.renderBundleEncoder.finish();
    }
    setRotateMatrix(rotateMatrix) {
        this.rotateMatrix = rotateMatrix;
        const buffer = new Float32Array(this.rotateMatrix);
        this.device.queue.writeBuffer(this.rotateMatrixBuffer, 0, 
        // 传递 ArrayBuffer
        buffer.buffer, 
        // 从哪里开始
        buffer.byteOffset, 
        // 取多长
        buffer.byteLength);
    }
    setVertices() {
        const buffer = new Float32Array(this.vertex);
        this.device.queue.writeBuffer(this.vbo, 0, 
        // 传递 ArrayBuffer
        buffer.buffer, 
        // 从哪里开始
        buffer.byteOffset, 
        // 取多长
        buffer.byteLength);
    }
    clear() {
        this.context.getCurrentTexture().destroy();
    }
    layout() {
        let videoWidth = this.videoWidth;
        let videoHeight = this.videoHeight;
        let canvasWidth = this.canvasWidth;
        let canvasHeight = this.canvasHeight;
        if (this.rotate === 90 || this.rotate === 270) {
            /*
             * videoWidth = this.videoHeight
             * videoHeight = this.videoWidth
             */
            canvasWidth = this.canvasHeight;
            canvasHeight = this.canvasWidth;
        }
        const scaleX = videoWidth / canvasWidth;
        const scaleY = videoHeight / canvasHeight;
        let isPaddingTop;
        if (scaleX > 1) {
            if (scaleX < scaleY) {
                isPaddingTop = false;
            }
            else {
                isPaddingTop = true;
            }
        }
        else {
            if (scaleX > scaleY) {
                isPaddingTop = true;
            }
            else {
                isPaddingTop = false;
            }
        }
        if (this.renderMode === 1 /* RenderMode.FILL */) {
            isPaddingTop = !isPaddingTop;
        }
        let texturePadding = 0;
        if (this.textureWidth !== this.videoWidth) {
            texturePadding = (this.textureWidth - this.videoWidth) / this.textureWidth;
        }
        if (isPaddingTop) {
            const paddingTop = (canvasHeight - videoHeight * canvasWidth / videoWidth) / canvasHeight;
            this.vertex = [
                -1, 1 - paddingTop, 0, 0, 0, 0, 0,
                -1, -1 + paddingTop, 0, 0, 1, 0, 0,
                1, 1 - paddingTop, 0, 1 - texturePadding, 0, 0, 0,
                1, -1 + paddingTop, 0, 1 - texturePadding, 1, 0, 0
            ];
        }
        else {
            const paddingLeft = (canvasWidth - videoWidth * canvasHeight / videoHeight) / canvasWidth;
            this.vertex = [
                -1 + paddingLeft, 1, 0, 0, 0, 0, 0,
                -1 + paddingLeft, -1, 0, 0, 1, 0, 0,
                1 - paddingLeft, 1, 0, 1 - texturePadding, 0, 0, 0,
                1 - paddingLeft, -1, 0, 1 - texturePadding, 1, 0, 0
            ];
        }
        (0,_function_flipVertex__WEBPACK_IMPORTED_MODULE_3__["default"])(this.vertex, this.flipHorizontal, this.flipVertical);
        this.setVertices();
    }
    viewport(width, height) {
        super.viewport(width, height);
    }
    setRotate(angle) {
        angle = angle % 360;
        if (angle === this.rotate) {
            return;
        }
        this.rotate = angle;
        this.setRotateMatrix(this.getRotateMatrix(angle));
        this.layout();
        this.clear();
    }
    destroy() {
        this.sampler = null;
        if (this.vbo) {
            this.vbo.destroy();
        }
        if (this.rotateMatrixBuffer) {
            this.rotateMatrixBuffer.destroy();
        }
        this.bindGroupLayout = null;
        this.bindGroup = null;
        this.pipelineLayout = null;
        this.renderBundle = null;
        this.renderBundleEncoder = null;
        this.fsModule = null;
        this.vsModule = null;
        this.renderPipeline = null;
        this.rotateMatrix = null;
        this.vertex = null;
        this.context = null;
        this.options = null;
        this.destroyed = true;
        if (this.device) {
            this.device.destroy();
            this.device = null;
        }
        if (this.adapter) {
            this.adapter = null;
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPUYUV16Render.ts":
/*!*************************************************!*\
  !*** ./src/avrender/image/WebGPUYUV16Render.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPUYUV16Render)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var _WebGPUYUVRender__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WebGPUYUVRender */ "./src/avrender/image/WebGPUYUVRender.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var _webgpu_wgsl_compute_uint2FloatLE_wgsl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./webgpu/wgsl/compute/uint2FloatLE.wgsl */ "./src/avrender/image/webgpu/wgsl/compute/uint2FloatLE.wgsl");
/* harmony import */ var _webgpu_wgsl_compute_uint2FloatBE_wgsl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./webgpu/wgsl/compute/uint2FloatBE.wgsl */ "./src/avrender/image/webgpu/wgsl/compute/uint2FloatBE.wgsl");
/* harmony import */ var _colorTransform_options__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./colorTransform/options */ "./src/avrender/image/colorTransform/options.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");
/* harmony import */ var _struct_HdrMetadata__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./struct/HdrMetadata */ "./src/avrender/image/struct/HdrMetadata.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");















class WebGPUYUV16Render extends _WebGPUYUVRender__WEBPACK_IMPORTED_MODULE_4__["default"] {
    metaYBuffer;
    metaUBuffer;
    metaVBuffer;
    metaABuffer;
    computeBindGroupLayout;
    computeBindGroupY;
    computeBindGroupU;
    computeBindGroupV;
    computeBindGroupA;
    computePipelineLayout;
    computePipeline;
    inputYTexture;
    inputUTexture;
    inputVTexture;
    inputATexture;
    computeModule;
    uint2Float;
    hdrMetadata;
    hdrMetadataBuffer;
    constructor(canvas, options) {
        super(canvas, options);
        this.hdrMetadata = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_1__["default"])(_struct_HdrMetadata__WEBPACK_IMPORTED_MODULE_12__["default"]);
        this.hdrMetadata.multiplier = 1.0;
    }
    generateFragmentSource(format, descriptor, colorTransformOptions) {
        colorTransformOptions.outputRGB = true;
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_11__["default"])(this.srcColorSpace, this.dstColorSpace, colorTransformOptions);
        let y = 'textureSample(yTexture, s, in_texcoord.xy).x;';
        let u = 'textureSample(uTexture, s, in_texcoord.xy).x';
        let v = 'textureSample(vTexture, s, in_texcoord.xy).x';
        let alpha = '1.0';
        if (format === 23 /* AVPixelFormat.AV_PIX_FMT_NV12 */
            || format === 189 /* AVPixelFormat.AV_PIX_FMT_NV24 */) {
            u = 'textureSample(uTexture, s, in_texcoord.xy).x';
            v = 'textureSample(uTexture, s, in_texcoord.xy).y';
        }
        else if (format === 24 /* AVPixelFormat.AV_PIX_FMT_NV21 */
            || format === 190 /* AVPixelFormat.AV_PIX_FMT_NV42 */) {
            u = 'textureSample(uTexture, s, in_texcoord.xy).y';
            v = 'textureSample(uTexture, s, in_texcoord.xy).x';
        }
        if ((descriptor.flags & 128 /* PixelFormatFlags.ALPHA */) && descriptor.nbComponents === 4) {
            alpha = 'textureSample(aTexture, s, in_texcoord.xy).x';
        }
        this.fragmentSource = `
      struct HdrMetadata {
        offset: f32,
        multiplier: f32,
        pqTonemapA: f32,
        pqTonemapB: f32,
        hlgOOTFGammaMinusOne: f32,
        hlgDstMaxLuminanceRelative: f32,
        nitsToSdrRelativeFactor: f32,
        sdrRelativeToNitsFactor: f32
      };

      @group(0) @binding(1) var s: sampler;
      @group(0) @binding(2) var<uniform> hdrMetadata: HdrMetadata;
      @group(0) @binding(3) var yTexture: texture_2d<f32>;
      @group(0) @binding(4) var uTexture: texture_2d<f32>;

      ${this.vTexture ? '@group(0) @binding(5) var vTexture: texture_2d<f32>;' : ''}
      ${this.aTexture ? '@group(0) @binding(6) var aTexture: texture_2d<f32>;' : ''}

      @fragment
      fn main(@location(0) in_texcoord: vec4<f32>) -> @location(0) vec4<f32> {

        let offset = hdrMetadata.offset;
        let multiplier = hdrMetadata.multiplier;
        let pq_tonemap_a = hdrMetadata.pqTonemapA;
        let pq_tonemap_b = hdrMetadata.pqTonemapB;
        let hlg_ootf_gamma_minus_one = hdrMetadata.hlgOOTFGammaMinusOne;
        let hlg_dst_max_luminance_relative = hdrMetadata.hlgDstMaxLuminanceRelative;
        let nits_to_sdr_relative_factor = hdrMetadata.nitsToSdrRelativeFactor;
        let sdr_relative_to_nits_factor = hdrMetadata.sdrRelativeToNitsFactor;

        let y = ${y}
        let u = ${u};
        let v = ${v};
        let alpha = ${alpha};
        var color = vec4(y, u, v, alpha);

        if (color.a > 0) {
          color.r /= color.a;
          color.g /= color.a;
          color.b /= color.a;
        }
        color.r -= offset;
        color.g -= offset;
        color.b -= offset;

        color.r *= multiplier;
        color.g *= multiplier;
        color.b *= multiplier;
        
        ${steps.reduce((pre, current) => pre + current, '')}

        color.r *= color.a;
        color.g *= color.a;
        color.b *= color.a;

        return color;
      }
    `;
    }
    async init() {
        await super.init(['float32-filterable']);
        this.metaYBuffer = this.device.createBuffer({
            size: Uint32Array.BYTES_PER_ELEMENT * 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.metaUBuffer = this.device.createBuffer({
            size: Uint32Array.BYTES_PER_ELEMENT * 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.metaVBuffer = this.device.createBuffer({
            size: Uint32Array.BYTES_PER_ELEMENT * 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.metaABuffer = this.device.createBuffer({
            size: Uint32Array.BYTES_PER_ELEMENT * 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.hdrMetadataBuffer = this.device.createBuffer({
            size: (47) & ~15,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
    }
    generateComputeBindGroup() {
        this.computeBindGroupLayout = this.device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: 'uniform'
                    }
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.COMPUTE,
                    texture: {
                        sampleType: 'uint'
                    }
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.COMPUTE,
                    storageTexture: {
                        format: 'r32float'
                    }
                }
            ]
        });
        this.computeBindGroupY = this.device.createBindGroup({
            layout: this.computeBindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this.metaYBuffer,
                        size: Uint32Array.BYTES_PER_ELEMENT * 4
                    }
                },
                {
                    binding: 1,
                    resource: this.inputYTexture.createView()
                },
                {
                    binding: 2,
                    resource: this.yTexture.createView()
                }
            ]
        });
        this.computeBindGroupU = this.device.createBindGroup({
            layout: this.computeBindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this.metaUBuffer,
                        size: Uint32Array.BYTES_PER_ELEMENT * 4
                    }
                },
                {
                    binding: 1,
                    resource: this.inputUTexture.createView()
                },
                {
                    binding: 2,
                    resource: this.uTexture.createView()
                }
            ]
        });
        if (this.vTexture) {
            this.computeBindGroupV = this.device.createBindGroup({
                layout: this.computeBindGroupLayout,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: this.metaVBuffer,
                            size: Uint32Array.BYTES_PER_ELEMENT * 4
                        }
                    },
                    {
                        binding: 1,
                        resource: this.inputVTexture.createView()
                    },
                    {
                        binding: 2,
                        resource: this.vTexture.createView()
                    }
                ]
            });
        }
        if (this.aTexture) {
            this.computeBindGroupA = this.device.createBindGroup({
                layout: this.computeBindGroupLayout,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: this.metaABuffer,
                            size: Uint32Array.BYTES_PER_ELEMENT * 4
                        }
                    },
                    {
                        binding: 1,
                        resource: this.inputATexture.createView()
                    },
                    {
                        binding: 2,
                        resource: this.aTexture.createView()
                    }
                ]
            });
        }
    }
    generateComputePipeline() {
        this.generateComputeBindGroup();
        this.computePipelineLayout = this.device.createPipelineLayout({
            bindGroupLayouts: [this.computeBindGroupLayout]
        });
        this.computeModule = this.device.createShaderModule({
            code: this.uint2Float
        });
        this.computePipeline = this.device.createComputePipeline({
            layout: this.computePipelineLayout,
            compute: {
                module: this.computeModule,
                entryPoint: 'main'
            }
        });
    }
    generateBindGroup() {
        if (!this.yTexture) {
            return;
        }
        const bindGroupLayoutEntry = [
            {
                binding: 0,
                visibility: GPUShaderStage.VERTEX,
                buffer: {
                    type: 'uniform'
                }
            },
            {
                binding: 1,
                visibility: GPUShaderStage.FRAGMENT,
                sampler: {
                    type: 'filtering'
                }
            },
            {
                binding: 2,
                visibility: GPUShaderStage.FRAGMENT,
                buffer: {
                    type: 'uniform'
                }
            },
            {
                binding: 3,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            },
            {
                binding: 4,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            },
        ];
        if (this.vTexture) {
            bindGroupLayoutEntry.push({
                binding: 5,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            });
        }
        if (this.aTexture) {
            bindGroupLayoutEntry.push({
                binding: 6,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            });
        }
        this.bindGroupLayout = this.device.createBindGroupLayout({
            entries: bindGroupLayoutEntry
        });
        const bindGroupEntry = [
            {
                binding: 0,
                resource: {
                    buffer: this.rotateMatrixBuffer,
                    size: Float32Array.BYTES_PER_ELEMENT * 16
                }
            },
            {
                binding: 1,
                resource: this.sampler
            },
            {
                binding: 2,
                resource: {
                    buffer: this.hdrMetadataBuffer,
                    size: this.hdrMetadataBuffer.size
                }
            },
            {
                binding: 3,
                resource: this.yTexture.createView()
            },
            {
                binding: 4,
                resource: this.uTexture.createView()
            }
        ];
        if (this.vTexture) {
            bindGroupEntry.push({
                binding: 5,
                resource: this.vTexture.createView()
            });
        }
        if (this.aTexture) {
            bindGroupEntry.push({
                binding: 6,
                resource: this.aTexture.createView()
            });
        }
        this.bindGroup = this.device.createBindGroup({
            layout: this.bindGroupLayout,
            entries: bindGroupEntry
        });
    }
    checkFrame(frame) {
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        if ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32) >>> 1) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 68) !== this.videoWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80) !== this.format) {
            if (this.yTexture) {
                this.yTexture.destroy();
            }
            if (this.uTexture) {
                this.uTexture.destroy();
            }
            if (this.vTexture) {
                this.vTexture.destroy();
            }
            if (this.aTexture) {
                this.aTexture.destroy();
            }
            if (this.inputYTexture) {
                this.inputYTexture.destroy();
            }
            if (this.inputUTexture) {
                this.inputUTexture.destroy();
            }
            if (this.inputVTexture) {
                this.inputVTexture.destroy();
            }
            if (this.inputATexture) {
                this.inputATexture.destroy();
            }
            this.yTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72)],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING,
                format: 'r32float'
            });
            this.uTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32 + 4) >>> 1, (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72) >>> descriptor.log2ChromaH)],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING,
                format: 'r32float'
            });
            if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
                this.vTexture = this.device.createTexture({
                    size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32 + 8) >>> 1, (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72) >>> descriptor.log2ChromaH)],
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING,
                    format: 'r32float'
                });
            }
            if (descriptor.nbComponents === 4) {
                this.aTexture = this.device.createTexture({
                    size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32 + 12) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72)],
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING,
                    format: 'r32float'
                });
            }
            this.inputYTexture = this.device.createTexture({
                size: [this.yTexture.width, this.yTexture.height],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                format: 'r16uint'
            });
            this.inputUTexture = this.device.createTexture({
                size: [this.uTexture.width, this.uTexture.height],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                format: 'r16uint'
            });
            if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
                this.inputVTexture = this.device.createTexture({
                    size: [this.vTexture.width, this.vTexture.height],
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                    format: 'r16uint'
                });
            }
            if (descriptor.nbComponents === 4) {
                this.inputATexture = this.device.createTexture({
                    size: [this.aTexture.width, this.aTexture.height],
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                    format: 'r16uint'
                });
            }
            const yBuffer = new Uint32Array([(1 << descriptor.comp[0].depth) - 1, this.inputYTexture.width, this.inputYTexture.height]);
            this.device.queue.writeBuffer(this.metaYBuffer, 0, yBuffer.buffer, yBuffer.byteOffset, yBuffer.byteLength);
            const uBuffer = new Uint32Array([(1 << descriptor.comp[1].depth) - 1, this.inputUTexture.width, this.inputUTexture.height]);
            this.device.queue.writeBuffer(this.metaUBuffer, 0, uBuffer.buffer, uBuffer.byteOffset, uBuffer.byteLength);
            if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
                const vBuffer = new Uint32Array([(1 << descriptor.comp[2].depth) - 1, this.inputVTexture.width, this.inputVTexture.height]);
                this.device.queue.writeBuffer(this.metaVBuffer, 0, vBuffer.buffer, vBuffer.byteOffset, vBuffer.byteLength);
            }
            if (descriptor.nbComponents === 4) {
                const aBuffer = new Uint32Array([(1 << descriptor.comp[3].depth) - 1, this.inputATexture.width, this.inputATexture.height]);
                this.device.queue.writeBuffer(this.metaABuffer, 0, aBuffer.buffer, aBuffer.byteOffset, aBuffer.byteLength);
            }
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_7__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 220), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 212), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 216), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 208));
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32) >>> 1;
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80);
            const colorTransformOptions = {
                type: 1 /* GLType.kWebGPU */,
                bitDepth: descriptor.comp[0].depth,
                toneMapPQAndHlgToDst: true,
                metadata: this.hdrMetadata,
                dstSdrMaxLuminanceNits: _colorTransform_options__WEBPACK_IMPORTED_MODULE_10__.DefaultSDRWhiteLevel,
                dstMaxLuminanceRelative: 1.0
            };
            const sideData = (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_13__.getAVFrameSideData)(frame, 14 /* AVFrameSideDataType.AV_FRAME_DATA_CONTENT_LIGHT_LEVEL */);
            if (sideData) {
                const lightMetadata = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](sideData + 4);
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[8](lightMetadata) > 0) {
                    colorTransformOptions.maxContentLightLevel = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[8](lightMetadata);
                }
            }
            this.generateFragmentSource(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80), descriptor, colorTransformOptions);
            this.uint2Float = (descriptor.flags & 1 /* PixelFormatFlags.BIG_ENDIAN */) ? _webgpu_wgsl_compute_uint2FloatBE_wgsl__WEBPACK_IMPORTED_MODULE_9__["default"] : _webgpu_wgsl_compute_uint2FloatLE_wgsl__WEBPACK_IMPORTED_MODULE_8__["default"];
            this.layout();
            this.generatePipeline();
            this.generateRenderBundleEncoder();
            this.generateComputePipeline();
            const hdrBuffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(this.hdrMetadata[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress], 32).slice();
            this.device.queue.writeBuffer(this.hdrMetadataBuffer, 0, hdrBuffer.buffer, hdrBuffer.byteOffset, hdrBuffer.byteLength);
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        const commandEncoder = this.device.createCommandEncoder();
        const computePass = commandEncoder.beginComputePass({});
        computePass.setPipeline(this.computePipeline);
        computePass.setBindGroup(0, this.computeBindGroupY);
        this.device.queue.writeTexture({
            texture: this.inputYTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](frame), (this.inputYTexture.width * this.inputYTexture.height) << 1), {
            offset: 0,
            bytesPerRow: this.inputYTexture.width << 1,
            rowsPerImage: this.inputYTexture.height
        }, {
            width: this.inputYTexture.width,
            height: this.inputYTexture.height,
            depthOrArrayLayers: 1
        });
        computePass.dispatchWorkgroups((this.inputYTexture.width + 7) >>> 3, (this.inputYTexture.height + 7) >>> 3);
        computePass.setBindGroup(0, this.computeBindGroupU);
        this.device.queue.writeTexture({
            texture: this.inputUTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](frame + 4), (this.inputUTexture.width * this.inputUTexture.height) << 1), {
            offset: 0,
            bytesPerRow: this.inputUTexture.width << 1,
            rowsPerImage: this.inputUTexture.height
        }, {
            width: this.inputUTexture.width,
            height: this.inputUTexture.height,
            depthOrArrayLayers: 1
        });
        computePass.dispatchWorkgroups((this.inputUTexture.width + 7) >>> 3, (this.inputUTexture.height + 7) >>> 3);
        if (this.inputVTexture) {
            computePass.setBindGroup(0, this.computeBindGroupV);
            this.device.queue.writeTexture({
                texture: this.inputVTexture
            }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](frame + 8), (this.inputVTexture.width * this.inputVTexture.height) << 1), {
                offset: 0,
                bytesPerRow: this.inputVTexture.width << 1,
                rowsPerImage: this.inputVTexture.height
            }, {
                width: this.inputVTexture.width,
                height: this.inputVTexture.height,
                depthOrArrayLayers: 1
            });
            computePass.dispatchWorkgroups((this.inputVTexture.width + 7) >>> 3, (this.inputVTexture.height + 7) >>> 3);
        }
        if (this.inputATexture) {
            computePass.setBindGroup(0, this.computeBindGroupA);
            this.device.queue.writeTexture({
                texture: this.inputATexture
            }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](frame + 12), (this.inputATexture.width * this.inputATexture.height) << 1), {
                offset: 0,
                bytesPerRow: this.inputATexture.width << 1,
                rowsPerImage: this.inputATexture.height
            }, {
                width: this.inputATexture.width,
                height: this.inputATexture.height,
                depthOrArrayLayers: 1
            });
            computePass.dispatchWorkgroups((this.inputATexture.width + 7) >>> 3, (this.inputATexture.height + 7) >>> 3);
        }
        computePass.end();
        const renderPass = commandEncoder.beginRenderPass({
            colorAttachments: [{
                    view: this.context.getCurrentTexture().createView(),
                    clearValue: {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 1
                    },
                    loadOp: 'clear',
                    storeOp: 'store'
                }]
        });
        renderPass.executeBundles([this.renderBundle]);
        renderPass.end();
        this.device.queue.submit([
            commandEncoder.finish()
        ]);
    }
    destroy() {
        if (this.inputYTexture) {
            this.inputYTexture.destroy();
            this.inputYTexture = null;
        }
        if (this.inputUTexture) {
            this.inputUTexture.destroy();
            this.inputUTexture = null;
        }
        if (this.inputVTexture) {
            this.inputVTexture.destroy();
            this.inputVTexture = null;
        }
        if (this.metaYBuffer) {
            this.metaYBuffer.destroy();
            this.metaYBuffer = null;
        }
        if (this.metaUBuffer) {
            this.metaUBuffer.destroy();
            this.metaUBuffer = null;
        }
        if (this.metaVBuffer) {
            this.metaVBuffer.destroy();
            this.metaVBuffer = null;
        }
        if (this.hdrMetadata) {
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_3__["default"])(this.hdrMetadata);
            this.hdrMetadata = null;
        }
        this.computeModule = null;
        this.computeBindGroupY = null;
        this.computeBindGroupU = null;
        this.computeBindGroupV = null;
        this.computeBindGroupLayout = null;
        this.computePipelineLayout = null;
        this.computePipeline = null;
        super.destroy();
    }
    static isSupport(frame) {
        if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_14__["default"])(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                if (info.flags & 32 /* PixelFormatFlags.RGB */) {
                    return false;
                }
                return (info.flags & 16 /* PixelFormatFlags.PLANER */) && ((info.comp[0].depth + 7) >>> 3) === 2;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPUYUV8Render.ts":
/*!************************************************!*\
  !*** ./src/avrender/image/WebGPUYUV8Render.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPUYUV8Render)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _WebGPUYUVRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGPUYUVRender */ "./src/avrender/image/WebGPUYUVRender.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");







class WebGPUYUV8Render extends _WebGPUYUVRender__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(canvas, options) {
        super(canvas, options);
    }
    generateFragmentSource(format, descriptor) {
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_5__["default"])(this.srcColorSpace, this.dstColorSpace, {
            bitDepth: 8,
            type: 1 /* GLType.kWebGPU */,
            outputRGB: true
        });
        let y = 'textureSample(yTexture, s, in_texcoord.xy).x';
        let u = 'textureSample(uTexture, s, in_texcoord.xy).x';
        let v = 'textureSample(vTexture, s, in_texcoord.xy).x';
        let alpha = '1.0';
        if (format === 23 /* AVPixelFormat.AV_PIX_FMT_NV12 */
            || format === 189 /* AVPixelFormat.AV_PIX_FMT_NV24 */) {
            u = 'textureSample(uTexture, s, in_texcoord.xy).x';
            v = 'textureSample(uTexture, s, in_texcoord.xy).y';
        }
        else if (format === 24 /* AVPixelFormat.AV_PIX_FMT_NV21 */
            || format === 190 /* AVPixelFormat.AV_PIX_FMT_NV42 */) {
            u = 'textureSample(uTexture, s, in_texcoord.xy).y';
            v = 'textureSample(uTexture, s, in_texcoord.xy).x';
        }
        if ((descriptor.flags & 128 /* PixelFormatFlags.ALPHA */) && descriptor.nbComponents === 4) {
            alpha = 'textureSample(aTexture, s, in_texcoord.xy).x';
        }
        this.fragmentSource = `
      @group(0) @binding(1) var s: sampler;
      @group(0) @binding(2) var yTexture: texture_2d<f32>;
      @group(0) @binding(3) var uTexture: texture_2d<f32>;
      ${this.vTexture ? '@group(0) @binding(4) var vTexture: texture_2d<f32>;' : ''}
      ${this.aTexture ? '@group(0) @binding(5) var aTexture: texture_2d<f32>;' : ''}
      
      @fragment
      fn main(@location(0) in_texcoord: vec4<f32>) -> @location(0) vec4<f32> {
        let y = ${y};
        let u = ${u};
        let v = ${v};
        let alpha = ${alpha};
        var color = vec4(y, u, v, alpha);
        ${steps.reduce((pre, current) => pre + current, '')}
        return color;
      }
    `;
    }
    checkFrame(frame) {
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68) !== this.videoWidth) {
            if (this.yTexture) {
                this.yTexture.destroy();
            }
            if (this.uTexture) {
                this.uTexture.destroy();
            }
            if (this.vTexture) {
                this.vTexture.destroy();
            }
            if (this.aTexture) {
                this.aTexture.destroy();
            }
            this.yTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72)],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                format: 'r8unorm'
            });
            this.uTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32 + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)].log2ChromaH],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                format: 'r8unorm'
            });
            if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
                this.vTexture = this.device.createTexture({
                    size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32 + 8), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)].log2ChromaH],
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                    format: 'r8unorm'
                });
            }
            if (descriptor.nbComponents === 4) {
                this.aTexture = this.device.createTexture({
                    size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32 + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72)],
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                    format: 'r8unorm'
                });
            }
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_4__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 220), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 212), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 216), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 208));
            this.generateFragmentSource(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80), descriptor);
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32);
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80);
            this.layout();
            this.generatePipeline();
            this.generateRenderBundleEncoder();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        this.device.queue.writeTexture({
            texture: this.yTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame), this.yTexture.width * this.yTexture.height), {
            offset: 0,
            bytesPerRow: this.yTexture.width,
            rowsPerImage: this.yTexture.height
        }, {
            width: this.yTexture.width,
            height: this.yTexture.height,
            depthOrArrayLayers: 1
        });
        this.device.queue.writeTexture({
            texture: this.uTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame + 4), this.uTexture.width * this.uTexture.height), {
            offset: 0,
            bytesPerRow: this.uTexture.width,
            rowsPerImage: this.uTexture.height
        }, {
            width: this.uTexture.width,
            height: this.uTexture.height,
            depthOrArrayLayers: 1
        });
        if (this.vTexture) {
            this.device.queue.writeTexture({
                texture: this.vTexture
            }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame + 8), this.vTexture.width * this.vTexture.height), {
                offset: 0,
                bytesPerRow: this.vTexture.width,
                rowsPerImage: this.vTexture.height
            }, {
                width: this.vTexture.width,
                height: this.vTexture.height,
                depthOrArrayLayers: 1
            });
        }
        if (this.aTexture) {
            this.device.queue.writeTexture({
                texture: this.aTexture
            }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame + 12), this.aTexture.width * this.aTexture.height), {
                offset: 0,
                bytesPerRow: this.aTexture.width,
                rowsPerImage: this.aTexture.height
            }, {
                width: this.aTexture.width,
                height: this.aTexture.height,
                depthOrArrayLayers: 1
            });
        }
        const commandEncoder = this.device.createCommandEncoder();
        const renderPass = commandEncoder.beginRenderPass({
            colorAttachments: [{
                    view: this.context.getCurrentTexture().createView(),
                    clearValue: {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 1
                    },
                    loadOp: 'clear',
                    storeOp: 'store'
                }]
        });
        renderPass.executeBundles([this.renderBundle]);
        renderPass.end();
        this.device.queue.submit([
            commandEncoder.finish()
        ]);
    }
    static isSupport(frame) {
        if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_6__["default"])(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                if (info.flags & 32 /* PixelFormatFlags.RGB */) {
                    return false;
                }
                return (info.flags & 16 /* PixelFormatFlags.PLANER */) && ((info.comp[0].depth + 7) >>> 3) === 1;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPUYUVRender.ts":
/*!***********************************************!*\
  !*** ./src/avrender/image/WebGPUYUVRender.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPUYUVRender)
/* harmony export */ });
/* harmony import */ var _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgpu/wgsl/vertex.wgsl */ "./src/avrender/image/webgpu/wgsl/vertex.wgsl");
/* harmony import */ var _WebGPURender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGPURender */ "./src/avrender/image/WebGPURender.ts");
/*
 * libmedia WebGPUYUVRender
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class WebGPUYUVRender extends _WebGPURender__WEBPACK_IMPORTED_MODULE_1__["default"] {
    yTexture;
    uTexture;
    vTexture;
    aTexture;
    constructor(canvas, options) {
        super(canvas, options);
        this.vertexSource = _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_0__["default"];
    }
    generateBindGroup() {
        if (!this.yTexture) {
            return;
        }
        const bindGroupLayoutEntry = [
            {
                binding: 0,
                visibility: GPUShaderStage.VERTEX,
                buffer: {
                    type: 'uniform'
                }
            },
            {
                binding: 1,
                visibility: GPUShaderStage.FRAGMENT,
                sampler: {
                    type: 'filtering'
                }
            },
            {
                binding: 2,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            },
            {
                binding: 3,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            },
        ];
        if (this.vTexture) {
            bindGroupLayoutEntry.push({
                binding: 4,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            });
        }
        if (this.aTexture) {
            bindGroupLayoutEntry.push({
                binding: 5,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            });
        }
        this.bindGroupLayout = this.device.createBindGroupLayout({
            entries: bindGroupLayoutEntry
        });
        const bindGroupEntry = [
            {
                binding: 0,
                resource: {
                    buffer: this.rotateMatrixBuffer,
                    size: Float32Array.BYTES_PER_ELEMENT * 16
                }
            },
            {
                binding: 1,
                resource: this.sampler
            },
            {
                binding: 2,
                resource: this.yTexture.createView()
            },
            {
                binding: 3,
                resource: this.uTexture.createView()
            }
        ];
        if (this.vTexture) {
            bindGroupEntry.push({
                binding: 4,
                resource: this.vTexture.createView()
            });
        }
        if (this.aTexture) {
            bindGroupEntry.push({
                binding: 5,
                resource: this.aTexture.createView()
            });
        }
        this.bindGroup = this.device.createBindGroup({
            layout: this.bindGroupLayout,
            entries: bindGroupEntry
        });
    }
    destroy() {
        if (this.yTexture) {
            this.yTexture.destroy();
        }
        if (this.uTexture) {
            this.uTexture.destroy();
        }
        if (this.vTexture) {
            this.vTexture.destroy();
        }
        if (this.aTexture) {
            this.aTexture.destroy();
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/colorSpace/ColorSpace.ts":
/*!*****************************************************!*\
  !*** ./src/avrender/image/colorSpace/ColorSpace.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ColorSpace)
/* harmony export */ });
/* harmony import */ var common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/math/Matrix4 */ "./src/common/math/Matrix4.ts");
/* harmony import */ var common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/math/Vector3 */ "./src/common/math/Vector3.ts");
/* harmony import */ var _transferFns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transferFns */ "./src/avrender/image/colorSpace/transferFns.ts");
/* harmony import */ var _primaries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./primaries */ "./src/avrender/image/colorSpace/primaries.ts");
/*
 * libmedia ColorSpace
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class ColorSpace {
    matrixId;
    primaryId;
    transferId;
    rangeId;
    constructor(matrixId, primaryId, transferId, rangeId) {
        this.matrixId = matrixId;
        this.primaryId = primaryId;
        this.transferId = transferId;
        this.rangeId = rangeId;
    }
    getMatrixId() {
        return this.matrixId;
    }
    getPrimaryId() {
        return this.primaryId;
    }
    getTransferId() {
        return this.transferId;
    }
    getRangeId() {
        return this.rangeId;
    }
    isWide() {
        if (this.primaryId === 9 /* AVColorPrimaries.AVCOL_PRI_BT2020 */
            || this.primaryId === 11 /* AVColorPrimaries.AVCOL_PRI_SMPTE431 */
            || this.primaryId === 12 /* AVColorPrimaries.AVCOL_PRI_SMPTE432 */) {
            return true;
        }
        return false;
    }
    isHDR() {
        return this.transferId === 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */
            || this.transferId === 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */;
    }
    isToneMappedByDefault() {
        if (
        // HLG
        this.transferId === 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */
            // PQ
            || this.transferId === 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */) {
            return true;
        }
        return false;
    }
    isAffectedBySDRWhiteLevel() {
        if (
        // HLG
        this.transferId === 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */
            // PQ
            || this.transferId === 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */) {
            return true;
        }
        return false;
    }
    fullRangeEncodedValues() {
        return this.transferId === 12 /* AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG */
            || this.transferId === 11 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4 */;
    }
    getTransferMatrix(bitDepth) {
        const chroma05 = (1 << (bitDepth - 1)) / ((1 << bitDepth) - 1);
        let Kr = 0;
        let Kb = 0;
        switch (this.matrixId) {
            case 0 /* AVColorSpace.AVCOL_SPC_RGB */:
                return new common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]();
            case 1 /* AVColorSpace.AVCOL_SPC_BT709 */:
            case 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */:
                Kr = 0.2126;
                Kb = 0.0722;
                break;
            case 4 /* AVColorSpace.AVCOL_SPC_FCC */:
                Kr = 0.30;
                Kb = 0.11;
                break;
            case 5 /* AVColorSpace.AVCOL_SPC_BT470BG */:
            case 6 /* AVColorSpace.AVCOL_SPC_SMPTE170M */:
                Kr = 0.299;
                Kb = 0.114;
                break;
            case 7 /* AVColorSpace.AVCOL_SPC_SMPTE240M */:
                Kr = 0.212;
                Kb = 0.087;
                break;
            case 8 /* AVColorSpace.AVCOL_SPC_YCOCG */: {
                return common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
                    // Y
                    0.25, 0.5, 0.25, 0.0,
                    // Cg
                    -0.25, 0.5, -0.25, chroma05,
                    // Co
                    0.5, 0.0, -0.5, chroma05,
                    0.0, 0.0, 0.0, 1.0
                ]);
            }
            // BT2020_CL is a special case.
            // Basically we return a matrix that transforms RYB values
            // to YUV values. (Note that the green component have been replaced
            // with the luminance.)
            case 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */: {
                Kr = 0.2627;
                Kb = 0.0593;
                return common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
                    // R
                    1.0, 0.0, 0.0, 0.0,
                    // Y
                    Kr, 1.0 - Kr - Kb, Kb, 0.0,
                    // B
                    0.0, 0.0, 1.0, 0.0,
                    0.0, 0.0, 0.0, 1.0
                ]);
            }
            case 9 /* AVColorSpace.AVCOL_SPC_BT2020_NCL */:
                Kr = 0.2627;
                Kb = 0.0593;
                break;
            case 11 /* AVColorSpace.AVCOL_SPC_SMPTE2085 */:
                return common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
                    // Y
                    0.0, 1.0, 0.0, 0.0,
                    // DX or DZ
                    0.0, -0.5,
                    0.493283,
                    0.5,
                    // DZ or DX
                    0.5, -0.991902 / 2.0, 0.0, 0.5,
                    0.0, 0.0, 0.0, 1.0,
                ]);
        }
        let Kg = 1.0 - Kr - Kb;
        let um = 0.5 / (1.0 - Kb);
        let vm = 0.5 / (1.0 - Kr);
        return common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
            // Y
            Kr, Kg, Kb, 0.0,
            // U
            um * -Kr, um * -Kg, um * (1.0 - Kb), 0.5,
            // V
            vm * (1.0 - Kr), vm * -Kg, vm * -Kb, 0.5,
            0.0, 0.0, 0.0, 1.0,
        ]);
    }
    getRangeAdjustMatrix(bitDepth) {
        switch (this.rangeId) {
            case 2 /* AVColorRange.AVCOL_RANGE_JPEG */:
                return new common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]();
            case 1 /* AVColorRange.AVCOL_RANGE_MPEG */:
                break;
        }
        // See ITU-T H.273 (2016), Section 8.3. The following is derived from
        // Equations 20-31.
        const shift = bitDepth - 8;
        const ay = 219 << shift;
        const c = (1 << bitDepth) - 1;
        const scaleY = c / ay;
        switch (this.matrixId) {
            case 0 /* AVColorSpace.AVCOL_SPC_RGB */:
            case 8 /* AVColorSpace.AVCOL_SPC_YCOCG */:
                return new common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]().setScale(new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([scaleY, scaleY, scaleY]))
                    .postTranslate(new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([-16.0 / 219.0, -16.0 / 219.0, -16.0 / 219.0]));
            case 1 /* AVColorSpace.AVCOL_SPC_BT709 */:
            case 4 /* AVColorSpace.AVCOL_SPC_FCC */:
            case 5 /* AVColorSpace.AVCOL_SPC_BT470BG */:
            case 6 /* AVColorSpace.AVCOL_SPC_SMPTE170M */:
            case 7 /* AVColorSpace.AVCOL_SPC_SMPTE240M */:
            case 9 /* AVColorSpace.AVCOL_SPC_BT2020_NCL */:
            case 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */:
            case 11 /* AVColorSpace.AVCOL_SPC_SMPTE2085 */:
            case 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */: {
                const aUV = 224 << shift;
                const scaleUV = c / aUV;
                const translateUV = (aUV - c) / (2.0 * aUV);
                return new common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]().setScale(new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([scaleY, scaleUV, scaleUV]))
                    .postTranslate(new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([-16.0 / 219.0, translateUV, translateUV]));
            }
        }
        return new common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]();
    }
    getTransferFunction_() {
        switch (this.transferId) {
            case 8 /* AVColorTransferCharacteristic.AVCOL_TRC_LINEAR */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFnLinear;
            case 4 /* AVColorTransferCharacteristic.AVCOL_TRC_GAMMA22 */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFn470SystemM;
            case 5 /* AVColorTransferCharacteristic.AVCOL_TRC_GAMMA28 */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFn470SystemBG;
            case 7 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE240M */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFnSMPTEST240;
            case 1 /* AVColorTransferCharacteristic.AVCOL_TRC_BT709 */:
            case 6 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE170M */:
            case 14 /* AVColorTransferCharacteristic.AVCOL_TRC_BT2020_10 */:
            case 15 /* AVColorTransferCharacteristic.AVCOL_TRC_BT2020_12 */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFnSRGB;
            case 17 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTEST428_1 */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFnSMPETST428_1;
            case 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */:
            case 12 /* AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG */:
            case 9 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG */:
            case 10 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG_SQRT */:
            case 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */:
            case 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */:
                return null;
        }
    }
    getTransferFunction(sdrWhiteLevel) {
        switch (this.transferId) {
            default:
                return this.getTransferFunction_();
        }
    }
    getInverseTransferFunction(sdrWhiteLevel) {
        const fn = this.getTransferFunction(sdrWhiteLevel);
        if (fn) {
            const fnInv = {
                a: 0,
                b: 0,
                c: 0,
                d: 0,
                e: 0,
                f: 0,
                g: 0
            };
            if (fn.a > 0 && fn.g > 0) {
                const aToG = Math.pow(fn.a, fn.g);
                fnInv.a = 1.0 / aToG;
                fnInv.b = -fn.e / aToG;
                fnInv.g = 1.0 / fn.g;
            }
            fnInv.d = fn.c * fn.d + fn.f;
            fnInv.e = -fn.b / fn.a;
            if (fn.c != 0) {
                fnInv.c = 1.0 / fn.c;
                fnInv.f = -fn.f / fn.c;
            }
            return fnInv;
        }
    }
    hasExtendedSkTransferFn() {
        return this.matrixId === 0 /* AVColorSpace.AVCOL_SPC_RGB */;
    }
    isValid() {
        return this.matrixId !== 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */
            && this.primaryId !== 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */
            && this.transferId !== 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */
            && this.rangeId !== 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */;
    }
    getColorSpacePrimaries() {
        const pri = _primaries__WEBPACK_IMPORTED_MODULE_3__.Invalid;
        switch (this.primaryId) {
            case 1 /* AVColorPrimaries.AVCOL_PRI_BT709 */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.Rec709;
            case 4 /* AVColorPrimaries.AVCOL_PRI_BT470M */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.Rec470SystemM;
            case 5 /* AVColorPrimaries.AVCOL_PRI_BT470BG */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.Rec470SystemBG;
            case 7 /* AVColorPrimaries.AVCOL_PRI_SMPTE240M */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.SMPTE_ST_240;
            case 8 /* AVColorPrimaries.AVCOL_PRI_FILM */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.GenericFilm;
            case 9 /* AVColorPrimaries.AVCOL_PRI_BT2020 */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.Rec2020;
            case 10 /* AVColorPrimaries.AVCOL_PRI_SMPTEST428_1 */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.SMPTE_ST_428_1;
            case 11 /* AVColorPrimaries.AVCOL_PRI_SMPTE431 */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.SMPTE_RP_431_2;
            case 12 /* AVColorPrimaries.AVCOL_PRI_SMPTE432 */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.SMPTE_EG_432_1;
        }
        return pri;
    }
    getPrimaryMatrix() {
        const pri = this.getColorSpacePrimaries();
        const toXYZD50 = _primaries__WEBPACK_IMPORTED_MODULE_3__.primariesToXYZD50(pri);
        return common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
            toXYZD50.rc(0, 0), toXYZD50.rc(0, 1), toXYZD50.rc(0, 2), 0,
            toXYZD50.rc(1, 0), toXYZD50.rc(1, 1), toXYZD50.rc(1, 2), 0,
            toXYZD50.rc(2, 0), toXYZD50.rc(2, 1), toXYZD50.rc(2, 2), 0,
            0, 0, 0, 1
        ]);
    }
}


/***/ }),

/***/ "./src/avrender/image/colorSpace/primaries.ts":
/*!****************************************************!*\
  !*** ./src/avrender/image/colorSpace/primaries.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GenericFilm: () => (/* binding */ GenericFilm),
/* harmony export */   Invalid: () => (/* binding */ Invalid),
/* harmony export */   Rec2020: () => (/* binding */ Rec2020),
/* harmony export */   Rec470SystemBG: () => (/* binding */ Rec470SystemBG),
/* harmony export */   Rec470SystemM: () => (/* binding */ Rec470SystemM),
/* harmony export */   Rec709: () => (/* binding */ Rec709),
/* harmony export */   SMPTE_EG_432_1: () => (/* binding */ SMPTE_EG_432_1),
/* harmony export */   SMPTE_RP_431_2: () => (/* binding */ SMPTE_RP_431_2),
/* harmony export */   SMPTE_ST_240: () => (/* binding */ SMPTE_ST_240),
/* harmony export */   SMPTE_ST_428_1: () => (/* binding */ SMPTE_ST_428_1),
/* harmony export */   primariesToXYZD50: () => (/* binding */ primariesToXYZD50)
/* harmony export */ });
/* unused harmony exports Rec601, ITU_T_H273_VALUE22, SRGB, P3, A98RGB, ProPhotoRGB, XYZD50, XYZD65, AppleGenericRGB, WideGamutColorSpin */
/* harmony import */ var common_math_Matrix3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/math/Matrix3 */ "./src/common/math/Matrix3.ts");
/* harmony import */ var common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/math/Vector3 */ "./src/common/math/Vector3.ts");
/* harmony import */ var common_math_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/math/matrix */ "./src/common/math/matrix.ts");
/* harmony import */ var common_math_vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/math/vector */ "./src/common/math/vector.ts");
/*
 * libmedia primary defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




// Rec. ITU-R BT.709-6, value 1.
const Rec709 = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06, 0.3127, 0.329];
// Rec. ITU-R BT.470-6 System M (historical), value 4.
const Rec470SystemM = [0.67, 0.33, 0.21, 0.71, 0.14, 0.08, 0.31, 0.316];
// Rec. ITU-R BT.470-6 System B, G (historical), value 5.
const Rec470SystemBG = [0.64, 0.33, 0.29, 0.60, 0.15, 0.06, 0.3127, 0.3290];
// Rec. ITU-R BT.601-7 525, value 6.
const Rec601 = [0.630, 0.340, 0.310, 0.595, 0.155, 0.070, 0.3127, 0.3290];
// SMPTE ST 240, value 7 (functionally the same as value 6).
const SMPTE_ST_240 = Rec601;
// Generic film (colour filters using Illuminant C), value 8.
const GenericFilm = [0.681, 0.319, 0.243, 0.692, 0.145, 0.049, 0.310, 0.316];
// Rec. ITU-R BT.2020-2, value 9.
const Rec2020 = [0.708, 0.292, 0.170, 0.797, 0.131, 0.046, 0.3127, 0.3290];
// SMPTE ST 428-1, value 10.
const SMPTE_ST_428_1 = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.3333333333333333, 0.3333333333333333];
// SMPTE RP 431-2, value 11.
const SMPTE_RP_431_2 = [0.680, 0.320, 0.265, 0.690, 0.150, 0.060, 0.314, 0.351];
// SMPTE EG 432-1, value 12.
const SMPTE_EG_432_1 = [0.680, 0.320, 0.265, 0.690, 0.150, 0.060, 0.3127, 0.3290];
// No corresponding industry specification identified, value 22.
// This is sometimes referred to as EBU 3213-E, but that document doesn't
// specify these values.
const ITU_T_H273_VALUE22 = [0.630, 0.340, 0.295, 0.605, 0.155, 0.077, 0.3127, 0.3290];
// CSS Color Level 4 predefined and xyz color spaces.
// 'srgb'
const SRGB = Rec709;
// 'display-p3' (and also 'p3' as a color gamut).
const P3 = SMPTE_EG_432_1;
// 'a98-rgb'
const A98RGB = [0.64, 0.33, 0.21, 0.71, 0.15, 0.06, 0.3127, 0.3290];
// 'prophoto-rgb'
const ProPhotoRGB = [0.7347, 0.2653, 0.1596, 0.8404, 0.0366, 0.0001, 0.34567, 0.35850];
// 'rec2020' (as both a predefined color space and color gamut).
// The value kRec2020 is already defined above.
// 'xyzd50'
const XYZD50 = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.34567, 0.35850];
// 'xyz' and 'xyzd65'
const XYZD65 = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.3127, 0.3290];
// //////////////////////////////////////////////////////////////////////////////
// Additional helper color primaries.
// Invalid primaries, initialized to zero.
const Invalid = [0, 0, 0, 0, 0, 0, 0, 0];
// The GenericRGB space on macOS.
const AppleGenericRGB = [0.63002, 0.34000, 0.29505, 0.60498, 0.15501, 0.07701, 0.3127, 0.3290];
// Primaries where the colors are rotated and the gamut is huge. Good for
// testing.
const WideGamutColorSpin = [0.01, 0.98, 0.01, 0.01, 0.98, 0.01, 0.3127, 0.3290];
function adaptToXYZ50(wx, wy) {
    const wXYZ = new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([wx / wy, 1, (1 - wx - wy) / wy]);
    const wXYZD50 = new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([0.96422, 1.0, 0.82521]);
    const xyzToLms = common_math_Matrix3__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
        0.8951, 0.2664, -0.1614,
        -0.7502, 1.7135, 0.0367,
        0.0389, -0.0685, 1.0296
    ]);
    const lmsToXyz = common_math_Matrix3__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
        0.9869929, -0.1470543, 0.1599627,
        0.4323053, 0.5183603, 0.0492912,
        -0.0085287, 0.0400428, 0.9684867
    ]);
    const srcCone = (0,common_math_vector__WEBPACK_IMPORTED_MODULE_3__.mvMul)(xyzToLms, wXYZ);
    const dstCone = (0,common_math_vector__WEBPACK_IMPORTED_MODULE_3__.mvMul)(xyzToLms, wXYZD50);
    let toXYZD50 = new common_math_Matrix3__WEBPACK_IMPORTED_MODULE_0__["default"]([
        dstCone.x / srcCone.x, 0, 0,
        0, dstCone.y / srcCone.y, 0,
        0, 0, dstCone.z / srcCone.z
    ]);
    toXYZD50 = (0,common_math_matrix__WEBPACK_IMPORTED_MODULE_2__.concat3x3)(toXYZD50, xyzToLms);
    toXYZD50 = (0,common_math_matrix__WEBPACK_IMPORTED_MODULE_2__.concat3x3)(lmsToXyz, toXYZD50);
    return toXYZD50;
}
function primariesToXYZD50(pri) {
    const matrix3 = common_math_Matrix3__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
        pri[0], pri[2], pri[4],
        pri[1], pri[3], pri[5],
        1 - pri[0] - pri[1], 1 - pri[2] - pri[3], 1 - pri[4] - pri[5]
    ]);
    const matrix3Inv = matrix3.copy().invert();
    const wXYZ = new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([pri[6] / pri[7], 1, (1 - pri[6] - pri[7]) / pri[7]]);
    const XYZ = (0,common_math_vector__WEBPACK_IMPORTED_MODULE_3__.mvMul)(matrix3Inv, wXYZ);
    let toXYZ = new common_math_Matrix3__WEBPACK_IMPORTED_MODULE_0__["default"]([
        XYZ.x, 0, 0,
        0, XYZ.y, 0,
        0, 0, XYZ.z
    ]);
    toXYZ = (0,common_math_matrix__WEBPACK_IMPORTED_MODULE_2__.concat3x3)(matrix3, toXYZ);
    const dxToD50 = adaptToXYZ50(pri[6], pri[7]);
    return (0,common_math_matrix__WEBPACK_IMPORTED_MODULE_2__.concat3x3)(dxToD50, toXYZ);
}


/***/ }),

/***/ "./src/avrender/image/colorSpace/transferFns.ts":
/*!******************************************************!*\
  !*** ./src/avrender/image/colorSpace/transferFns.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TransferFn470SystemBG: () => (/* binding */ TransferFn470SystemBG),
/* harmony export */   TransferFn470SystemM: () => (/* binding */ TransferFn470SystemM),
/* harmony export */   TransferFnLinear: () => (/* binding */ TransferFnLinear),
/* harmony export */   TransferFnSMPETST428_1: () => (/* binding */ TransferFnSMPETST428_1),
/* harmony export */   TransferFnSMPTEST240: () => (/* binding */ TransferFnSMPTEST240),
/* harmony export */   TransferFnSRGB: () => (/* binding */ TransferFnSRGB)
/* harmony export */ });
/* unused harmony exports TransferFnRec709, TransferFn2Dot2, TransferFnRec2020, TransferFnPQ, TransferFnHLG */
/*
 * libmedia transfer defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const TransferFnRec709 = {
    g: 2.222222222222, a: 0.909672415686, b: 0.090327584314, c: 0.222222222222, d: 0.081242858299, e: 0.0, f: 0.0
};
const TransferFn470SystemM = {
    g: 2.2, a: 1.0, b: 0.0, c: 0.0, d: 0.0, e: 0.0, f: 0.0
};
const TransferFn470SystemBG = {
    g: 2.8, a: 1.0, b: 0.0, c: 0.0, d: 0.0, e: 0.0, f: 0.0
};
const TransferFnSMPTEST240 = {
    g: 2.222222222222, a: 0.899626676224, b: 0.100373323776, c: 0.25, d: 0.091286342118, e: 0.0, f: 0.0
};
const TransferFnLinear = {
    g: 1.0, a: 1.0, b: 0.0, c: 0.0, d: 0.0, e: 0.0, f: 0.0
};
const TransferFnSRGB = {
    g: 2.4, a: 0.9478672985781991, b: 0.05213270142180095, c: 0.07739938080495357, d: 0.04045, e: 0.0, f: 0.0
};
// eslint-disable-next-line camelcase
const TransferFnSMPETST428_1 = {
    g: 2.6, a: 1.034080527699, b: 0.0, c: 0.0, d: 0.0, e: 0.0, f: 0.0
};
const TransferFn2Dot2 = {
    g: 2.2, a: 1.0, b: 0.0, c: 0.0, d: 0.0, e: 0.0, f: 0.0
};
const TransferFnRec2020 = {
    g: 2.22222, a: 0.909672, b: 0.0903276, c: 0.222222, d: 0.0812429, e: 0.0, f: 0.0
};
const TransferFnPQ = {
    g: -2.0, a: -107 / 128.0, b: 1.0, c: 0.012683313515655966, d: 18.8515625, e: -2392 / 128, f: 6.277394636015326
};
const TransferFnHLG = {
    g: -3.0, a: 2.0, b: 2.0, c: 5.591816309728916, d: 0.28466892, e: 0.55991073, f: 0.0
};


/***/ }),

/***/ "./src/avrender/image/colorTransform/colorTransformHLGOOTF.ts":
/*!********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/colorTransformHLGOOTF.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeHLGToneMapConstants: () => (/* binding */ computeHLGToneMapConstants),
/* harmony export */   "default": () => (/* binding */ colorTransformHLGOOTF)
/* harmony export */ });
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./options */ "./src/avrender/image/colorTransform/options.ts");
/*
 * libmedia hlg ootf
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

// The luminance vector in rec2020 linear space.
const kLr = 0.2627;
const kLg = 0.6780;
const kLb = 0.0593;
function computeHLGToneMapConstants(options) {
    options.metadata.hlgDstMaxLuminanceRelative = options.dstMaxLuminanceRelative;
    const dstMaxLuminanceNits = options.dstSdrMaxLuminanceNits * options.dstMaxLuminanceRelative;
    options.metadata.hlgOOTFGammaMinusOne = 1.2 + 0.42 * Math.log10(dstMaxLuminanceNits / _options__WEBPACK_IMPORTED_MODULE_0__.HLGRefMaxLumNits) / Math.log10(10.0) - 1.0;
}
function colorTransformHLGOOTF(options) {
    if (options.type === 0 /* GLType.kWebGL */) {
        return `
      {
        vec4 luma_vec = vec4(${kLr}, ${kLg}, ${kLb}, 0.0);
        float L = dot(color, luma_vec);
        if (L > 0.0) {
          color.r *= pow(L, hlg_ootf_gamma_minus_one);
          color.g *= pow(L, hlg_ootf_gamma_minus_one);
          color.b *= pow(L, hlg_ootf_gamma_minus_one);
          color.r *= hlg_dst_max_luminance_relative;
          color.g *= hlg_dst_max_luminance_relative;
          color.b *= hlg_dst_max_luminance_relative;
        }
      }
    `;
    }
    else if (options.type === 1 /* GLType.kWebGPU */) {
        return `
      {
        let luma_vec: vec4<f32> = vec4(${kLr}, ${kLg}, ${kLb}, 0.0);
        let L: f32 = dot(color, luma_vec);
        if (L > 0.0) {
          color.r *= pow(L, hlg_ootf_gamma_minus_one);
          color.g *= pow(L, hlg_ootf_gamma_minus_one);
          color.b *= pow(L, hlg_ootf_gamma_minus_one);
          color.r *= hlg_dst_max_luminance_relative;
          color.g *= hlg_dst_max_luminance_relative;
          color.b *= hlg_dst_max_luminance_relative;
        }
      }
    `;
    }
    return '';
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/colorTransformMatrix.ts":
/*!*******************************************************************!*\
  !*** ./src/avrender/image/colorTransform/colorTransformMatrix.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ colorTransformMatrix)
/* harmony export */ });
/*
 * libmedia color transform matrix
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function colorTransformMatrix(matrix, options) {
    let mat4String = '';
    let vec4String = '';
    if (options.type === 0 /* GLType.kWebGL */) {
        mat4String = 'mat4';
        vec4String = 'vec4';
    }
    else if (options.type === 1 /* GLType.kWebGPU */) {
        mat4String = 'mat4x4';
        vec4String = 'vec4';
    }
    if (!mat4String || !vec4String) {
        return '';
    }
    let source = `
      color = ${mat4String}(
        ${matrix.rc(0, 0)}, ${matrix.rc(1, 0)}, ${matrix.rc(2, 0)}, 0,
        ${matrix.rc(0, 1)}, ${matrix.rc(1, 1)}, ${matrix.rc(2, 1)}, 0,
        ${matrix.rc(0, 2)}, ${matrix.rc(1, 2)}, ${matrix.rc(2, 2)}, 0,
        0, 0, 0, 1
      ) * color;
    `;
    if (matrix.rc(0, 3) !== 0 || matrix.rc(1, 3) !== 0 || matrix.rc(2, 3) !== 0) {
        source += `
        color += ${vec4String}(${matrix.rc(0, 3)}, ${matrix.rc(1, 3)}, ${matrix.rc(2, 3)}, 0);
      `;
    }
    return source;
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/colorTransformSdrToDstNitsRelative.ts":
/*!*********************************************************************************!*\
  !*** ./src/avrender/image/colorTransform/colorTransformSdrToDstNitsRelative.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeSdrRelativeToNitsFactor: () => (/* binding */ computeSdrRelativeToNitsFactor),
/* harmony export */   "default": () => (/* binding */ colorTransformSdrToDstNitsRelative)
/* harmony export */ });
/*
 * libmedia color transform sdr to dst nits relative
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function computeSdrRelativeToNitsFactor(unityNits, options) {
    options.metadata.sdrRelativeToNitsFactor = options.dstSdrMaxLuminanceNits / unityNits;
}
function colorTransformSdrToDstNitsRelative(options) {
    return `
    color.r *= sdr_relative_to_nits_factor;
    color.g *= sdr_relative_to_nits_factor;
    color.b *= sdr_relative_to_nits_factor;
 `;
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/colorTransformSrcNitsToSdrRelative.ts":
/*!*********************************************************************************!*\
  !*** ./src/avrender/image/colorTransform/colorTransformSrcNitsToSdrRelative.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeNitsToSdrRelativeFactor: () => (/* binding */ computeNitsToSdrRelativeFactor),
/* harmony export */   "default": () => (/* binding */ colorTransformSrcNitsToSdrRelative)
/* harmony export */ });
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./options */ "./src/avrender/image/colorTransform/options.ts");
/*
 * libmedia color transform src nits to sdr relative
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function computeNitsToSdrRelativeFactor(unityNits, useSrcSdrWhite, options) {
    let sdrWhiteNits = options.dstSdrMaxLuminanceNits;
    if (useSrcSdrWhite) {
        sdrWhiteNits = _options__WEBPACK_IMPORTED_MODULE_0__.DefaultSDRWhiteLevel;
        if (options.ndwl) {
            sdrWhiteNits = options.ndwl;
        }
    }
    options.metadata.nitsToSdrRelativeFactor = unityNits / sdrWhiteNits;
}
function colorTransformSrcNitsToSdrRelative(options) {
    return `
    color.r *= nits_to_sdr_relative_factor;
    color.g *= nits_to_sdr_relative_factor;
    color.b *= nits_to_sdr_relative_factor;
  `;
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/colorTransformToneMapInRec2020Linear.ts":
/*!***********************************************************************************!*\
  !*** ./src/avrender/image/colorTransform/colorTransformToneMapInRec2020Linear.ts ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeTonemapAB: () => (/* binding */ computeTonemapAB),
/* harmony export */   "default": () => (/* binding */ colorTransformToneMapInRec2020Linear)
/* harmony export */ });
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./options */ "./src/avrender/image/colorTransform/options.ts");
/*
 * libmedia colorTransform tone map in rec2020 linear
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function computeSrcMaxLumRelative(src, options) {
    let srcMaxLumNits = _options__WEBPACK_IMPORTED_MODULE_0__.HLGRefMaxLumNits;
    if (src.getTransferId() !== 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */) {
        if (options.maxContentLightLevel > 0) {
            srcMaxLumNits = options.maxContentLightLevel;
        }
    }
    return srcMaxLumNits / options.dstSdrMaxLuminanceNits;
}
function computeTonemapAB(src, options) {
    const srcMaxLumRelative = computeSrcMaxLumRelative(src, options);
    if (srcMaxLumRelative > options.dstMaxLuminanceRelative) {
        options.metadata.pqTonemapA = options.dstMaxLuminanceRelative /
            (srcMaxLumRelative * srcMaxLumRelative);
        options.metadata.pqTonemapB = 1.0 / options.dstMaxLuminanceRelative;
    }
    else {
        options.metadata.pqTonemapA = 0;
        options.metadata.pqTonemapB = 0;
    }
}
function colorTransformToneMapInRec2020Linear(options) {
    return `
    {
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let maximum: f32' : 'float maximum'} = max(color.r, max(color.g, color.b));
      if (maximum > 0.0) {
        color.r *= (1.0 + pq_tonemap_a * maximum) / (1.0 + pq_tonemap_b * maximum);
        color.g *= (1.0 + pq_tonemap_a * maximum) / (1.0 + pq_tonemap_b * maximum);
        color.b *= (1.0 + pq_tonemap_a * maximum) / (1.0 + pq_tonemap_b * maximum);
      }
    }
 `;
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/function/toFloatString.ts":
/*!*********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/function/toFloatString.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toFloatString)
/* harmony export */ });
/*
 * libmedia to float string
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function toFloatString(v) {
    if (v === (v >>> 0)) {
        return `${v}.0`;
    }
    return v.toString();
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/generateSteps.ts":
/*!************************************************************!*\
  !*** ./src/avrender/image/colorTransform/generateSteps.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ generateSteps)
/* harmony export */ });
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./options */ "./src/avrender/image/colorTransform/options.ts");
/* harmony import */ var _colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./colorTransformMatrix */ "./src/avrender/image/colorTransform/colorTransformMatrix.ts");
/* harmony import */ var _transferFn_hlgInvOETF__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transferFn/hlgInvOETF */ "./src/avrender/image/colorTransform/transferFn/hlgInvOETF.ts");
/* harmony import */ var _transferFn_pq2Linear__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transferFn/pq2Linear */ "./src/avrender/image/colorTransform/transferFn/pq2Linear.ts");
/* harmony import */ var _transferFn_transferFn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transferFn/transferFn */ "./src/avrender/image/colorTransform/transferFn/transferFn.ts");
/* harmony import */ var _transferFn_toLinear__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transferFn/toLinear */ "./src/avrender/image/colorTransform/transferFn/toLinear.ts");
/* harmony import */ var _colorTransformHLGOOTF__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./colorTransformHLGOOTF */ "./src/avrender/image/colorTransform/colorTransformHLGOOTF.ts");
/* harmony import */ var _colorTransformSrcNitsToSdrRelative__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./colorTransformSrcNitsToSdrRelative */ "./src/avrender/image/colorTransform/colorTransformSrcNitsToSdrRelative.ts");
/* harmony import */ var _colorTransformToneMapInRec2020Linear__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./colorTransformToneMapInRec2020Linear */ "./src/avrender/image/colorTransform/colorTransformToneMapInRec2020Linear.ts");
/* harmony import */ var _colorTransformSdrToDstNitsRelative__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./colorTransformSdrToDstNitsRelative */ "./src/avrender/image/colorTransform/colorTransformSdrToDstNitsRelative.ts");
/* harmony import */ var _transferFn_hlgOETF__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./transferFn/hlgOETF */ "./src/avrender/image/colorTransform/transferFn/hlgOETF.ts");
/* harmony import */ var _transferFn_pqFromLinear__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transferFn/pqFromLinear */ "./src/avrender/image/colorTransform/transferFn/pqFromLinear.ts");
/* harmony import */ var _transferFn_fromLinear__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./transferFn/fromLinear */ "./src/avrender/image/colorTransform/transferFn/fromLinear.ts");
/*
 * libmedia generate fragment steps
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */














function generateSteps(src, dst, options) {
    const steps = [];
    const srcMatrixIsIdentityOrYcgco = src.getMatrixId() === 8 /* AVColorSpace.AVCOL_SPC_YCOCG */;
    // 1. limited range 转 full range
    const srcRangeAdjustStep = (0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(src.getRangeAdjustMatrix(options.bitDepth), options);
    if (!srcMatrixIsIdentityOrYcgco) {
        steps.push(srcRangeAdjustStep);
    }
    if (src.getMatrixId() === 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */) {
        // BT2020 CL is a special case.
        // not to do
    }
    else {
        // 2. 反变换 ColorSpace Matrix，YCbCr 转 RGB
        steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(src.getTransferMatrix(options.bitDepth).invert(), options));
    }
    if (srcMatrixIsIdentityOrYcgco) {
        steps.push(srcRangeAdjustStep);
    }
    if (dst.isValid()) {
        if ( true && src.isHDR()) {
            switch (src.getTransferId()) {
                // 3. 如果是 HLG 视频，应用 HLG 反向 OETF
                case 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */:
                    steps.push((0,_transferFn_hlgInvOETF__WEBPACK_IMPORTED_MODULE_3__["default"])(options));
                    break;
                // 3. 如果是 PQ 视频，将 PQ 曲线转线性曲线。
                case 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */:
                    steps.push((0,_transferFn_pq2Linear__WEBPACK_IMPORTED_MODULE_4__["default"])(options));
                    break;
                default:
                    const fn = src.getTransferFunction();
                    if (fn) {
                        steps.push((0,_transferFn_transferFn__WEBPACK_IMPORTED_MODULE_5__["default"])(fn, src.hasExtendedSkTransferFn(), options));
                    }
                    else {
                        steps.push((0,_transferFn_toLinear__WEBPACK_IMPORTED_MODULE_6__["default"])(src.getTransferId(), options));
                    }
            }
            if (src.getMatrixId() === 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */) {
                steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(src.getTransferMatrix(options.bitDepth).invert(), options));
            }
            // 4. RGB 空间转 XYZ 空间
            steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(src.getPrimaryMatrix(), options));
            const rec2020Linear = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_0__["default"](0 /* AVColorSpace.AVCOL_SPC_RGB */, 9 /* AVColorPrimaries.AVCOL_PRI_BT2020 */, 8 /* AVColorTransferCharacteristic.AVCOL_TRC_LINEAR */, 2 /* AVColorRange.AVCOL_RANGE_JPEG */);
            switch (src.getTransferId()) {
                // HLG
                case 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */:
                    if (options.toneMapPQAndHlgToDst) {
                        (0,_colorTransformHLGOOTF__WEBPACK_IMPORTED_MODULE_7__.computeHLGToneMapConstants)(options);
                        steps.push((0,_colorTransformHLGOOTF__WEBPACK_IMPORTED_MODULE_7__["default"])(options));
                    }
                    else {
                        (0,_colorTransformSrcNitsToSdrRelative__WEBPACK_IMPORTED_MODULE_8__.computeNitsToSdrRelativeFactor)(12.0 / _options__WEBPACK_IMPORTED_MODULE_1__.DefaultSDRWhiteLevel, false, options);
                        steps.push((0,_colorTransformSrcNitsToSdrRelative__WEBPACK_IMPORTED_MODULE_8__["default"])(options));
                    }
                    break;
                case 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */:
                    (0,_colorTransformSrcNitsToSdrRelative__WEBPACK_IMPORTED_MODULE_8__.computeNitsToSdrRelativeFactor)(_options__WEBPACK_IMPORTED_MODULE_1__.PQRefMaxLumNits, true, options);
                    steps.push((0,_colorTransformSrcNitsToSdrRelative__WEBPACK_IMPORTED_MODULE_8__["default"])(options));
                    if (options.toneMapPQAndHlgToDst) {
                        // 5. XYZ 转 Rec2020。
                        steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(rec2020Linear.getPrimaryMatrix().invert(), options));
                        (0,_colorTransformToneMapInRec2020Linear__WEBPACK_IMPORTED_MODULE_9__.computeTonemapAB)(src, options);
                        // 6. 基于显示器最高亮度 + UI 白点亮度，进行 Tone Mapping
                        steps.push((0,_colorTransformToneMapInRec2020Linear__WEBPACK_IMPORTED_MODULE_9__["default"])(options));
                        // 7. Rec2020 转为 XYZ
                        steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(rec2020Linear.getPrimaryMatrix(), options));
                    }
                    break;
                default:
                    break;
            }
            // 8. XYZ 转 RGB
            steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(dst.getPrimaryMatrix().invert(), options));
            if (dst.getMatrixId() === 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */) {
                steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(dst.getTransferMatrix(options.bitDepth), options));
            }
            switch (dst.getTransferId()) {
                // 9. 如果是 HLG 视频，应用 HLG 转 OETF
                case 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */:
                    (0,_colorTransformSdrToDstNitsRelative__WEBPACK_IMPORTED_MODULE_10__.computeSdrRelativeToNitsFactor)(_options__WEBPACK_IMPORTED_MODULE_1__.DefaultSDRWhiteLevel, options);
                    steps.push((0,_colorTransformSdrToDstNitsRelative__WEBPACK_IMPORTED_MODULE_10__["default"])(options));
                    steps.push((0,_transferFn_hlgOETF__WEBPACK_IMPORTED_MODULE_11__["default"])(options));
                    break;
                // 9 如果是 PQ 视频，将线性曲线转 PQ 曲线。
                case 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */:
                    (0,_colorTransformSdrToDstNitsRelative__WEBPACK_IMPORTED_MODULE_10__.computeSdrRelativeToNitsFactor)(_options__WEBPACK_IMPORTED_MODULE_1__.PQRefMaxLumNits, options);
                    steps.push((0,_colorTransformSdrToDstNitsRelative__WEBPACK_IMPORTED_MODULE_10__["default"])(options));
                    steps.push((0,_transferFn_pqFromLinear__WEBPACK_IMPORTED_MODULE_12__["default"])(options));
                default:
                    const fn = dst.getInverseTransferFunction();
                    if (fn) {
                        steps.push((0,_transferFn_transferFn__WEBPACK_IMPORTED_MODULE_5__["default"])(fn, src.hasExtendedSkTransferFn(), options));
                    }
                    else {
                        steps.push((0,_transferFn_fromLinear__WEBPACK_IMPORTED_MODULE_13__["default"])(src.getTransferId(), options));
                    }
                    break;
            }
        }
        /**
         * 下面的步骤是把 RGB 转到目标颜色空间，判断是否需要
         * 片段着色器输出的颜色应该是 RGB 非线性空间？（此处存疑，未找到相关资料，但找到的其他类似项目均未转换为线性空间，显示器会根据输出做相应的电光转换？） 全色域颜色
         * 但如果后续需要处理颜色（如混合、插值），需要将非线性空间转换为线性空间，在线性空间中处理
         */
        if (!options.outputRGB) {
            const dstMatrixIsIdentityOrYcgco = dst.getMatrixId() === 8 /* AVColorSpace.AVCOL_SPC_YCOCG */;
            // 10. Range 反变换
            const dstRangeAdjustStep = (0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(dst.getRangeAdjustMatrix(options.bitDepth).invert(), options);
            if (dstMatrixIsIdentityOrYcgco) {
                steps.push(dstRangeAdjustStep);
            }
            if (dst.getMatrixId() === 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */) {
                // not to do
            }
            else {
                steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(dst.getTransferMatrix(options.bitDepth), options));
            }
            if (!dstMatrixIsIdentityOrYcgco) {
                steps.push(dstRangeAdjustStep);
            }
        }
    }
    return steps;
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/options.ts":
/*!******************************************************!*\
  !*** ./src/avrender/image/colorTransform/options.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultSDRWhiteLevel: () => (/* binding */ DefaultSDRWhiteLevel),
/* harmony export */   HLGRefMaxLumNits: () => (/* binding */ HLGRefMaxLumNits),
/* harmony export */   PQRefMaxLumNits: () => (/* binding */ PQRefMaxLumNits)
/* harmony export */ });
/*
 * libmedia ColorTransformOptions defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const DefaultSDRWhiteLevel = 203.0;
// The maximum brightness of the reference display for HLG computations.
const HLGRefMaxLumNits = 1000.0;
// The maximum reference brightness of a PQ signal.
const PQRefMaxLumNits = 10000.0;


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts":
/*!********************************************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ colorTransformPerChannelTransferFn)
/* harmony export */ });
/*
 * libmedia colorTransformPerChannelTransferFn
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function colorTransformPerChannelTransferFn(fn, extended, options) {
    if (extended) {
        return `
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = abs(color.r);
        ${fn()}
        color.r = sign(color.r) * v;
      }
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = abs(color.g);
        ${fn()}
        color.g = sign(color.g) * v;
      }
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = abs(color.b);
        ${fn()}
        color.b = sign(color.b) * v;
      }
    `;
    }
    else {
        return `
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = color.r;
        ${fn()}
        color.r = v;
      }
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = color.g;
        ${fn()}
        color.g = v;
      }
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = color.b;
        ${fn()}
        color.b = v;
      }
    `;
    }
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/fromLinear.ts":
/*!********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/fromLinear.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fromLinear)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia linear oetf
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function fromLinear(transferId, options) {
    function fn() {
        switch (transferId) {
            case 9 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG */:
                return `
          if (v < 0.0) {
            v = 0.0;
          }
          else {
            v =  1.0 + log(v) / log(10.0) / 2.0;
          }
        `;
            case 10 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG_SQRT */:
                return `
          if (v < sqrt(10.0) / 1000.0)
            v = 0.0;
          }
          else {
            v = 1.0 + log(v) / log(10.0) / 2.5;
          }
        `;
            case 11 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4 */:
                return `
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 1.099296826809442;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let b: f32' : 'float b'}= 0.018053968510807;
          if (v < -b) {
            v = -a * pow(-v, 0.45) + (a - 1.0);
          }
          else if (v <= b) {
            v = 4.5 * v;
          }
          else {
            v = a * pow(v, 0.45) - (a - 1.0);
          }
        `;
            case 12 /* AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG */:
                return `
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 1.099;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let b: f32' : 'float b'} = 0.018;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let l: f32' : 'float l'} = 0.0045;

          if (v < -l) {
            v = -(a * pow(-4.0 * v, 0.45) + (a - 1.0)) / 4.0;
          }
          else if (v <= b) {
            v = 4.5 * v;
          }
          else {
            v = a * pow(v, 0.45) - (a - 1.0);
          }
        `;
            default:
                return '';
        }
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/hlgInvOETF.ts":
/*!********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/hlgInvOETF.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hlgInvOETF)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia hlg oetf
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function hlgInvOETF(options) {
    function fn() {
        let source = `
      v = max(0.0, v);
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 0.17883277f;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let b: f32' : 'float b'} = 0.28466892f;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c: f32' : 'float c'} = 0.55991073f;
      if (v <= 0.5) {
        v = v * v + 4.0;
      }
      else {
        v = exp((v - c) / a) + b;
      }
      v = v / 12.0;
    `;
        return source;
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/hlgOETF.ts":
/*!*****************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/hlgOETF.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hlgOETF)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia hlg oetf
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function hlgOETF(options) {
    function fn() {
        let source = `
      v = max(0.0, v);
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 0.17883277f;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let b: f32' : 'float b'} = 0.28466892f;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c: f32' : 'float c'} = 0.55991073f;
      if (v <= 1.0) {
        v = 0.5 * sqrt(v);
      }
      else {
        v = a * log(v - b) + c;
      }
    `;
        return source;
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/pq2Linear.ts":
/*!*******************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/pq2Linear.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pq2Linear)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia pq eotf
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function pq2Linear(options) {
    function fn() {
        let source = `
      v = max(0.0, v);
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let m1: f32' : 'float m1'} = (2610.0 / 4096.0) / 4.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let m2: f32' : 'float m2'} = (2523.0 / 4096.0) * 128.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c1: f32' : 'float c1'} = 3424.0 / 4096.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c2: f32' : 'float c2'} = (2413.0 / 4096.0) * 32.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c3: f32' : 'float c3'} = (2392.0 / 4096.0) * 32.0;
      
      ${options.type === 0 /* GLType.kWebGL */ ? `
        #ifdef GL_FRAGMENT_PRECISION_HIGH
        highp float v2 = v;
        #else
        float v2 = v;
        #endif
      ` : 'var v2: f32 = v;'}
  
      v2 = pow(max(pow(v2, 1.0 / m2) - c1, 0.0) / (c2 - c3 * pow(v2, 1.0 / m2)), 1.0 / m1);
      v = v2;
    `;
        return source;
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/pqFromLinear.ts":
/*!**********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/pqFromLinear.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pqFromLinear)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia pq oetf
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function pqFromLinear(options) {
    function fn() {
        let source = `
      v = max(0.0, v);
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let m1: f32' : 'float m1'} = (2610.0 / 4096.0) / 4.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let m2: f32' : 'float m2'} = (2523.0 / 4096.0) * 128.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c1: f32' : 'float c1'} = 3424.0 / 4096.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c2: f32' : 'float c2'} = (2413.0 / 4096.0) * 32.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c3: f32' : 'float c3'} = (2392.0 / 4096.0) * 32.0;
      v =  pow((c1 + c2 * pow(v, m1)) / (1.0 + c3 * pow(v, m1)), m2);
    `;
        return source;
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/toLinear.ts":
/*!******************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/toLinear.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toLinear)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia linear eotf
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function toLinear(transferId, options) {
    function fn() {
        switch (transferId) {
            case 9 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG */:
                return `
          if (v < 0.0) {
            v = 0.0;
          }
          else {
            v = pow(10.0, (v - 1.0) * 2.0);
          }
        `;
            case 10 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG_SQRT */:
                return `
          if (v < 0.0) {
            v = 0.0;
          }
          else {
            v = pow(10.0, (v - 1.0) * 2.5);
          }
        `;
            case 11 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4 */:
                return `
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 1.099296826809442;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let from_linear_neg_a: f32' : 'float from_linear_neg_a'} = -1.047844;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let from_linear_b: f32' : 'float from_linear_b'} = 0.081243;
          if (v < from_linear_neg_a) {
            v = -pow((a - 1.0 - v) / a, 1.0 / 0.45);
          }
          else if (v <= from_linear_b) {
            v = v / 4.5;
          }
          else {
            v = pow((v + a - 1.0) / a, 1.0 / 0.45);
          }
        `;
            case 12 /* AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG */:
                return `
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 1.099;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let from_linear_neg_l: f32' : 'float from_linear_neg_l'} = -0.020250;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let from_linear_b: f32' : 'float from_linear_b'} = 0.081000;
          if (v < from_linear_neg_l) {
            v = -pow((1.0 - a - v * 4.0) / a, 1.0 / 0.45) / 4.0;
          }
          else if (v <= from_linear_b) {
            v = v / 4.5;
          }
          else {
            v = pow((v + a - 1.0) / a, 1.0 / 0.45);
          }
        `;
            default:
                return '';
        }
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/transferFn.ts":
/*!********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/transferFn.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ transferFn)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/* harmony import */ var _function_toFloatString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/toFloatString */ "./src/avrender/image/colorTransform/function/toFloatString.ts");
/*
 * libmedia transfer fn
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function transferFn(tfn, extended, options) {
    function fn() {
        let epsilon = 0.0009765625;
        let linear = 'v';
        if (Math.abs(tfn.c - 1.0) > epsilon) {
            linear = `${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_1__["default"])(tfn.c)} * ${linear}`;
        }
        if (Math.abs(tfn.f) > epsilon) {
            linear = `${linear} + ${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_1__["default"])(tfn.f)}`;
        }
        let nonlinear = 'v';
        if (Math.abs(tfn.a = 1.0) > epsilon) {
            nonlinear = `${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_1__["default"])(tfn.a)} * ${nonlinear}`;
        }
        if (Math.abs(tfn.b) > epsilon) {
            nonlinear = `${nonlinear} + ${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_1__["default"])(tfn.b)}`;
        }
        if (Math.abs(tfn.g - 1.0) > epsilon) {
            nonlinear = `pow(${nonlinear}, ${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_1__["default"])(tfn.g)})`;
        }
        if (Math.abs(tfn.e) > epsilon) {
            nonlinear = `${nonlinear} + ${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_1__["default"])(tfn.e)}`;
        }
        let source = `
      if (v < ${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_1__["default"])(tfn.d)}) {
        v = ${linear};
      }
      else {
        v = ${nonlinear};
      }
    `;
        return source;
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/function/flipVertex.ts":
/*!***************************************************!*\
  !*** ./src/avrender/image/function/flipVertex.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ flipVertex)
/* harmony export */ });
/*
 * libmedia flip vertex
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function flipVertex(vertex, flipHorizontal, flipVertical) {
    if (flipHorizontal) {
        let x = vertex[3];
        let y = vertex[4];
        vertex[3] = vertex[17];
        vertex[4] = vertex[18];
        vertex[17] = x;
        vertex[18] = y;
        x = vertex[10];
        y = vertex[11];
        vertex[10] = vertex[24];
        vertex[11] = vertex[25];
        vertex[24] = x;
        vertex[25] = y;
    }
    if (flipVertical) {
        let x = vertex[3];
        let y = vertex[4];
        vertex[3] = vertex[10];
        vertex[4] = vertex[11];
        vertex[10] = x;
        vertex[11] = y;
        x = vertex[17];
        y = vertex[18];
        vertex[17] = vertex[24];
        vertex[18] = vertex[25];
        vertex[24] = x;
        vertex[25] = y;
    }
}


/***/ }),

/***/ "./src/avrender/image/struct/HdrMetadata.ts":
/*!**************************************************!*\
  !*** ./src/avrender/image/struct/HdrMetadata.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HdrMetadata)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia HdrMetadata defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class HdrMetadata {
    offset;
    multiplier;
    pqTonemapA;
    pqTonemapB;
    hlgOOTFGammaMinusOne;
    hlgDstMaxLuminanceRelative;
    nitsToSdrRelativeFactor;
    sdrRelativeToNitsFactor;
}
(function (prototype) {
    var map = new Map();
    map.set("offset", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("multiplier", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("pqTonemapA", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("pqTonemapB", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("hlgOOTFGammaMinusOne", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("hlgDstMaxLuminanceRelative", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("nitsToSdrRelativeFactor", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("sdrRelativeToNitsFactor", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 32);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(HdrMetadata.prototype);


/***/ }),

/***/ "./src/avrender/image/webgl/program/BaseProgram.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/image/webgl/program/BaseProgram.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseProgram)
/* harmony export */ });
/* harmony import */ var _Program__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Program */ "./src/avrender/image/webgl/program/Program.ts");
/*
 * libmedia BaseProgram
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class BaseProgram extends _Program__WEBPACK_IMPORTED_MODULE_0__["default"] {
    enableColor;
    aPoint;
    aColor;
    constructor(vertexShader, fragmentShader, enableColor = true) {
        super(vertexShader, fragmentShader);
        this.enableColor = enableColor;
    }
    link(gl) {
        super.link(gl);
        this.aPoint = this.gl.getAttribLocation(this.program, 'point');
        this.aColor = this.gl.getAttribLocation(this.program, 'color');
        if (this.enableColor) {
            this.gl.enableVertexAttribArray(this.aPoint);
            this.gl.enableVertexAttribArray(this.aColor);
        }
        else {
            this.gl.enableVertexAttribArray(this.aPoint);
        }
    }
    bind() {
        super.bind();
        if (this.enableColor) {
            this.gl.vertexAttribPointer(this.aPoint, 3, this.gl.FLOAT, false, 7 * Float32Array.BYTES_PER_ELEMENT, 0);
            this.gl.vertexAttribPointer(this.aColor, 4, this.gl.FLOAT, false, 7 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);
        }
        else {
            this.gl.vertexAttribPointer(this.aPoint, 3, this.gl.FLOAT, false, 7 * Float32Array.BYTES_PER_ELEMENT, 0);
        }
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/Program.ts":
/*!*****************************************************!*\
  !*** ./src/avrender/image/webgl/program/Program.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Program)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avrender\\image\\webgl\\program\\Program.ts";

class Program {
    gl;
    _program;
    vertexShader;
    fragmentShader;
    constructor(vertexShader, fragmentShader) {
        this.vertexShader = vertexShader;
        this.fragmentShader = fragmentShader;
    }
    link(gl) {
        this.gl = gl;
        if (this.vertexShader) {
            this.vertexShader.compile(this.gl);
        }
        if (this.fragmentShader) {
            this.fragmentShader.compile(this.gl);
        }
        // 创建程序对象
        this._program = this.gl.createProgram();
        this.gl.attachShader(this._program, this.vertexShader.shader);
        this.gl.attachShader(this._program, this.fragmentShader.shader);
        this.gl.linkProgram(this._program);
        if (true) {
            if (!this.gl.getProgramParameter(this._program, this.gl.LINK_STATUS)) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal(this.gl.getProgramInfoLog(this._program), cheap__fileName__0, 62);
            }
        }
    }
    stop() {
        this.vertexShader.stop(this.gl);
        this.fragmentShader.stop(this.gl);
        this.gl.deleteProgram(this._program);
        this.vertexShader = null;
        this.fragmentShader = null;
        this._program = null;
    }
    bind() {
        this.gl.useProgram(this._program);
    }
    get program() {
        return this._program;
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/RGB8Program.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/image/webgl/program/RGB8Program.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RGB8Program)
/* harmony export */ });
/* harmony import */ var _RGBProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RGBProgram */ "./src/avrender/image/webgl/program/RGBProgram.ts");
/*
 * libmedia RGB8Program
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class RGB8Program extends _RGBProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(rgbFragmentSource) {
        super(rgbFragmentSource);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/RGBProgram.ts":
/*!********************************************************!*\
  !*** ./src/avrender/image/webgl/program/RGBProgram.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RGBProgram)
/* harmony export */ });
/* harmony import */ var _VideoProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VideoProgram */ "./src/avrender/image/webgl/program/VideoProgram.ts");
/*
 * libmedia RGBProgram
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class RGBProgram extends _VideoProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    rgbSamplerLocation;
    constructor(rgbFragmentSource) {
        super(rgbFragmentSource);
    }
    link(gl) {
        super.link(gl);
        this.rgbSamplerLocation = this.gl.getUniformLocation(this.program, 'rgb_Sampler');
    }
    bindRGBTexture(unit = 0) {
        this.gl.uniform1i(this.rgbSamplerLocation, unit);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/VideoProgram.ts":
/*!**********************************************************!*\
  !*** ./src/avrender/image/webgl/program/VideoProgram.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoProgram)
/* harmony export */ });
/* harmony import */ var _BaseProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseProgram */ "./src/avrender/image/webgl/program/BaseProgram.ts");
/* harmony import */ var _shader_VertexShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader/VertexShader */ "./src/avrender/image/webgl/shader/VertexShader.ts");
/* harmony import */ var _shader_FragmentShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shader/FragmentShader */ "./src/avrender/image/webgl/shader/FragmentShader.ts");
/* harmony import */ var _glsl_vertex_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../glsl/vertex.vert */ "./src/avrender/image/webgl/glsl/vertex.vert");
/*
 * libmedia VideoProgram
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class VideoProgram extends _BaseProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    rotateMatrixLocation;
    constructor(yuvFragmentSource) {
        super(new _shader_VertexShader__WEBPACK_IMPORTED_MODULE_1__["default"](_glsl_vertex_vert__WEBPACK_IMPORTED_MODULE_3__["default"]), new _shader_FragmentShader__WEBPACK_IMPORTED_MODULE_2__["default"](yuvFragmentSource));
    }
    link(gl) {
        super.link(gl);
        this.rotateMatrixLocation = this.gl.getUniformLocation(this.program, 'rotateMatrix');
    }
    setRotateMatrix(matrix) {
        this.gl.uniformMatrix4fv(this.rotateMatrixLocation, false, new Float32Array(matrix));
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/YUV16Program.ts":
/*!**********************************************************!*\
  !*** ./src/avrender/image/webgl/program/YUV16Program.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ YUV16Program)
/* harmony export */ });
/* harmony import */ var _YUVProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./YUVProgram */ "./src/avrender/image/webgl/program/YUVProgram.ts");
/*
 * libmedia YUV16Program
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class YUV16Program extends _YUVProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    maxUniformLocation;
    offsetLocation;
    multiplierLocation;
    pqTonemapALocation;
    pqTonemapBLocation;
    hlgOOTFGammaMinusOneLocation;
    hlgDstMaxLuminanceRelativeLocation;
    nitsToSdrRelativeFactorLocation;
    sdrRelativeToNitsFactorLocation;
    constructor(yuvFragmentSource) {
        super(yuvFragmentSource);
    }
    link(gl) {
        super.link(gl);
        this.maxUniformLocation = this.gl.getUniformLocation(this.program, 'v_max');
        this.offsetLocation = this.gl.getUniformLocation(this.program, 'offset');
        this.multiplierLocation = this.gl.getUniformLocation(this.program, 'multiplier');
        this.pqTonemapALocation = this.gl.getUniformLocation(this.program, 'pq_tonemap_a');
        this.pqTonemapBLocation = this.gl.getUniformLocation(this.program, 'pq_tonemap_b');
        this.hlgOOTFGammaMinusOneLocation = this.gl.getUniformLocation(this.program, 'hlg_ootf_gamma_minus_one');
        this.hlgDstMaxLuminanceRelativeLocation = this.gl.getUniformLocation(this.program, 'hlg_dst_max_luminance_relative');
        this.nitsToSdrRelativeFactorLocation = this.gl.getUniformLocation(this.program, 'nits_to_sdr_relative_factor');
        this.sdrRelativeToNitsFactorLocation = this.gl.getUniformLocation(this.program, 'sdr_relative_to_nits_factor');
    }
    setMax(max) {
        this.gl.uniform1f(this.maxUniformLocation, max);
    }
    setMetaData(data) {
        this.gl.uniform1f(this.offsetLocation, data.offset);
        this.gl.uniform1f(this.multiplierLocation, data.multiplier);
        this.gl.uniform1f(this.pqTonemapALocation, data.pqTonemapA);
        this.gl.uniform1f(this.pqTonemapBLocation, data.pqTonemapB);
        this.gl.uniform1f(this.hlgOOTFGammaMinusOneLocation, data.hlgOOTFGammaMinusOne);
        this.gl.uniform1f(this.hlgDstMaxLuminanceRelativeLocation, data.hlgDstMaxLuminanceRelative);
        this.gl.uniform1f(this.nitsToSdrRelativeFactorLocation, data.nitsToSdrRelativeFactor);
        this.gl.uniform1f(this.sdrRelativeToNitsFactorLocation, data.sdrRelativeToNitsFactor);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/YUV8Program.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/image/webgl/program/YUV8Program.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ YUV8Program)
/* harmony export */ });
/* harmony import */ var _YUVProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./YUVProgram */ "./src/avrender/image/webgl/program/YUVProgram.ts");
/*
 * libmedia YUV8Program
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class YUV8Program extends _YUVProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(yuvFragmentSource) {
        super(yuvFragmentSource);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/YUVProgram.ts":
/*!********************************************************!*\
  !*** ./src/avrender/image/webgl/program/YUVProgram.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ YUVProgram)
/* harmony export */ });
/* harmony import */ var _VideoProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VideoProgram */ "./src/avrender/image/webgl/program/VideoProgram.ts");
/*
 * libmedia YUVProgram
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class YUVProgram extends _VideoProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    ySamplerLocation;
    uSamplerLocation;
    vSamplerLocation;
    aSamplerLocation;
    constructor(yuvFragmentSource) {
        super(yuvFragmentSource);
    }
    link(gl) {
        super.link(gl);
        this.ySamplerLocation = this.gl.getUniformLocation(this.program, 'y_Sampler');
        this.uSamplerLocation = this.gl.getUniformLocation(this.program, 'u_Sampler');
        this.vSamplerLocation = this.gl.getUniformLocation(this.program, 'v_Sampler');
        this.aSamplerLocation = this.gl.getUniformLocation(this.program, 'a_Sampler');
    }
    bindYTexture(unit = 0) {
        this.gl.uniform1i(this.ySamplerLocation, unit);
    }
    bindUTexture(unit = 0) {
        this.gl.uniform1i(this.uSamplerLocation, unit);
    }
    bindVTexture(unit = 0) {
        this.gl.uniform1i(this.vSamplerLocation, unit);
    }
    bindATexture(unit = 0) {
        this.gl.uniform1i(this.aSamplerLocation, unit);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/shader/FragmentShader.ts":
/*!***********************************************************!*\
  !*** ./src/avrender/image/webgl/shader/FragmentShader.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FragmentShader)
/* harmony export */ });
/* harmony import */ var _Shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shader */ "./src/avrender/image/webgl/shader/Shader.ts");
/*
 * libmedia FragmentShader
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class FragmentShader extends _Shader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(source) {
        super(1 /* ShaderType.FRAGMENT */, source);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/shader/Shader.ts":
/*!***************************************************!*\
  !*** ./src/avrender/image/webgl/shader/Shader.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Shader)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avrender\\image\\webgl\\shader\\Shader.ts";
/*
 * libmedia Shader
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class Shader {
    type;
    _shader;
    _source;
    compiled;
    constructor(type, source) {
        this.type = type;
        this._shader = null;
        this._source = source;
        this.compiled = false;
    }
    compile(gl) {
        if (this.compiled) {
            return;
        }
        this._shader = gl.createShader(this.type === 0 /* ShaderType.VERTEX */ ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
        gl.shaderSource(this._shader, this._source);
        gl.compileShader(this._shader);
        if (true) {
            if (!gl.getShaderParameter(this._shader, gl.COMPILE_STATUS)) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal(gl.getShaderInfoLog(this._shader), cheap__fileName__0, 60);
            }
        }
        this.compiled = true;
    }
    stop(gl) {
        gl.deleteShader(this._shader);
        this._shader = null;
    }
    get shader() {
        return this._shader;
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/shader/VertexShader.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/image/webgl/shader/VertexShader.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VertexShader)
/* harmony export */ });
/* harmony import */ var _Shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shader */ "./src/avrender/image/webgl/shader/Shader.ts");
/*
 * libmedia VertexShader
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class VertexShader extends _Shader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(source) {
        super(0 /* ShaderType.VERTEX */, source);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/texture/RGBTexture.ts":
/*!********************************************************!*\
  !*** ./src/avrender/image/webgl/texture/RGBTexture.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RGBTexture)
/* harmony export */ });
/* harmony import */ var _Texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture */ "./src/avrender/image/webgl/texture/Texture.ts");
/*
 * libmedia RGBTexture
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class RGBTexture extends _Texture__WEBPACK_IMPORTED_MODULE_0__["default"] {
    filter;
    format;
    internalformat;
    dataType;
    constructor(gl, width, height) {
        super(gl, width, height);
        this.format = this.gl.RGB;
        this.filter = this.gl.LINEAR;
        this.internalformat = this.gl.RGB;
        this.dataType = this.gl.UNSIGNED_BYTE;
    }
    init() {
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.filter);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.filter);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    }
    setFormat(format) {
        this.format = format;
    }
    setInternalformat(format) {
        this.internalformat = format;
    }
    setDataType(type) {
        this.dataType = type;
    }
    setFilter(filter) {
        this.filter = filter;
    }
    fill(data) {
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.setUnpackAlignment();
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.internalformat, this.width, this.height, 0, this.format, this.dataType, data);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/texture/Texture.ts":
/*!*****************************************************!*\
  !*** ./src/avrender/image/webgl/texture/Texture.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Texture)
/* harmony export */ });
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/*
 * libmedia Texture
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class Texture {
    gl;
    width;
    height;
    texture;
    constructor(gl, width, height) {
        this.gl = gl;
        this.width = width;
        this.height = height;
        this.texture = this.gl.createTexture();
    }
    getTexture() {
        return this.texture;
    }
    bind(unit) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.number(unit)) {
            this.gl.activeTexture(this.gl.TEXTURE0 + unit);
        }
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
    }
    setSize(width, height) {
        this.width = width;
        this.height = height;
    }
    /**
     * 设置对齐字节数
     */
    setUnpackAlignment() {
        if (this.width % 8 === 0) {
            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 8);
        }
        else if (this.width % 4 === 0) {
            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 4);
        }
        else if (this.width % 2 === 0) {
            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 2);
        }
        else {
            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
        }
    }
    destroy() {
        if (this.texture) {
            this.gl.deleteTexture(this.texture);
            this.texture = null;
        }
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/texture/YUVTexture.ts":
/*!********************************************************!*\
  !*** ./src/avrender/image/webgl/texture/YUVTexture.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ YUVTexture)
/* harmony export */ });
/* harmony import */ var _Texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture */ "./src/avrender/image/webgl/texture/Texture.ts");
/*
 * libmedia YUVTexture
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class YUVTexture extends _Texture__WEBPACK_IMPORTED_MODULE_0__["default"] {
    filter;
    format;
    internalformat;
    dataType;
    constructor(gl, width, height) {
        super(gl, width, height);
        this.format = this.gl.LUMINANCE;
        this.filter = this.gl.LINEAR;
        this.internalformat = this.gl.LUMINANCE;
        this.dataType = this.gl.UNSIGNED_BYTE;
    }
    init() {
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.filter);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.filter);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    }
    setFormat(format) {
        this.format = format;
    }
    setInternalformat(format) {
        this.internalformat = format;
    }
    setDataType(type) {
        this.dataType = type;
    }
    setFilter(filter) {
        this.filter = filter;
    }
    fill(data) {
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.setUnpackAlignment();
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.internalformat, this.width, this.height, 0, this.format, this.dataType, data);
    }
}


/***/ }),

/***/ "./src/avrender/pcm/AudioSourceBufferNode.ts":
/*!***************************************************!*\
  !*** ./src/avrender/pcm/AudioSourceBufferNode.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioSourceBufferNode)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var avutil_struct_avpcmbuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/struct/avpcmbuffer */ "./src/avutil/struct/avpcmbuffer.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var cheap_config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/config */ "./src/cheap/config.ts");
/* harmony import */ var common_util_os__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/os */ "./src/common/util/os.ts");
var cheap__fileName__14 = "src\\avrender\\pcm\\AudioSourceBufferNode.ts";


/*
 * libmedia AudioSourceBufferNode
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */







const BUFFER_LENGTH = (common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].windows || common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].mac || common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].linux) ? 10 : 20;
class AudioSourceBufferNode {
    context;
    observer;
    options;
    pullIPC;
    buffer;
    channels;
    ended;
    float32;
    buffered;
    pause;
    startTime;
    dest;
    queue;
    firstRendered;
    constructor(context, observer, options = {}) {
        this.context = context;
        this.observer = observer;
        this.options = options;
    }
    async request(method, params, transfer) {
        switch (method) {
            case 'init': {
                break;
            }
            case 'start': {
                const { port, channels } = params;
                this.channels = channels;
                this.pullIPC = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__["default"](port);
                this.buffer = this.allocBuffer();
                this.float32 = new Float32Array((0,cheap_heap__WEBPACK_IMPORTED_MODULE_4__.getHeapU8)().buffer);
                this.queue = [];
                this.startTime = 0;
                this.ended = false;
                this.pause = false;
                this.firstRendered = false;
                await this.pullIPC.request('pull', {
                    buffer: this.buffer
                });
                this.buffering();
                await this.pullIPC.request('pull', {
                    buffer: this.buffer
                });
                this.buffered = true;
                this.process();
                break;
            }
            case 'restart': {
                if (!this.ended) {
                    return;
                }
                this.buffer = this.allocBuffer();
                this.queue = [];
                this.startTime = 0;
                this.ended = false;
                this.pause = false;
                this.firstRendered = false;
                await this.pullIPC.request('pull', {
                    buffer: this.buffer
                });
                this.buffering();
                await this.pullIPC.request('pull', {
                    buffer: this.buffer
                });
                this.buffered = true;
                this.process();
                break;
            }
            case 'stop': {
                this.freeBuffer(this.buffer);
                this.buffer = null;
                this.ended = true;
                this.pullIPC.destroy();
                break;
            }
            case 'clear': {
                this.queue.forEach((buffer) => {
                    buffer.disconnect();
                });
                this.queue.length = 0;
                break;
            }
            case 'pause': {
                this.pause = true;
                break;
            }
            case 'unpause': {
                this.pause = false;
                if (!this.queue.length) {
                    this.process();
                }
                break;
            }
        }
    }
    allocBuffer() {
        const buffer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(40);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](buffer, (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(4 * this.channels));
        const data = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(512 * BUFFER_LENGTH * this.channels);
        for (let i = 0; i < this.channels; i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](buffer) + (i * 4), data + 128 * BUFFER_LENGTH * 4 * i);
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](buffer + 12, 128 * BUFFER_LENGTH);
        return buffer;
    }
    freeBuffer(buffer) {
        if (!buffer) {
            return;
        }
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](buffer));
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avFreep)(buffer);
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(buffer);
    }
    async pull() {
        this.buffered = false;
        const ret = await this.pullIPC.request('pull', {
            buffer: this.buffer
        });
        if (ret < 0) {
            this.ended = true;
        }
        else {
            this.buffered = true;
            if (!this.queue.length) {
                this.process();
            }
        }
    }
    buffering() {
        if (!this.float32.length) {
            this.float32 = new Float32Array((0,cheap_heap__WEBPACK_IMPORTED_MODULE_4__.getHeapU8)().buffer);
        }
        const audioBuffer = this.context.createBuffer(this.channels, BUFFER_LENGTH * 128, this.context.sampleRate);
        for (let i = 0; i < this.channels; i++) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](this.buffer) + (i * 4))) {
                let pos = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](this.buffer) + (i * 4)) >>> 2;
                if (audioBuffer.copyToChannel && !cheap_config__WEBPACK_IMPORTED_MODULE_7__.USE_THREADS) {
                    audioBuffer.copyToChannel(this.float32.subarray(pos, pos + BUFFER_LENGTH * 128), i, 0);
                }
                else {
                    const audioData = audioBuffer.getChannelData(i);
                    audioData.set(this.float32.subarray(pos, pos + BUFFER_LENGTH * 128), 0);
                }
            }
        }
        const bufferSource = this.context.createBufferSource();
        bufferSource.buffer = audioBuffer;
        bufferSource.onended = () => {
            this.queue.shift();
            if (this.ended && !this.queue.length) {
                this.freeBuffer(this.buffer);
                common_util_logger__WEBPACK_IMPORTED_MODULE_6__.info('audio source ended', cheap__fileName__14, 230);
                this.observer.onEnded();
                return;
            }
            this.process();
            if (!this.queue.length) {
                this.observer.onStutter();
            }
            if (!this.firstRendered) {
                this.firstRendered = true;
                this.observer.onFirstRendered();
            }
        };
        if (this.startTime === 0) {
            this.startTime = this.context.currentTime;
        }
        bufferSource.start(this.startTime);
        if (this.dest) {
            bufferSource.connect(this.dest);
        }
        this.startTime += bufferSource.buffer.duration;
        this.queue.push(bufferSource);
    }
    connect(dest) {
        this.dest = dest;
    }
    disconnect() {
        for (let i = 0; i < this.queue.length; i++) {
            this.queue[i].disconnect();
        }
        this.dest = null;
        this.queue.length = 0;
    }
    process() {
        if (this.buffer && !this.pause && this.buffered) {
            this.buffering();
            this.pull();
        }
    }
}


/***/ }),

/***/ "./src/avrender/pcm/AudioSourceWorkletNode.ts":
/*!****************************************************!*\
  !*** ./src/avrender/pcm/AudioSourceWorkletNode.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioSourceWorkletNode)
/* harmony export */ });
/* harmony import */ var _audioWorklet_base_AudioWorkletNodeBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audioWorklet/base/AudioWorkletNodeBase */ "./src/avrender/pcm/audioWorklet/base/AudioWorkletNodeBase.ts");
/*
 * libmedia AudioSourceWorkletNode
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class AudioSourceWorkletNode extends _audioWorklet_base_AudioWorkletNodeBase__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, observer, options = {}) {
        super(context, observer, 'audio-source-processor', options);
    }
}


/***/ }),

/***/ "./src/avrender/pcm/AudioSourceWorkletProcessor.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/pcm/AudioSourceWorkletProcessor.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var _audioWorklet_base_AudioWorkletProcessorBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audioWorklet/base/AudioWorkletProcessorBase */ "./src/avrender/pcm/audioWorklet/base/AudioWorkletProcessorBase.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_os__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/os */ "./src/common/util/os.ts");
var cheap__fileName__0 = "src\\avrender\\pcm\\AudioSourceWorkletProcessor.ts";
/*
 * libmedia AudioSourceWorkletProcessor
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





const BUFFER_LENGTH = (common_util_os__WEBPACK_IMPORTED_MODULE_4__["default"].windows || common_util_os__WEBPACK_IMPORTED_MODULE_4__["default"].mac || common_util_os__WEBPACK_IMPORTED_MODULE_4__["default"].linux) ? 10 : 20;
class AudioSourceWorkletProcessor extends _audioWorklet_base_AudioWorkletProcessorBase__WEBPACK_IMPORTED_MODULE_1__["default"] {
    pullIPC;
    frontBuffer;
    backBuffer;
    channels;
    backBufferOffset;
    ended;
    frontBuffered;
    pause;
    firstRendered;
    stopped;
    afterPullResolve;
    constructor() {
        super();
        this.ended = false;
        this.pause = true;
        this.ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.REQUEST, async (request) => {
            switch (request.method) {
                case 'init': {
                    this.ipcPort.reply(request);
                    break;
                }
                case 'start': {
                    const { port, channels } = request.params;
                    this.channels = channels;
                    this.pullIPC = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](port);
                    const backBuffer = [];
                    const frontBuffer = [];
                    await this.pull(backBuffer);
                    await this.pull(frontBuffer);
                    this.frontBuffer = frontBuffer;
                    this.backBuffer = backBuffer;
                    this.backBufferOffset = 0;
                    this.ended = false;
                    this.frontBuffered = true;
                    this.pause = false;
                    this.firstRendered = false;
                    this.stopped = false;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'restart': {
                    if (!this.ended) {
                        this.ipcPort.reply(request);
                        return;
                    }
                    const backBuffer = [];
                    const frontBuffer = [];
                    await this.pull(backBuffer);
                    await this.pull(frontBuffer);
                    this.frontBuffer = frontBuffer;
                    this.backBuffer = backBuffer;
                    this.backBufferOffset = 0;
                    this.ended = false;
                    this.frontBuffered = true;
                    this.pause = false;
                    this.firstRendered = false;
                    this.stopped = false;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'clear': {
                    this.backBufferOffset = BUFFER_LENGTH;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'stop': {
                    if (!this.ended && !this.pause) {
                        await new Promise((resolve) => {
                            this.afterPullResolve = resolve;
                        });
                    }
                    this.stopped = true;
                    this.pullIPC.destroy();
                    this.ipcPort.reply(request);
                    break;
                }
                case 'pause': {
                    this.pause = true;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'unpause': {
                    this.pause = false;
                    this.ipcPort.reply(request);
                    break;
                }
            }
        });
    }
    async pull(data) {
        const buffer = await this.pullIPC.request('pullBuffer', {
            nbSamples: BUFFER_LENGTH * 128
        });
        if (common_util_is__WEBPACK_IMPORTED_MODULE_2__.number(buffer)) {
            this.ended = true;
        }
        else {
            const float = new Float32Array(buffer);
            for (let i = 0; i < this.channels; i++) {
                data[i] = float.subarray(i * BUFFER_LENGTH * 128, (i + 1) * BUFFER_LENGTH * 128);
            }
        }
        if (this.afterPullResolve) {
            this.afterPullResolve();
        }
    }
    swapBuffer() {
        if (this.frontBuffered) {
            this.backBuffer = this.frontBuffer;
            this.backBufferOffset = 0;
            this.frontBuffer = [];
        }
        else {
            return false;
        }
        this.frontBuffered = false;
        this.pull(this.frontBuffer).then(() => {
            this.frontBuffered = true;
        });
        return true;
    }
    process(inputs, outputs, parameters) {
        if (this.stopped) {
            return false;
        }
        if (this.backBuffer && !this.pause) {
            if (this.backBufferOffset === BUFFER_LENGTH) {
                if (this.ended) {
                    this.backBuffer = null;
                    this.frontBuffer = null;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_3__.info('audio source ended', cheap__fileName__0, 199);
                    this.ipcPort.notify('ended');
                    return true;
                }
                if (!this.swapBuffer()) {
                    this.ipcPort.notify('stutter');
                    return true;
                }
            }
            const output = outputs[0];
            for (let i = 0; i < this.channels; i++) {
                output[i].set(this.backBuffer[i].subarray(this.backBufferOffset * 128, (this.backBufferOffset + 1) * 128), 0);
            }
            this.backBufferOffset++;
            if (!this.firstRendered) {
                this.firstRendered = true;
                this.ipcPort.notify('firstRendered');
            }
        }
        return true;
    }
}
// @ts-ignore
registerProcessor('audio-source-processor', AudioSourceWorkletProcessor);


/***/ }),

/***/ "./src/avrender/pcm/AudioSourceWorkletProcessor2.ts":
/*!**********************************************************!*\
  !*** ./src/avrender/pcm/AudioSourceWorkletProcessor2.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var _audioWorklet_base_AudioWorkletProcessorBase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./audioWorklet/base/AudioWorkletProcessorBase */ "./src/avrender/pcm/audioWorklet/base/AudioWorkletProcessorBase.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var avutil_struct_avpcmbuffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/struct/avpcmbuffer */ "./src/avutil/struct/avpcmbuffer.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_os__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/os */ "./src/common/util/os.ts");
var cheap__fileName__10 = "src\\avrender\\pcm\\AudioSourceWorkletProcessor2.ts";


/*
 * libmedia AudioSourceWorkletProcessor in share memory
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */







const BUFFER_LENGTH = (common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].windows || common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].mac || common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].linux) ? 10 : 20;
class AudioSourceWorkletProcessor2 extends _audioWorklet_base_AudioWorkletProcessorBase__WEBPACK_IMPORTED_MODULE_3__["default"] {
    pullIPC;
    frontBuffer;
    backBuffer;
    channels;
    backBufferOffset;
    ended;
    frontBuffered;
    firstRendered;
    float32;
    pause;
    stopped;
    afterPullResolve;
    constructor() {
        super();
        this.ended = false;
        this.pause = true;
        this.ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_2__.REQUEST, async (request) => {
            switch (request.method) {
                case 'init': {
                    const { memory } = request.params;
                    await (0,cheap_heap__WEBPACK_IMPORTED_MODULE_4__.initThread)({
                        memory,
                        disableAsm: true
                    });
                    this.ipcPort.reply(request);
                    break;
                }
                case 'start': {
                    const { port, channels } = request.params;
                    this.channels = channels;
                    this.pullIPC = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_2__["default"](port);
                    const frontBuffer = this.allocBuffer();
                    const backBuffer = this.allocBuffer();
                    await this.pullIPC.request('pull', {
                        buffer: backBuffer
                    });
                    await this.pullIPC.request('pull', {
                        buffer: frontBuffer
                    });
                    this.frontBuffer = frontBuffer;
                    this.backBuffer = backBuffer;
                    this.backBufferOffset = 0;
                    this.ended = false;
                    this.pause = false;
                    this.frontBuffered = true;
                    this.firstRendered = false;
                    this.stopped = false;
                    this.float32 = new Float32Array((0,cheap_heap__WEBPACK_IMPORTED_MODULE_4__.getHeapU8)().buffer);
                    this.ipcPort.reply(request);
                    break;
                }
                case 'restart': {
                    if (!this.ended) {
                        this.ipcPort.reply(request);
                        return;
                    }
                    const frontBuffer = this.allocBuffer();
                    const backBuffer = this.allocBuffer();
                    await this.pullIPC.request('pull', {
                        buffer: backBuffer
                    });
                    await this.pullIPC.request('pull', {
                        buffer: frontBuffer
                    });
                    this.frontBuffer = frontBuffer;
                    this.backBuffer = backBuffer;
                    this.backBufferOffset = 0;
                    this.ended = false;
                    this.pause = false;
                    this.frontBuffered = true;
                    this.firstRendered = false;
                    this.stopped = false;
                    this.float32 = new Float32Array((0,cheap_heap__WEBPACK_IMPORTED_MODULE_4__.getHeapU8)().buffer);
                    this.ipcPort.reply(request);
                    break;
                }
                case 'stop': {
                    if (!this.ended && !this.pause) {
                        await new Promise((resolve) => {
                            this.afterPullResolve = resolve;
                        });
                    }
                    this.freeBuffer(this.backBuffer);
                    this.freeBuffer(this.frontBuffer);
                    this.backBuffer = 0;
                    this.frontBuffer = 0;
                    this.stopped = true;
                    this.pullIPC.destroy();
                    this.ipcPort.reply(request);
                    break;
                }
                case 'clear': {
                    this.backBufferOffset = BUFFER_LENGTH;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'pause': {
                    this.pause = true;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'unpause': {
                    this.pause = false;
                    this.ipcPort.reply(request);
                    break;
                }
            }
        });
    }
    allocBuffer() {
        const buffer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avMallocz)(40);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](buffer, (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avMallocz)(4 * this.channels));
        const data = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avMallocz)(512 * BUFFER_LENGTH * this.channels);
        for (let i = 0; i < this.channels; i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](buffer) + (i * 4), data + 128 * BUFFER_LENGTH * 4 * i);
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](buffer + 12, 128 * BUFFER_LENGTH);
        return buffer;
    }
    freeBuffer(buffer) {
        if (!buffer) {
            return;
        }
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](buffer));
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avFreep)(buffer);
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avFree)(buffer);
    }
    async pull() {
        const ret = await this.pullIPC.request('pull', {
            buffer: this.frontBuffer
        });
        if (ret < 0) {
            this.ended = true;
        }
        if (this.afterPullResolve) {
            this.afterPullResolve();
        }
    }
    swapBuffer() {
        if (this.frontBuffered) {
            const backBuffer = this.backBuffer;
            this.backBuffer = this.frontBuffer;
            this.frontBuffer = backBuffer;
            this.backBufferOffset = 0;
        }
        else {
            return false;
        }
        this.frontBuffered = false;
        this.pull().then(() => {
            this.frontBuffered = true;
        });
        return true;
    }
    process(inputs, outputs, parameters) {
        if (this.stopped) {
            return false;
        }
        if (this.backBuffer && !this.pause) {
            if (this.backBufferOffset === BUFFER_LENGTH) {
                if (this.ended) {
                    this.freeBuffer(this.backBuffer);
                    this.freeBuffer(this.frontBuffer);
                    this.backBuffer = 0;
                    this.frontBuffer = 0;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info('audio source ended', cheap__fileName__10, 239);
                    this.ipcPort.notify('ended');
                    return true;
                }
                if (!this.swapBuffer()) {
                    this.ipcPort.notify('stutter');
                    return true;
                }
            }
            const output = outputs[0];
            for (let i = 0; i < this.channels; i++) {
                output[i].set(this.float32.subarray((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](this.backBuffer) + (i * 4)) >>> 2) + this.backBufferOffset * 128, (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](this.backBuffer) + (i * 4)) >>> 2) + (this.backBufferOffset + 1) * 128), 0);
            }
            this.backBufferOffset++;
            if (!this.firstRendered) {
                this.firstRendered = true;
                this.ipcPort.notify('firstRendered');
            }
        }
        return true;
    }
}
// @ts-ignore
registerProcessor('audio-source-processor', AudioSourceWorkletProcessor2);


/***/ }),

/***/ "./src/avrender/pcm/audioWorklet/base/AudioWorkletNodeBase.ts":
/*!********************************************************************!*\
  !*** ./src/avrender/pcm/audioWorklet/base/AudioWorkletNodeBase.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioWorkletNodeBase)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/*
 * libmedia AudioWorkletNodeBase
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class AudioWorkletNodeBase {
    audioWorkletNode;
    ipcPort;
    observer;
    constructor(context, observer, processor, options = {}) {
        this.observer = observer;
        this.audioWorkletNode = new AudioWorkletNode(context, processor, options);
        this.ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](this.audioWorkletNode.port);
        this.ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.NOTIFY, (request) => {
            switch (request.method) {
                case 'ended':
                    this.observer.onEnded();
                    break;
                case 'firstRendered':
                    this.observer.onFirstRendered();
                    break;
                case 'stutter':
                    this.observer.onStutter();
                    break;
            }
        });
    }
    async request(method, params, transfer) {
        return this.ipcPort.request(method, params, transfer);
    }
    connect(audioNode) {
        this.audioWorkletNode.connect(audioNode);
    }
    getNode() {
        return this.audioWorkletNode;
    }
    disconnect() {
        this.audioWorkletNode.disconnect();
    }
    getParameters(type) {
        const parameters = this.audioWorkletNode.parameters;
        // @ts-ignore
        if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.func(parameters.get)) {
            // @ts-ignore
            return parameters.get(type);
        }
        parameters.forEach((value, key) => {
            if (key === type) {
                return value;
            }
        });
    }
}


/***/ }),

/***/ "./src/avrender/pcm/audioWorklet/base/AudioWorkletProcessorBase.ts":
/*!*************************************************************************!*\
  !*** ./src/avrender/pcm/audioWorklet/base/AudioWorkletProcessorBase.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioWorkletProcessorBase)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/*
 * libmedia AudioWorkletProcessorBase
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class AudioWorkletProcessorBase extends AudioWorkletProcessor {
    ipcPort;
    constructor() {
        super();
        this.ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](this.port);
    }
    async request(method, params, transfer) {
        return this.ipcPort.request(method, params, transfer);
    }
    notify(method, params, transfer) {
        this.ipcPort.notify(method, params, transfer);
    }
}


/***/ }),

/***/ "./src/avrender/pcm/audioWorklet/base/registerProcessor.ts":
/*!*****************************************************************!*\
  !*** ./src/avrender/pcm/audioWorklet/base/registerProcessor.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ registerProcessor)
/* harmony export */ });
/* harmony import */ var common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/function/sourceLoad */ "./src/common/function/sourceLoad.ts");
/*
 * libmedia registerProcessor
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

async function registerProcessor(audioContext, moduleId) {
    const source = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_0__["default"])(moduleId, {
        varName: 'processor'
    });
    const blob = new Blob([source], { type: 'text/javascript' });
    const workerUrl = URL.createObjectURL(blob);
    await audioContext.audioWorklet.addModule(workerUrl);
}


/***/ }),

/***/ "./src/avrender/track/Track.ts":
/*!*************************************!*\
  !*** ./src/avrender/track/Track.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Track)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avrender\\track\\Track.ts";
/*
 * libmedia Track
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


var Operator;
(function (Operator) {
    Operator[Operator["ADD"] = 0] = "ADD";
    Operator[Operator["REMOVE"] = 1] = "REMOVE";
    Operator[Operator["UPDATE_TIMESTAMP_OFFSET"] = 2] = "UPDATE_TIMESTAMP_OFFSET";
})(Operator || (Operator = {}));
const defaultTrackOptions = {
    mediaBufferMax: 10
};
class Track {
    sourceBuffer;
    operatorQueue;
    updating;
    lastRemoveTime;
    paddingCallback;
    options;
    ending;
    onQuotaExceededError;
    onEnded;
    constructor(options = {}) {
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend({}, defaultTrackOptions, options);
        this.operatorQueue = [];
        this.updating = false;
        this.lastRemoveTime = 0;
        this.ending = false;
    }
    setSourceBuffer(sourceBuffer) {
        this.sourceBuffer = sourceBuffer;
        this.sourceBuffer.onupdateend = () => {
            if (this.paddingCallback) {
                this.paddingCallback();
                this.paddingCallback = null;
            }
            if (this.operatorQueue && this.operatorQueue.length) {
                this.enqueue();
            }
            else {
                this.updating = false;
                if (this.ending) {
                    if (this.onEnded) {
                        this.onEnded();
                    }
                }
            }
        };
        this.sourceBuffer.onerror = (error) => {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.error(`track update buffer error: ${error}`, cheap__fileName__0, 102);
        };
    }
    changeMimeType(type) {
        if (this.sourceBuffer) {
            this.sourceBuffer.changeType(type);
        }
    }
    enqueue() {
        if (this.operatorQueue.length) {
            const operator = this.operatorQueue.shift();
            if (operator.operator === Operator.ADD) {
                try {
                    this.sourceBuffer.appendBuffer(operator.buffer);
                    this.updating = true;
                    if (operator.callback) {
                        this.paddingCallback = operator.callback;
                    }
                }
                catch (error) {
                    if (error instanceof DOMException && error.name === 'QuotaExceededError') {
                        // buffer 满了，返回队列重新操作
                        this.operatorQueue.unshift(operator);
                        if (this.onQuotaExceededError) {
                            this.onQuotaExceededError();
                        }
                        this.updating = false;
                    }
                    else {
                        throw error;
                    }
                }
            }
            else if (operator.operator === Operator.REMOVE) {
                this.sourceBuffer.remove(operator.start, operator.end);
                this.updating = true;
                if (operator.callback) {
                    this.paddingCallback = operator.callback;
                }
            }
            else if (operator.operator === Operator.UPDATE_TIMESTAMP_OFFSET) {
                this.sourceBuffer.timestampOffset = operator.timestampOffset;
                if (operator.callback) {
                    operator.callback();
                }
                this.enqueue();
            }
        }
    }
    addBuffer(buffer, callback) {
        if (!buffer) {
            if (callback) {
                callback();
            }
            return;
        }
        this.operatorQueue.push({
            operator: Operator.ADD,
            buffer,
            callback
        });
        if (!this.updating) {
            this.enqueue();
        }
    }
    updateTimestampOffset(timestampOffset, callback) {
        this.operatorQueue.push({
            operator: Operator.UPDATE_TIMESTAMP_OFFSET,
            timestampOffset,
            callback
        });
        if (!this.updating) {
            this.enqueue();
        }
    }
    removeBuffer(time, callback) {
        if (this.ending) {
            return;
        }
        time = Math.floor(time);
        if (time - this.lastRemoveTime < this.options.mediaBufferMax << 1) {
            return;
        }
        this.operatorQueue.push({
            operator: Operator.REMOVE,
            start: this.lastRemoveTime,
            end: time - this.options.mediaBufferMax,
            callback
        });
        if (!this.updating) {
            this.enqueue();
        }
        this.lastRemoveTime = time - this.options.mediaBufferMax;
    }
    removeAllBuffer(callback) {
        if (this.sourceBuffer.buffered.length) {
            this.operatorQueue.push({
                operator: Operator.REMOVE,
                start: this.sourceBuffer.buffered.start(0),
                end: this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1),
                callback
            });
            if (!this.updating) {
                this.enqueue();
            }
        }
        else if (callback) {
            callback();
        }
    }
    end() {
        this.ending = true;
        if (!this.updating && !this.operatorQueue.length) {
            if (this.onEnded) {
                this.onEnded();
            }
        }
    }
    stop() {
        if (this.sourceBuffer) {
            try {
                this.sourceBuffer.abort();
                this.updating = false;
            }
            catch (error) { }
            try {
                if (this.sourceBuffer.buffered.length) {
                    if (!this.updating) {
                        this.sourceBuffer.remove(this.sourceBuffer.buffered.start(0), this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1));
                        this.updating = true;
                    }
                    else {
                        this.operatorQueue.push({
                            operator: Operator.REMOVE,
                            start: this.sourceBuffer.buffered.start(0),
                            end: this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1)
                        });
                    }
                }
                if (this.paddingCallback) {
                    this.paddingCallback();
                    this.paddingCallback = null;
                }
            }
            catch (error) { }
        }
    }
    reset() {
        this.stop();
        this.operatorQueue.length = 0;
        this.ending = false;
    }
    isPaused() {
        return !this.updating && this.operatorQueue.length;
    }
    getQueueLength() {
        return this.operatorQueue.length;
    }
    getBufferedTime() {
        if (this.sourceBuffer && this.sourceBuffer.buffered.length) {
            return this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1) - this.sourceBuffer.buffered.start(0);
        }
        return 0;
    }
    getBufferedStart() {
        if (this.sourceBuffer && this.sourceBuffer.buffered.length) {
            return this.sourceBuffer.buffered.start(0);
        }
        return 0;
    }
    getBufferedEnd() {
        if (this.sourceBuffer && this.sourceBuffer.buffered.length) {
            return this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1);
        }
        return 0;
    }
    getSourceBuffer() {
        return this.sourceBuffer;
    }
    setMediaBufferMax(max) {
        this.options.mediaBufferMax = max;
    }
    getMediaBufferMax() {
        return this.options.mediaBufferMax;
    }
    destroy() {
        this.stop();
        this.operatorQueue = null;
        if (this.sourceBuffer) {
            this.sourceBuffer.onupdateend = this.sourceBuffer.onerror = null;
            this.sourceBuffer = null;
        }
    }
}


/***/ }),

/***/ "./src/avrender/track/function/getAudioMimeType.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/track/function/getAudioMimeType.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getAudioMimeType)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avcodec/function/getAudioCodec */ "./src/avcodec/function/getAudioCodec.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");

/*
 * libmedia get audio mimetype
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function getAudioMimeType(codecpar) {
    let mimeType = '';
    // firefox supports 'audio/mp4, codecs="mp3"', use 'audio/mpeg' for chrome, safari
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 4) === 86017 /* AVCodecID.AV_CODEC_ID_MP3 */ && !common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].firefox) {
        mimeType = 'audio/mpeg';
    }
    else {
        mimeType = `audio/mp4; codecs="${(0,avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_1__["default"])(codecpar)}"`;
    }
    return mimeType;
}


/***/ }),

/***/ "./src/avrender/track/function/getVideoMimeType.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/track/function/getVideoMimeType.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getVideoMimeType)
/* harmony export */ });
/* harmony import */ var avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avcodec/function/getVideoCodec */ "./src/avcodec/function/getVideoCodec.ts");
/*
 * libmedia get video mimetype
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function getVideoMimeType(codecpar) {
    return `video/mp4; codecs="${(0,avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_0__["default"])(codecpar)}"`;
}


/***/ }),

/***/ "./src/avutil/constant.ts":
/*!********************************!*\
  !*** ./src/avutil/constant.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AV_MILLI_TIME_BASE: () => (/* binding */ AV_MILLI_TIME_BASE),
/* harmony export */   AV_MILLI_TIME_BASE_Q: () => (/* binding */ AV_MILLI_TIME_BASE_Q),
/* harmony export */   AV_TIME_BASE: () => (/* binding */ AV_TIME_BASE),
/* harmony export */   AV_TIME_BASE_Q: () => (/* binding */ AV_TIME_BASE_Q),
/* harmony export */   INT32_MAX: () => (/* binding */ INT32_MAX),
/* harmony export */   NOPTS_VALUE: () => (/* binding */ NOPTS_VALUE),
/* harmony export */   NOPTS_VALUE_BIGINT: () => (/* binding */ NOPTS_VALUE_BIGINT),
/* harmony export */   UINT16_MAX: () => (/* binding */ UINT16_MAX),
/* harmony export */   UINT32_MAX: () => (/* binding */ UINT32_MAX)
/* harmony export */ });
/* unused harmony exports AV_TIME_BASE1_Q, INT8_MAX, INT16_MAX, INT8_MIN, INT16_MIN, INT32_MIN, UINT8_MAX */
/* harmony import */ var _struct_rational__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./struct/rational */ "./src/avutil/struct/rational.ts");
/*
 * libmedia constant
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const NOPTS_VALUE_BIGINT = -BigInt(1);
const NOPTS_VALUE = -1;
const AV_TIME_BASE = 1000000;
const AV_MILLI_TIME_BASE = 1000;
/**
 * 微秒时间基
 */
const AV_TIME_BASE_Q = new _struct_rational__WEBPACK_IMPORTED_MODULE_0__.Rational({ den: AV_TIME_BASE, num: 1 });
/**
 * 毫秒时间基
 */
const AV_MILLI_TIME_BASE_Q = new _struct_rational__WEBPACK_IMPORTED_MODULE_0__.Rational({ den: AV_MILLI_TIME_BASE, num: 1 });
/**
 * 秒时间基
 */
const AV_TIME_BASE1_Q = new _struct_rational__WEBPACK_IMPORTED_MODULE_0__.Rational({ den: 1, num: 1 });
const INT8_MAX = 127;
const INT16_MAX = 32767;
const INT32_MAX = 2147483647;
const INT8_MIN = -128;
const INT16_MIN = -32768;
const INT32_MIN = -INT32_MAX - 1;
const UINT8_MAX = 255;
const UINT16_MAX = 65535;
const UINT32_MAX = 4294967295;


/***/ }),

/***/ "./src/avutil/error.ts":
/*!*****************************!*\
  !*** ./src/avutil/error.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CODEC_NOT_SUPPORT: () => (/* binding */ CODEC_NOT_SUPPORT),
/* harmony export */   DATA_INVALID: () => (/* binding */ DATA_INVALID),
/* harmony export */   EAGAIN: () => (/* binding */ EAGAIN),
/* harmony export */   EOF: () => (/* binding */ EOF),
/* harmony export */   FORMAT_NOT_SUPPORT: () => (/* binding */ FORMAT_NOT_SUPPORT),
/* harmony export */   INVALID_ARGUMENT: () => (/* binding */ INVALID_ARGUMENT),
/* harmony export */   INVALID_OPERATE: () => (/* binding */ INVALID_OPERATE),
/* harmony export */   NO_MEMORY: () => (/* binding */ NO_MEMORY)
/* harmony export */ });
/*
 * libmedia error defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const FORMAT_NOT_SUPPORT = -1;
const DATA_INVALID = -2;
const INVALID_ARGUMENT = -3;
const NO_MEMORY = -4;
const INVALID_OPERATE = -5;
const EAGAIN = -6;
const EOF = -7;
const CODEC_NOT_SUPPORT = -8;


/***/ }),

/***/ "./src/avutil/function/audioData2AVFrame.ts":
/*!**************************************************!*\
  !*** ./src/avutil/function/audioData2AVFrame.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   audioData2AVFrame: () => (/* binding */ audioData2AVFrame)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _util_avframe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var _util_sample__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/sample */ "./src/avutil/util/sample.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");


/* libmedia AudioData to AVFrame utils
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function mapFormat(format) {
    switch (format) {
        case 'u8':
            return 0 /* AVSampleFormat.AV_SAMPLE_FMT_U8 */;
        case 's16':
            return 1 /* AVSampleFormat.AV_SAMPLE_FMT_S16 */;
        case 's32':
            return 2 /* AVSampleFormat.AV_SAMPLE_FMT_S32 */;
        case 'f32':
            return 3 /* AVSampleFormat.AV_SAMPLE_FMT_FLT */;
        case 'u8-planar':
            return 5 /* AVSampleFormat.AV_SAMPLE_FMT_U8P */;
        case 's16-planar':
            return 6 /* AVSampleFormat.AV_SAMPLE_FMT_S16P */;
        case 's32-planar':
            return 7 /* AVSampleFormat.AV_SAMPLE_FMT_S32P */;
        case 'f32-planar':
            return 8 /* AVSampleFormat.AV_SAMPLE_FMT_FLTP */;
        default:
            throw new Error('not support');
    }
}
function audioData2AVFrame(audioData, avframe = 0) {
    if (avframe === 0) {
        avframe = (0,_util_avframe__WEBPACK_IMPORTED_MODULE_2__.createAVFrame)();
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 152, audioData.sampleRate);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 76, audioData.numberOfFrames);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 292, audioData.numberOfChannels);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 80, mapFormat(audioData.format));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avframe + 104, BigInt(Math.floor(audioData.timestamp)));
    (0,_util_avframe__WEBPACK_IMPORTED_MODULE_2__.getAudioBuffer)(avframe);
    const planar = (0,_util_sample__WEBPACK_IMPORTED_MODULE_3__.sampleFormatIsPlanar)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 80));
    const planes = planar ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 292) : 1;
    for (let i = 0; i < planes; i++) {
        audioData.copyTo((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avframe + 64) + (i * 4)), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 32)), {
            planeIndex: i
        });
    }
    return avframe;
}


/***/ }),

/***/ "./src/avutil/function/avpacket2EncodedAudioChunk.ts":
/*!***********************************************************!*\
  !*** ./src/avutil/function/avpacket2EncodedAudioChunk.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ avpacket2EncodedAudioChunk)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");


function avpacket2EncodedAudioChunk(avpacket, pts) {
    const timestamp = Number(pts ?? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8));
    const key = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */;
    return new EncodedAudioChunk({
        type: key ? 'key' : 'delta',
        timestamp,
        data: (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28))
    });
}


/***/ }),

/***/ "./src/avutil/function/avpacket2EncodedVideoChunk.ts":
/*!***********************************************************!*\
  !*** ./src/avutil/function/avpacket2EncodedVideoChunk.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ avpacket2EncodedVideoChunk)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");


function avpacket2EncodedVideoChunk(avpacket, pts) {
    const timestamp = Number(pts ?? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8));
    const key = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */;
    return new EncodedVideoChunk({
        type: key ? 'key' : 'delta',
        timestamp,
        data: (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28))
    });
}


/***/ }),

/***/ "./src/avutil/function/createMessageChannel.ts":
/*!*****************************************************!*\
  !*** ./src/avutil/function/createMessageChannel.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createMessageChannel)
/* harmony export */ });
/* harmony import */ var cheap_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/config */ "./src/cheap/config.ts");
/* harmony import */ var common_network_FakeMessageChannel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/FakeMessageChannel */ "./src/common/network/FakeMessageChannel.ts");
/*
 * libmedia create MessageChannel
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function createMessageChannel() {
    if (cheap_config__WEBPACK_IMPORTED_MODULE_0__.USE_THREADS && true) {
        return new MessageChannel();
    }
    return new common_network_FakeMessageChannel__WEBPACK_IMPORTED_MODULE_1__["default"]();
}


/***/ }),

/***/ "./src/avutil/function/hasAlphaChannel.ts":
/*!************************************************!*\
  !*** ./src/avutil/function/hasAlphaChannel.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hasAlphaChannel)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");

/*
 * libmedia hasAlphaChannel
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function hasAlphaChannel(parameters) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters) !== 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
        return false;
    }
    const descriptor = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_1__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 28)];
    return descriptor && (descriptor.flags & 128 /* PixelFormatFlags.ALPHA */);
}


/***/ }),

/***/ "./src/avutil/function/isHdr.ts":
/*!**************************************!*\
  !*** ./src/avutil/function/isHdr.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isHdr)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");


function isHdr(parameters) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters) !== 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
        return false;
    }
    const descriptor = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_1__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 28)];
    if (!descriptor || descriptor.comp[0].depth <= 8) {
        return false;
    }
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 92) === 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */
        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 92) === 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */;
}


/***/ }),

/***/ "./src/avutil/implement/AVFramePoolImpl.ts":
/*!*************************************************!*\
  !*** ./src/avutil/implement/AVFramePoolImpl.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVFramePoolImpl)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _struct_avframe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../struct/avframe */ "./src/avutil/struct/avframe.ts");
/* harmony import */ var cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _util_avframe__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/avframe */ "./src/avutil/util/avframe.ts");


/*
 * libmedia AVFrame pool implement
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





class AVFramePoolImpl {
    list;
    mutex;
    constructor(list, mutex) {
        this.list = list;
        this.mutex = mutex;
    }
    alloc() {
        let avframe = this.list.find((avframe) => {
            return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(avframe + 320, -1, 1, 16, 2) === -1;
        }, 20);
        if (!avframe) {
            avframe = (0,_util_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(328);
            (0,_util_avframe__WEBPACK_IMPORTED_MODULE_6__.getAVFrameDefault)(avframe);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[16](avframe + 320, 1);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.lock(this.mutex);
            }
            this.list.push(avframe, 20);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.unlock(this.mutex);
            }
        }
        return avframe;
    }
    release(avframe) {
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.load(avframe + 320, 16, 2) <= 0) {
            return;
        }
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.sub(avframe + 320, 1, 16, 2) === 1) {
            (0,_util_avframe__WEBPACK_IMPORTED_MODULE_6__.unrefAVFrame)(avframe);
            cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.store(avframe + 320, -1, 16, 2);
        }
    }
}


/***/ }),

/***/ "./src/avutil/implement/AVPCMBufferPoolImpl.ts":
/*!*****************************************************!*\
  !*** ./src/avutil/implement/AVPCMBufferPoolImpl.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVPCMBufferPoolImpl)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _struct_avpcmbuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../struct/avpcmbuffer */ "./src/avutil/struct/avpcmbuffer.ts");
/* harmony import */ var cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");


/*
 * libmedia AVPCMBuffer pool implement
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class AVPCMBufferPoolImpl {
    list;
    mutex;
    constructor(list, mutex) {
        this.list = list;
        this.mutex = mutex;
    }
    alloc() {
        let buffer = this.list.find((buffer) => {
            return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(buffer + 40, -1, 1, 16, 2) === -1;
        }, 20);
        if (!buffer) {
            buffer = (0,_util_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(48);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[16](buffer + 40, 1);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.lock(this.mutex);
            }
            this.list.push(buffer, 20);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.unlock(this.mutex);
            }
        }
        return buffer;
    }
    release(buffer) {
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.load(buffer + 40, 16, 2) <= 0) {
            return;
        }
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.sub(buffer + 40, 1, 16, 2) === 1) {
            cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.store(buffer + 40, -1, 16, 2);
        }
    }
}


/***/ }),

/***/ "./src/avutil/implement/AVPacketPoolImpl.ts":
/*!**************************************************!*\
  !*** ./src/avutil/implement/AVPacketPoolImpl.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVPacketPoolImpl)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _struct_avpacket__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../struct/avpacket */ "./src/avutil/struct/avpacket.ts");
/* harmony import */ var _util_avpacket__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/avpacket */ "./src/avutil/util/avpacket.ts");







class AVPacketPoolImpl {
    list;
    mutex;
    constructor(list, mutex) {
        this.list = list;
        this.mutex = mutex;
    }
    alloc() {
        let avpacket = this.list.find((avpacket) => {
            return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_2__.compareExchange(avpacket + 88, -1, 1, 16, 2) === -1;
        }, 20);
        if (!avpacket) {
            avpacket = (0,_util_mem__WEBPACK_IMPORTED_MODULE_4__.avMallocz)(96);
            (0,_util_avpacket__WEBPACK_IMPORTED_MODULE_6__.getAVPacketDefault)(avpacket);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[16](avpacket + 88, 1);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.lock(this.mutex);
            }
            this.list.push(avpacket, 20);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(this.mutex);
            }
        }
        return avpacket;
    }
    release(avpacket) {
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_2__.load(avpacket + 88, 16, 2) <= 0) {
            return;
        }
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_2__.sub(avpacket + 88, 1, 16, 2) === 1) {
            (0,_util_avpacket__WEBPACK_IMPORTED_MODULE_6__.unrefAVPacket)(avpacket);
            cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_2__.store(avpacket + 88, -1, 16, 2);
        }
    }
}


/***/ }),

/***/ "./src/avutil/pixelFormatDescriptor.ts":
/*!*********************************************!*\
  !*** ./src/avutil/pixelFormatDescriptor.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PixelFormatDescriptorsMap: () => (/* binding */ PixelFormatDescriptorsMap)
/* harmony export */ });
/*
 * libmedia pixel format descriptor
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const PixelFormatDescriptorsMap = {
    /**
     * 1 字节
     */
    [0 /* AVPixelFormat.AV_PIX_FMT_YUV420P */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [12 /* AVPixelFormat.AV_PIX_FMT_YUVJ420P */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [4 /* AVPixelFormat.AV_PIX_FMT_YUV422P */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [13 /* AVPixelFormat.AV_PIX_FMT_YUVJ422P */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [5 /* AVPixelFormat.AV_PIX_FMT_YUV444P */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [14 /* AVPixelFormat.AV_PIX_FMT_YUVJ444P */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [23 /* AVPixelFormat.AV_PIX_FMT_NV12 */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 2,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 2,
                offset: 1,
                shift: 0,
                depth: 8
            }
        ]
    },
    /**
     * 2 字节 yuv420
     */
    [59 /* AVPixelFormat.AV_PIX_FMT_YUV420P9BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [60 /* AVPixelFormat.AV_PIX_FMT_YUV420P9LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [61 /* AVPixelFormat.AV_PIX_FMT_YUV420P10BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [62 /* AVPixelFormat.AV_PIX_FMT_YUV420P10LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [122 /* AVPixelFormat.AV_PIX_FMT_YUV420P12BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [123 /* AVPixelFormat.AV_PIX_FMT_YUV420P12LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [124 /* AVPixelFormat.AV_PIX_FMT_YUV420P14BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [125 /* AVPixelFormat.AV_PIX_FMT_YUV420P14LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [46 /* AVPixelFormat.AV_PIX_FMT_YUV420P16BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    [45 /* AVPixelFormat.AV_PIX_FMT_YUV420P16LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    /**
     * 2 字节 yuv422
     */
    [69 /* AVPixelFormat.AV_PIX_FMT_YUV422P9BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [70 /* AVPixelFormat.AV_PIX_FMT_YUV422P9LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [63 /* AVPixelFormat.AV_PIX_FMT_YUV422P10BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [64 /* AVPixelFormat.AV_PIX_FMT_YUV422P10LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [126 /* AVPixelFormat.AV_PIX_FMT_YUV422P12BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [127 /* AVPixelFormat.AV_PIX_FMT_YUV422P12LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [128 /* AVPixelFormat.AV_PIX_FMT_YUV422P14BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [129 /* AVPixelFormat.AV_PIX_FMT_YUV422P14LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [48 /* AVPixelFormat.AV_PIX_FMT_YUV422P16BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    [47 /* AVPixelFormat.AV_PIX_FMT_YUV422P16LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    /**
     * 2 字节 yuv444
     */
    [65 /* AVPixelFormat.AV_PIX_FMT_YUV444P9BE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [66 /* AVPixelFormat.AV_PIX_FMT_YUV444P9LE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [67 /* AVPixelFormat.AV_PIX_FMT_YUV444P10BE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [68 /* AVPixelFormat.AV_PIX_FMT_YUV444P10LE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [130 /* AVPixelFormat.AV_PIX_FMT_YUV444P12BE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [131 /* AVPixelFormat.AV_PIX_FMT_YUV444P12LE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [132 /* AVPixelFormat.AV_PIX_FMT_YUV444P14BE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [133 /* AVPixelFormat.AV_PIX_FMT_YUV444P14LE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [50 /* AVPixelFormat.AV_PIX_FMT_YUV444P16BE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    [49 /* AVPixelFormat.AV_PIX_FMT_YUV444P16LE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    [26 /* AVPixelFormat.AV_PIX_FMT_RGBA */]: {
        nbComponents: 4,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 32 /* PixelFormatFlags.RGB */ | 128 /* PixelFormatFlags.ALPHA */,
        comp: [
            {
                plane: 0,
                step: 4,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 1,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 2,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 3,
                shift: 0,
                depth: 8
            }
        ]
    },
    [119 /* AVPixelFormat.AV_PIX_FMT_RGB0 */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 32 /* PixelFormatFlags.RGB */,
        comp: [
            {
                plane: 0,
                step: 4,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 1,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 2,
                shift: 0,
                depth: 8
            }
        ]
    },
    [28 /* AVPixelFormat.AV_PIX_FMT_BGRA */]: {
        nbComponents: 4,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 32 /* PixelFormatFlags.RGB */ | 128 /* PixelFormatFlags.ALPHA */,
        comp: [
            {
                plane: 0,
                step: 4,
                offset: 2,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 1,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 3,
                shift: 0,
                depth: 8
            }
        ]
    },
    [121 /* AVPixelFormat.AV_PIX_FMT_BGR0 */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 32 /* PixelFormatFlags.RGB */,
        comp: [
            {
                plane: 0,
                step: 4,
                offset: 2,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 1,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [33 /* AVPixelFormat.AV_PIX_FMT_YUVA420P */]: {
        nbComponents: 4,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */ | 128 /* PixelFormatFlags.ALPHA */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 3,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    }
};


/***/ }),

/***/ "./src/avutil/sampleFormatDescriptor.ts":
/*!**********************************************!*\
  !*** ./src/avutil/sampleFormatDescriptor.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVSampleFormatDescriptors: () => (/* binding */ AVSampleFormatDescriptors)
/* harmony export */ });
const AVSampleFormatDescriptors = {
    [0 /* AVSampleFormat.AV_SAMPLE_FMT_U8 */]: {
        bits: 8,
        planar: false
    },
    [1 /* AVSampleFormat.AV_SAMPLE_FMT_S16 */]: {
        bits: 16,
        planar: false
    },
    [2 /* AVSampleFormat.AV_SAMPLE_FMT_S32 */]: {
        bits: 32,
        planar: false
    },
    [10 /* AVSampleFormat.AV_SAMPLE_FMT_S64 */]: {
        bits: 64,
        planar: false
    },
    [3 /* AVSampleFormat.AV_SAMPLE_FMT_FLT */]: {
        bits: 32,
        planar: false
    },
    [4 /* AVSampleFormat.AV_SAMPLE_FMT_DBL */]: {
        bits: 64,
        planar: false
    },
    [5 /* AVSampleFormat.AV_SAMPLE_FMT_U8P */]: {
        bits: 8,
        planar: true
    },
    [6 /* AVSampleFormat.AV_SAMPLE_FMT_S16P */]: {
        bits: 16,
        planar: true
    },
    [7 /* AVSampleFormat.AV_SAMPLE_FMT_S32P */]: {
        bits: 32,
        planar: true
    },
    [11 /* AVSampleFormat.AV_SAMPLE_FMT_S64P */]: {
        bits: 64,
        planar: true
    },
    [8 /* AVSampleFormat.AV_SAMPLE_FMT_FLTP */]: {
        bits: 32,
        planar: true
    },
    [9 /* AVSampleFormat.AV_SAMPLE_FMT_DBLP */]: {
        bits: 64,
        planar: true
    },
};


/***/ }),

/***/ "./src/avutil/stringEnum.ts":
/*!**********************************!*\
  !*** ./src/avutil/stringEnum.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AudioCodecString2CodecId: () => (/* binding */ AudioCodecString2CodecId),
/* harmony export */   Ext2Format: () => (/* binding */ Ext2Format),
/* harmony export */   Ext2IOLoader: () => (/* binding */ Ext2IOLoader),
/* harmony export */   Format2AVFormat: () => (/* binding */ Format2AVFormat),
/* harmony export */   PixfmtString2AVPixelFormat: () => (/* binding */ PixfmtString2AVPixelFormat),
/* harmony export */   SampleFmtString2SampleFormat: () => (/* binding */ SampleFmtString2SampleFormat),
/* harmony export */   SubtitleCodecString2CodecId: () => (/* binding */ SubtitleCodecString2CodecId),
/* harmony export */   VideoCodecString2CodecId: () => (/* binding */ VideoCodecString2CodecId),
/* harmony export */   colorRange2AVColorRange: () => (/* binding */ colorRange2AVColorRange),
/* harmony export */   colorSpace2AVColorSpace: () => (/* binding */ colorSpace2AVColorSpace),
/* harmony export */   disposition2AVDisposition: () => (/* binding */ disposition2AVDisposition),
/* harmony export */   mediaType2AVMediaType: () => (/* binding */ mediaType2AVMediaType)
/* harmony export */ });
/* unused harmony exports colorPrimaries2AVColorPrimaries, colorTrc2AVColorTransferCharacteristic */
const Ext2Format = {
    'flv': 0 /* AVFormat.FLV */,
    'mp4': 1 /* AVFormat.MOV */,
    'mov': 1 /* AVFormat.MOV */,
    'ts': 2 /* AVFormat.MPEGTS */,
    'ivf': 4 /* AVFormat.IVF */,
    'opus': 3 /* AVFormat.OGGS */,
    'oggs': 3 /* AVFormat.OGGS */,
    'ogg': 3 /* AVFormat.OGGS */,
    'm3u8': 2 /* AVFormat.MPEGTS */,
    'm3u': 2 /* AVFormat.MPEGTS */,
    'mpd': 1 /* AVFormat.MOV */,
    'mp3': 11 /* AVFormat.MP3 */,
    'mkv': 5 /* AVFormat.MATROSKA */,
    'mka': 5 /* AVFormat.MATROSKA */,
    'webm': 6 /* AVFormat.WEBM */,
    'aac': 12 /* AVFormat.AAC */,
    'flac': 14 /* AVFormat.FLAC */,
    'wav': 13 /* AVFormat.WAV */,
    'srt': 16 /* AVFormat.SUBRIP */,
    'vtt': 15 /* AVFormat.WEBVTT */,
    'ssa': 17 /* AVFormat.ASS */,
    'ass': 17 /* AVFormat.ASS */,
    'xml': 18 /* AVFormat.TTML */,
    'ttml': 18 /* AVFormat.TTML */,
    'h264': 8 /* AVFormat.H264 */,
    '264': 8 /* AVFormat.H264 */,
    'avc': 8 /* AVFormat.H264 */,
    'h265': 9 /* AVFormat.HEVC */,
    '265': 9 /* AVFormat.HEVC */,
    'hevc': 9 /* AVFormat.HEVC */,
    'h266': 10 /* AVFormat.VVC */,
    '266': 10 /* AVFormat.VVC */,
    'vvc': 10 /* AVFormat.VVC */
};
const Ext2IOLoader = {
    'm3u8': 2 /* IOType.HLS */,
    'm3u': 2 /* IOType.HLS */,
    'mpd': 3 /* IOType.DASH */
};
const VideoCodecString2CodecId = {
    'copy': 0 /* AVCodecID.AV_CODEC_ID_NONE */,
    'h264': 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    'avc': 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    'hevc': 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    'h265': 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    'vvc': 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    'h266': 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    'av1': 225 /* AVCodecID.AV_CODEC_ID_AV1 */,
    'vp9': 167 /* AVCodecID.AV_CODEC_ID_VP9 */,
    'vp8': 139 /* AVCodecID.AV_CODEC_ID_VP8 */,
    'mpeg4': 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
    'theora': 30 /* AVCodecID.AV_CODEC_ID_THEORA */
};
const AudioCodecString2CodecId = {
    'copy': 0 /* AVCodecID.AV_CODEC_ID_NONE */,
    'aac': 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    'ac3': 86019 /* AVCodecID.AV_CODEC_ID_AC3 */,
    'eac3': 86056 /* AVCodecID.AV_CODEC_ID_EAC3 */,
    'dca': 86020 /* AVCodecID.AV_CODEC_ID_DTS */,
    'mp3': 86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
    'opus': 86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
    'flac': 86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
    'speex': 86051 /* AVCodecID.AV_CODEC_ID_SPEEX */,
    'vorbis': 86021 /* AVCodecID.AV_CODEC_ID_VORBIS */,
    'pcm_alaw': 65543 /* AVCodecID.AV_CODEC_ID_PCM_ALAW */,
    'pcm_mulaw': 65542 /* AVCodecID.AV_CODEC_ID_PCM_MULAW */
};
const SubtitleCodecString2CodecId = {
    'webvtt': 94226 /* AVCodecID.AV_CODEC_ID_WEBVTT */,
    'subrip': 94225 /* AVCodecID.AV_CODEC_ID_SUBRIP */,
    'ass': 94230 /* AVCodecID.AV_CODEC_ID_ASS */,
    'ttml': 94232 /* AVCodecID.AV_CODEC_ID_TTML */,
    'mov_text': 94213 /* AVCodecID.AV_CODEC_ID_MOV_TEXT */,
    'hdmv_pgs': 94214 /* AVCodecID.AV_CODEC_ID_HDMV_PGS_SUBTITLE */,
    'hdmv_text': 94231 /* AVCodecID.AV_CODEC_ID_HDMV_TEXT_SUBTITLE */,
    'dvd': 94208 /* AVCodecID.AV_CODEC_ID_DVD_SUBTITLE */,
    'dvb': 94209 /* AVCodecID.AV_CODEC_ID_DVB_SUBTITLE */,
    'eia_608': 94218 /* AVCodecID.AV_CODEC_ID_EIA_608 */
};
const PixfmtString2AVPixelFormat = {
    'yuv420p': 0 /* AVPixelFormat.AV_PIX_FMT_YUV420P */,
    'yuv422p': 4 /* AVPixelFormat.AV_PIX_FMT_YUV422P */,
    'yuv444p': 5 /* AVPixelFormat.AV_PIX_FMT_YUV444P */,
    'yuva420p': 33 /* AVPixelFormat.AV_PIX_FMT_YUVA420P */,
    'yuva422p': 78 /* AVPixelFormat.AV_PIX_FMT_YUVA422P */,
    'yuva444p': 79 /* AVPixelFormat.AV_PIX_FMT_YUVA444P */,
    'yuv420p10le': 62 /* AVPixelFormat.AV_PIX_FMT_YUV420P10LE */,
    'yuv422p10le': 64 /* AVPixelFormat.AV_PIX_FMT_YUV422P10LE */,
    'yuv444p10le': 68 /* AVPixelFormat.AV_PIX_FMT_YUV444P10LE */,
    'yuva420p10le': 87 /* AVPixelFormat.AV_PIX_FMT_YUVA420P10LE */,
    'yuva422p10le': 89 /* AVPixelFormat.AV_PIX_FMT_YUVA422P10LE */,
    'yuva444p10le': 91 /* AVPixelFormat.AV_PIX_FMT_YUVA444P10LE */,
    'yuv420p10be': 61 /* AVPixelFormat.AV_PIX_FMT_YUV420P10BE */,
    'yuv422p10be': 63 /* AVPixelFormat.AV_PIX_FMT_YUV422P10BE */,
    'yuv444p10be': 67 /* AVPixelFormat.AV_PIX_FMT_YUV444P10BE */,
    'yuva420p10be': 86 /* AVPixelFormat.AV_PIX_FMT_YUVA420P10BE */,
    'yuva422p10be': 88 /* AVPixelFormat.AV_PIX_FMT_YUVA422P10BE */,
    'yuva444p10be': 90 /* AVPixelFormat.AV_PIX_FMT_YUVA444P10BE */,
};
const SampleFmtString2SampleFormat = {
    'u8': 0 /* AVSampleFormat.AV_SAMPLE_FMT_U8 */,
    'u8-planar': 5 /* AVSampleFormat.AV_SAMPLE_FMT_U8P */,
    's16': 1 /* AVSampleFormat.AV_SAMPLE_FMT_S16 */,
    's16-planar': 6 /* AVSampleFormat.AV_SAMPLE_FMT_S16P */,
    's32': 2 /* AVSampleFormat.AV_SAMPLE_FMT_S32 */,
    's32-planar': 7 /* AVSampleFormat.AV_SAMPLE_FMT_S32P */,
    's64': 10 /* AVSampleFormat.AV_SAMPLE_FMT_S64 */,
    's64-planar': 11 /* AVSampleFormat.AV_SAMPLE_FMT_S64P */,
    'float': 3 /* AVSampleFormat.AV_SAMPLE_FMT_FLT */,
    'float-planar': 8 /* AVSampleFormat.AV_SAMPLE_FMT_FLTP */,
    'double': 4 /* AVSampleFormat.AV_SAMPLE_FMT_DBL */,
    'double-planar': 9 /* AVSampleFormat.AV_SAMPLE_FMT_DBLP */,
};
const Format2AVFormat = {
    'flv': 0 /* AVFormat.FLV */,
    'mp4': 1 /* AVFormat.MOV */,
    'mov': 1 /* AVFormat.MOV */,
    'ts': 2 /* AVFormat.MPEGTS */,
    'mpegts': 2 /* AVFormat.MPEGTS */,
    'ivf': 4 /* AVFormat.IVF */,
    'opus': 3 /* AVFormat.OGGS */,
    'ogg': 3 /* AVFormat.OGGS */,
    'm3u8': 2 /* AVFormat.MPEGTS */,
    'm3u': 2 /* AVFormat.MPEGTS */,
    'mpd': 1 /* AVFormat.MOV */,
    'mp3': 11 /* AVFormat.MP3 */,
    'mkv': 5 /* AVFormat.MATROSKA */,
    'matroska': 5 /* AVFormat.MATROSKA */,
    'mka': 5 /* AVFormat.MATROSKA */,
    'webm': 6 /* AVFormat.WEBM */,
    'aac': 12 /* AVFormat.AAC */,
    'flac': 14 /* AVFormat.FLAC */,
    'wav': 13 /* AVFormat.WAV */,
    'raw_h264': 8 /* AVFormat.H264 */,
    'raw_h265': 9 /* AVFormat.HEVC */,
    'raw_vvc': 10 /* AVFormat.VVC */
};
const colorRange2AVColorRange = {
    'tv': 1 /* AVColorRange.AVCOL_RANGE_MPEG */,
    'pc': 2 /* AVColorRange.AVCOL_RANGE_JPEG */
};
const colorSpace2AVColorSpace = {
    'bt709': 1 /* AVColorSpace.AVCOL_SPC_BT709 */,
    'fcc': 4 /* AVColorSpace.AVCOL_SPC_FCC */,
    'bt470bg': 5 /* AVColorSpace.AVCOL_SPC_BT470BG */,
    'smpte170m': 6 /* AVColorSpace.AVCOL_SPC_SMPTE170M */,
    'smpte240m': 7 /* AVColorSpace.AVCOL_SPC_SMPTE240M */,
    'ycgco': 8 /* AVColorSpace.AVCOL_SPC_YCGCO */,
    'gbr': 0 /* AVColorSpace.AVCOL_SPC_RGB */,
    'bt2020ncl': 9 /* AVColorSpace.AVCOL_SPC_BT2020_NCL */
};
const colorPrimaries2AVColorPrimaries = {
    'bt709': 1 /* AVColorPrimaries.AVCOL_PRI_BT709 */,
    'bt470m': 4 /* AVColorPrimaries.AVCOL_PRI_BT470M */,
    'bt470bg': 5 /* AVColorPrimaries.AVCOL_PRI_BT470BG */,
    'smpte170m': 6 /* AVColorPrimaries.AVCOL_PRI_SMPTE170M */,
    'smpte240m': 7 /* AVColorPrimaries.AVCOL_PRI_SMPTE240M */,
    'smpte428': 10 /* AVColorPrimaries.AVCOL_PRI_SMPTE428 */,
    'film': 8 /* AVColorPrimaries.AVCOL_PRI_FILM */,
    'smpte431': 11 /* AVColorPrimaries.AVCOL_PRI_SMPTE431 */,
    'smpte432': 12 /* AVColorPrimaries.AVCOL_PRI_SMPTE432 */,
    'bt2020': 9 /* AVColorPrimaries.AVCOL_PRI_BT2020 */,
    'jedec-p22': 22 /* AVColorPrimaries.AVCOL_PRI_JEDEC_P22 */,
    'ebu3213': 22 /* AVColorPrimaries.AVCOL_PRI_EBU3213 */
};
const colorTrc2AVColorTransferCharacteristic = {
    'bt709': 1 /* AVColorTransferCharacteristic.AVCOL_TRC_BT709 */,
    'gamma22': 4 /* AVColorTransferCharacteristic.AVCOL_TRC_GAMMA22 */,
    'gamma28': 5 /* AVColorTransferCharacteristic.AVCOL_TRC_GAMMA28 */,
    'smpte170m': 6 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE170M */,
    'smpte240m': 7 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE240M */,
    'srgb': 13 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_1 */,
    'xvycc': 11 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4 */,
    'bt2020-10': 14 /* AVColorTransferCharacteristic.AVCOL_TRC_BT2020_10 */,
    'bt2020-12': 15 /* AVColorTransferCharacteristic.AVCOL_TRC_BT2020_12 */
};
const mediaType2AVMediaType = {
    'Audio': 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */,
    'Video': 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */,
    'Subtitle': 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */,
    'Attachment': 4 /* AVMediaType.AVMEDIA_TYPE_ATTACHMENT */,
    'Data': 2 /* AVMediaType.AVMEDIA_TYPE_DATA */
};
const disposition2AVDisposition = {
    'default': 1 /* AVDisposition.DEFAULT */,
    'dub': 2 /* AVDisposition.DUB */,
    'original': 4 /* AVDisposition.ORIGINAL */,
    'comment': 8 /* AVDisposition.COMMENT */,
    'lyrics': 16 /* AVDisposition.LYRICS */,
    'karaoke': 32 /* AVDisposition.KARAOKE */,
    'forced': 64 /* AVDisposition.FORCED */,
    'hearing impaired': 128 /* AVDisposition.HEARING_IMPAIRED */,
    'visual impaired': 256 /* AVDisposition.VISUAL_IMPAIRED */,
    'clean effects': 512 /* AVDisposition.CLEAN_EFFECTS */,
    'attached pic': 1024 /* AVDisposition.ATTACHED_PIC */,
    'timed thumbnails': 2048 /* AVDisposition.TIMED_THUMBNAILS */,
    'captions': 65536 /* AVDisposition.CAPTIONS */,
    'descriptions': 131072 /* AVDisposition.DESCRIPTIONS */,
    'metadata': 262144 /* AVDisposition.METADATA */,
    'dependent': 524288 /* AVDisposition.DEPENDENT */,
    'still image': 1048576 /* AVDisposition.STILL_IMAGE */
};


/***/ }),

/***/ "./src/avutil/struct/audiosample.ts":
/*!******************************************!*\
  !*** ./src/avutil/struct/audiosample.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVChannelLayout: () => (/* binding */ AVChannelLayout)
/* harmony export */ });
/* unused harmony export AVChannelCustom */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


class AVChannelCustom {
    id;
    name;
    opaque;
}
(function (prototype) {
    var map = new Map();
    map.set("id", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("name", { 0: 4, 1: 0, 2: 0, 3: 1, 4: 16, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 24);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVChannelCustom.prototype);
class AVChannelLayout {
    /**
     * Channel order used in this layout.
     * This is a mandatory field.
     */
    order;
    /**
     * Number of channels in this layout. Mandatory field.
     */
    nbChannels;
    /**
     * Details about which channels are present in this layout.
     * For AV_CHANNEL_ORDER_UNSPEC, this field is undefined and must not be
     * used.
     */
    u;
    /**
     * For some private data of the user.
     */
    opaque;
}
(function (prototype) {
    var map = new Map();
    map.set("order", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("nbChannels", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("u", { 0: (function (prototype) {
            var map = new Map();
            map.set("mask", { 0: 10, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
            map.set("map", { 0: AVChannelCustom, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
            return prototype;
        })({}), 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 24);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVChannelLayout.prototype);


/***/ }),

/***/ "./src/avutil/struct/avbuffer.ts":
/*!***************************************!*\
  !*** ./src/avutil/struct/avbuffer.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVBufferRef: () => (/* binding */ AVBufferRef)
/* harmony export */ });
/* unused harmony exports AVBuffer, AVBufferPool, BufferPoolEntry */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\..\cheap\thread\mutex.ts */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
var cheap__BufferPoolEntry__16;



/*
 * libmedia AVBuffer defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class AVBuffer {
    /**
     * data described by this buffer
     */
    data = 0;
    /**
     * size of data in bytes
     */
    size = 0;
    /**
     *  number of existing AVBufferRef instances referring to this buffer
     */
    refcount = 0;
    /**
     * a callback for freeing the data
     */
    free = 0;
    /**
     * an opaque pointer, to be used by the freeing callback
     */
    opaque = 0;
    /**
     * A combination of AV_BUFFER_FLAG_*
     */
    flags = 0 /* AVBufferFlags.NONE */;
    /**
     * A combination of BUFFER_FLAG_*
     */
    flagsInternal = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("refcount", { 0: 9, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("free", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("flagsInternal", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 28);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVBuffer.prototype);
function avbufferDefaultFree(opaque, data) {
    (0,_util_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(data);
}
class AVBufferRef {
    buffer = 0;
    /**
     * The data buffer. It is considered writable if and only if
     * this is the only reference to the buffer, in which case
     * av_buffer_is_writable() returns 1.
     */
    data = 0;
    /**
     * Size of data in bytes.
     */
    size = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("buffer", { 0: AVBuffer, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVBufferRef.prototype);
class AVBufferPool {
    mutex;
    pool = 0;
    /**
     *  number of existing AVBufferRef instances referring to this buffer
     */
    refcount = 0;
    /**
     * Size of data in bytes.
     */
    size = 0;
    /**
     * an opaque pointer, to be used by the freeing callback
     */
    opaque = 0;
    alloc = 0;
    alloc2 = 0;
    poolFree = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("mutex", { 0: _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_2__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("pool", { 0: cheap__BufferPoolEntry__16, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("refcount", { 0: 9, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("alloc", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("alloc2", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("poolFree", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 32);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVBufferPool.prototype);
class BufferPoolEntry {
    data = 0;
    /**
     * an opaque pointer, to be used by the freeing callback
     */
    opaque = 0;
    /**
     * a callback for freeing the data
     */
    free = 0;
    pool = 0;
    next = 0;
    /*
     * An AVBuffer structure to (re)use as AVBuffer for subsequent uses
     * of this BufferPoolEntry.
     */
    buffer;
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("free", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("pool", { 0: AVBufferPool, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("next", { 0: BufferPoolEntry, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("buffer", { 0: AVBuffer, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 48);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(BufferPoolEntry.prototype);
cheap__BufferPoolEntry__16 = BufferPoolEntry;


/***/ }),

/***/ "./src/avutil/struct/avcodecparameters.ts":
/*!************************************************!*\
  !*** ./src/avutil/struct/avcodecparameters.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVCodecParameters)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _avpacket_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./avpacket.ts */ "./src/avutil/struct/avpacket.ts");
/* harmony import */ var _rational_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rational */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _audiosample_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./audiosample.ts */ "./src/avutil/struct/audiosample.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _util_codecparameters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/codecparameters */ "./src/avutil/util/codecparameters.ts");





/*
 * libmedia AVCodecParameters defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




/**
 * FFmpeg AVCodecParameters 定义
 */
class AVCodecParameters {
    /**
     * General type of the encoded data.
     */
    codecType = -1 /* AVMediaType.AVMEDIA_TYPE_UNKNOWN */;
    /**
     * Specific type of the encoded data (the codec used).
     */
    codecId = 0 /* AVCodecID.AV_CODEC_ID_NONE */;
    /**
     * Additional information about the codec (corresponds to the AVI FOURCC).
     */
    codecTag = 0;
    /**
     * Extra binary data needed for initializing the decoder, codec-dependent.
     *
     * Must be allocated with av_malloc() and will be freed by
     * avcodec_parameters_free(). The allocated size of extradata must be at
     * least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding
     * bytes zeroed.
     */
    extradata = 0;
    extradataSize = 0;
    /**
     * Additional data associated with the entire stream.
     *
     * Should be allocated with av_packet_side_data_new() or
     * av_packet_side_data_add(), and will be freed by avcodec_parameters_free().
     */
    codedSideData = 0;
    /**
     * Amount of entries in @ref coded_side_data.
     */
    nbCodedSideData = 0;
    /**
     * - video: the pixel format, the value corresponds to enum AVPixelFormat.
     * - audio: the sample format, the value corresponds to enum AVSampleFormat.
     */
    format = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * The average bitrate of the encoded data (in bits per second).
     */
    bitRate = BigInt(0);
    /**
     * The number of bits per sample in the codedwords.
     *
     * This is basically the bitrate per sample. It is mandatory for a bunch of
     * formats to actually decode them. It's the number of bits for one sample in
     * the actual coded bitstream.
     *
     * This could be for example 4 for ADPCM
     * For PCM formats this matches bits_per_raw_sample
     * Can be 0
     */
    bitsPerCodedSample = 0;
    /**
     * This is the number of valid bits in each output sample. If the
     * sample format has more bits, the least significant bits are additional
     * padding bits, which are always 0. Use right shifts to reduce the sample
     * to its actual size. For example, audio formats with 24 bit samples will
     * have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.
     * To get the original sample use "(int32_t)sample >> 8"."
     *
     * For ADPCM this might be 12 or 16 or similar
     * Can be 0
     */
    bitsPerRawSample = 0;
    /**
     * Codec-specific bitstream restrictions that the stream conforms to.
     */
    profile = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    level = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * Video only. The dimensions of the video frame in pixels.
     */
    width = 0;
    height = 0;
    /**
     * Video only. The aspect ratio (width / height) which a single pixel
     * should have when displayed.
     *
     * When the aspect ratio is unknown / undefined, the numerator should be
     * set to 0 (the denominator may have any value).
     */
    sampleAspectRatio = new _rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational({ den: 1, num: 1 });
    /**
     * Video only. Number of frames per second, for streams with constant frame
     * durations. Should be set to { 0, 1 } when some frames have differing
     * durations or if the value is not known.
     *
     * @note This field correponds to values that are stored in codec-level
     * headers and is typically overridden by container/transport-layer
     * timestamps, when available. It should thus be used only as a last resort,
     * when no higher-level timing information is available.
     */
    framerate = new _rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational({ den: 1, num: 0 });
    /**
     * Video only. The order of the fields in interlaced video.
     */
    fieldOrder = 0 /* AVFieldOrder.AV_FIELD_UNKNOWN */;
    /**
     * Video only. Additional colorspace characteristics.
     */
    colorRange = 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */;
    colorPrimaries = 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */;
    colorTrc = 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */;
    colorSpace = 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */;
    chromaLocation = 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */;
    /**
     * Video only. Number of delayed frames.
     */
    videoDelay = 0;
    /**
     * Audio only. The channel layout and number of channels.
     */
    chLayout;
    /**
     * Audio only. The number of audio samples per second.
     */
    sampleRate = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * Audio only. The number of bytes per coded audio frame, required by some
     * formats.
     *
     * Corresponds to nBlockAlign in WAVEFORMATEX.
     */
    blockAlign = 0;
    /**
     * Audio only. Audio frame size, if known. Required by some formats to be static.
     */
    frameSize = 0;
    /**
     * Audio only. The amount of padding (in samples) inserted by the encoder at
     * the beginning of the audio. I.e. this number of leading decoded samples
     * must be discarded by the caller to get the original audio without leading
     * padding.
     */
    initialPadding = 0;
    /**
     * Audio only. The amount of padding (in samples) appended by the encoder to
     * the end of the audio. I.e. this number of decoded samples must be
     * discarded by the caller from the end of the stream to get the original
     * audio without any trailing padding.
     */
    trailingPadding = 0;
    /**
     * Audio only. Number of samples to skip after a discontinuity.
     */
    seekPreroll = 0;
    /**
     * 码流格式
     * 对于 h264/h265/h266 标记是 annexb 还是 avcc 格式
     */
    bitFormat = 0;
    destroy() {
        (0,_util_codecparameters__WEBPACK_IMPORTED_MODULE_6__.freeCodecParameters)(this[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
        this[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] = 0;
    }
}
(function (prototype) {
    var map = new Map();
    map.set("codecType", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("codecId", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("codecTag", { 0: 8, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("extradata", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("extradataSize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("codedSideData", { 0: _avpacket_ts__WEBPACK_IMPORTED_MODULE_2__.AVPacketSideData, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("nbCodedSideData", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("format", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    map.set("bitRate", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    map.set("bitsPerCodedSample", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 40, 8: 0 });
    map.set("bitsPerRawSample", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 44, 8: 0 });
    map.set("profile", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 48, 8: 0 });
    map.set("level", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 52, 8: 0 });
    map.set("width", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 56, 8: 0 });
    map.set("height", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 60, 8: 0 });
    map.set("sampleAspectRatio", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("framerate", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("fieldOrder", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    map.set("colorRange", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 84, 8: 0 });
    map.set("colorPrimaries", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 88, 8: 0 });
    map.set("colorTrc", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 92, 8: 0 });
    map.set("colorSpace", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 96, 8: 0 });
    map.set("chromaLocation", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 100, 8: 0 });
    map.set("videoDelay", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 104, 8: 0 });
    map.set("chLayout", { 0: _audiosample_ts__WEBPACK_IMPORTED_MODULE_4__.AVChannelLayout, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 112, 8: 0 });
    map.set("sampleRate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 136, 8: 0 });
    map.set("blockAlign", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 140, 8: 0 });
    map.set("frameSize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 144, 8: 0 });
    map.set("initialPadding", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 148, 8: 0 });
    map.set("trailingPadding", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 152, 8: 0 });
    map.set("seekPreroll", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 156, 8: 0 });
    map.set("bitFormat", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 160, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 168);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVCodecParameters.prototype);


/***/ }),

/***/ "./src/avutil/struct/avdict.ts":
/*!*************************************!*\
  !*** ./src/avutil/struct/avdict.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVDictionary: () => (/* binding */ AVDictionary)
/* harmony export */ });
/* unused harmony export AVDictionaryEntry */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


class AVDictionaryEntry {
    key = 0;
    value = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("key", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("value", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVDictionaryEntry.prototype);
class AVDictionary {
    count = 0;
    elems = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("count", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("elems", { 0: AVDictionaryEntry, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVDictionary.prototype);


/***/ }),

/***/ "./src/avutil/struct/avframe.ts":
/*!**************************************!*\
  !*** ./src/avutil/struct/avframe.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AV_NUM_DATA_POINTERS: () => (/* binding */ AV_NUM_DATA_POINTERS)
/* harmony export */ });
/* unused harmony exports AVFrameSideData, AVMasteringDisplayMetadata, AVContentLightMetadata, default, AVFrameRef */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _avdict_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./avdict.ts */ "./src/avutil/struct/avdict.ts");
/* harmony import */ var _avbuffer_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./avbuffer.ts */ "./src/avutil/struct/avbuffer.ts");
/* harmony import */ var _rational_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rational */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var _audiosample_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./audiosample.ts */ "./src/avutil/struct/audiosample.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _util_avframe__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/avframe */ "./src/avutil/util/avframe.ts");







/*
 * libmedia AVFrame defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




const AV_NUM_DATA_POINTERS = 8;
class AVFrameSideData {
    type = 0;
    data = 0;
    size = 0;
    metadata = 0;
    buf = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("type", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("metadata", { 0: _avdict_ts__WEBPACK_IMPORTED_MODULE_2__.AVDictionary, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("buf", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_3__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 20);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVFrameSideData.prototype);
class AVMasteringDisplayMetadata {
    /**
     * CIE 1931 xy chromaticity coords of color primaries (r, g, b order).
     */
    displayPrimaries;
    /**
     * CIE 1931 xy chromaticity coords of white point.
     */
    whitePoint;
    /**
     * Min luminance of mastering display (cd/m^2).
     */
    minLuminance;
    /**
     * Max luminance of mastering display (cd/m^2).
     */
    maxLuminance;
    /**
     * Flag indicating whether the display primaries (and white point) are set.
     */
    hasPrimaries;
    /**
     * Flag indicating whether the luminance (min_ and max_) have been set.
     */
    hasLuminance;
}
(function (prototype) {
    var map = new Map();
    map.set("displayPrimaries", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 1, 4: 6, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("whitePoint", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 1, 4: 2, 5: 0, 6: 0, 7: 48, 8: 0 });
    map.set("minLuminance", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("maxLuminance", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("hasPrimaries", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    map.set("hasLuminance", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 84, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 88);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVMasteringDisplayMetadata.prototype);
class AVContentLightMetadata {
    /**
     * Max content light level (cd/m^2).
     */
    maxCLL;
    /**
     * Max average light level per frame (cd/m^2).
     */
    maxFALL;
}
(function (prototype) {
    var map = new Map();
    map.set("maxCLL", { 0: 8, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("maxFALL", { 0: 8, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVContentLightMetadata.prototype);
/**
 * FFmpeg AVFrame 定义
 */
class AVFrame {
    /**
     * pointer to the picture/channel planes.
     * This might be different from the first allocated byte
     *
     * Some decoders access areas outside 0,0 - width, height, please
     * see avcodec_align_dimensions2(). Some filters and swscale can read
     * up to 16 bytes beyond the planes, if these filters are to be used,
     * then 16 extra bytes must be allocated.
     *
     * NOTE: Except for hwaccel formats, pointers not needed by the format
     * MUST be set to NULL.
     */
    data = new Array(AV_NUM_DATA_POINTERS).fill(0, 0, AV_NUM_DATA_POINTERS);
    /**
     * For video, size in bytes of each picture line.
     * For audio, size in bytes of each plane.
     *
     * For audio, only linesize[0] may be set. For planar audio, each channel
     * plane must be the same size.
     *
     * For video the linesizes should be multiples of the CPUs alignment
     * preference, this is 16 or 32 for modern desktop CPUs.
     * Some code requires such alignment other code can be slower without
     * correct alignment, for yet other it makes no difference.
     *
     * @note The linesize may be larger than the size of usable data -- there
     * may be extra padding present for performance reasons.
     */
    linesize = new Array(AV_NUM_DATA_POINTERS).fill(0, 0, AV_NUM_DATA_POINTERS);
    /**
     * pointers to the data planes/channels.
     *
     * For video, this should simply point to data[].
     *
     * For planar audio, each channel has a separate data pointer, and
     * linesize[0] contains the size of each channel buffer.
     * For packed audio, there is just one data pointer, and linesize[0]
     * contains the total size of the buffer for all channels.
     *
     * Note: Both data and extended_data should always be set in a valid frame,
     * but for planar audio with more channels that can fit in data,
     * extended_data must be used in order to access all channels.
     */
    extendedData = 0;
    /**
     * @name Video dimensions
     * Video frames only. The coded dimensions (in pixels) of the video frame,
     * i.e. the size of the rectangle that contains some well-defined values.
     *
     * @note The part of the frame intended for display/presentation is further
     * restricted by the @ref cropping "Cropping rectangle".
     *
     */
    width = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    height = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * number of audio samples (per channel) described by this frame
     */
    nbSamples = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * format of the frame, -1 if unknown or unset
     * Values correspond to enum AVPixelFormat for video frames,
     * enum AVSampleFormat for audio)
     */
    format = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * 1 -> keyframe, 0-> not
     *
     * @deprecated Use AV_FRAME_FLAG_KEY instead
     */
    keyFrame = 0;
    /**
     * Picture type of the frame.
     */
    pictType = 0 /* AVPictureType.AV_PICTURE_TYPE_NONE */;
    /**
     * Sample aspect ratio for the video frame, 0/1 if unknown/unspecified.
     */
    sampleAspectRatio = new _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational({ den: 1, num: 0 });
    /**
     * Presentation timestamp in time_base units (time when frame should be shown to user).
     */
    pts = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE_BIGINT;
    /**
     * DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn't used)
     * This is also the Presentation time of this AVFrame calculated from
     * only AVPacket.dts values without pts values.
     */
    pktDts = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE_BIGINT;
    /**
     * Time base for the timestamps in this frame.
     * In the future, this field may be set on frames output by decoders or
     * filters, but its value will be by default ignored on input to encoders
     * or filters.
     */
    timeBase;
    /**
     * quality (between 1 (good) and FF_LAMBDA_MAX (bad))
     */
    quality = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * Frame owner's private data.
     *
     * This field may be set by the code that allocates/owns the frame data.
     * It is then not touched by any library functions, except:
     * - it is copied to other references by av_frame_copy_props() (and hence by
     *   av_frame_ref());
     * - it is set to NULL when the frame is cleared by av_frame_unref()
     * - on the caller's explicit request. E.g. libavcodec encoders/decoders
     *   will copy this field to/from @ref AVPacket "AVPackets" if the caller sets
     *   @ref AV_CODEC_FLAG_COPY_OPAQUE.
     *
     * @see opaque_ref the reference-counted analogue
     */
    opaque = 0;
    /**
     * Number of fields in this frame which should be repeated, i.e. the total
     * duration of this frame should be repeat_pict + 2 normal field durations.
     *
     * For interlaced frames this field may be set to 1, which signals that this
     * frame should be presented as 3 fields: beginning with the first field (as
     * determined by AV_FRAME_FLAG_TOP_FIELD_FIRST being set or not), followed
     * by the second field, and then the first field again.
     *
     * For progressive frames this field may be set to a multiple of 2, which
     * signals that this frame's duration should be (repeat_pict + 2) / 2
     * normal frame durations.
     *
     * @note This field is computed from MPEG2 repeat_first_field flag and its
     * associated flags, H.264 pic_struct from picture timing SEI, and
     * their analogues in other codecs. Typically it should only be used when
     * higher-layer timing information is not available.
     */
    repeatPict = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * The content of the picture is interlaced.
     *
     * @deprecated Use AV_FRAME_FLAG_INTERLACED instead
     */
    interlacedFrame = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * If the content is interlaced, is top field displayed first.
     *
     * @deprecated Use AV_FRAME_FLAG_TOP_FIELD_FIRST instead
     */
    topFieldFirst = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * Tell user application that palette has changed from previous frame.
     *  @deprecated
     */
    paletteHasChanged = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * Sample rate of the audio data.
     */
    sampleRate = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * AVBuffer references backing the data for this frame. If all elements of
     * this array are NULL, then this frame is not reference counted. This array
     * must be filled contiguously -- if buf[i] is non-NULL then buf[j] must
     * also be non-NULL for all j < i.
     *
     * There may be at most one AVBuffer per data plane, so for video this array
     * always contains all the references. For planar audio with more than
     * AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in
     * this array. Then the extra AVBufferRef pointers are stored in the
     * extended_buf array.
     */
    buf = new Array(AV_NUM_DATA_POINTERS).fill(0, 0, AV_NUM_DATA_POINTERS);
    /**
     * For planar audio which requires more than AV_NUM_DATA_POINTERS
     * AVBufferRef pointers, this array will hold all the references which
     * cannot fit into AVFrame.buf.
     *
     * Note that this is different from AVFrame.extended_data, which always
     * contains all the pointers. This array only contains the extra pointers,
     * which cannot fit into AVFrame.buf.
     *
     * This array is always allocated using av_malloc() by whoever constructs
     * the frame. It is freed in av_frame_unref().
     */
    extendedBuf = 0;
    /**
     * Number of elements in extended_buf.
     */
    nbExtendedBuf = 0;
    sideData = 0;
    nbSideData = 0;
    /**
     * Frame flags, a combination of @ref lavu_frame_flags
     */
    flags = 0 /* AVFrameFlags.AV_FRAME_FLAG_NONE */;
    /**
     * MPEG vs JPEG YUV range.
     * - encoding: Set by user
     * - decoding: Set by libavcodec
     */
    colorRange = 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */;
    colorPrimaries = 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */;
    colorTrc = 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */;
    /**
     * YUV colorspace type.
     * - encoding: Set by user
     * - decoding: Set by libavcodec
     */
    colorSpace = 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */;
    chromaLocation = 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */;
    /**
     * frame timestamp estimated using various heuristics, in stream time base
     * - encoding: unused
     * - decoding: set by libavcodec, read by user.
     */
    bestEffortTimestamp = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE_BIGINT;
    /**
     * reordered pos from the last AVPacket that has been input into the decoder
     * - encoding: unused
     * - decoding: Read by user.
     * @deprecated use AV_CODEC_FLAG_COPY_OPAQUE to pass through arbitrary user
     *             data from packets to frames
     */
    pktPos = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE_BIGINT;
    /**
     * metadata.
     * - encoding: Set by user.
     * - decoding: Set by libavcodec.
     */
    metadata = 0;
    /**
     * decode error flags of the frame, set to a combination of
     * FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there
     * were errors during the decoding.
     * - encoding: unused
     * - decoding: set by libavcodec, read by user.
     */
    decodeErrorFlags = 0 /* FFDecodeError.NONE */;
    /**
     * size of the corresponding packet containing the compressed
     * frame.
     * It is set to a negative value if unknown.
     * - encoding: unused
     * - decoding: set by libavcodec, read by user.
     * @deprecated use AV_CODEC_FLAG_COPY_OPAQUE to pass through arbitrary user
     *             data from packets to frames
     */
    pktSize = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * For hwaccel-format frames, this should be a reference to the
     * AVHWFramesContext describing the frame.
     */
    hwFramesCtx = 0;
    /**
     * AVBufferRef for free use by the API user. FFmpeg will never check the
     * contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when
     * the frame is unreferenced. av_frame_copy_props() calls create a new
     * reference with av_buffer_ref() for the target frame's opaque_ref field.
     *
     * This is unrelated to the opaque field, although it serves a similar
     * purpose.
     */
    opaqueRef = 0;
    /**
     * @anchor cropping
     * @name Cropping
     * Video frames only. The number of pixels to discard from the the
     * top/bottom/left/right border of the frame to obtain the sub-rectangle of
     * the frame intended for presentation.
     */
    cropTop = 0;
    cropBottom = 0;
    cropLeft = 0;
    cropRight = 0;
    /**
     * AVBufferRef for internal use by a single libav* library.
     * Must not be used to transfer data between libraries.
     * Has to be NULL when ownership of the frame leaves the respective library.
     *
     * Code outside the FFmpeg libs should never check or change the contents of the buffer ref.
     *
     * FFmpeg calls av_buffer_unref() on it when the frame is unreferenced.
     * av_frame_copy_props() calls create a new reference with av_buffer_ref()
     * for the target frame's private_ref field.
     */
    privateRef = 0;
    /**
     * Channel layout of the audio data.
     */
    chLayout;
    /**
     * Duration of the frame, in the same units as pts. 0 if unknown.
     */
    duration = BigInt(0);
    close() {
        (0,_util_avframe__WEBPACK_IMPORTED_MODULE_8__.unrefAVFrame)(this[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
        (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_5__["default"])(this);
    }
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 1, 4: 8, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("linesize", { 0: 15, 1: 0, 2: 0, 3: 1, 4: 8, 5: 0, 6: 0, 7: 32, 8: 0 });
    map.set("extendedData", { 0: 2, 1: 1, 2: 2, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("width", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 68, 8: 0 });
    map.set("height", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("nbSamples", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 76, 8: 0 });
    map.set("format", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    map.set("keyFrame", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 84, 8: 0 });
    map.set("pictType", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 88, 8: 0 });
    map.set("sampleAspectRatio", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 92, 8: 0 });
    map.set("pts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 104, 8: 0 });
    map.set("pktDts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 112, 8: 0 });
    map.set("timeBase", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 120, 8: 0 });
    map.set("quality", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 128, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 132, 8: 0 });
    map.set("repeatPict", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 136, 8: 0 });
    map.set("interlacedFrame", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 140, 8: 0 });
    map.set("topFieldFirst", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 144, 8: 0 });
    map.set("paletteHasChanged", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 148, 8: 0 });
    map.set("sampleRate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 152, 8: 0 });
    map.set("buf", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_3__.AVBufferRef, 1: 1, 2: 1, 3: 1, 4: 8, 5: 0, 6: 0, 7: 156, 8: 0 });
    map.set("extendedBuf", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_3__.AVBufferRef, 1: 1, 2: 2, 3: 0, 4: 0, 5: 0, 6: 0, 7: 188, 8: 0 });
    map.set("nbExtendedBuf", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 192, 8: 0 });
    map.set("sideData", { 0: AVFrameSideData, 1: 1, 2: 2, 3: 0, 4: 0, 5: 0, 6: 0, 7: 196, 8: 0 });
    map.set("nbSideData", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 200, 8: 0 });
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 204, 8: 0 });
    map.set("colorRange", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 208, 8: 0 });
    map.set("colorPrimaries", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 212, 8: 0 });
    map.set("colorTrc", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 216, 8: 0 });
    map.set("colorSpace", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 220, 8: 0 });
    map.set("chromaLocation", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 224, 8: 0 });
    map.set("bestEffortTimestamp", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 232, 8: 0 });
    map.set("pktPos", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 240, 8: 0 });
    map.set("metadata", { 0: _avdict_ts__WEBPACK_IMPORTED_MODULE_2__.AVDictionary, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 248, 8: 0 });
    map.set("decodeErrorFlags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 252, 8: 0 });
    map.set("pktSize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 256, 8: 0 });
    map.set("hwFramesCtx", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_3__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 260, 8: 0 });
    map.set("opaqueRef", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_3__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 264, 8: 0 });
    map.set("cropTop", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 268, 8: 0 });
    map.set("cropBottom", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 272, 8: 0 });
    map.set("cropLeft", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 276, 8: 0 });
    map.set("cropRight", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 280, 8: 0 });
    map.set("privateRef", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_3__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 284, 8: 0 });
    map.set("chLayout", { 0: _audiosample_ts__WEBPACK_IMPORTED_MODULE_6__.AVChannelLayout, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 288, 8: 0 });
    map.set("duration", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 312, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 320);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVFrame.prototype);
class AVFrameRef extends AVFrame {
    refCount;
}
(function (prototype) {
    var map = new Map();
    map.set("refCount", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 320, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 328);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVFrameRef.prototype);


/***/ }),

/***/ "./src/avutil/struct/avpacket.ts":
/*!***************************************!*\
  !*** ./src/avutil/struct/avpacket.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVPacketSideData: () => (/* binding */ AVPacketSideData)
/* harmony export */ });
/* unused harmony exports default, AVPacketRef */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _avbuffer_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./avbuffer.ts */ "./src/avutil/struct/avbuffer.ts");
/* harmony import */ var _rational_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rational */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");






class AVPacketSideData {
    data = 0;
    size = _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE;
    type = -1 /* AVPacketSideDataType.AV_PKT_DATA_UNKNOWN */;
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("type", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVPacketSideData.prototype);
/**
 * FFmpeg AVPacket 定义
 */
class AVPacket {
    /**
     * A reference to the reference-counted buffer where the packet data is
     * stored.
     * May be NULL, then the packet data is not reference-counted.
     */
    buf = 0;
    /**
     * Presentation timestamp in AVStream->time_base units; the time at which
     * the decompressed packet will be presented to the user.
     * Can be AV_NOPTS_VALUE if it is not stored in the file.
     * pts MUST be larger or equal to dts as presentation cannot happen before
     * decompression, unless one wants to view hex dumps. Some formats misuse
     * the terms dts and pts/cts to mean something different. Such timestamps
     * must be converted to true pts/dts before they are stored in AVPacket.
     */
    pts = _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT;
    /**
     * Decompression timestamp in AVStream->time_base units; the time at which
     * the packet is decompressed.
     * Can be AV_NOPTS_VALUE if it is not stored in the file.
     */
    dts = _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT;
    data = 0;
    size = 0;
    streamIndex = _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE;
    /**
     * A combination of @AVPacketFlags values
     */
    flags = 0;
    /**
     * Additional packet data that can be provided by the container.
     * Packet can contain several types of side information.
     */
    sideData = 0;
    sideDataElems = 0;
    /**
     * Duration of this packet in AVStream->time_base units, 0 if unknown.
     * Equals next_pts - this_pts in presentation order.
     */
    duration = _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT;
    pos = _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT;
    /**
     * for some private data of the user
     */
    opaque = 0;
    /**
     * AVBufferRef for free use by the API user. FFmpeg will never check the
     * contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when
     * the packet is unreferenced. av_packet_copy_props() calls create a new
     * reference with av_buffer_ref() for the target packet's opaque_ref field.
     *
     * This is unrelated to the opaque field, although it serves a similar
     * purpose.
     */
    opaqueRef = 0;
    /**
     * 编码时间基
     *
     * 封装时用户设置
     */
    timeBase = new _rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational({ den: _constant__WEBPACK_IMPORTED_MODULE_4__.AV_TIME_BASE, num: 1 });
    /**
     * 码流格式
     * 对于 h264/h265/h266 标记是 annexb 还是 avcc 格式
     */
    bitFormat = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("buf", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_2__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("pts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("dts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    map.set("streamIndex", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 36, 8: 0 });
    map.set("sideData", { 0: AVPacketSideData, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 40, 8: 0 });
    map.set("sideDataElems", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 44, 8: 0 });
    map.set("duration", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 48, 8: 0 });
    map.set("pos", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 56, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("opaqueRef", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_2__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 68, 8: 0 });
    map.set("timeBase", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("bitFormat", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 88);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVPacket.prototype);
class AVPacketRef extends AVPacket {
    refCount;
}
(function (prototype) {
    var map = new Map();
    map.set("refCount", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 88, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 96);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVPacketRef.prototype);


/***/ }),

/***/ "./src/avutil/struct/avpcmbuffer.ts":
/*!******************************************!*\
  !*** ./src/avutil/struct/avpcmbuffer.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVPCMBuffer)
/* harmony export */ });
/* unused harmony export AVPCMBufferRef */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia AVPCMBuffer defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class AVPCMBuffer {
    /**
     * pcm 数据
     * 可同时存放多个 channel 数据
     */
    data;
    /**
     * data 每一个 channel 的缓冲区大小
     */
    linesize;
    /**
     * 当前存放了多少个采样点
     */
    nbSamples;
    /**
     * 当前 data 每个 channel 能存放的最大采样点数
     */
    maxnbSamples;
    /**
     * 声道数
     */
    channels;
    /**
     * 采样率
     */
    sampleRate;
    /**
     * pts
     */
    timestamp;
    /**
     * 时长
     */
    duration;
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 2, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("linesize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("nbSamples", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("maxnbSamples", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("channels", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("sampleRate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("timestamp", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("duration", { 0: 19, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 40);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVPCMBuffer.prototype);
class AVPCMBufferRef extends AVPCMBuffer {
    refCount;
}
(function (prototype) {
    var map = new Map();
    map.set("refCount", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 40, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 48);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVPCMBufferRef.prototype);


/***/ }),

/***/ "./src/avutil/struct/avsubtitle.ts":
/*!*****************************************!*\
  !*** ./src/avutil/struct/avsubtitle.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVSubtitleType: () => (/* binding */ AVSubtitleType)
/* harmony export */ });
/*
 * libmedia AVSubtitle defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
var AVSubtitleType;
(function (AVSubtitleType) {
    AVSubtitleType[AVSubtitleType["SUBTITLE_NONE"] = 0] = "SUBTITLE_NONE";
    /**
     * Plain text, the text field must be set by the decoder and is
     * authoritative. ass and pict fields may contain approximations.
     */
    AVSubtitleType[AVSubtitleType["SUBTITLE_TEXT"] = 1] = "SUBTITLE_TEXT";
    /**
     * Formatted webvtt, the ass field must be set by the decoder and is
     * authoritative. pict and text fields may contain approximations.
     */
    AVSubtitleType[AVSubtitleType["SUBTITLE_WEBVTT"] = 2] = "SUBTITLE_WEBVTT";
    /**
     * Formatted text, the ass field must be set by the decoder and is
     * authoritative. pict and text fields may contain approximations.
     */
    AVSubtitleType[AVSubtitleType["SUBTITLE_ASS"] = 3] = "SUBTITLE_ASS";
})(AVSubtitleType || (AVSubtitleType = {}));


/***/ }),

/***/ "./src/avutil/struct/rational.ts":
/*!***************************************!*\
  !*** ./src/avutil/struct/rational.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Rational: () => (/* binding */ Rational)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia Rational defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class Rational {
    /**
     * 分子
     */
    num = 1;
    /**
     * 分母
     */
    den = 1;
    constructor(init) {
        if (init) {
            this.den = init.den;
            this.num = init.num;
        }
    }
}
(function (prototype) {
    var map = new Map();
    map.set("num", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("den", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(Rational.prototype);


/***/ }),

/***/ "./src/avutil/util/av1syntax.ts":
/*!**************************************!*\
  !*** ./src/avutil/util/av1syntax.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   f: () => (/* binding */ f),
/* harmony export */   leb128: () => (/* binding */ leb128),
/* harmony export */   uvlc: () => (/* binding */ uvlc)
/* harmony export */ });
/* unused harmony exports le, su, ns, L, NS */
/*
 * libmedia av1 syntax util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function f(bitReader, n) {
    let x = 0;
    for (let i = 0; i < n; i++) {
        x = 2 * x + bitReader.readU1();
    }
    return x;
}
function uvlc(bitReader) {
    let leadingZeros = 0;
    while (true) {
        let done = f(bitReader, 1);
        if (done) {
            break;
        }
        leadingZeros++;
    }
    if (leadingZeros >= 32) {
        return (1) - 1;
    }
    const value = f(bitReader, leadingZeros);
    return value + (1 << leadingZeros) - 1;
}
function le(bitReader, n) {
    let t = 0;
    for (let i = 0; i < n; i++) {
        let byte = f(bitReader, 8);
        t += (byte << (i * 8));
    }
    return t;
}
function leb128(bitReader) {
    let value = 0;
    let Leb128Bytes = 0;
    for (let i = 0; i < 8; i++) {
        let leb128Byte_ = f(bitReader, 8);
        value |= ((leb128Byte_ & 0x7f) << (i * 7));
        Leb128Bytes += 1;
        if (!(leb128Byte_ & 0x80)) {
            break;
        }
    }
    return value;
}
function su(bitReader, n) {
    let value = f(bitReader, n);
    let signMask = 1 << (n - 1);
    if (value & signMask) {
        value = value - 2 * signMask;
    }
    return value;
}
function ns(bitReader, n) {
    let w = Math.floor(Math.log2(n)) + 1;
    let m = (1 << w) - n;
    let v = f(bitReader, w - 1);
    if (v < m) {
        return v;
    }
    let extraBit = f(bitReader, 1);
    return (v << 1) - m + extraBit;
}
function L(bitReader, n) {
    let x = 0;
    for (let i = 0; i < n; i++) {
        x = 2 * x + bitReader.readU1();
    }
    return x;
}
function NS(bitReader, n) {
    let w = Math.floor(Math.log2(n)) + 1;
    let m = (1 << w) - n;
    let v = L(bitReader, w - 1);
    if (v < m) {
        return v;
    }
    let extraBit = L(bitReader, 1);
    return (v << 1) - m + extraBit;
}


/***/ }),

/***/ "./src/avutil/util/avbuffer.ts":
/*!*************************************!*\
  !*** ./src/avutil/util/avbuffer.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avbufferAlloc: () => (/* binding */ avbufferAlloc),
/* harmony export */   avbufferCreate: () => (/* binding */ avbufferCreate),
/* harmony export */   avbufferRealloc: () => (/* binding */ avbufferRealloc),
/* harmony export */   avbufferRef: () => (/* binding */ avbufferRef),
/* harmony export */   avbufferReplace: () => (/* binding */ avbufferReplace),
/* harmony export */   avbufferUnref: () => (/* binding */ avbufferUnref)
/* harmony export */ });
/* unused harmony exports bufferCreate, avbufferAllocz, bufferReplace, avbufferIsWritable, avbufferGetOpaque, avbufferGetRefCount, avbufferMakeWritable, bufferPoolFlush, bufferPoolFree, poolReleaseBuffer */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var _struct_avbuffer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../struct/avbuffer */ "./src/avutil/struct/avbuffer.ts");
/* harmony import */ var cheap_stack__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/stack */ "./src/cheap/stack.ts");





/*
 * libmedia avbuffer util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */






const BUFFER_FLAG_REALLOCATABLE = 1;
function bufferCreate(buf, data, size, free = 0, opaque = 0, flags = 0) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](buf, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](buf + 4, size);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](buf + 12, free);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](buf + 16, opaque);
    cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_6__.store(buf + 8, 1, 9, 2);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](buf + 20, flags);
    const ref = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(12);
    if (!ref) {
        return 0;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](ref, buf);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](ref + 4, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](ref + 8, size);
    return ref;
}
function avbufferCreate(data, size, free = 0, opaque = 0, flags = 0) {
    const buf = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(28);
    if (!buf) {
        return 0;
    }
    const ref = bufferCreate(buf, data, size, free, opaque, flags);
    if (!ref) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(buf);
        return 0;
    }
    return ref;
}
function avbufferAlloc(size) {
    const data = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(size);
    return avbufferCreate(data, size);
}
function avbufferAllocz(size) {
    const p = avbufferAlloc(size);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](p + 4), 0, size);
    return p;
}
function avbufferRef(buf) {
    const ref = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(12);
    // @ts-ignore
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(ref, buf, 12);
    cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_6__.add(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 8, 1, 9, 2);
    return ref;
}
function bufferReplace(dst, src) {
    const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst));
    if (src) {
        // @ts-ignore
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src), 12);
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFreep)(src);
    }
    else {
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFreep)(dst);
    }
    if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_6__.sub(buf + 8, 1, 9, 2) === 1) {
        const freeAvbuffer = !(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](buf + 24) & 2 /* BufferFlags.BUFFER_FLAG_NO_FREE */);
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf + 16)) {
            poolReleaseBuffer(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf + 16), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf));
        }
        else {
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf));
        }
        if (freeAvbuffer) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(buf);
        }
    }
}
function avbufferUnref(buf) {
    if (!buf || !cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf)) {
        return;
    }
    bufferReplace(buf, 0);
}
function avbufferIsWritable(buf) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 20) & 1 /* AVBufferFlags.READONLY */) {
        return 0;
    }
    return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_6__.load(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 8, 9, 2) === 1 ? 1 : 0;
}
function avbufferGetOpaque(buf) {
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 16);
}
function avbufferGetRefCount(buf) {
    return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_6__.load(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 8, 9, 2);
}
function avbufferMakeWritable(pbuf) {
    const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pbuf);
    if (!buf) {
        return -1;
    }
    if (avbufferIsWritable(buf)) {
        return 0;
    }
    const newbuf = avbufferAlloc(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](buf + 8));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](newbuf + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](buf + 8));
    let newbufp = cheap_stack__WEBPACK_IMPORTED_MODULE_8__.malloc(4);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](newbufp, newbuf);
    bufferReplace(pbuf, newbufp);
    cheap_stack__WEBPACK_IMPORTED_MODULE_8__.free(4);
    return 0;
}
function avbufferReplace(pdst, src) {
    const dst = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pdst);
    if (!src) {
        avbufferUnref(pdst);
        return 0;
    }
    if (dst && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 4) === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 4)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 4));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 8));
        return 0;
    }
    const tmp = avbufferRef(src);
    avbufferUnref(pdst);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](pdst, tmp);
    return 0;
}
function avbufferRealloc(pdst, size) {
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pdst)) {
        const data = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avRealloc)(0, size);
        const buf = avbufferCreate(data, size);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](pdst, buf);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 24) | BUFFER_FLAG_REALLOCATABLE);
        return 0;
    }
    const ref = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pdst);
    const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](ref);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](ref + 8) === size) {
        return 0;
    }
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](buf + 24) & BUFFER_FLAG_REALLOCATABLE)
        || !avbufferIsWritable(ref)
        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](ref + 4) !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf)) {
        let newRef = cheap_stack__WEBPACK_IMPORTED_MODULE_8__.malloc(4);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](newRef, 0);
        const ret = avbufferRealloc(newRef, size);
        if (ret < 0) {
            cheap_stack__WEBPACK_IMPORTED_MODULE_8__.free(4);
            return ret;
        }
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](newRef) + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf), Math.min(size, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](buf + 4)));
        bufferReplace(pdst, newRef);
        cheap_stack__WEBPACK_IMPORTED_MODULE_8__.free(4);
        return 0;
    }
    const tmp = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avRealloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf), size);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](ref + 4, tmp), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](buf, tmp);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](ref + 8, size), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](buf + 4, size);
    return 0;
}
function bufferPoolFlush(pool) {
    while (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pool + 4)) {
        const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pool + 4);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](pool + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf + 16));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf + 4)) {
            poolReleaseBuffer(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf));
        }
        else {
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf));
        }
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(buf);
    }
}
function bufferPoolFree(pool) {
    bufferPoolFlush(pool);
    _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.destroy(pool);
    (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(pool);
}
function poolReleaseBuffer(opaque, data) {
    const buf = opaque;
    const pool = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf + 12);
    _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.lock(pool);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](buf + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pool + 4));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](pool + 4, buf);
    _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.unlock(pool);
    if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_6__.sub(pool + 8, 1, 9, 2) === 1) {
        bufferPoolFree(pool);
    }
}


/***/ }),

/***/ "./src/avutil/util/avdict.ts":
/*!***********************************!*\
  !*** ./src/avutil/util/avdict.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avDictSet: () => (/* binding */ avDictSet),
/* harmony export */   freeAVDict: () => (/* binding */ freeAVDict),
/* harmony export */   freeAVDict2: () => (/* binding */ freeAVDict2)
/* harmony export */ });
/* unused harmony exports avDictCount, avDictIterate, avDictGet, avDictCopy */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _struct_avdict_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../struct/avdict */ "./src/avutil/struct/avdict.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");





/*
 * libmedia avdict util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function freeAVDict(pm) {
    freeAVDict2(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pm));
    (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avFreep)(pm);
}
function freeAVDict2(m) {
    if (m) {
        while (cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](m, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) - 1), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) + 1) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8);
            (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8 + 4);
        }
        (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avFreep)(m + 4);
    }
}
function avDictCount(m) {
    return m ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) : 0;
}
function avDictIterate(m, prev) {
    let i = 0;
    if (!m) {
        return 0;
    }
    if (prev) {
        i = ((prev - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4)) >>> 3) + 1;
    }
    if (i >= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m)) {
        return 0;
    }
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + (i * 8);
}
function avDictGet(m, key, prev = 0, flags = 0) {
    if (!m) {
        return 0;
    }
    let entry = prev;
    if (!key) {
        return 0;
    }
    while ((entry = avDictIterate(m, entry))) {
        let s = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.readCString)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](entry));
        if (flags & 1 /* AVDictFlags.MATCH_CASE */) {
            s.toLocaleLowerCase();
            key.toLocaleLowerCase();
        }
        if (s === key
            || ((flags & 2 /* AVDictFlags.IGNORE_SUFFIX */)
                && s.indexOf(key) === 0)) {
            return entry;
        }
    }
}
function avDictSet(m, key, value, flags = 0) {
    if (!m) {
        throw new Error('m is nullptr');
    }
    let tag = 0;
    if (flags & 64 /* AVDictFlags.MULTIKEY */) {
        tag = avDictGet(m, key, 0, flags);
    }
    if (tag) {
        if (flags & 16 /* AVDictFlags.DONT_OVERWRITE */) {
            return 0;
        }
        if (flags & 32 /* AVDictFlags.APPEND */) {
            value = `${(0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.readCString)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](tag + 4))},${value}`;
        }
        cheap_heap__WEBPACK_IMPORTED_MODULE_4__.Allocator.free(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](tag + 4));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](tag + 4, cheap_heap__WEBPACK_IMPORTED_MODULE_4__.Allocator.malloc(value.length + 1));
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.writeCString)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](tag + 4), value, value.length);
    }
    else {
        let tmp = cheap_heap__WEBPACK_IMPORTED_MODULE_4__.Allocator.realloc(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4), (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) + 1) * 8);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](m + 4, tmp);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8, cheap_heap__WEBPACK_IMPORTED_MODULE_4__.Allocator.malloc(key.length + 1));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8 + 4, cheap_heap__WEBPACK_IMPORTED_MODULE_4__.Allocator.malloc(value.length + 1));
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.writeCString)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8), key, key.length);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.writeCString)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8 + 4), value, value.length);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](m, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) + 1);
    }
    return 0;
}
function avDictCopy(dst, src, flags) {
    if (!dst || !src) {
        return -1;
    }
    let t = 0;
    while ((t = avDictIterate(src, t))) {
        let ret = avDictSet(dst, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.readCString)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](t)), (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.readCString)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](t + 4)), flags);
        if (ret < 0) {
            return ret;
        }
    }
    return 0;
}


/***/ }),

/***/ "./src/avutil/util/avframe.ts":
/*!************************************!*\
  !*** ./src/avutil/util/avframe.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createAVFrame: () => (/* binding */ createAVFrame),
/* harmony export */   destroyAVFrame: () => (/* binding */ destroyAVFrame),
/* harmony export */   getAVFrameDefault: () => (/* binding */ getAVFrameDefault),
/* harmony export */   getAVFrameSideData: () => (/* binding */ getAVFrameSideData),
/* harmony export */   getAudioBuffer: () => (/* binding */ getAudioBuffer),
/* harmony export */   unrefAVFrame: () => (/* binding */ unrefAVFrame)
/* harmony export */ });
/* unused harmony exports freeSideData, wipeSideData, getVideoBuffer, getBuffer, refAVFrame, copyAVFrameProps, cloneAVFrame */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _struct_audiosample_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./..\struct\audiosample.ts */ "./src/avutil/struct/audiosample.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./..\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _struct_avframe__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../struct/avframe */ "./src/avutil/struct/avframe.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _avbuffer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./avbuffer */ "./src/avutil/util/avbuffer.ts");
/* harmony import */ var _avdict__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./avdict */ "./src/avutil/util/avdict.ts");
/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../error */ "./src/avutil/error.ts");
/* harmony import */ var _channel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./channel */ "./src/avutil/util/channel.ts");
/* harmony import */ var _sample__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./sample */ "./src/avutil/util/sample.ts");
/* harmony import */ var _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var cheap_stack__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! cheap/stack */ "./src/cheap/stack.ts");
/* harmony import */ var _util_common__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../util/common */ "./src/avutil/util/common.ts");
/* harmony import */ var _pixel__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./pixel */ "./src/avutil/util/pixel.ts");






/*
 * libmedia avframe util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */














function createAVFrame() {
    const frame = (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avMallocz)(320);
    getAVFrameDefault(frame);
    return frame;
}
function destroyAVFrame(frame) {
    unrefAVFrame(frame);
    (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avFree)(frame);
}
function freeSideData(ptr) {
    const sideData = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](ptr);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferUnref)(sideData + 16);
    (0,_avdict__WEBPACK_IMPORTED_MODULE_10__.freeAVDict)(sideData + 12);
    (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avFreep)(ptr);
}
function wipeSideData(frame) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 200); i++) {
        freeSideData(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 196) + (i * 4));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 200, 0);
    (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avFreep)(frame + 196);
}
function getAVFrameSideData(frame, type) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 200); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 196) + i * 4)) === type) {
            return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 196) + (i * 4));
        }
    }
    return 0;
}
function getAVFrameDefault(frame) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 64) !== frame) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avFreep)(frame + 64);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memset)(frame, 0, 320);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](frame + 104, _constant__WEBPACK_IMPORTED_MODULE_8__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](frame + 112, _constant__WEBPACK_IMPORTED_MODULE_8__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](frame + 232, _constant__WEBPACK_IMPORTED_MODULE_8__.NOPTS_VALUE_BIGINT);
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](frame + 240, _constant__WEBPACK_IMPORTED_MODULE_8__.NOPTS_VALUE_BIGINT);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 256, -1);
    }
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 84, 1);
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 92, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 96, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 80, -1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + 64, frame);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 212, 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 216, 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 220, 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 208, 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 224, 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 204, 0);
}
function getVideoBuffer(frame, algin = 0) {
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_14__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80)];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_11__.INVALID_ARGUMENT;
    }
    const linesizes = cheap_stack__WEBPACK_IMPORTED_MODULE_15__.malloc(16);
    const sizes = cheap_stack__WEBPACK_IMPORTED_MODULE_15__.malloc(16);
    const planePadding = Math.max(32, algin);
    let ret = 0;
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32)) {
        if (algin <= 0) {
            algin = 32;
        }
        for (let i = 1; i < algin; i += i) {
            ret = (0,_pixel__WEBPACK_IMPORTED_MODULE_17__.pixelFillLinesizes)(frame + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80), (0,_util_common__WEBPACK_IMPORTED_MODULE_16__.alignFunc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 68), i));
            if (ret < 0) {
                defer();
                return ret;
            }
            if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32) & (algin - 1))) {
                break;
            }
        }
        for (let i = 0; i < 4 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32 + 4 * (i)); i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 32 + i * 4, (0,_util_common__WEBPACK_IMPORTED_MODULE_16__.alignFunc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32 + 4 * (i)), algin));
        }
    }
    for (let i = 0; i < 4; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](linesizes + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32 + 4 * (i)));
    }
    const paddingHeight = (0,_util_common__WEBPACK_IMPORTED_MODULE_16__.alignFunc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 72), 32);
    if ((ret = (0,_pixel__WEBPACK_IMPORTED_MODULE_17__.pixelFillPlaneSizes)(sizes, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80), paddingHeight, linesizes)) < 0) {
        defer();
        return ret;
    }
    let totalSize = 4 * planePadding;
    for (let i = 0; i < 4; i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](sizes + (i * 4)) > _constant__WEBPACK_IMPORTED_MODULE_8__.INT32_MAX - totalSize) {
            _error__WEBPACK_IMPORTED_MODULE_11__.INVALID_ARGUMENT;
        }
        totalSize += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](sizes + (i * 4));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + 156, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferAlloc)(totalSize));
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 156)) {
        unrefAVFrame(frame);
        defer();
        return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
    }
    if ((ret = (0,_pixel__WEBPACK_IMPORTED_MODULE_17__.pixelFillPointer)(frame, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80), paddingHeight, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 156) + 4), linesizes)) < 0) {
        unrefAVFrame(frame);
        defer();
        return ret;
    }
    for (let i = 1; i < 4; i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 4 * (i))) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + i * 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 4 * (i)) + i * planePadding);
        }
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + 64, frame);
    defer();
    return 0;
    function defer() {
        cheap_stack__WEBPACK_IMPORTED_MODULE_15__.free(16);
        cheap_stack__WEBPACK_IMPORTED_MODULE_15__.free(16);
    }
}
function getAudioBuffer(frame, algin) {
    const planar = (0,_sample__WEBPACK_IMPORTED_MODULE_13__.sampleFormatIsPlanar)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80));
    const channels = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 292);
    const planes = planar ? channels : 1;
    let ret = 0;
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32)) {
        ret = (0,_sample__WEBPACK_IMPORTED_MODULE_13__.sampleFormatGetLinesize)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80), channels, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 76), algin);
        if (ret < 0) {
            return ret;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 32, ret);
    }
    if (planes > _struct_avframe__WEBPACK_IMPORTED_MODULE_6__.AV_NUM_DATA_POINTERS) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + 64, (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avMalloc)(planes * 4));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + 188, (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avMalloc)(planes * 4));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 188) || !cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 64)) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avFreep)(frame + 64);
            (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avFreep)(frame + 188);
            return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 192, planes - _struct_avframe__WEBPACK_IMPORTED_MODULE_6__.AV_NUM_DATA_POINTERS);
    }
    else {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + 64, frame);
    }
    for (let i = 0; i < Math.min(planes, _struct_avframe__WEBPACK_IMPORTED_MODULE_6__.AV_NUM_DATA_POINTERS); i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + 156 + i * 4, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferAlloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32)));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 156 + 4 * (i))) {
            unrefAVFrame(frame);
            return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 64) + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 156 + i * 4) + 4)), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + i * 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 156 + i * 4) + 4));
    }
    for (let i = 0; i < planes - _struct_avframe__WEBPACK_IMPORTED_MODULE_6__.AV_NUM_DATA_POINTERS; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 188) + (i * 4), (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferAlloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32)));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 188) + (i * 4))) {
            unrefAVFrame(frame);
            return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 64) + (i + _struct_avframe__WEBPACK_IMPORTED_MODULE_6__.AV_NUM_DATA_POINTERS), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 188) + i * 4) + 4));
    }
}
function getBuffer(frame, algin) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80) < 0) {
        return _error__WEBPACK_IMPORTED_MODULE_11__.INVALID_ARGUMENT;
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 68) > 0 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 72) > 0) {
        return getVideoBuffer(frame, algin);
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 76) > 0 && (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[10](frame + 296) || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 292) > 0)) {
        return getAudioBuffer(frame, algin);
    }
    return _error__WEBPACK_IMPORTED_MODULE_11__.INVALID_ARGUMENT;
}
function refAVFrame(dst, src) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 80));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 68, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 68));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 72, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 72));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(dst + 288, src + 288, 24);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 76, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 76));
    let ret = copyAVFrameProps(dst, src);
    if (ret < 0) {
        return ret;
    }
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 156)) {
        for (let i = 0; i < 8; i++) {
            if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 4 * (i)) || !cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 32 + 4 * (i))) {
                continue;
            }
            let size = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 32 + 4 * (i));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + i * 4, (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avMalloc)(size));
            if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 4 * (i))) {
                unrefAVFrame(dst);
                return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
            }
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 4 * (i)), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 4 * (i)), size);
        }
        return 0;
    }
    for (let i = 0; i < 8; i++) {
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 156 + 4 * (i))) {
            continue;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 156 + i * 4, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 156 + 4 * (i))));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 156 + 4 * (i))) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
        }
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 188)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 188, (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avMallocz)(4 * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 192)));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 188)) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 192, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 192));
        for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 192); i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 188) + (i * 4), (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 188) + (i * 4))));
            if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 188) + (i * 4))) {
                unrefAVFrame(dst);
                return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
            }
        }
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 64) !== src) {
        let ch = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 292);
        if (!ch) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_11__.INVALID_ARGUMENT;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 64, (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avMallocz)(4 * ch));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 64)) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
        }
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 64), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 64), 4 * ch);
    }
    else {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 64, dst);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(dst, src, 32);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(dst + 32, src + 32, 32);
    return 0;
}
function unrefAVFrame(frame) {
    wipeSideData(frame);
    for (let i = 0; i < (8); i++) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferUnref)(frame + 156 + i * 4);
    }
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 192); i++) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferUnref)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 188) + (i * 4));
    }
    (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avFreep)(frame + 188);
    (0,_avdict__WEBPACK_IMPORTED_MODULE_10__.freeAVDict)(frame + 248);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferUnref)(frame + 260);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferUnref)(frame + 264);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferUnref)(frame + 284);
    getAVFrameDefault(frame);
}
function copyAVFrameProps(dst, src) {
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 84, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 84));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 88, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 88));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(dst + 92, src + 92, 8);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 268, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 268));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 272, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 272));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 276, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 276));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 280, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 280));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 104, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 104));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 136, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 136));
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 140, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 140));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 144));
    }
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 148, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 148));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 152, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 152));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 132, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 132));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 112, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 112));
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 240, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 240));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 256, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 256));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 128, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 128));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 232, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 232));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 204, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 204));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 252, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 252));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 212, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 212));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 216, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 216));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 220, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 220));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 208, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 208));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 224, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 224));
    let ret = (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferReplace)(dst + 264, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 264));
    ret |= (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferReplace)(dst + 284, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 284));
    return ret;
}
function cloneAVFrame(frame) {
    const ret = createAVFrame();
    refAVFrame(ret, frame);
    return ret;
}


/***/ }),

/***/ "./src/avutil/util/avpacket.ts":
/*!*************************************!*\
  !*** ./src/avutil/util/avpacket.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAVPacketData: () => (/* binding */ addAVPacketData),
/* harmony export */   addAVPacketSideData: () => (/* binding */ addAVPacketSideData),
/* harmony export */   copyAVPacketData: () => (/* binding */ copyAVPacketData),
/* harmony export */   copyAVPacketProps: () => (/* binding */ copyAVPacketProps),
/* harmony export */   createAVPacket: () => (/* binding */ createAVPacket),
/* harmony export */   deleteAVPacketSideData: () => (/* binding */ deleteAVPacketSideData),
/* harmony export */   destroyAVPacket: () => (/* binding */ destroyAVPacket),
/* harmony export */   freeAVPacketSideData: () => (/* binding */ freeAVPacketSideData),
/* harmony export */   getAVPacketData: () => (/* binding */ getAVPacketData),
/* harmony export */   getAVPacketDefault: () => (/* binding */ getAVPacketDefault),
/* harmony export */   getAVPacketSideData: () => (/* binding */ getAVPacketSideData),
/* harmony export */   hasAVPacketSideData: () => (/* binding */ hasAVPacketSideData),
/* harmony export */   newSideData: () => (/* binding */ newSideData),
/* harmony export */   refAVPacket: () => (/* binding */ refAVPacket),
/* harmony export */   unrefAVPacket: () => (/* binding */ unrefAVPacket)
/* harmony export */ });
/* unused harmony exports initAVPacketData, addSideData, copyAVPacketSideData */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _struct_avpacket_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../struct/avpacket */ "./src/avutil/struct/avpacket.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _avbuffer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./avbuffer */ "./src/avutil/util/avbuffer.ts");





/*
 * libmedia avpacket util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





const AV_INPUT_BUFFER_PADDING_SIZE = 64;
function getAVPacketData(avpacket, safe) {
    return safe ? (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapSafeUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28)) : (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28));
}
function initAVPacketData(avpacket, length) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 24, (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(length));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 28, length);
    return (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28));
}
function getAVPacketSideData(avpacket, type) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 8) === type) {
            return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + (i * 12);
        }
    }
    return 0;
}
function hasAVPacketSideData(avpacket, type) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 8) === type) {
            return true;
        }
    }
    return false;
}
function addSideData(psd, pnbSd, type, data, length) {
    const sideDataElems = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](pnbSd);
    const sideData = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](psd);
    for (let i = 0; i < sideDataElems; i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](sideData + i * 12 + 8) === type) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](sideData + i * 12));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](sideData + i * 12, data);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](sideData + i * 12 + 4, length);
            return;
        }
    }
    const len = (sideDataElems + 1) * 12;
    const newSideData = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(len);
    if (sideDataElems) {
        for (let i = 0; i < sideDataElems; i++) {
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(newSideData + (i * 12), sideData + (i * 12), 12);
        }
    }
    const ele = newSideData + (sideDataElems * 12);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](ele, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](ele + 8, type);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](ele + 4, length);
    if (sideData) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(sideData);
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](psd, newSideData);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](pnbSd, sideDataElems + 1);
    return ele;
}
function newSideData(psd, pnbSd, type, size) {
    const data = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(size + AV_INPUT_BUFFER_PADDING_SIZE);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memset)(data + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
    return addSideData(psd, pnbSd, type, data, size);
}
function addAVPacketSideData(avpacket, type, data, length) {
    addSideData(avpacket + 40, avpacket + 44, type, data, length);
}
function deleteAVPacketSideData(avpacket, type) {
    let index = -1;
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 8) === type) {
            index = i;
            break;
        }
    }
    if (index > -1) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) === 1) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40)));
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 40, 0);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 44, 0);
        }
        else {
            const len = (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) - 1) * 12;
            const sideData = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(len);
            for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
                if (i !== index) {
                    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(sideData + (i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + (i * 12), 12);
                }
                else {
                    (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12));
                }
            }
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 40, sideData);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 44, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) - 1);
        }
    }
}
function createAVPacket() {
    const avpacket = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(88);
    getAVPacketDefault(avpacket);
    return avpacket;
}
function destroyAVPacket(avpacket) {
    unrefAVPacket(avpacket);
    (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(avpacket);
}
function freeAVPacketSideData(pSideData, pnbSideData) {
    const sideData = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pSideData);
    const nbSideData = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](pnbSideData);
    if (sideData) {
        for (let i = 0; i < nbSideData; i++) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](sideData + i * 12));
        }
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFreep)(pSideData);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](pnbSideData, 0);
    }
}
function getAVPacketDefault(avpacket) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 24, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 28, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 40, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 44, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 32, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 56, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 48, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 36, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 16, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 8, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 76, _constant__WEBPACK_IMPORTED_MODULE_6__.AV_TIME_BASE);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 72, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 80, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket, 0);
}
function copyAVPacketSideData(dst, src) {
    freeAVPacketSideData(dst + 40, dst + 44);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44)) {
        let size = 12;
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 40, (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(size * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44)));
        for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44); i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12 + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 4));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12 + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 8));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12, (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 4)));
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 4));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 44, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44));
    }
}
function copyAVPacketProps(dst, src) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 32));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 56));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 48, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 48));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 36));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 16));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 8));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 64, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 64));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 76, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 76));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 72, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 72));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 80));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 68, 0);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferReplace)(dst + 68, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 68));
    copyAVPacketSideData(dst, src);
    return 0;
}
function allocAVPacket(buf, size) {
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferRealloc)(buf, size + AV_INPUT_BUFFER_PADDING_SIZE);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 4) + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
    return 0;
}
function refAVPacket(dst, src) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferUnref)(dst);
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, 0);
    copyAVPacketProps(dst, src);
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src) && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
        allocAVPacket(dst, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4));
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 28, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
    return 0;
}
function unrefAVPacket(avpacket) {
    freeAVPacketSideData(avpacket + 40, avpacket + 44);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferUnref)(avpacket + 68);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferUnref)(avpacket);
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24)) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24));
    }
    getAVPacketDefault(avpacket);
}
function copyAVPacketData(dst, src) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferUnref)(dst);
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, 0);
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src) && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
        allocAVPacket(dst, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4));
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 28, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
}
function addAVPacketData(avpacket, data, size) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferUnref)(avpacket);
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24)) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferCreate)(data, size + AV_INPUT_BUFFER_PADDING_SIZE));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 24, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 28, size);
}


/***/ }),

/***/ "./src/avutil/util/channel.ts":
/*!************************************!*\
  !*** ./src/avutil/util/channel.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setChannelLayoutFromMask: () => (/* binding */ setChannelLayoutFromMask),
/* harmony export */   unInitChannelLayout: () => (/* binding */ unInitChannelLayout)
/* harmony export */ });
/* unused harmony export getChannelLayoutNBChannels */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common */ "./src/avutil/util/common.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");






function getChannelLayoutNBChannels(layout) {
    return (0,_common__WEBPACK_IMPORTED_MODULE_2__.popCount64)(layout);
}
function unInitChannelLayout(channelLayout) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](channelLayout) == 2 /* AVChannelOrder.AV_CHANNEL_ORDER_CUSTOM */) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFreep)(channelLayout + 8);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.memset)(channelLayout, 0, 24);
}
function setChannelLayoutFromMask(channelLayout, mask) {
    if (!mask) {
        return avutil_error__WEBPACK_IMPORTED_MODULE_5__.INVALID_ARGUMENT;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](channelLayout, 1 /* AVChannelOrder.AV_CHANNEL_ORDER_NATIVE */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](channelLayout + 4, (0,_common__WEBPACK_IMPORTED_MODULE_2__.popCount64)(BigInt(mask >>> 0)));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[10](channelLayout + 8, BigInt(mask >>> 0));
    return 0;
}


/***/ }),

/***/ "./src/avutil/util/codecparameters.ts":
/*!********************************************!*\
  !*** ./src/avutil/util/codecparameters.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copyCodecParameters: () => (/* binding */ copyCodecParameters),
/* harmony export */   freeCodecParameters: () => (/* binding */ freeCodecParameters)
/* harmony export */ });
/* unused harmony export resetCodecParameters */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _struct_audiosample_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./..\struct\audiosample.ts */ "./src/avutil/struct/audiosample.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./..\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _channel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./channel */ "./src/avutil/util/channel.ts");
/* harmony import */ var _avpacket__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _struct_avpacket__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../struct/avpacket */ "./src/avutil/struct/avpacket.ts");












function copyCodecParametersSideData(pDst, pnbDst, src, nbSrc) {
    if (!src) {
        return;
    }
    const dst = (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avMallocz)(nbSrc * 12);
    for (let i = 0; i < nbSrc; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + i * 12 + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + i * 12 + 8));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + i * 12 + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + i * 12 + 4));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + i * 12, (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avMalloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + i * 12 + 4)));
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(dst + i * 12, src + i * 12, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + i * 12 + 4));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](pnbDst, nbSrc);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](pDst, dst);
    return 0;
}
function copyCodecParameters(dst, src) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 4));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[8](dst + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[8](src + 8));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 28, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 32));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 40, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 40));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 44, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 48, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 48));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 52, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 52));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 56));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 60, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 60));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 68, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 68));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 64, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 64));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 80));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 84, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 84));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 88, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 88));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 92, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 92));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 96, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 96));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 100, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 100));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 104, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 104));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(dst + 112, src + 112, 24);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 136, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 136));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 140, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 140));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 144));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 148, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 148));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 152, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 152));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 156, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 156));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(dst + 72, src + 72, 8);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 12)) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 12)) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 12));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 12, (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avMalloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 16)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 16));
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 16));
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 20)) {
        copyCodecParametersSideData(dst + 20, dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 20), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 24));
    }
}
function resetCodecParameters(par) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](par + 12)) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avFreep)(par + 12);
    }
    (0,_channel__WEBPACK_IMPORTED_MODULE_7__.unInitChannelLayout)(par + 112);
    (0,_avpacket__WEBPACK_IMPORTED_MODULE_8__.freeAVPacketSideData)(par + 20, par + 24);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memset)(par, 0, 168);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par, -1 /* AVMediaType.AVMEDIA_TYPE_UNKNOWN */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 4, 0 /* AVCodecID.AV_CODEC_ID_NONE */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 28, -1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 112, 0 /* AVChannelOrder.AV_CHANNEL_ORDER_UNSPEC */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 80, 0 /* AVFieldOrder.AV_FIELD_UNKNOWN */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 84, 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 88, 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 92, 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 96, 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 100, 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 64, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 68, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 72, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 72, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 48, _constant__WEBPACK_IMPORTED_MODULE_9__.NOPTS_VALUE);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 52, _constant__WEBPACK_IMPORTED_MODULE_9__.NOPTS_VALUE);
}
function freeCodecParameters(par) {
    if (!par) {
        return;
    }
    resetCodecParameters(par);
    (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avFree)(par);
}


/***/ }),

/***/ "./src/avutil/util/common.ts":
/*!***********************************!*\
  !*** ./src/avutil/util/common.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alignFunc: () => (/* binding */ alignFunc),
/* harmony export */   milliSecond2Second: () => (/* binding */ milliSecond2Second),
/* harmony export */   popCount64: () => (/* binding */ popCount64)
/* harmony export */ });
/* unused harmony export popCount */
/*
 * libmedia common util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function popCount(x) {
    x -= (x >> 1) & 0x55555555;
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0F0F0F0F;
    x += x >> 8;
    return (x + (x >> 16)) & 0x3F;
}
function popCount64(x) {
    return popCount(Number(x & 0xffffffffn)) + popCount(Number(x >> BigInt(32) & 0xffffffffn));
}
function milliSecond2Second(time) {
    const integer = time / BigInt(1000);
    const decimal = time - integer * BigInt(1000);
    return Number(integer) + Number(decimal) / 1000;
}
function alignFunc(value, alignment) {
    return (value + alignment - 1) & ~(alignment - 1);
}


/***/ }),

/***/ "./src/avutil/util/expgolomb.ts":
/*!**************************************!*\
  !*** ./src/avutil/util/expgolomb.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readSE: () => (/* binding */ readSE),
/* harmony export */   readUE: () => (/* binding */ readUE)
/* harmony export */ });
/* unused harmony exports readTE, writeUE, writeSE, writeTE */
/*
 * libmedia expgolomb util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const UESizeTable = [
    // 0 的二进制所需的比特个数
    1,
    // 1 的二进制所需的比特个数    
    1,
    // 2~3 的二进制所需的比特个数   
    2, 2,
    // 4~7 的二进制所需的比特个数
    3, 3, 3, 3,
    // 8~15 的二进制所需的比特个数
    4, 4, 4, 4, 4, 4, 4, 4,
    // 16~31 的二进制所需的比特个数
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    // 32~63 的二进制所需的比特个数
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    // 64~127 的二进制所需的比特个数
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    // 128~255 的二进制所需的比特个数
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
];
/**
 * ue(v) 指数哥伦布解码
 */
function readUE(bitReader) {
    let result = 0;
    // leadingZeroBits
    let i = 0;
    while (i < 32 && bitReader.readU1() === 0) {
        i++;
    }
    // 计算 read_bits ( leadingZeroBits )
    result = bitReader.readU(i);
    // 计算 codeNum，1 << i 即为 2 的 i 次幂
    result += (1 << i) - 1;
    return result;
}
/**
 * se(v) 有符号指数哥伦布解码
 */
function readSE(bitReader) {
    let result = readUE(bitReader);
    // 判断 result 的奇偶性
    if (result & 0x01) {
        // 如果为奇数，说明编码前 > 0
        result = (result + 1) / 2;
    }
    else {
        // 如果为偶数，说明编码前 <= 0
        result = -result / 2;
    }
    return result;
}
/**
 * te(v) 截断指数哥伦布解码
 */
function readTE(bitReader, x) {
    let result = 0;
    // 判断取值上限
    if (x === 1) {
        // 如果为 1 则将读取到的比特值取反
        result = 1 - bitReader.readU1();
    }
    else if (x > 1) {
        // 否则按照 ue(v) 进行解码
        result = readUE(bitReader);
    }
    return result;
}
/**
 * ue(v) 指数哥伦布编码
 */
function writeUE(bitWriter, value) {
    let size = 0;
    if (value === 0) {
        // 0 直接编码为 1
        bitWriter.writeU1(1);
    }
    else {
        let tmp = ++value;
        // 判断所需比特个数是否大于 16 位
        if (tmp >= 0x00010000) {
            size += 16;
            tmp >>= 16;
        }
        // 判断此时所需比特个数是否大于 8 位
        if (tmp >= 0x100) {
            size += 8;
            tmp >>= 8;
        }
        // 最终 tmp 移位至 8 位以内，去查表
        size += UESizeTable[tmp];
        // 最终得出编码 value 所需的总比特数：2 * size - 1
        bitWriter.writeU(2 * size - 1, value);
    }
}
/**
 * se(v) 有符号指数哥伦布编码
 */
function writeSE(bitWriter, value) {
    if (value <= 0) {
        writeUE(bitWriter, -value * 2);
    }
    else {
        writeUE(bitWriter, value * 2 - 1);
    }
}
/**
 * te(v) 截断指数哥伦布编码
 */
function writeTE(bitWriter, x, value) {
    if (x === 1) {
        bitWriter.writeU1(1 & ~value);
    }
    else if (x > 1) {
        writeUE(bitWriter, value);
    }
}


/***/ }),

/***/ "./src/avutil/util/intread.ts":
/*!************************************!*\
  !*** ./src/avutil/util/intread.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r8: () => (/* binding */ r8),
/* harmony export */   rb16: () => (/* binding */ rb16),
/* harmony export */   rb24: () => (/* binding */ rb24),
/* harmony export */   rb32: () => (/* binding */ rb32),
/* harmony export */   rl16: () => (/* binding */ rl16),
/* harmony export */   rl32: () => (/* binding */ rl32)
/* harmony export */ });
/* unused harmony exports rl24, rl64, rb64 */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");

/*
 * libmedia int read util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function r8(p) {
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[2](p);
}
function rl16(p) {
    return (r8(p + 1) << 8) | r8(p);
}
function rb16(p) {
    return (r8(p) << 8) | r8(p + 1);
}
function rl24(p) {
    return (r8(p + 2) << 16) | (r8(p + 1) << 8) + r8(p);
}
function rb24(p) {
    return (r8(p) << 16) | (r8(p + 1) << 8) | r8(p + 2);
}
function rl32(p) {
    return (rl16(p + 2) << 16) | rl16(p);
}
function rb32(p) {
    return (rb16(p) << 16) | rb16(p + 2);
}
function rl64(p) {
    return (BigInt(rl32(p + 4)) << BigInt(32)) | BigInt(rl32(p));
}
function rb64(p) {
    return (BigInt(rb32(p)) << BigInt(32)) | BigInt(rb32(p + 4));
}


/***/ }),

/***/ "./src/avutil/util/mem.ts":
/*!********************************!*\
  !*** ./src/avutil/util/mem.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avFree: () => (/* binding */ avFree),
/* harmony export */   avFreep: () => (/* binding */ avFreep),
/* harmony export */   avMalloc: () => (/* binding */ avMalloc),
/* harmony export */   avMallocz: () => (/* binding */ avMallocz),
/* harmony export */   avRealloc: () => (/* binding */ avRealloc)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__1 = "src\\avutil\\util\\mem.ts";



/*
 * libmedia mem util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function avMalloc(len) {
    const p = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(len);
    if (!p) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal('can not alloc buffer', cheap__fileName__1, 32);
    }
    return p;
}
function avMallocz(len) {
    const p = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(len);
    if (!p) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal('can not alloc buffer', cheap__fileName__1, 40);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memset)(p, 0, len);
    return p;
}
function avFree(p) {
    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(p);
}
function avFreep(p) {
    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](p));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](p, 0);
}
function avRealloc(p, size) {
    return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.realloc(p, size);
}


/***/ }),

/***/ "./src/avutil/util/nalu.ts":
/*!*********************************!*\
  !*** ./src/avutil/util/nalu.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getNextNaluStart: () => (/* binding */ getNextNaluStart),
/* harmony export */   isAnnexb: () => (/* binding */ isAnnexb),
/* harmony export */   naluUnescape: () => (/* binding */ naluUnescape),
/* harmony export */   splitNaluByStartCode: () => (/* binding */ splitNaluByStartCode)
/* harmony export */ });
/* unused harmony exports splitNaluByLength, joinNaluByStartCode, joinNaluByLength, naluEscape */
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/*
 * libmedia nalu util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function isAnnexb(data) {
    return data.length > 4
        && data[0] === 0
        && data[1] === 0
        && (data[2] === 1
            || data[2] === 0 && data[3] === 1);
}
function getNextNaluStart(data, offset) {
    let t = 0;
    for (let i = offset; i < data.length; i++) {
        switch (data[i]) {
            case 0:
                t++;
                break;
            case 1:
                if (t >= 2) {
                    return {
                        offset: i - Math.min(t, 3),
                        startCode: Math.min(t + 1, 4)
                    };
                }
                t = 0;
                break;
            default:
                t = 0;
        }
    }
    return {
        offset: -1,
        startCode: 0
    };
}
function splitNaluByStartCode(buffer) {
    const list = [];
    let offset = 0;
    let current = getNextNaluStart(buffer, offset);
    let next = {
        offset: -1,
        startCode: 0
    };
    while (next = getNextNaluStart(buffer, current.offset + current.startCode), next.offset > -1) {
        list.push(buffer.subarray(current.offset + current.startCode, next.offset, true));
        current = next;
    }
    list.push(buffer.subarray(current.offset + current.startCode, undefined, true));
    return list;
}
function splitNaluByLength(buffer, naluLengthSizeMinusOne) {
    const list = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](buffer);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = buffer.subarray((Number(bufferReader.getPos() & 0xffffffffn) >> 0), (Number(bufferReader.getPos() & 0xffffffffn) >> 0) + length, true);
        bufferReader.skip(length);
        list.push(nalu);
    }
    return list;
}
function joinNaluByStartCode(nalus, output, slice = false) {
    if (!output) {
        let length = nalus.reduce((prev, nalu, index) => {
            return prev + ((index && slice) ? 3 : 4) + nalu.length;
        }, 0);
        output = new Uint8Array(length);
    }
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__["default"](output);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu, index) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        if (!index && slice) {
            bufferWriter.writeUint8(0x00);
        }
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(nalu);
    });
    return output;
}
function joinNaluByLength(nalus, naluLengthSizeMinusOne, output) {
    if (!output) {
        const length = nalus.reduce((prev, nalu) => {
            return prev + naluLengthSizeMinusOne + 1 + nalu.length;
        }, 0);
        output = new Uint8Array(length);
    }
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__["default"](output);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu) => {
        if (naluLengthSizeMinusOne === 3) {
            bufferWriter.writeUint32(nalu.length);
        }
        else if (naluLengthSizeMinusOne === 2) {
            bufferWriter.writeUint24(nalu.length);
        }
        else if (naluLengthSizeMinusOne === 1) {
            bufferWriter.writeUint16(nalu.length);
        }
        else {
            bufferWriter.writeUint8(nalu.length);
        }
        bufferWriter.writeBuffer(nalu);
    });
    return output;
}
function naluUnescape(data, start = 0, end) {
    if (!end) {
        end = data.length;
    }
    const buffer = new Uint8Array(data.length);
    let zeroCount = 0;
    let pos = 0;
    for (let i = 0; i < data.length; i++) {
        if (i >= start && i < end) {
            if (data[i] === 0) {
                zeroCount++;
            }
            else {
                if (data[i] === 3 && zeroCount === 2 && i + 1 < data.length && data[i + 1] <= 3) {
                    i++;
                    if (i === data.length) {
                        break;
                    }
                    else {
                        if (data[i] === 0) {
                            zeroCount = 1;
                        }
                        else {
                            zeroCount = 0;
                        }
                    }
                }
                else {
                    zeroCount = 0;
                }
            }
        }
        buffer[pos++] = data[i];
    }
    return buffer.slice(0, pos);
}
function naluEscape(data, start = 0, end) {
    if (!end) {
        end = data.length;
    }
    const indexes = [];
    let zeroCount = 0;
    for (let i = start; i < end; i++) {
        if (i >= end) {
            break;
        }
        if (data[i] === 0) {
            zeroCount++;
        }
        else {
            if (data[i] <= 3 && zeroCount === 2) {
                indexes.push(i);
            }
            zeroCount = 0;
        }
    }
    if (indexes.length) {
        const buffer = new Uint8Array(data.length + indexes.length);
        let pos = 0;
        let subData = data.subarray(0, indexes[0]);
        buffer.set(subData, pos);
        pos += subData.length;
        buffer[pos++] = 3;
        for (let i = 1; i < indexes.length; i++) {
            subData = data.subarray(indexes[i - 1], indexes[i]);
            buffer.set(subData, pos);
            pos += subData.length;
            buffer[pos++] = 3;
        }
        subData = data.subarray(indexes[indexes.length - 1], data.length);
        buffer.set(subData, pos);
        pos += subData.length;
        return buffer;
    }
    else {
        return data;
    }
}


/***/ }),

/***/ "./src/avutil/util/pixel.ts":
/*!**********************************!*\
  !*** ./src/avutil/util/pixel.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pixelFillLinesizes: () => (/* binding */ pixelFillLinesizes),
/* harmony export */   pixelFillPlaneSizes: () => (/* binding */ pixelFillPlaneSizes),
/* harmony export */   pixelFillPointer: () => (/* binding */ pixelFillPointer)
/* harmony export */ });
/* unused harmony exports chromaLocation2Pos, pixelGetLinesize, pixelAlloc, pixelGetSize */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../error */ "./src/avutil/error.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_stack__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/stack */ "./src/cheap/stack.ts");
/* harmony import */ var _util_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/common */ "./src/avutil/util/common.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");


/*
 * libmedia video pixel util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */







function chromaLocation2Pos(pos) {
    if (pos <= 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */ || pos >= 7 /* AVChromaLocation.AVCHROMA_LOC_NB */) {
        return;
    }
    return {
        x: (pos & 1) * 128,
        y: ((pos >>> 1) ^ (pos < 4 ? 1 : 0)) * 128
    };
}
function getMaxPixSteps(desc) {
    const maxPixSteps = [0, 0, 0, 0];
    const maxPixStepsComps = [0, 0, 0, 0];
    for (let i = 0; i < 4; i++) {
        if (desc.comp[i] && desc.comp[i].step > maxPixSteps[desc.comp[i].plane]) {
            maxPixSteps[desc.comp[i].plane] = desc.comp[i].step;
            maxPixStepsComps[desc.comp[i].plane] = i;
        }
    }
    return {
        maxPixSteps,
        maxPixStepsComps
    };
}
function setSystematicPal(pal, pixfmt) {
    for (let i = 0; i < 256; i++) {
        let r, g, b;
        switch (pixfmt) {
            case 20 /* AVPixelFormat.AV_PIX_FMT_RGB8 */:
                r = (i >> 5) * 36;
                g = ((i >> 2) & 7) * 36;
                b = (i & 3) * 85;
                break;
            case 17 /* AVPixelFormat.AV_PIX_FMT_BGR8 */:
                b = (i >> 6) * 85;
                g = ((i >> 3) & 7) * 36;
                r = (i & 7) * 36;
                break;
            case 22 /* AVPixelFormat.AV_PIX_FMT_RGB4_BYTE */:
                r = (i >> 3) * 255;
                g = ((i >> 1) & 3) * 85;
                b = (i & 1) * 255;
                break;
            case 19 /* AVPixelFormat.AV_PIX_FMT_BGR4_BYTE */:
                b = (i >> 3) * 255;
                g = ((i >> 1) & 3) * 85;
                r = (i & 1) * 255;
                break;
            case 8 /* AVPixelFormat.AV_PIX_FMT_GRAY8 */:
                r = b = g = i;
                break;
            default:
                return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[8](pal + (i * 4), b + (g << 8) + (r << 16) + (-16777216));
    }
    return 0;
}
function pixelGetLinesize_(width, plane, maxStep, maxStepComp, desc) {
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    if (width < 0) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    const s = (maxStepComp === 1 || maxStepComp === 2) ? desc.log2ChromaW : 0;
    const shiftedW = ((width + (1 << s) - 1)) >>> s;
    if (shiftedW && maxStep > _constant__WEBPACK_IMPORTED_MODULE_4__.INT32_MAX / shiftedW) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    let linesize = maxStep * shiftedW;
    if (desc.flags & 4 /* PixelFormatFlags.BIT_STREAM */) {
        linesize = (linesize + 7) >>> 3;
    }
    return linesize;
}
function pixelGetLinesize(pixfmt, width, plane) {
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[pixfmt];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    const { maxPixSteps, maxPixStepsComps } = getMaxPixSteps(desc);
    return pixelGetLinesize_(width, plane, maxPixSteps[plane], maxPixStepsComps[plane], desc);
}
function pixelFillLinesizes(linesizes, pixfmt, width) {
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[pixfmt];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    const { maxPixSteps, maxPixStepsComps } = getMaxPixSteps(desc);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memset)(linesizes, 0, 16);
    let ret = 0;
    for (let i = 0; i < 4; i++) {
        if ((ret = pixelGetLinesize_(width, i, maxPixSteps[i], maxPixStepsComps[i], desc)) < 0) {
            return ret;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](linesizes + (i * 4), ret);
    }
}
function pixelFillPlaneSizes(sizes, pixfmt, height, linesizes) {
    const hasPlane = [0, 0, 0, 0];
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[pixfmt];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memset)(sizes, 0, 16);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes) > _constant__WEBPACK_IMPORTED_MODULE_4__.INT32_MAX / height) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](sizes, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes) * height);
    if (desc.flags & 2 /* PixelFormatFlags.PALETTE */) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](sizes + 4, 1024);
        return 0;
    }
    for (let i = 0; i < 4; i++) {
        if (desc.comp[i]) {
            hasPlane[desc.comp[i].plane] = 1;
        }
    }
    for (let i = 0; i < 4 && hasPlane[i]; i++) {
        let s = (i === 1 || i === 2) ? desc.log2ChromaH : 0;
        let h = (height + (1 << s) - 1) >> s;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes + (i * 4)) > _constant__WEBPACK_IMPORTED_MODULE_4__.INT32_MAX / h) {
            return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](sizes + (i * 4), h * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes + (i * 4)));
    }
    return 0;
}
function pixelFillPointer(data, pixfmt, height, ptr, linesizes) {
    const linesizes1 = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    const sizes = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memset)(data, 0, 16);
    for (let i = 0; i < 4; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](linesizes1 + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes + (i * 4)));
    }
    let ret = pixelFillPlaneSizes(sizes, pixfmt, height, linesizes1);
    if (ret < 0) {
        defer();
        return ret;
    }
    ret = 0;
    for (let i = 0; i < 4; i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i * 4)) > _constant__WEBPACK_IMPORTED_MODULE_4__.INT32_MAX - ret) {
            defer();
            return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
        }
        ret += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i * 4));
    }
    if (!ptr) {
        defer();
        return ret;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](data, ptr);
    for (let i = 1; i < 4 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i * 4)); i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](data + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](data + (i - 1)) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i - 1)));
    }
    defer();
    return ret;
    function defer() {
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
    }
}
function pixelAlloc(pointers, linesizes, w, h, pixfmt, align = 1) {
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[pixfmt];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    const linesizes1 = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    const sizes = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    let ret = 0;
    if ((ret = pixelFillLinesizes(linesizes, pixfmt, align > 7 ? (0,_util_common__WEBPACK_IMPORTED_MODULE_7__.alignFunc)(w, 8) : w)) < 0) {
        defer();
        return ret;
    }
    for (let i = 0; i < 4; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](linesizes + (i * 4), (0,_util_common__WEBPACK_IMPORTED_MODULE_7__.alignFunc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes + (i * 4)), align));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](linesizes1 + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes + (i * 4)));
    }
    if ((ret = pixelFillPlaneSizes(sizes, pixfmt, h, linesizes1)) < 0) {
        defer();
        return ret;
    }
    let totalSize = align;
    for (let i = 0; i < 4; i++) {
        if (totalSize > _constant__WEBPACK_IMPORTED_MODULE_4__.INT32_MAX - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i * 4))) {
            defer();
            return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
        }
        totalSize += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i * 4));
    }
    const buf = (0,_mem__WEBPACK_IMPORTED_MODULE_8__.avMalloc)(totalSize);
    if (!buf) {
        defer();
        return _error__WEBPACK_IMPORTED_MODULE_3__.NO_MEMORY;
    }
    if ((ret = pixelFillPointer(pointers, pixfmt, h, buf, linesizes)) < 0) {
        defer();
        return ret;
    }
    if (desc.flags & 2 /* PixelFormatFlags.PALETTE */) {
        if (align < 4) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_8__.avFree)(buf);
            defer();
            return ret;
        }
        setSystematicPal(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pointers + 4), pixfmt);
    }
    if ((desc.flags & 2 /* PixelFormatFlags.PALETTE */)
        && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pointers + 4)
        && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pointers + 4) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pointers) > cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes) * h) {
        /* zero-initialize the padding before the palette */
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pointers) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes) * h, 0, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pointers + 4) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pointers) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes) * h);
    }
    defer();
    return ret;
    function defer() {
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
    }
}
function pixelGetSize(pixfmt, width, height, align) {
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[pixfmt];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    const linesizes = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    const alignedLinesizes = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    const sizes = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    let ret = 0;
    if ((ret = pixelFillLinesizes(linesizes, pixfmt, width)) < 0) {
        defer();
        return ret;
    }
    for (let i = 0; i < 4; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](alignedLinesizes + (i * 4), (0,_util_common__WEBPACK_IMPORTED_MODULE_7__.alignFunc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes + (i * 4)), align));
    }
    if ((ret = pixelFillPlaneSizes(sizes, pixfmt, height, alignedLinesizes)) < 0) {
        defer();
        return ret;
    }
    let totalSize = 0;
    for (let i = 0; i < 4; i++) {
        if (totalSize > _constant__WEBPACK_IMPORTED_MODULE_4__.INT32_MAX - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i * 4))) {
            defer();
            return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
        }
        totalSize += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i * 4));
    }
    defer();
    return totalSize;
    function defer() {
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
    }
}


/***/ }),

/***/ "./src/avutil/util/rational.ts":
/*!*************************************!*\
  !*** ./src/avutil/util/rational.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avQ2D: () => (/* binding */ avQ2D),
/* harmony export */   avQ2D2: () => (/* binding */ avQ2D2),
/* harmony export */   avReduce: () => (/* binding */ avReduce),
/* harmony export */   avRescaleQ: () => (/* binding */ avRescaleQ)
/* harmony export */ });
/* unused harmony exports avRescaleQ2, avReduce2 */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_math_gcd__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/math/gcd */ "./src/common/math/gcd.ts");



/**
 * 将一个时间戳由一个时间基转换到另一个时间基
 *
 * @param a 待转换时间戳
 * @param bp 待转换时间戳的时间基
 * @param cq 目标时间基
 */
function avRescaleQ(a, bq, cq) {
    const b = a * BigInt(bq.num >>> 0) * BigInt(cq.den >>> 0);
    const c = BigInt(bq.den >>> 0) * BigInt(cq.num >>> 0);
    return b / c;
}
/**
 * 将一个时间戳由一个时间基转换到另一个时间基
 *
 * @param a 待转换时间戳
 * @param bp 待转换时间戳的时间基
 * @param cq 目标时间基
 */
function avRescaleQ2(a, bq, cq) {
    const b = a * BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](bq) >>> 0) * BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](cq + 4) >>> 0);
    const c = BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](bq + 4) >>> 0) * BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](cq) >>> 0);
    return b / c;
}
/**
 * 将一个时间基转换成 double
 *
 * @param a
 */
function avQ2D(a) {
    return a.num / a.den;
}
/**
 * 将一个时间基转换成 double
 *
 * @param a
 */
function avQ2D2(a) {
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a + 4);
}
/**
 * 化简 Rational
 *
 * @param a
 */
function avReduce(a) {
    const gcdValue = (0,common_math_gcd__WEBPACK_IMPORTED_MODULE_2__["default"])(a.num, a.den);
    if (gcdValue <= 1) {
        return;
    }
    a.den /= gcdValue;
    a.num /= gcdValue;
}
/**
 * 化简 Rational
 *
 * @param a
 */
function avReduce2(a) {
    const gcdValue = (0,common_math_gcd__WEBPACK_IMPORTED_MODULE_2__["default"])(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a + 4));
    if (gcdValue <= 1) {
        return;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](a + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a + 4) / gcdValue);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](a, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a) / gcdValue);
}


/***/ }),

/***/ "./src/avutil/util/sample.ts":
/*!***********************************!*\
  !*** ./src/avutil/util/sample.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sampleFormatGetLinesize: () => (/* binding */ sampleFormatGetLinesize),
/* harmony export */   sampleFormatIsPlanar: () => (/* binding */ sampleFormatIsPlanar)
/* harmony export */ });
/* unused harmony exports getBytesPerSample, sampleFillArrays, sampleAlloc, sampleSetSilence */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _util_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/common */ "./src/avutil/util/common.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _sampleFormatDescriptor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../sampleFormatDescriptor */ "./src/avutil/sampleFormatDescriptor.ts");


/*
 * libmedia audio sample util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





function getBytesPerSample(format) {
    return (format < 0 || format >= 12 /* AVSampleFormat.AV_SAMPLE_FMT_NB */)
        ? 0
        : _sampleFormatDescriptor__WEBPACK_IMPORTED_MODULE_6__.AVSampleFormatDescriptors[format].bits >> 3;
}
function sampleFormatIsPlanar(format) {
    return (format < 0 || format >= 12 /* AVSampleFormat.AV_SAMPLE_FMT_NB */)
        ? false
        : _sampleFormatDescriptor__WEBPACK_IMPORTED_MODULE_6__.AVSampleFormatDescriptors[format].planar;
}
function sampleFormatGetLinesize(format, channels, nbSamples, align) {
    const sampleSize = getBytesPerSample(format);
    const planar = sampleFormatIsPlanar(format);
    if (!sampleSize || nbSamples <= 0 || channels <= 0) {
        return -1;
    }
    if (!align) {
        align = 1;
        nbSamples = (0,_util_common__WEBPACK_IMPORTED_MODULE_4__.alignFunc)(nbSamples, 32);
    }
    if (channels > _constant__WEBPACK_IMPORTED_MODULE_3__.INT32_MAX / align || channels * nbSamples > (_constant__WEBPACK_IMPORTED_MODULE_3__.INT32_MAX - align * channels) / sampleSize) {
        return -1;
    }
    return planar ? (0,_util_common__WEBPACK_IMPORTED_MODULE_4__.alignFunc)(nbSamples * sampleSize, align) : (0,_util_common__WEBPACK_IMPORTED_MODULE_4__.alignFunc)(nbSamples * sampleSize * channels, align);
}
function sampleFillArrays(audioData, buf, format, linesize, channels) {
    const planar = sampleFormatIsPlanar(format);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.memset)(audioData, 0, planar ? 4 * channels : 4);
    if (!buf) {
        return -1;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](audioData, buf);
    if (planar) {
        for (let i = 1; i < channels; i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](audioData + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](audioData + (i - 1)) + linesize);
        }
    }
    return 0;
}
function sampleAlloc(audioData, format, linesize, channels) {
    const planar = sampleFormatIsPlanar(format);
    const bufSize = planar ? linesize * channels : linesize;
    if (bufSize < 0) {
        return bufSize;
    }
    const buf = (0,_util_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(bufSize);
    const ret = sampleFillArrays(audioData, buf, format, linesize, channels);
    if (ret < 0) {
        (0,_util_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(buf);
        return ret;
    }
    return 0;
}
function sampleSetSilence(audioData, offset, format, nbSamples, channels) {
    const planar = sampleFormatIsPlanar(format);
    const planes = planar ? channels : 1;
    const blockAlign = getBytesPerSample(format) * (planar ? 1 : channels);
    const dataSize = nbSamples * blockAlign;
    const fillChar = (format === 0 /* AVSampleFormat.AV_SAMPLE_FMT_U8 */ || format === 5 /* AVSampleFormat.AV_SAMPLE_FMT_U8P */)
        ? 0x80
        : 0x00;
    offset *= blockAlign;
    for (let i = 0; i < planes; i++) {
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](audioData + (i * 4)) + offset, fillChar, dataSize);
    }
}


/***/ }),

/***/ "./src/cheap/allocator/AllocatorJS.ts":
/*!********************************************!*\
  !*** ./src/cheap/allocator/AllocatorJS.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AllocatorJS)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var _thread_mutex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _staticData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../staticData */ "./src/cheap/staticData.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\cheap\\allocator\\AllocatorJS.ts";





const ALIGNMENT_IN_BYTES = 8;
const ALIGNMENT_MASK = ALIGNMENT_IN_BYTES - 1;
const POINTER_SIZE_IN_BYTES = 4;
const BYTES_TO_QUADS_SHIFT = 2;
const MIN_FREEABLE_SIZE_IN_BYTES = 16;
const MIN_FREEABLE_SIZE_IN_QUADS = bytesToQuads(MIN_FREEABLE_SIZE_IN_BYTES);
const MAX_HEIGHT = 32;
const HEADER_SIZE_IN_QUADS = 1 + (MAX_HEIGHT * 2);
const HEADER_OFFSET_IN_QUADS = 1;
const HEIGHT_OFFSET_IN_QUADS = 0;
const NEXT_OFFSET_IN_QUADS = 2;
const POINTER_SIZE_IN_QUADS = 1;
const POINTER_OVERHEAD_IN_QUADS = 2;
const FIRST_BLOCK_OFFSET_IN_QUADS = HEADER_OFFSET_IN_QUADS + HEADER_SIZE_IN_QUADS + POINTER_OVERHEAD_IN_QUADS;
const FIRST_BLOCK_OFFSET_IN_BYTES = FIRST_BLOCK_OFFSET_IN_QUADS * POINTER_SIZE_IN_BYTES;
const OVERHEAD_IN_BYTES = (FIRST_BLOCK_OFFSET_IN_QUADS + 1) * POINTER_SIZE_IN_BYTES;
class AllocatorJS {
    buffer;
    byteOffset;
    heapOffset;
    heapLength;
    int32Array;
    updates;
    options;
    shared;
    handles;
    constructor(options, init = true) {
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend({
            growSize: 1048576,
            maxHeapSize: 2097152000
        }, options);
        this.handles = [];
        this.buffer = options.buffer;
        this.shared = false;
        if (this.options.memory || this.buffer instanceof ArrayBuffer || this.buffer instanceof SharedArrayBuffer) {
            this.byteOffset = options.byteOffset ?? 0;
            this.heapOffset = alignHeapOffset(this.byteOffset + quadsToBytes(MAX_HEIGHT), options.byteLength ?? this.buffer.byteLength);
            this.heapLength = alignHeapLength((options.byteLength ?? this.buffer.byteLength) - this.heapOffset);
            this.int32Array = new Int32Array(this.buffer, this.heapOffset, bytesToQuads(this.heapLength));
            this.updates = new Int32Array(this.buffer, this.byteOffset, MAX_HEIGHT);
            if (typeof SharedArrayBuffer === 'function' && this.buffer instanceof SharedArrayBuffer) {
                this.shared = true;
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal('Expected buffer to be an instance of Buffer or ArrayBuffer', cheap__fileName__0, 109);
        }
        if (init) {
            this.updates.fill(HEADER_OFFSET_IN_QUADS);
            prepare(this.int32Array);
            checkListIntegrity(this.int32Array);
        }
    }
    addUpdateHandle(handle) {
        if (!common_util_array__WEBPACK_IMPORTED_MODULE_1__.has(this.handles, handle)) {
            this.handles.push(handle);
        }
    }
    removeUpdateHandle(handle) {
        common_util_array__WEBPACK_IMPORTED_MODULE_1__.remove(this.handles, handle);
    }
    malloc_(size) {
        size = align(size, ALIGNMENT_MASK);
        if (size < MIN_FREEABLE_SIZE_IN_BYTES) {
            size = MIN_FREEABLE_SIZE_IN_BYTES;
        }
        const minimumSize = bytesToQuads(size);
        const block = this.findFreeBlock(this.int32Array, minimumSize);
        if (block <= HEADER_OFFSET_IN_QUADS) {
            return 0;
        }
        const blockSize = readSize(this.int32Array, block);
        if (blockSize - (minimumSize + POINTER_OVERHEAD_IN_QUADS) >= MIN_FREEABLE_SIZE_IN_QUADS) {
            split(this.int32Array, block, minimumSize, blockSize, this.updates);
        }
        else {
            remove(this.int32Array, block, blockSize, this.updates);
        }
        return quadsToBytes(block) + this.heapOffset;
    }
    /**
     * Allocate a given number of bytes and return the offset.
     * If allocation fails, returns 0.
     */
    malloc(size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex, !false);
            this.checkBuffer();
        }
        const address = this.malloc_(size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex);
        }
        return address;
    }
    calloc_(num, size) {
        let numberOfBytes = num * size;
        if (numberOfBytes < MIN_FREEABLE_SIZE_IN_BYTES) {
            numberOfBytes = MIN_FREEABLE_SIZE_IN_BYTES;
        }
        else {
            numberOfBytes = align(numberOfBytes, ALIGNMENT_MASK);
        }
        const address = this.malloc_(numberOfBytes);
        if (address === 0) {
            // Not enough space
            return 0;
        }
        const offset = bytesToQuads(address - this.heapOffset);
        this.int32Array.subarray(offset, offset + bytesToQuads(numberOfBytes)).fill(0);
        return address;
    }
    calloc(num, size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex, !false);
            this.checkBuffer();
        }
        const address = this.calloc_(num, size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex);
        }
        return address;
    }
    realloc_(address, size) {
        if (address === 0) {
            return this.malloc_(size);
        }
        const originAddress = address;
        if (size === 0) {
            this.free_(originAddress);
            return 0;
        }
        address = address - this.heapOffset;
        let originBlock = bytesToQuads(address);
        let block = originBlock;
        let padding = 0;
        if (isAlign(this.int32Array, originBlock)) {
            block = this.int32Array[originBlock - 1];
            padding = originBlock - block;
        }
        const blockSize = readSize(this.int32Array, block) - padding;
        const minimumSize = bytesToQuads(align(size, ALIGNMENT_MASK));
        if (blockSize >= minimumSize) {
            return originAddress;
        }
        else {
            const newAddress = this.malloc_(size);
            if (newAddress === 0) {
                this.free_(originAddress);
                return 0;
            }
            this.int32Array.set(this.int32Array.subarray(originBlock, originBlock + blockSize), bytesToQuads(newAddress - this.heapOffset));
            this.free_(originAddress);
            return newAddress;
        }
    }
    realloc(address, size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex, !false);
            this.checkBuffer();
        }
        address = this.realloc_(address, size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex);
        }
        return address;
    }
    alignedAlloc_(alignment, size) {
        if (alignment <= ALIGNMENT_IN_BYTES) {
            // malloc 以 ALIGNMENT_IN_BYTES 字节对齐
            return this.malloc_(size);
        }
        const address = this.malloc_(size + alignment - 1 + POINTER_SIZE_IN_BYTES);
        if (address === 0) {
            return 0;
        }
        const alignmentAddress = (address + alignment - 1 + POINTER_SIZE_IN_BYTES) & ~(alignment - 1);
        this.int32Array[bytesToQuads(alignmentAddress - this.heapOffset) - POINTER_SIZE_IN_QUADS] = bytesToQuads(address - this.heapOffset);
        return alignmentAddress;
    }
    alignedAlloc(alignment, size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex, !false);
            this.checkBuffer();
        }
        const address = this.alignedAlloc_(alignment, size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex);
        }
        return address;
    }
    free_(address) {
        if (address === 0) {
            return;
        }
        address = address - this.heapOffset;
        let block = bytesToQuads(address);
        if (isAlign(this.int32Array, block)) {
            block = this.int32Array[block - POINTER_SIZE_IN_QUADS];
        }
        if (isFree(this.int32Array, block)) {
            return;
        }
        const blockSize = readSize(this.int32Array, block);
        const preceding = getFreeBlockBefore(this.int32Array, block);
        const trailing = getFreeBlockAfter(this.int32Array, block);
        if (preceding !== 0) {
            if (trailing !== 0) {
                insertMiddle(this.int32Array, preceding, block, blockSize, trailing, this.updates);
            }
            else {
                insertAfter(this.int32Array, preceding, block, blockSize, this.updates);
            }
        }
        else if (trailing !== 0) {
            insertBefore(this.int32Array, trailing, block, blockSize, this.updates);
        }
        else {
            insert(this.int32Array, block, blockSize, this.updates);
        }
    }
    /**
     * Free a number of bytes from the given address.
     */
    free(address) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex, !false);
            this.checkBuffer();
        }
        this.free_(address);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex);
        }
    }
    /**
     * Return the size of the block at the given address.
     */
    sizeof(address) {
        if (address === 0) {
            return 0;
        }
        address -= this.heapOffset;
        let block = bytesToQuads(address);
        if (isAlign(this.int32Array, block)) {
            block = this.int32Array[block - POINTER_SIZE_IN_QUADS];
        }
        return quadsToBytes(readSize(this.int32Array, block));
    }
    /**
     * 获取堆分配信息
     *
     * @returns
     */
    inspect() {
        this.checkBuffer();
        return inspect(this.int32Array, this.heapOffset);
    }
    findFreeBlock(int32Array, minimumSize) {
        let block = findFreeBlock(int32Array, minimumSize);
        if (block === HEADER_OFFSET_IN_QUADS) {
            if (this.options.growAllowed && this.heapLength < this.options.maxHeapSize) {
                const block = this.int32Array.length + 1;
                let int32Array;
                let updates;
                let byteOffset = 0;
                let heapLength = 0;
                let heapOffset = 0;
                if (this.options.onResize) {
                    const result = this.options.onResize(this.int32Array, this.int32Array.byteLength + align(Math.max(this.options.growSize, quadsToBytes(minimumSize)), ALIGNMENT_MASK));
                    byteOffset = result.byteOffset ?? 0;
                    heapOffset = alignHeapOffset(byteOffset + quadsToBytes(MAX_HEIGHT), result.byteLength ?? result.buffer.byteLength);
                    heapLength = alignHeapLength((result.byteLength ?? result.buffer.byteLength) - heapOffset);
                    int32Array = new Int32Array(result.buffer, heapOffset, bytesToQuads(heapLength));
                    updates = new Int32Array(result.buffer, byteOffset, MAX_HEIGHT);
                }
                else {
                    const buffer = new ArrayBuffer(this.int32Array.length + bytesToQuads(this.options.growSize));
                    heapOffset = alignHeapOffset(byteOffset + quadsToBytes(MAX_HEIGHT), buffer.byteLength);
                    heapLength = alignHeapLength(buffer.byteLength - heapOffset);
                    int32Array = new Int32Array(buffer, heapOffset, bytesToQuads(heapLength));
                    int32Array.set(this.int32Array, 0);
                    updates = new Int32Array(buffer, byteOffset, MAX_HEIGHT);
                }
                this.byteOffset = byteOffset;
                this.heapOffset = heapOffset;
                this.buffer = int32Array.buffer;
                this.heapLength = heapLength;
                this.int32Array = int32Array;
                this.updates = updates;
                const blockSize = int32Array.length - (block - 1) - POINTER_OVERHEAD_IN_QUADS;
                writeFreeBlockSize(int32Array, blockSize, block);
                const preceding = getFreeBlockBefore(int32Array, block);
                if (preceding !== 0) {
                    insertAfter(int32Array, preceding, block, blockSize, this.updates);
                }
                else {
                    insert(int32Array, block, blockSize, this.updates);
                }
                if (this.handles.length) {
                    common_util_array__WEBPACK_IMPORTED_MODULE_1__.each(this.handles, (func) => {
                        func(this.buffer);
                    });
                }
                return this.findFreeBlock(this.int32Array, minimumSize);
            }
            return block;
        }
        else {
            return block;
        }
    }
    getBuffer() {
        return this.buffer;
    }
    isAlloc(pointer) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex, !false);
            this.checkBuffer();
        }
        const block = bytesToQuads(pointer - this.heapOffset);
        let next = this.int32Array[HEADER_OFFSET_IN_QUADS + NEXT_OFFSET_IN_QUADS];
        // sometime get undefined from the last free node in v8
        // but it's is all right |=_=
        while (next && next !== HEADER_OFFSET_IN_QUADS) {
            if (block >= next && block < next + this.int32Array[next - POINTER_SIZE_IN_QUADS]) {
                if (this.shared) {
                    (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex);
                }
                return false;
            }
            next = this.int32Array[next + NEXT_OFFSET_IN_QUADS];
        }
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex);
        }
        return true;
    }
    checkBuffer() {
        if (this.options.memory && this.options.memory.buffer !== this.buffer) {
            this.buffer = this.options.memory.buffer;
            this.heapLength = alignHeapLength(this.buffer.byteLength - this.heapOffset);
            this.int32Array = new Int32Array(this.buffer, this.heapOffset, bytesToQuads(this.heapLength));
        }
    }
}
/**
 * Prepare the given int32Array and ensure it contains a valid header.
 */
function prepare(int32Array) {
    if (!verifyHeader(int32Array)) {
        writeInitialHeader(int32Array);
    }
}
/**
 * Verify that the int32Array contains a valid header.
 */
function verifyHeader(int32Array) {
    return int32Array[HEADER_OFFSET_IN_QUADS - 1] === HEADER_SIZE_IN_QUADS
        && int32Array[HEADER_OFFSET_IN_QUADS + HEADER_SIZE_IN_QUADS] === HEADER_SIZE_IN_QUADS;
}
/**
 * Write the initial header for an empty int32Array.
 */
function writeInitialHeader(int32Array) {
    const header = HEADER_OFFSET_IN_QUADS;
    const headerSize = HEADER_SIZE_IN_QUADS;
    const block = FIRST_BLOCK_OFFSET_IN_QUADS;
    const blockSize = int32Array.length - (header + headerSize + POINTER_OVERHEAD_IN_QUADS + POINTER_SIZE_IN_QUADS);
    writeFreeBlockSize(int32Array, headerSize, header);
    int32Array[header + HEIGHT_OFFSET_IN_QUADS] = 1;
    int32Array[header + NEXT_OFFSET_IN_QUADS] = block;
    for (let height = 1; height < MAX_HEIGHT; height++) {
        int32Array[header + NEXT_OFFSET_IN_QUADS + height] = HEADER_OFFSET_IN_QUADS;
    }
    writeFreeBlockSize(int32Array, blockSize, block);
    int32Array[block + HEIGHT_OFFSET_IN_QUADS] = 1;
    int32Array[block + NEXT_OFFSET_IN_QUADS] = header;
}
/**
 * Check the integrity of the freelist in the given array.
 */
function checkListIntegrity(int32Array) {
    let block = FIRST_BLOCK_OFFSET_IN_QUADS;
    while (block < int32Array.length - POINTER_SIZE_IN_QUADS) {
        const size = readSize(int32Array, block);
        /* istanbul ignore if  */
        if (size < POINTER_OVERHEAD_IN_QUADS || size >= int32Array.length - FIRST_BLOCK_OFFSET_IN_QUADS) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal(`Got invalid sized chunk at ${quadsToBytes(block)} (${quadsToBytes(size)} bytes).`, cheap__fileName__0, 568);
        }
        else if (isFree(int32Array, block)) {
            checkFreeBlockIntegrity(int32Array, block, size);
        }
        else {
            checkUsedBlockIntegrity(int32Array, block, size);
        }
        block += size + POINTER_OVERHEAD_IN_QUADS;
    }
    return true;
}
function checkFreeBlockIntegrity(int32Array, block, blockSize) {
    /* istanbul ignore if  */
    if (int32Array[block - 1] !== int32Array[block + blockSize]) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal(`Block length header does not match footer (${quadsToBytes(int32Array[block - 1])} vs ${quadsToBytes(int32Array[block + blockSize])}).`, cheap__fileName__0, 584);
    }
    const height = int32Array[block + HEIGHT_OFFSET_IN_QUADS];
    /* istanbul ignore if  */
    if (height < 1 || height > MAX_HEIGHT) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal(`Block ${quadsToBytes(block)} height must be between 1 and ${MAX_HEIGHT}, got ${height}.`, cheap__fileName__0, 589);
    }
    for (let i = 0; i < height; i++) {
        const pointer = int32Array[block + NEXT_OFFSET_IN_QUADS + i];
        /* istanbul ignore if  */
        if (pointer >= FIRST_BLOCK_OFFSET_IN_QUADS && !isFree(int32Array, pointer)) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal(`Block ${quadsToBytes(block)} has a pointer to a non-free block (${quadsToBytes(pointer)}).`, cheap__fileName__0, 595);
        }
    }
    return true;
}
function checkUsedBlockIntegrity(int32Array, block, blockSize) {
    /* istanbul ignore if  */
    if (int32Array[block - 1] !== int32Array[block + blockSize]) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal(`Block length header does not match footer (${quadsToBytes(int32Array[block - 1])} vs ${quadsToBytes(int32Array[block + blockSize])}).`, cheap__fileName__0, 604);
    }
    else {
        return true;
    }
}
/**
 * Inspect the freelist in the given array.
 */
function inspect(int32Array, byteOffset) {
    const blocks = [];
    const header = readListNode(int32Array, HEADER_OFFSET_IN_QUADS, byteOffset);
    let block = FIRST_BLOCK_OFFSET_IN_QUADS;
    let used = 0;
    while (block < int32Array.length - POINTER_SIZE_IN_QUADS) {
        const size = readSize(int32Array, block);
        /* istanbul ignore if  */
        if (size < POINTER_OVERHEAD_IN_QUADS || size >= int32Array.length) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal(`Got invalid sized chunk at ${quadsToBytes(block)} (${quadsToBytes(size)})`, cheap__fileName__0, 624);
        }
        if (isFree(int32Array, block)) {
            // @flowIssue todo
            blocks.push(readListNode(int32Array, block, byteOffset));
        }
        else {
            used += quadsToBytes(size);
            blocks.push({
                type: 'used',
                block: block,
                offset: quadsToBytes(block) + byteOffset,
                size: quadsToBytes(size)
            });
        }
        block += size + POINTER_OVERHEAD_IN_QUADS;
    }
    return { header, blocks, total: quadsToBytes(int32Array.length), used };
}
/**
 * Convert quads to bytes.
 */
function quadsToBytes(num) {
    return (num << BYTES_TO_QUADS_SHIFT) >>> 0;
}
/**
 * Convert bytes to quads.
 */
function bytesToQuads(num) {
    return num >>> BYTES_TO_QUADS_SHIFT;
}
/**
 * Align the given value to 8 bytes.
 */
function align(value, alignment) {
    return ((value + alignment) & ~alignment) >>> 0;
}
/**
 * align heap
 *
 * @param offset heap start offset
 * @param byteLength  buffer length
 * @returns
 */
function alignHeapOffset(offset, byteLength) {
    const length = byteLength - offset;
    // 保证 heapLength 为 ALIGNMENT_IN_BYTES 对齐
    let heapOffset = offset + (align(length, ALIGNMENT_MASK) === length
        ? 0
        : (length - align(length, ALIGNMENT_MASK) + ALIGNMENT_IN_BYTES));
    return heapOffset;
}
function alignHeapLength(length) {
    // header 所占 int length 为奇数，则总长度也需要为奇数保证 body 为偶数
    if (!((HEADER_OFFSET_IN_QUADS + HEADER_SIZE_IN_QUADS) % 2)) {
        length -= POINTER_SIZE_IN_BYTES;
    }
    return length;
}
/**
 * Read the list pointers for a given block.
 */
function readListNode(int32Array, block, byteOffset) {
    const height = int32Array[block + HEIGHT_OFFSET_IN_QUADS];
    const pointers = [];
    for (let i = 0; i < height; i++) {
        pointers.push(int32Array[block + NEXT_OFFSET_IN_QUADS + i]);
    }
    return {
        type: 'free',
        block,
        offset: quadsToBytes(block) + byteOffset,
        height,
        pointers,
        size: quadsToBytes(int32Array[block - 1])
    };
}
/**
 * Read the size (in quads) of the block at the given address.
 */
function readSize(int32Array, block) {
    const n = int32Array[block - 1];
    const mask = n >> 31;
    return (n + mask) ^ mask;
}
/**
 * Write the size of the block at the given address.
 * Note: This ONLY works for free blocks, not blocks in use.
 */
function writeFreeBlockSize(int32Array, size, block) {
    int32Array[block - 1] = size;
    int32Array[block + size] = size;
}
/**
 * Populate the `UPDATES` array with the offset of the last item in each
 * list level, *before* a node of at least the given size.
 */
function findPredecessors(int32Array, minimumSize, UPDATES) {
    const listHeight = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS];
    let node = HEADER_OFFSET_IN_QUADS;
    for (let height = listHeight; height > 0; height--) {
        let next = node + NEXT_OFFSET_IN_QUADS + (height - 1);
        while (int32Array[next] >= FIRST_BLOCK_OFFSET_IN_QUADS && int32Array[int32Array[next] - 1] < minimumSize) {
            node = int32Array[next];
            next = node + NEXT_OFFSET_IN_QUADS + (height - 1);
        }
        UPDATES[height - 1] = node;
    }
}
/**
 * Find a free block with at least the given size and return its offset in quads.
 */
function findFreeBlock(int32Array, minimumSize) {
    let block = HEADER_OFFSET_IN_QUADS;
    for (let height = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS]; height > 0; height--) {
        let next = int32Array[block + NEXT_OFFSET_IN_QUADS + (height - 1)];
        while (next !== HEADER_OFFSET_IN_QUADS && int32Array[next - POINTER_SIZE_IN_QUADS] < minimumSize) {
            block = next;
            next = int32Array[block + NEXT_OFFSET_IN_QUADS + (height - 1)];
        }
    }
    block = int32Array[block + NEXT_OFFSET_IN_QUADS];
    if (block === HEADER_OFFSET_IN_QUADS) {
        return block;
    }
    else {
        return block;
    }
}
/**
 * Split the given block after a certain number of bytes and add the second half to the freelist.
 */
function split(int32Array, block, firstSize, blockSize, UPDATES) {
    const second = (block + firstSize + POINTER_OVERHEAD_IN_QUADS);
    const secondSize = (blockSize - (second - block));
    remove(int32Array, block, blockSize, UPDATES);
    int32Array[block - 1] = -firstSize;
    int32Array[block + firstSize] = -firstSize;
    int32Array[second - 1] = -secondSize;
    int32Array[second + secondSize] = -secondSize;
    insert(int32Array, second, secondSize, UPDATES);
}
/**
 * Remove the given block from the freelist and mark it as allocated.
 */
function remove(int32Array, block, blockSize, UPDATES) {
    findPredecessors(int32Array, blockSize, UPDATES);
    let node = int32Array[UPDATES[0] + NEXT_OFFSET_IN_QUADS];
    while (node !== block && node !== HEADER_OFFSET_IN_QUADS && int32Array[node - 1] <= blockSize) {
        for (let height = int32Array[node + HEIGHT_OFFSET_IN_QUADS] - 1; height >= 0; height--) {
            if (int32Array[node + NEXT_OFFSET_IN_QUADS + height] === block) {
                UPDATES[height] = node;
            }
        }
        node = int32Array[node + NEXT_OFFSET_IN_QUADS];
    }
    let listHeight = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS];
    for (let height = 0; height < listHeight; height++) {
        const next = int32Array[UPDATES[height] + NEXT_OFFSET_IN_QUADS + height];
        if (next !== block) {
            break;
        }
        int32Array[UPDATES[height] + NEXT_OFFSET_IN_QUADS + height] = int32Array[block + NEXT_OFFSET_IN_QUADS + height];
    }
    while (listHeight > 0 && int32Array[HEADER_OFFSET_IN_QUADS + NEXT_OFFSET_IN_QUADS + (listHeight - 1)] === HEADER_OFFSET_IN_QUADS) {
        listHeight--;
        int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS] = listHeight;
    }
    // invert the size sign to signify an allocated block
    int32Array[block - 1] = -blockSize;
    int32Array[block + blockSize] = -blockSize;
}
/**
 * Determine whether the block at the given address is free or not.
 */
function isFree(int32Array, block) {
    /* istanbul ignore if  */
    if (block < HEADER_SIZE_IN_QUADS) {
        return false;
    }
    const size = int32Array[block - POINTER_SIZE_IN_QUADS];
    if (size < 0) {
        return false;
    }
    else {
        return true;
    }
}
/**
 * Determine whether the block at the given address is free or not.
 */
function isAlign(int32Array, block) {
    /* istanbul ignore if  */
    if (block < HEADER_SIZE_IN_QUADS) {
        return false;
    }
    const origin = int32Array[block - POINTER_SIZE_IN_QUADS];
    if (origin < 0) {
        return false;
    }
    else {
        return true;
    }
}
/**
 * Get the address of the block before the given one and return the address *if it is free*,
 * otherwise 0.
 */
function getFreeBlockBefore(int32Array, block) {
    if (block <= FIRST_BLOCK_OFFSET_IN_QUADS) {
        return 0;
    }
    const beforeSize = int32Array[block - POINTER_OVERHEAD_IN_QUADS];
    if (beforeSize < POINTER_OVERHEAD_IN_QUADS) {
        return 0;
    }
    return block - (POINTER_OVERHEAD_IN_QUADS + beforeSize);
}
/**
 * Get the address of the block after the given one and return its address *if it is free*,
 * otherwise 0.
 */
function getFreeBlockAfter(int32Array, block) {
    const blockSize = readSize(int32Array, block);
    if (block + blockSize + POINTER_OVERHEAD_IN_QUADS >= int32Array.length - 2) {
        // Block is the last in the list.
        return 0;
    }
    const next = (block + blockSize + POINTER_OVERHEAD_IN_QUADS);
    const nextSize = int32Array[next - POINTER_SIZE_IN_QUADS];
    if (nextSize < POINTER_OVERHEAD_IN_QUADS) {
        return 0;
    }
    return next;
}
/**
 * Insert the given block into the freelist and return the number of bytes that were freed.
 */
function insert(int32Array, block, blockSize, UPDATES) {
    findPredecessors(int32Array, blockSize, UPDATES);
    const blockHeight = generateHeight(int32Array, block, blockSize, UPDATES);
    for (let height = 1; height <= blockHeight; height++) {
        const update = UPDATES[height - 1] + NEXT_OFFSET_IN_QUADS + (height - 1);
        int32Array[block + NEXT_OFFSET_IN_QUADS + (height - 1)] = int32Array[update];
        int32Array[update] = block;
        UPDATES[height - 1] = HEADER_OFFSET_IN_QUADS;
    }
    int32Array[block - 1] = blockSize;
    int32Array[block + blockSize] = blockSize;
    return blockSize;
}
/**
 * Insert the given block into the freelist before the given free block,
 * joining them together, returning the number of bytes which were freed.
 */
function insertBefore(int32Array, trailing, block, blockSize, UPDATES) {
    const trailingSize = readSize(int32Array, trailing);
    remove(int32Array, trailing, trailingSize, UPDATES);
    const size = (blockSize + trailingSize + POINTER_OVERHEAD_IN_QUADS);
    int32Array[block - POINTER_SIZE_IN_QUADS] = -size;
    int32Array[trailing + trailingSize] = -size;
    insert(int32Array, block, size, UPDATES);
    return blockSize;
}
/**
 * Insert the given block into the freelist in between the given free blocks,
 * joining them together, returning the number of bytes which were freed.
 */
function insertMiddle(int32Array, preceding, block, blockSize, trailing, UPDATES) {
    const precedingSize = readSize(int32Array, preceding);
    const trailingSize = readSize(int32Array, trailing);
    const size = ((trailing - preceding) + trailingSize);
    remove(int32Array, preceding, precedingSize, UPDATES);
    remove(int32Array, trailing, trailingSize, UPDATES);
    int32Array[preceding - POINTER_SIZE_IN_QUADS] = -size;
    int32Array[trailing + trailingSize] = -size;
    insert(int32Array, preceding, size, UPDATES);
    return blockSize;
}
/**
 * Insert the given block into the freelist after the given free block,
 * joining them together, returning the number of bytes which were freed.
 */
function insertAfter(int32Array, preceding, block, blockSize, UPDATES) {
    const precedingSize = (block - preceding) - POINTER_OVERHEAD_IN_QUADS;
    const size = ((block - preceding) + blockSize);
    remove(int32Array, preceding, precedingSize, UPDATES);
    int32Array[preceding - POINTER_SIZE_IN_QUADS] = -size;
    int32Array[block + blockSize] = -size;
    insert(int32Array, preceding, size, UPDATES);
    return blockSize;
}
/**
 * Generate a random height for a block, growing the list height by 1 if required.
 */
function generateHeight(int32Array, block, blockSize, UPDATES) {
    const listHeight = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS];
    let height = randomHeight();
    if (blockSize - 1 < height + 1) {
        height = blockSize - 2;
    }
    if (height > listHeight) {
        const newHeight = listHeight + 1;
        int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS] = newHeight;
        int32Array[HEADER_OFFSET_IN_QUADS + NEXT_OFFSET_IN_QUADS + (newHeight - 1)] = HEADER_OFFSET_IN_QUADS;
        UPDATES[newHeight] = HEADER_OFFSET_IN_QUADS;
        int32Array[block + HEIGHT_OFFSET_IN_QUADS] = newHeight;
        return newHeight;
    }
    else {
        int32Array[block + HEIGHT_OFFSET_IN_QUADS] = height;
        return height;
    }
}
/**
 * Generate a random height for a new block.
 */
function randomHeight() {
    let height = 1;
    while (Math.random() < 0.5 && height < MAX_HEIGHT) {
        height += 1;
    }
    return height;
}


/***/ }),

/***/ "./src/cheap/allocator/Table.ts":
/*!**************************************!*\
  !*** ./src/cheap/allocator/Table.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebassemblyTable: () => (/* binding */ WebassemblyTable)
/* harmony export */ });
const INIT_SIZE = 10;
class WebassemblyTable {
    table;
    pointer;
    nodes;
    constructor() {
        this.table = new WebAssembly.Table({
            initial: 6 /* BuiltinTableSlot.SLOT_NB */ + INIT_SIZE,
            element: 'anyfunc'
        });
        this.pointer = 6 /* BuiltinTableSlot.SLOT_NB */;
        this.nodes = [{
                pointer: this.pointer,
                length: INIT_SIZE,
                free: true
            }];
    }
    getPointer() {
        return this.pointer;
    }
    alloc(count) {
        let p = this.findFree(count);
        if (p < 0) {
            const last = this.nodes[this.nodes.length - 1];
            const length = count - (last.free ? last.length : 0);
            this.table.grow(length);
            if (last.free) {
                last.length = last.length + length;
            }
            else {
                this.nodes.push({
                    pointer: last.pointer + last.length,
                    length,
                    free: true
                });
            }
            p = this.findFree(count);
        }
        const node = this.nodes[p];
        if (node.length > count) {
            this.nodes.splice(p + 1, 0, {
                pointer: node.pointer + count,
                length: node.length - count,
                free: true
            });
            node.length = count;
        }
        node.free = false;
        return node.pointer;
    }
    free(pointer) {
        let p = this.findNode(pointer);
        const node = this.nodes[p];
        if (node && !node.free) {
            const before = this.nodes[p - 1];
            const after = this.nodes[p + 1];
            if (before && before.free) {
                if (after && after.free) {
                    before.length += (node.length + after.length);
                    this.nodes.splice(p, 2);
                }
                else {
                    before.length += node.length;
                    this.nodes.splice(p, 1);
                }
            }
            else {
                if (after && after.free) {
                    node.length += after.length;
                    this.nodes.splice(p + 1, 1);
                    node.free = true;
                }
                else {
                    node.free = true;
                }
            }
        }
        if (this.nodes.length === 1 && this.nodes[0].free) {
            // 当全部 free 之后重新创建新的 Table，之前 WebAssembly 设置的函数引用在 chrome 上没有被回收，会内存泄漏
            const table = new WebAssembly.Table({
                initial: 6 /* BuiltinTableSlot.SLOT_NB */ + INIT_SIZE,
                element: 'anyfunc'
            });
            this.pointer = 6 /* BuiltinTableSlot.SLOT_NB */;
            this.nodes = [{
                    pointer: this.pointer,
                    length: INIT_SIZE,
                    free: true
                }];
            for (let i = 1; i < this.pointer; i++) {
                table.set(i, this.table.get(i));
            }
            this.table = table;
        }
    }
    get(index) {
        return this.table.get(index);
    }
    set(index, value) {
        if (index < 0 || index >= this.pointer) {
            throw new RangeError('index out of bound');
        }
        this.table.set(index, value);
    }
    inspect() {
        return this.nodes;
    }
    findFree(length) {
        let index = -1;
        for (let i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i].length >= length && this.nodes[i].free) {
                index = i;
                break;
            }
        }
        return index;
    }
    findNode(pointer) {
        let index = -1;
        for (let i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i].pointer === pointer) {
                index = i;
                break;
            }
        }
        return index;
    }
}


/***/ }),

/***/ "./src/cheap/asm/memory.ts":
/*!*********************************!*\
  !*** ./src/cheap/asm/memory.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* unused harmony exports instance, support */
/* harmony import */ var common_util_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/base64 */ "./src/common/util/base64.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
/* harmony import */ var _memory_asm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./memory.asm */ "./src/cheap/asm/memory.asm");
/* harmony import */ var _memory_asm__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_memory_asm__WEBPACK_IMPORTED_MODULE_5__);
var cheap__fileName__0 = "src\\cheap\\asm\\memory.ts";






/**
 * WebAssembly runtime 实例
 */
let instance;
function support() {
    return !!instance;
}
async function init(memory) {
    try {
        let wasm = (0,common_util_base64__WEBPACK_IMPORTED_MODULE_0__.base64ToUint8Array)((_memory_asm__WEBPACK_IMPORTED_MODULE_5___default()));
        common_util_wasm__WEBPACK_IMPORTED_MODULE_4__.setMemoryShared(wasm, typeof SharedArrayBuffer === 'function' && memory.buffer instanceof SharedArrayBuffer);
        instance = (await WebAssembly.instantiate(wasm, {
            env: {
                memory
            }
        })).instance;
        (0,_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.override)({
            [4 /* CTypeEnum.char */]: instance.exports.readU8,
            [5 /* CTypeEnum.atomic_char */]: instance.exports.readU8,
            [2 /* CTypeEnum.uint8 */]: instance.exports.readU8,
            [3 /* CTypeEnum.atomic_uint8 */]: instance.exports.readU8,
            [6 /* CTypeEnum.uint16 */]: instance.exports.readU16,
            [7 /* CTypeEnum.atomic_uint16 */]: instance.exports.readU16,
            [8 /* CTypeEnum.uint32 */]: (pointer) => {
                return instance.exports.read32(pointer) >>> 0;
            },
            [9 /* CTypeEnum.atomic_uint32 */]: (pointer) => {
                return instance.exports.read32(pointer) >>> 0;
            },
            [10 /* CTypeEnum.uint64 */]: (pointer) => {
                return BigInt.asUintN(64, instance.exports.read64(pointer));
            },
            [22 /* CTypeEnum.atomic_uint64 */]: (pointer) => {
                return BigInt.asUintN(64, instance.exports.read64(pointer));
            },
            [11 /* CTypeEnum.int8 */]: instance.exports.read8,
            [12 /* CTypeEnum.atomic_int8 */]: instance.exports.read8,
            [13 /* CTypeEnum.int16 */]: instance.exports.read16,
            [14 /* CTypeEnum.atomic_int16 */]: instance.exports.read16,
            [15 /* CTypeEnum.int32 */]: instance.exports.read32,
            [16 /* CTypeEnum.atomic_int32 */]: instance.exports.read32,
            [17 /* CTypeEnum.int64 */]: instance.exports.read64,
            [21 /* CTypeEnum.atomic_int64 */]: instance.exports.read64,
            [18 /* CTypeEnum.float */]: instance.exports.readf32,
            [19 /* CTypeEnum.double */]: instance.exports.readf64,
            [20 /* CTypeEnum.pointer */]: (pointer) => {
                return instance.exports.read32(pointer) >>> 0;
            }
        });
        (0,_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.override)({
            [4 /* CTypeEnum.char */]: instance.exports.write8,
            [5 /* CTypeEnum.atomic_char */]: instance.exports.write8,
            [2 /* CTypeEnum.uint8 */]: instance.exports.write8,
            [3 /* CTypeEnum.atomic_uint8 */]: instance.exports.write8,
            [6 /* CTypeEnum.uint16 */]: instance.exports.write16,
            [7 /* CTypeEnum.atomic_uint16 */]: instance.exports.write16,
            [8 /* CTypeEnum.uint32 */]: instance.exports.write32,
            [9 /* CTypeEnum.atomic_uint32 */]: instance.exports.write32,
            [10 /* CTypeEnum.uint64 */]: instance.exports.write64,
            [22 /* CTypeEnum.atomic_uint64 */]: instance.exports.write64,
            [11 /* CTypeEnum.int8 */]: instance.exports.write8,
            [12 /* CTypeEnum.atomic_int8 */]: instance.exports.write8,
            [13 /* CTypeEnum.int16 */]: instance.exports.write16,
            [14 /* CTypeEnum.atomic_int16 */]: instance.exports.write16,
            [15 /* CTypeEnum.int32 */]: instance.exports.write32,
            [16 /* CTypeEnum.atomic_int32 */]: instance.exports.write32,
            [17 /* CTypeEnum.int64 */]: instance.exports.write64,
            [21 /* CTypeEnum.atomic_int64 */]: instance.exports.write64,
            [18 /* CTypeEnum.float */]: instance.exports.writef32,
            [19 /* CTypeEnum.double */]: instance.exports.writef64,
            [20 /* CTypeEnum.pointer */]: instance.exports.write32
        });
    }
    catch (error) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.warn('memory asm not support, cannot use asm memory function', cheap__fileName__0, 96);
    }
}


/***/ }),

/***/ "./src/cheap/config.ts":
/*!*****************************!*\
  !*** ./src/cheap/config.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HEAP_INITIAL: () => (/* binding */ HEAP_INITIAL),
/* harmony export */   HEAP_MAXIMUM: () => (/* binding */ HEAP_MAXIMUM),
/* harmony export */   HEAP_OFFSET: () => (/* binding */ HEAP_OFFSET),
/* harmony export */   STACK_ALIGNMENT: () => (/* binding */ STACK_ALIGNMENT),
/* harmony export */   STACK_SIZE: () => (/* binding */ STACK_SIZE),
/* harmony export */   USE_THREADS: () => (/* binding */ USE_THREADS)
/* harmony export */ });
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");


/**
 * 是否使用多线程
 */
const USE_THREADS =  true && (common_util_support__WEBPACK_IMPORTED_MODULE_0__["default"].thread || false) && common_util_constant__WEBPACK_IMPORTED_MODULE_1__.SELF.CHEAP_DISABLE_THREAD !== true;
/**
 * 栈地址对齐
 * 栈地址至少是 16 字节对齐，因为 wasm 的基本类型中最大是 v128 16 字节
 */
let STACK_ALIGNMENT = 16;
/**
 * 栈大小，应为 STACK_ALIGNMENT 的整数倍
 */
let STACK_SIZE = 1048576;
/**
 * 堆保留段，可用于静态数据区分配
 */
const HEAP_OFFSET = 1024;
/**
 * 堆初始大小
 */
const HEAP_INITIAL = (common_util_constant__WEBPACK_IMPORTED_MODULE_1__.SELF.CHEAP_HEAP_INITIAL ?? 265);
/**
 * 堆最大大小
 */
const HEAP_MAXIMUM = 65536;


/***/ }),

/***/ "./src/cheap/ctypeEnumImpl.ts":
/*!************************************!*\
  !*** ./src/cheap/ctypeEnumImpl.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_function_isLittleEndian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/function/isLittleEndian */ "./src/common/function/isLittleEndian.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");



let getAllocator;
let getView;
const littleEndian = (0,common_function_isLittleEndian__WEBPACK_IMPORTED_MODULE_0__["default"])();
function writeU8(pointer, value) {
    getView().setUint8(pointer, value);
}
function readU8(pointer) {
    return getView().getUint8(pointer);
}
function writeU16(pointer, value) {
    getView().setUint16(pointer, value, littleEndian);
}
function readU16(pointer) {
    return getView().getUint16(pointer, littleEndian);
}
function writeU32(pointer, value) {
    getView().setUint32(pointer, value, littleEndian);
}
function readU32(pointer) {
    return getView().getUint32(pointer, littleEndian);
}
function writeU64(pointer, value) {
    getView().setBigUint64(pointer, value, littleEndian);
}
function readU64(pointer) {
    return getView().getBigUint64(pointer, littleEndian);
}
function write8(pointer, value) {
    getView().setInt8(pointer, value);
}
function read8(pointer) {
    return getView().getInt8(pointer);
}
function write16(pointer, value) {
    getView().setInt16(pointer, value, littleEndian);
}
function read16(pointer) {
    return getView().getInt16(pointer, littleEndian);
}
function write32(pointer, value) {
    getView().setInt32(pointer, value, littleEndian);
}
function read32(pointer) {
    return getView().getInt32(pointer, littleEndian);
}
function write64(pointer, value) {
    getView().setBigInt64(pointer, value, littleEndian);
}
function read64(pointer) {
    return getView().getBigInt64(pointer, littleEndian);
}
function writef32(pointer, value) {
    getView().setFloat32(pointer, value, littleEndian);
}
function readf32(pointer) {
    return getView().getFloat32(pointer, littleEndian);
}
function writef64(pointer, value) {
    getView().setFloat64(pointer, value, littleEndian);
}
function readf64(pointer) {
    return getView().getFloat64(pointer, littleEndian);
}
function readPointer(pointer) {
    return getView().getUint32(pointer, littleEndian);
}
function writePointer(pointer, value) {
    return getView().setUint32(pointer, value, littleEndian);
}
function init(getAllocator_, getView_) {
    getAllocator = getAllocator_;
    getView = getView_;
    (0,_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.override)({
        [4 /* CTypeEnum.char */]: readU8,
        [5 /* CTypeEnum.atomic_char */]: readU8,
        [2 /* CTypeEnum.uint8 */]: readU8,
        [3 /* CTypeEnum.atomic_uint8 */]: readU8,
        [6 /* CTypeEnum.uint16 */]: readU16,
        [7 /* CTypeEnum.atomic_uint16 */]: readU16,
        [8 /* CTypeEnum.uint32 */]: readU32,
        [9 /* CTypeEnum.atomic_uint32 */]: readU32,
        [10 /* CTypeEnum.uint64 */]: readU64,
        [11 /* CTypeEnum.int8 */]: read8,
        [12 /* CTypeEnum.atomic_int8 */]: read8,
        [13 /* CTypeEnum.int16 */]: read16,
        [14 /* CTypeEnum.atomic_int16 */]: read16,
        [15 /* CTypeEnum.int32 */]: read32,
        [16 /* CTypeEnum.atomic_int32 */]: read32,
        [17 /* CTypeEnum.int64 */]: read64,
        [18 /* CTypeEnum.float */]: readf32,
        [19 /* CTypeEnum.double */]: readf64,
        [20 /* CTypeEnum.pointer */]: readPointer,
        [23 /* CTypeEnum.bool */]: (pointer) => {
            return !!read8(pointer);
        },
        [24 /* CTypeEnum.atomic_bool */]: (pointer) => {
            return !!read8(pointer);
        }
    });
    (0,_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.override)({
        [4 /* CTypeEnum.char */]: writeU8,
        [5 /* CTypeEnum.atomic_char */]: writeU8,
        [2 /* CTypeEnum.uint8 */]: writeU8,
        [3 /* CTypeEnum.atomic_uint8 */]: writeU8,
        [6 /* CTypeEnum.uint16 */]: writeU16,
        [7 /* CTypeEnum.atomic_uint16 */]: writeU16,
        [8 /* CTypeEnum.uint32 */]: writeU32,
        [9 /* CTypeEnum.atomic_uint32 */]: writeU32,
        [10 /* CTypeEnum.uint64 */]: writeU64,
        [11 /* CTypeEnum.int8 */]: write8,
        [12 /* CTypeEnum.atomic_int8 */]: write8,
        [13 /* CTypeEnum.int16 */]: write16,
        [14 /* CTypeEnum.atomic_int16 */]: write16,
        [15 /* CTypeEnum.int32 */]: write32,
        [16 /* CTypeEnum.atomic_int32 */]: write32,
        [17 /* CTypeEnum.int64 */]: write64,
        [18 /* CTypeEnum.float */]: writef32,
        [19 /* CTypeEnum.double */]: writef64,
        [20 /* CTypeEnum.pointer */]: writePointer,
        [23 /* CTypeEnum.bool */]: (pointer, value) => {
            write8(pointer, value ? 1 : 0);
        },
        [24 /* CTypeEnum.atomic_bool */]: ((pointer, value) => {
            write8(pointer, value ? 1 : 0);
        })
    });
}


/***/ }),

/***/ "./src/cheap/ctypeEnumRead.ts":
/*!************************************!*\
  !*** ./src/cheap/ctypeEnumRead.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CTypeEnumRead: () => (/* binding */ CTypeEnumRead),
/* harmony export */   override: () => (/* binding */ override)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");

const CTypeEnumRead = {
    [4 /* CTypeEnum.char */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [5 /* CTypeEnum.atomic_char */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [2 /* CTypeEnum.uint8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [3 /* CTypeEnum.atomic_uint8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [6 /* CTypeEnum.uint16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [7 /* CTypeEnum.atomic_uint16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [8 /* CTypeEnum.uint32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [9 /* CTypeEnum.atomic_uint32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [10 /* CTypeEnum.uint64 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [11 /* CTypeEnum.int8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [12 /* CTypeEnum.atomic_int8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [13 /* CTypeEnum.int16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [14 /* CTypeEnum.atomic_int16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [15 /* CTypeEnum.int32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [16 /* CTypeEnum.atomic_int32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [17 /* CTypeEnum.int64 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [18 /* CTypeEnum.float */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [19 /* CTypeEnum.double */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [20 /* CTypeEnum.pointer */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [0 /* CTypeEnum.null */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [1 /* CTypeEnum.void */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [22 /* CTypeEnum.atomic_uint64 */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [21 /* CTypeEnum.atomic_int64 */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [23 /* CTypeEnum.bool */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [24 /* CTypeEnum.atomic_bool */]: function (pointer) {
        throw new Error('invalid operate');
    }
};
function override(funcs) {
    common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend(CTypeEnumRead, funcs);
}


/***/ }),

/***/ "./src/cheap/ctypeEnumWrite.ts":
/*!*************************************!*\
  !*** ./src/cheap/ctypeEnumWrite.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CTypeEnumWrite: () => (/* binding */ CTypeEnumWrite),
/* harmony export */   override: () => (/* binding */ override)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");

const CTypeEnumWrite = {
    [4 /* CTypeEnum.char */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [5 /* CTypeEnum.atomic_char */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [2 /* CTypeEnum.uint8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [3 /* CTypeEnum.atomic_uint8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [6 /* CTypeEnum.uint16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [7 /* CTypeEnum.atomic_uint16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [8 /* CTypeEnum.uint32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [9 /* CTypeEnum.atomic_uint32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [10 /* CTypeEnum.uint64 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [11 /* CTypeEnum.int8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [12 /* CTypeEnum.atomic_int8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [13 /* CTypeEnum.int16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [14 /* CTypeEnum.atomic_int16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [15 /* CTypeEnum.int32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [16 /* CTypeEnum.atomic_int32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [17 /* CTypeEnum.int64 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [18 /* CTypeEnum.float */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [19 /* CTypeEnum.double */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [20 /* CTypeEnum.pointer */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [0 /* CTypeEnum.null */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [1 /* CTypeEnum.void */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [22 /* CTypeEnum.atomic_uint64 */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [21 /* CTypeEnum.atomic_int64 */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [23 /* CTypeEnum.bool */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [24 /* CTypeEnum.atomic_bool */]: function (pointer, value) {
        throw new Error('invalid operate');
    }
};
function override(funcs) {
    common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend(CTypeEnumWrite, funcs);
}


/***/ }),

/***/ "./src/cheap/definedStruct.ts":
/*!************************************!*\
  !*** ./src/cheap/definedStruct.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   definedStruct: () => (/* binding */ definedStruct),
/* harmony export */   revokeDefinedStruct: () => (/* binding */ revokeDefinedStruct)
/* harmony export */ });
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./typedef */ "./src/cheap/typedef.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_function_toString__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/function/toString */ "./src/common/function/toString.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");









function definedProperty(target, key, get, set) {
    Object.defineProperty(target, key, {
        get,
        set,
        configurable: true,
        enumerable: true
    });
}
/**
 * 指针的值
 *
 * @param address
 * @returns
 */
function getPointerValue(address) {
    return function () {
        return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20 /* CTypeEnum.pointer */](address());
    };
}
function getStruct(target, key, address, struct) {
    return function () {
        return target[`__$__${key}`] || (target[`__$__${key}`] = definedStruct(address(), struct));
    };
}
function getCTypeEnumValue(address, type) {
    return function () {
        return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[type](address());
    };
}
function getBitFieldValue(address, type, bitLen, offset) {
    const shift = _typedef__WEBPACK_IMPORTED_MODULE_4__.CTypeEnum2Bytes[type] * 8 - offset - bitLen;
    const valueMask = Math.pow(2, bitLen) - 1;
    return function () {
        let value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[type](address());
        return (value >>> shift) & valueMask;
    };
}
function setPointerValue(address) {
    return function (newValue) {
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[8 /* CTypeEnum.uint32 */](address(), newValue);
    };
}
function setStruct(obj, key, address, struct) {
    const localKey = `__$__${key}`;
    return function (newValue) {
        const proxy = obj[localKey] || (obj[localKey] = definedStruct(address(), struct));
        common_util_object__WEBPACK_IMPORTED_MODULE_6__.each(newValue, (value, key) => {
            proxy[key] = value;
        });
        obj[localKey] = proxy;
    };
}
function setCTypeEnumValue(address, type) {
    return function (newValue) {
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[type](address(), newValue);
    };
}
function setBitFieldValue(address, type, bitLen, offset) {
    let zeroMask = 0;
    let len = _typedef__WEBPACK_IMPORTED_MODULE_4__.CTypeEnum2Bytes[type] * 8;
    for (let i = 0; i < bitLen; i++) {
        zeroMask |= (1 << (len - 1 - (i + offset)));
    }
    const valueMask = Math.pow(2, bitLen) - 1;
    const shift = len - offset - bitLen;
    return function (newValue) {
        const addr = address();
        const value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[type](addr);
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[type](addr, (value & ~zeroMask) | ((newValue & valueMask) << shift));
    };
}
function definedArrayStruct(address, length, type) {
    const obj = {};
    let size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_0__["default"])(type);
    for (let i = 0; i < length; i++) {
        const key = (0,common_function_toString__WEBPACK_IMPORTED_MODULE_7__["default"])(i);
        definedProperty(obj, key, getStruct(obj, key, () => {
            return address() + size * i;
        }, type), setStruct(obj, key, () => {
            return address() + size * i;
        }, type));
    }
    return obj;
}
function definedArrayCTypeEnum(address, length, type) {
    const obj = {};
    let size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_0__["default"])(type);
    for (let i = 0; i < length; i++) {
        const key = (0,common_function_toString__WEBPACK_IMPORTED_MODULE_7__["default"])(i);
        definedProperty(obj, key, getCTypeEnumValue(() => {
            return address() + size * i;
        }, type), setCTypeEnumValue(() => {
            return address() + size * i;
        }, type));
    }
    return obj;
}
function getArray(address, target, key) {
    return function () {
        const t = target[`__$__${key}`];
        t[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = address();
        return t;
    };
}
function setArrayStruct(obj, key, address, length, type) {
    const localKey = `__$__${key}`;
    return function (newValue) {
        let proxy = obj[localKey] || definedArrayStruct(address, length, type);
        proxy[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = address();
        common_util_array__WEBPACK_IMPORTED_MODULE_8__.each(newValue, (value, key) => {
            proxy[key] = value;
        });
        obj[localKey] = proxy;
    };
}
function setArrayCTypeEnum(obj, key, address, length, type) {
    const localKey = `__$__${key}`;
    return function (newValue) {
        let proxy = obj[localKey] || definedArrayCTypeEnum(address, length, type);
        proxy[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = address();
        common_util_array__WEBPACK_IMPORTED_MODULE_8__.each(newValue, (value, key) => {
            proxy[key] = value;
        });
        obj[localKey] = proxy;
    };
}
function definedStruct(address, struct) {
    let prototype = common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(struct) ? struct.prototype : struct;
    const obj = {};
    obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = address;
    Object.setPrototypeOf(obj, prototype);
    while (true) {
        let keysMeta = prototype[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta];
        if (keysMeta) {
            keysMeta.forEach((meta, key) => {
                if (meta[3 /* KeyMetaKey.Array */]) {
                    if (meta[1 /* KeyMetaKey.Pointer */]) {
                        definedProperty(obj, key, getArray(() => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, obj, key), setArrayCTypeEnum(obj, key, () => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, meta[4 /* KeyMetaKey.ArrayLength */], 20 /* CTypeEnum.pointer */));
                    }
                    else {
                        if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_5__.object(meta[0 /* KeyMetaKey.Type */])) {
                            definedProperty(obj, key, getArray(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, obj, key), setArrayStruct(obj, key, () => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[4 /* KeyMetaKey.ArrayLength */], meta[0 /* KeyMetaKey.Type */]));
                        }
                        else {
                            definedProperty(obj, key, getArray(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, obj, key), setArrayCTypeEnum(obj, key, () => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[4 /* KeyMetaKey.ArrayLength */], meta[0 /* KeyMetaKey.Type */]));
                        }
                    }
                }
                else {
                    if (meta[1 /* KeyMetaKey.Pointer */]) {
                        definedProperty(obj, key, getPointerValue(() => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }), setPointerValue(() => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }));
                    }
                    else if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_5__.object(meta[0 /* KeyMetaKey.Type */])) {
                        definedProperty(obj, key, getStruct(obj, key, () => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, meta[0 /* KeyMetaKey.Type */]), setStruct(obj, key, () => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, meta[0 /* KeyMetaKey.Type */]));
                    }
                    else {
                        if (meta[5 /* KeyMetaKey.BitField */]) {
                            definedProperty(obj, key, getBitFieldValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */], meta[6 /* KeyMetaKey.BitFieldLength */], meta[8 /* KeyMetaKey.BaseBitOffset */]), setBitFieldValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */], meta[6 /* KeyMetaKey.BitFieldLength */], meta[8 /* KeyMetaKey.BaseBitOffset */]));
                        }
                        else {
                            definedProperty(obj, key, getCTypeEnumValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */]), setCTypeEnumValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */]));
                        }
                    }
                }
            });
        }
        prototype = Object.getPrototypeOf(prototype);
        if (!prototype) {
            break;
        }
    }
    return obj;
}
function revokeDefinedStruct(target) {
    let prototype = Object.getPrototypeOf(target);
    while (true) {
        let keysMeta = prototype[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta];
        if (keysMeta) {
            keysMeta.forEach((meta, key) => {
                delete target[key];
            });
        }
        prototype = Object.getPrototypeOf(prototype);
        if (!prototype) {
            break;
        }
    }
}


/***/ }),

/***/ "./src/cheap/function/definedMetaProperty.ts":
/*!***************************************************!*\
  !*** ./src/cheap/function/definedMetaProperty.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ definedMetaProperty)
/* harmony export */ });
function definedMetaProperty(target, key, value) {
    Object.defineProperty(target, key, {
        value,
        writable: false,
        enumerable: false,
        configurable: false
    });
}


/***/ }),

/***/ "./src/cheap/heap.ts":
/*!***************************!*\
  !*** ./src/cheap/heap.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Allocator: () => (/* binding */ Allocator),
/* harmony export */   Memory: () => (/* binding */ Memory),
/* harmony export */   StackPointer: () => (/* binding */ StackPointer),
/* harmony export */   StackTop: () => (/* binding */ StackTop),
/* harmony export */   Table: () => (/* binding */ Table),
/* harmony export */   allocThreadId: () => (/* binding */ allocThreadId),
/* harmony export */   getHeap16: () => (/* binding */ getHeap16),
/* harmony export */   getHeap32: () => (/* binding */ getHeap32),
/* harmony export */   getHeap64: () => (/* binding */ getHeap64),
/* harmony export */   getHeap8: () => (/* binding */ getHeap8),
/* harmony export */   getHeapF32: () => (/* binding */ getHeapF32),
/* harmony export */   getHeapF64: () => (/* binding */ getHeapF64),
/* harmony export */   getHeapU16: () => (/* binding */ getHeapU16),
/* harmony export */   getHeapU32: () => (/* binding */ getHeapU32),
/* harmony export */   getHeapU64: () => (/* binding */ getHeapU64),
/* harmony export */   getHeapU8: () => (/* binding */ getHeapU8),
/* harmony export */   getView: () => (/* binding */ getView),
/* harmony export */   initThread: () => (/* binding */ initThread)
/* harmony export */ });
/* unused harmony exports ThreadId, isMainThread, ThreadName, StackSize, getAtomicsBuffer, initMain */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var _allocator_AllocatorJS__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./allocator/AllocatorJS */ "./src/cheap/allocator/AllocatorJS.ts");
/* harmony import */ var _allocator_Table__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./allocator/Table */ "./src/cheap/allocator/Table.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config */ "./src/cheap/config.ts");
/* harmony import */ var _staticData__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./staticData */ "./src/cheap/staticData.ts");
/* harmony import */ var _thread_atomicsImpl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./thread/atomicsImpl */ "./src/cheap/thread/atomicsImpl.ts");
/* harmony import */ var _asm_memory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./asm/memory */ "./src/cheap/asm/memory.ts");
/* harmony import */ var _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./thread/asm/atomics */ "./src/cheap/thread/asm/atomics.ts");
/* harmony import */ var _ctypeEnumImpl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ctypeEnumImpl */ "./src/cheap/ctypeEnumImpl.ts");
/* harmony import */ var common_function_isAudioWorklet__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/function/isAudioWorklet */ "./src/common/function/isAudioWorklet.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");













/**
 * 线程 id
 */
let ThreadId = -1;
let isMainThread = true;
/**
 * 线程名
 */
let ThreadName = '';
/**
 * 当前线程的栈顶指针
 */
let StackPointer = null;
/**
 * 栈结束位置
 */
let StackTop = null;
/**
 * 当前线程栈大小
 */
let StackSize = 0;
/**
 * 当前线程的 Table
 */
let Table = null;
/**
 * 堆分配器
 */
let Allocator = null;
/**
 * 堆
 */
let Memory = null;
/**
 * 1 字节整型读取
 * - int8
 * - -128 to 127
 */
let Heap8 = null;
/**
 * 2 字节整型读取
 * - int16
 * - -32768 to 32767
 */
let Heap16 = null;
/**
 * 4 字节整型读取
 * - int32
 * - -2147483648 to 2147483647
 */
let Heap32 = null;
/**
 * 8 字节整型读取
 * - int64
 * - 0 to 4294967295
 */
let Heap64 = null;
/**
 * 1 字节无符号整型读取
 * - uint8
 * - 0 to 255
 */
let HeapU8 = null;
/**
 * 2 字节无符号整型读取
 * - uint16
 * - 0 to 65535
 */
let HeapU16 = null;
/**
 * 4 字节无符号整型读取
 * - uint32
 * - 0 to 4294967295
 */
let HeapU32 = null;
/**
 * 8 字节无符号整型读取
 * - uint64
 * - 0 to 4294967295
 */
let HeapU64 = null;
/**
 * 32 位浮点数
 * float
 */
let HeapFloat32 = null;
/**
 * 64 位浮点数
 * double
 */
let HeapFloat64 = null;
/**
 * 堆访问器
 */
let view = null;
let AtomicBufferMap = {
    [5 /* CTypeEnum.atomic_char */]: HeapU8,
    [3 /* CTypeEnum.atomic_uint8 */]: HeapU8,
    [7 /* CTypeEnum.atomic_uint16 */]: HeapU16,
    [9 /* CTypeEnum.atomic_uint32 */]: HeapU32,
    [22 /* CTypeEnum.atomic_uint64 */]: HeapU64,
    [12 /* CTypeEnum.atomic_int8 */]: Heap8,
    [14 /* CTypeEnum.atomic_int16 */]: Heap16,
    [16 /* CTypeEnum.atomic_int32 */]: Heap32,
    [21 /* CTypeEnum.atomic_int64 */]: Heap64
};
function checkHeap() {
    if (Memory && Memory.buffer !== HeapU8.buffer) {
        return true;
    }
    return false;
}
function getHeapU8() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU8;
}
function getHeap8() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap8;
}
function getHeapU16() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU16;
}
function getHeap16() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap16;
}
function getHeapU32() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU32;
}
function getHeap32() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap32;
}
function getHeap64() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap64;
}
function getHeapU64() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU64;
}
function getHeapF32() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapFloat32;
}
function getHeapF64() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapFloat64;
}
function getView() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return view;
}
function getAtomicsBuffer(type) {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return AtomicBufferMap[type];
}
function setAllocator(a) {
    if (Allocator) {
        Allocator.removeUpdateHandle(updateHeap);
    }
    Allocator = a;
    if (common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap) {
        common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.Allocator = Allocator;
    }
    Allocator.addUpdateHandle(updateHeap);
    updateHeap(Allocator.getBuffer());
}
function updateHeap(heap) {
    Heap8 = new Int8Array(heap);
    Heap16 = new Int16Array(heap);
    Heap32 = new Int32Array(heap);
    Heap64 = new BigInt64Array(heap);
    HeapU8 = new Uint8Array(heap);
    HeapU16 = new Uint16Array(heap);
    HeapU32 = new Uint32Array(heap);
    HeapU64 = new BigUint64Array(heap);
    HeapFloat32 = new Float32Array(heap);
    HeapFloat64 = new Float64Array(heap);
    view = new DataView(heap);
    AtomicBufferMap = {
        [5 /* CTypeEnum.atomic_char */]: HeapU8,
        [3 /* CTypeEnum.atomic_uint8 */]: HeapU8,
        [7 /* CTypeEnum.atomic_uint16 */]: HeapU16,
        [9 /* CTypeEnum.atomic_uint32 */]: HeapU32,
        [22 /* CTypeEnum.atomic_uint64 */]: HeapU64,
        [12 /* CTypeEnum.atomic_int8 */]: Heap8,
        [14 /* CTypeEnum.atomic_int16 */]: Heap16,
        [16 /* CTypeEnum.atomic_int32 */]: Heap32,
        [21 /* CTypeEnum.atomic_int64 */]: Heap64
    };
}
function allocThreadId() {
    return Atomics.add(HeapU32, _staticData__WEBPACK_IMPORTED_MODULE_6__.threadCounter >>> 2, 1);
}
/**
 * 子线程初始化
 *
 * @param options
 */
async function initThread(options) {
    (0,_ctypeEnumImpl__WEBPACK_IMPORTED_MODULE_10__["default"])(() => {
        return Allocator;
    }, getView);
    (0,_thread_atomicsImpl__WEBPACK_IMPORTED_MODULE_7__["default"])(getAtomicsBuffer);
    Memory = options.memory;
    const allocator = new _allocator_AllocatorJS__WEBPACK_IMPORTED_MODULE_2__["default"]({
        buffer: Memory.buffer,
        memory: Memory,
        byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET,
        maxHeapSize: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_MAXIMUM * 64 * 1024,
        growAllowed: true,
        onResize(old, need) {
            Memory.grow((need - old.byteLength) >>> 16);
            return {
                buffer: Memory.buffer,
                byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET
            };
        }
    }, false);
    setAllocator(allocator);
    if (options.stackPointer) {
        StackSize = options.stackSize;
        StackTop = options.stackPointer;
        StackPointer = new WebAssembly.Global({
            value: 'i32',
            mutable: true
        }, StackTop + StackSize);
        Table = new _allocator_Table__WEBPACK_IMPORTED_MODULE_3__.WebassemblyTable();
    }
    if (typeof options.id === 'number') {
        ThreadId = options.id;
    }
    else {
        ThreadId = Atomics.add(HeapU32, _staticData__WEBPACK_IMPORTED_MODULE_6__.threadCounter >>> 2, 1);
    }
    ThreadName = options.name ?? 'anonymous';
    common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap = {
        initThread,
        Allocator,
        Table,
        ThreadId,
        ThreadName,
        Memory,
        StackSize,
        StackTop,
        StackPointer,
        isMainThread: false
    };
    isMainThread = false;
    {
        if (!options.disableAsm) {
            // @ts-ignore
            if (typeof BigInt === 'function' && BigInt !== Number
                && (common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '85', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '78', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '15', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].newEdge)) {
                await (0,_asm_memory__WEBPACK_IMPORTED_MODULE_8__["default"])(Memory);
            }
            if ( true && _config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS
                && (common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '85', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '78', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '15', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].newEdge)) {
                await (0,_thread_asm_atomics__WEBPACK_IMPORTED_MODULE_9__["default"])(Memory);
            }
        }
    }
}
/**
 * 主线程初始化
 */
function initMain() {
    (0,_ctypeEnumImpl__WEBPACK_IMPORTED_MODULE_10__["default"])(() => {
        return Allocator;
    }, getView);
    (0,_thread_atomicsImpl__WEBPACK_IMPORTED_MODULE_7__["default"])(getAtomicsBuffer);
    Memory = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.Memory ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.Memory : new WebAssembly.Memory({
        initial: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_INITIAL,
        maximum: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_MAXIMUM,
        shared: _config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS
    });
    Allocator = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.Allocator ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.Allocator : new _allocator_AllocatorJS__WEBPACK_IMPORTED_MODULE_2__["default"]({
        buffer: Memory.buffer,
        memory: Memory,
        byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET,
        maxHeapSize: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_MAXIMUM * 64 * 1024,
        growAllowed: true,
        onResize(old, need) {
            Memory.grow((need - old.byteLength) >>> 16);
            return {
                buffer: Memory.buffer,
                byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET
            };
        }
    });
    Allocator.addUpdateHandle(updateHeap);
    updateHeap(Allocator.getBuffer());
    StackSize = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.StackSize ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.StackSize : _config__WEBPACK_IMPORTED_MODULE_5__.STACK_SIZE;
    StackTop = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.StackTop ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.StackTop : Allocator.malloc(StackSize);
    StackPointer = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.StackPointer ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.StackPointer : new WebAssembly.Global({
        value: 'i32',
        mutable: true
    }, StackTop + StackSize);
    Table = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.Table ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.Table : new _allocator_Table__WEBPACK_IMPORTED_MODULE_3__.WebassemblyTable();
    ThreadId = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.ThreadId ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.ThreadId : 0;
    ThreadName = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.ThreadName ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.ThreadName : 'main';
    if (!common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap) {
        if (_config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS && true) {
            Atomics.store(HeapU32, _staticData__WEBPACK_IMPORTED_MODULE_6__.threadCounter >>> 2, ThreadId + 1);
            Atomics.store(Heap32, _staticData__WEBPACK_IMPORTED_MODULE_6__.heapMutex >>> 2, 0);
        }
        else {
            HeapU32[_staticData__WEBPACK_IMPORTED_MODULE_6__.threadCounter >>> 2] = ThreadId + 1;
            let index = _staticData__WEBPACK_IMPORTED_MODULE_6__.heapMutex >>> 2;
            Heap32[index] = 0;
        }
    }
    {
        // @ts-ignore
        if (typeof BigInt === 'function' && BigInt !== Number
            && (common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '85', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '78', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '15', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].newEdge)) {
            (0,_asm_memory__WEBPACK_IMPORTED_MODULE_8__["default"])(Memory);
        }
        if (_config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS
            && true
            && (common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '85', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '78', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '15', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].newEdge)) {
            (0,_thread_asm_atomics__WEBPACK_IMPORTED_MODULE_9__["default"])(Memory);
        }
    }
    if (!common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap) {
        common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap = {
            Allocator,
            Table,
            ThreadId,
            ThreadName,
            Memory,
            StackSize,
            StackTop,
            StackPointer,
            isMainThread: true,
            threadCounter: _staticData__WEBPACK_IMPORTED_MODULE_6__.threadCounter,
            heapMutex: _staticData__WEBPACK_IMPORTED_MODULE_6__.heapMutex
        };
    }
    isMainThread = true;
}
{
    if (!(0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_1__["default"])() && !(0,common_function_isAudioWorklet__WEBPACK_IMPORTED_MODULE_11__["default"])()) {
        initMain();
    }
    else {
        common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap = {
            initThread,
            isMainThread: false
        };
        isMainThread = false;
    }
}


/***/ }),

/***/ "./src/cheap/proxyStruct.ts":
/*!**********************************!*\
  !*** ./src/cheap/proxyStruct.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   proxyStruct: () => (/* binding */ proxyStruct),
/* harmony export */   revokeProxyStruct: () => (/* binding */ revokeProxyStruct)
/* harmony export */ });
/* unused harmony export findKeyMeta */
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./typedef */ "./src/cheap/typedef.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_function_toNumber__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/function/toNumber */ "./src/common/function/toNumber.ts");









const ObjectPro = Object.getPrototypeOf({});
function findKeyMeta(prototype, key) {
    while (true) {
        let keysMeta = prototype[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta];
        if (keysMeta) {
            const meta = keysMeta.get(key);
            if (meta) {
                return meta;
            }
        }
        prototype = Object.getPrototypeOf(prototype);
        if (!prototype || prototype === ObjectPro) {
            return null;
        }
    }
}
function proxyArray(address, length, type, pointer) {
    const obj = {};
    obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = address;
    let size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_0__["default"])(pointer ? 20 /* CTypeEnum.pointer */ : type);
    const proxy = new Proxy(obj, {
        get(target, propertyKey, receiver) {
            if (propertyKey === _symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress) {
                return target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress];
            }
            const index = (0,common_function_toNumber__WEBPACK_IMPORTED_MODULE_8__["default"])(propertyKey);
            if (pointer) {
                return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20 /* CTypeEnum.pointer */](target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + index * size);
            }
            else {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(type)) {
                    return target[propertyKey];
                }
                else {
                    return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[type](target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + index * size);
                }
            }
        },
        set(target, propertyKey, newValue, receiver) {
            if (propertyKey === _symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress) {
                target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = newValue;
                return true;
            }
            const index = (0,common_function_toNumber__WEBPACK_IMPORTED_MODULE_8__["default"])(propertyKey);
            if (pointer) {
                _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20 /* CTypeEnum.pointer */](target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + index * size, newValue);
                target[propertyKey] = newValue;
            }
            else {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(type)) {
                    const proxy = target[propertyKey] || (target[propertyKey] = proxyStruct(target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + index * size, type));
                    common_util_object__WEBPACK_IMPORTED_MODULE_6__.each(newValue, (value, key) => {
                        proxy[key] = value;
                    });
                    target[propertyKey] = proxy;
                }
                else {
                    _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[type](target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + index * size, newValue);
                    target[propertyKey] = newValue;
                }
            }
            return true;
        }
    });
    return proxy;
}
function proxyStruct(address, struct) {
    const prototype = common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(struct) ? struct.prototype : struct;
    const obj = {};
    obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = address;
    Object.setPrototypeOf(obj, prototype);
    const { proxy, revoke } = Proxy.revocable(obj, {
        get(target, propertyKey, receiver) {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.string(propertyKey)) {
                const meta = findKeyMeta(prototype, propertyKey.replace(/^\$+/, ''));
                if (meta) {
                    const address = target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                    if (meta[3 /* KeyMetaKey.Array */]) {
                        const t = target[propertyKey];
                        t[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = address;
                        return t;
                    }
                    else if (meta[1 /* KeyMetaKey.Pointer */]) {
                        let p = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20 /* CTypeEnum.pointer */](address);
                        return p;
                    }
                    else if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_5__.object(meta[0 /* KeyMetaKey.Type */])) {
                        return target[propertyKey] || (target[propertyKey] = proxyStruct(address, meta[0 /* KeyMetaKey.Type */]));
                    }
                    else {
                        let value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[meta[0 /* KeyMetaKey.Type */]](address);
                        if (meta[5 /* KeyMetaKey.BitField */]) {
                            value = ((value >>> (_typedef__WEBPACK_IMPORTED_MODULE_4__.CTypeEnum2Bytes[meta[0 /* KeyMetaKey.Type */]] * 8 - meta[8 /* KeyMetaKey.BaseBitOffset */] - meta[6 /* KeyMetaKey.BitFieldLength */]))
                                & (Math.pow(2, meta[6 /* KeyMetaKey.BitFieldLength */]) - 1));
                        }
                        return value;
                    }
                }
                else {
                    return target[propertyKey];
                }
            }
            else {
                return target[propertyKey];
            }
        },
        set(target, propertyKey, newValue, receiver) {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.string(propertyKey)) {
                const meta = findKeyMeta(prototype, propertyKey.replace(/^\$+/, ''));
                if (meta) {
                    const address = target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                    if (meta[3 /* KeyMetaKey.Array */]) {
                        const proxy = target[propertyKey] || proxyArray(address, meta[4 /* KeyMetaKey.ArrayLength */], meta[0 /* KeyMetaKey.Type */], meta[1 /* KeyMetaKey.Pointer */]);
                        common_util_array__WEBPACK_IMPORTED_MODULE_7__.each(newValue, (value, key) => {
                            proxy[key] = value;
                        });
                        target[propertyKey] = proxy;
                    }
                    else {
                        if (meta[1 /* KeyMetaKey.Pointer */]) {
                            _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20 /* CTypeEnum.pointer */](address, newValue);
                            target[propertyKey] = newValue;
                        }
                        else if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_5__.object(meta[0 /* KeyMetaKey.Type */])) {
                            const proxy = target[propertyKey] || (target[propertyKey] = proxyStruct(address, meta[0 /* KeyMetaKey.Type */]));
                            common_util_object__WEBPACK_IMPORTED_MODULE_6__.each(newValue, (value, key) => {
                                proxy[key] = value;
                            });
                            target[propertyKey] = proxy;
                        }
                        else {
                            if (meta[5 /* KeyMetaKey.BitField */]) {
                                let mask = 0;
                                let len = _typedef__WEBPACK_IMPORTED_MODULE_4__.CTypeEnum2Bytes[meta[0 /* KeyMetaKey.Type */]] * 8;
                                for (let i = 0; i < meta[6 /* KeyMetaKey.BitFieldLength */]; i++) {
                                    mask |= (1 << (len - 1 - (i + meta[8 /* KeyMetaKey.BaseBitOffset */])));
                                }
                                const value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[meta[0 /* KeyMetaKey.Type */]](address);
                                _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[meta[0 /* KeyMetaKey.Type */]](address, (value & ~mask) | ((newValue & (Math.pow(2, meta[6 /* KeyMetaKey.BitFieldLength */]) - 1))
                                    << (len - meta[8 /* KeyMetaKey.BaseBitOffset */] - meta[6 /* KeyMetaKey.BitFieldLength */])));
                            }
                            else {
                                _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[meta[0 /* KeyMetaKey.Type */]](address, newValue);
                            }
                            target[propertyKey] = newValue;
                        }
                    }
                }
                else {
                    target[propertyKey] = newValue;
                }
            }
            else {
                target[propertyKey] = newValue;
            }
            return true;
        }
    });
    obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructProxyRevoke] = revoke;
    return proxy;
}
function revokeProxyStruct(target) {
    const revoke = target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructProxyRevoke];
    if (revoke) {
        revoke();
    }
}


/***/ }),

/***/ "./src/cheap/stack.ts":
/*!****************************!*\
  !*** ./src/cheap/stack.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   free: () => (/* binding */ free),
/* harmony export */   malloc: () => (/* binding */ malloc)
/* harmony export */ });
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./heap */ "./src/cheap/heap.ts");

function malloc(size) {
    _heap__WEBPACK_IMPORTED_MODULE_0__.StackPointer.value -= size;
    return _heap__WEBPACK_IMPORTED_MODULE_0__.StackPointer.value;
}
function free(size) {
    _heap__WEBPACK_IMPORTED_MODULE_0__.StackPointer.value += size;
}


/***/ }),

/***/ "./src/cheap/staticData.ts":
/*!*********************************!*\
  !*** ./src/cheap/staticData.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   heapMutex: () => (/* binding */ heapMutex),
/* harmony export */   malloc: () => (/* binding */ malloc),
/* harmony export */   threadCounter: () => (/* binding */ threadCounter)
/* harmony export */ });
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ "./src/cheap/config.ts");
/* harmony import */ var _thread_mutex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./thread/mutex */ "./src/cheap/thread/mutex.ts");
/**
 * 静态分配区只能在此文件分配
 * 导出在其他地方使用
 */



/**
 * 静态分配区栈顶指针
 */
let pointer = (0) + 1;
function malloc(length, algin = 1) {
    let address = pointer;
    while (address % algin) {
        address = address + 1;
    }
    pointer = address + length;
    return address;
}
/**
 * 线程计数器地址
 */
const threadCounter = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.threadCounter
    ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.threadCounter
    : malloc(4, 4);
/**
 * 堆分配锁地址
 */
const heapMutex = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.heapMutex
    ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.heapMutex
    : malloc(4, 4);


/***/ }),

/***/ "./src/cheap/std/buffer/SafeUint8Array.ts":
/*!************************************************!*\
  !*** ./src/cheap/std/buffer/SafeUint8Array.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SafeUint8Array)
/* harmony export */ });
/* unused harmony export SafeBufferView */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../heap */ "./src/cheap/heap.ts");
/* harmony import */ var common_interface_ArrayLike__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/interface/ArrayLike */ "./src/common/interface/ArrayLike.ts");




class SafeBufferView {
    pointer;
    len;
    constructor(pointer, len) {
        this.pointer = pointer;
        this.len = len;
    }
    get byteLength() {
        return this.len;
    }
    get buffer() {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getHeapU8)().buffer;
    }
    get byteOffset() {
        return this.pointer;
    }
    getFloat32(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getFloat32(this.pointer + byteOffset, littleEndian);
    }
    getFloat64(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getFloat64(this.pointer + byteOffset, littleEndian);
    }
    getInt8(byteOffset) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getInt8(this.pointer + byteOffset);
    }
    getInt16(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getInt16(this.pointer + byteOffset, littleEndian);
    }
    getInt32(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getInt32(this.pointer + byteOffset, littleEndian);
    }
    getUint8(byteOffset) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getUint8(this.pointer + byteOffset);
    }
    getUint16(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getUint16(this.pointer + byteOffset, littleEndian);
    }
    getUint32(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getUint32(this.pointer + byteOffset, littleEndian);
    }
    setFloat32(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setFloat32(this.pointer + byteOffset, value, littleEndian);
    }
    setFloat64(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setFloat64(this.pointer + byteOffset, value, littleEndian);
    }
    setInt8(byteOffset, value) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setInt8(this.pointer + byteOffset, value);
    }
    setInt16(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setInt16(this.pointer + byteOffset, value, littleEndian);
    }
    setInt32(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setInt32(this.pointer + byteOffset, value, littleEndian);
    }
    setUint8(byteOffset, value) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setUint8(this.pointer + byteOffset, value);
    }
    setUint16(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setUint16(this.pointer + byteOffset, value, littleEndian);
    }
    setUint32(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setUint32(this.pointer + byteOffset, value, littleEndian);
    }
    getBigInt64(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getBigInt64(this.pointer + byteOffset, littleEndian);
    }
    getBigUint64(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getBigUint64(this.pointer + byteOffset, littleEndian);
    }
    setBigInt64(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setBigInt64(this.pointer + byteOffset, value, littleEndian);
    }
    setBigUint64(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setBigUint64(this.pointer + byteOffset, value, littleEndian);
    }
}
class SafeUint8Array extends common_interface_ArrayLike__WEBPACK_IMPORTED_MODULE_3__["default"] {
    pointer;
    len;
    constructor(pointer, len) {
        super();
        this.pointer = pointer;
        this.len = len;
        return this.proxy;
    }
    getIndexValue(index) {
        return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[2](this.pointer + index);
    }
    setIndexValue(index, value) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[2](this.pointer + index, value);
    }
    set(array, offset = 0) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getHeapU8)().set(array, this.pointer + offset);
    }
    subarray(begin = 0, end, safe) {
        if (safe) {
            return new SafeUint8Array(this.pointer + begin, (end ? end : this.len) - begin);
        }
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getHeapU8)().subarray(this.pointer + begin, this.pointer + (end ?? this.len));
    }
    slice(start = 0, end) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getHeapU8)().slice(this.pointer + start, this.pointer + (end ?? this.len));
    }
    get length() {
        return this.len;
    }
    get byteLength() {
        return this.len;
    }
    get buffer() {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getHeapU8)().buffer;
    }
    get byteOffset() {
        return this.pointer;
    }
    get view() {
        return new SafeBufferView(this.pointer, this.len);
    }
}


/***/ }),

/***/ "./src/cheap/std/collection/List.ts":
/*!******************************************!*\
  !*** ./src/cheap/std/collection/List.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ List)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var _std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _structAccess__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../structAccess */ "./src/cheap/std/structAccess.ts");












class ListNode {
    // @ts-ignore
    prev;
    // @ts-ignore
    next;
    data;
}
(function (prototype) {
    var map = new Map();
    map.set("prev", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("next", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("data", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(ListNode.prototype);
class List {
    length = 0;
    head = 0;
    tail = 0;
    createNode(item, type, move = false) {
        const pNode = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc(12);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode + 4, 0);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode, 0);
        if (common_util_is__WEBPACK_IMPORTED_MODULE_7__.number(type)) {
            if (type === 20) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode + 8, item);
            }
            else {
                const p = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc((0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__["default"])(type));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[type](p, item);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode + 8, p);
            }
        }
        else {
            if (move) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode + 8, item);
            }
            else {
                const p = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc((0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__["default"])(type));
                (0,_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpy)(p, item[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress], (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__["default"])(type));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode + 8, p);
            }
        }
        return pNode;
    }
    getItem(data, type) {
        let result;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_7__.number(type)) {
            if (type === 20) {
                result = data;
            }
            else {
                result = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[type](data);
            }
        }
        else {
            result = (0,_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(data, type);
        }
        return result;
    }
    push(item, type, move = false) {
        const pNode = this.createNode(item, type, move);
        if (!this.tail) {
            this.head = pNode;
            this.tail = pNode;
        }
        else {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](this.tail + 4, pNode);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode, this.tail);
            this.tail = pNode;
        }
        this.length++;
    }
    pop(type) {
        const pNode = this.tail;
        let result = this.getItem(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode + 8), type);
        if (this.length > 1) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode) + 4, 0);
            this.tail = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode);
        }
        else {
            this.head = 0, this.tail = 0;
        }
        this.length--;
        cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode + 8));
        cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(pNode);
        return result;
    }
    shift(type) {
        const pNode = this.head;
        let result = this.getItem(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode + 8), type);
        if (this.length > 1) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode + 4), 0);
            this.head = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode + 4);
        }
        else {
            this.head = 0, this.tail = 0;
        }
        this.length--;
        cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode + 8));
        cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(pNode);
        return result;
    }
    unshift(item, type, move = false) {
        const pNode = this.createNode(item, type, move);
        if (!this.head) {
            this.head = pNode;
            this.tail = pNode;
        }
        else {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](this.head, pNode);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode + 4, this.head);
            this.head = pNode;
        }
        this.length++;
    }
    forEach(callback, type) {
        if (!this.length) {
            return;
        }
        let current = this.head;
        let index = 0;
        while (current !== 0) {
            if (callback(this.getItem(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 8), type), index) === false) {
                break;
            }
            current = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 4);
            index++;
        }
    }
    find(callback, type) {
        if (!this.length) {
            return 0;
        }
        let current = this.head;
        let index = 0;
        while (current !== 0) {
            const item = this.getItem(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 8), type);
            if (callback(item, index) === true) {
                return item;
            }
            current = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 4);
            index++;
        }
        return 0;
    }
    indexOf(index, type) {
        if (!this.length) {
            return 0;
        }
        let current = this.head;
        let i = 0;
        while (current !== 0) {
            if (i === index) {
                return this.getItem(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 8), type);
            }
            current = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 4);
            i++;
        }
        return 0;
    }
    clear(callback, type) {
        if (this.length) {
            let current = this.head;
            while (current !== 0) {
                if (callback) {
                    callback(this.getItem(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 8), type));
                }
                cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 8));
                const next = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 4);
                cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(current);
                current = next;
            }
        }
        this.head = 0, this.tail = 0;
        this.length = 0;
    }
}
(function (prototype) {
    var map = new Map();
    map.set("length", { 0: 8, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("head", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("tail", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(List.prototype);


/***/ }),

/***/ "./src/cheap/std/function/isPointer.ts":
/*!*********************************************!*\
  !*** ./src/cheap/std/function/isPointer.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isPointer)
/* harmony export */ });
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");

function isPointer(p) {
    return common_util_is__WEBPACK_IMPORTED_MODULE_0__.number(p) && p >= 0;
}


/***/ }),

/***/ "./src/cheap/std/make.ts":
/*!*******************************!*\
  !*** ./src/cheap/std/make.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ make)
/* harmony export */ });
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var _memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_function_isDef__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/function/isDef */ "./src/common/function/isDef.ts");
/* harmony import */ var _structAccess__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./structAccess */ "./src/cheap/std/structAccess.ts");







/**
 * 创建一个 struct 实例
 *
 * @param target
 * @returns
 */
function make(struct, init) {
    const size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_0__["default"])(struct);
    const address = cheap_heap__WEBPACK_IMPORTED_MODULE_1__.Allocator.malloc(size);
    if (!address) {
        throw new TypeError('cannot alloc memory for struct');
    }
    (0,_memory__WEBPACK_IMPORTED_MODULE_2__.memset)(address, 0, size);
    const target = (0,_structAccess__WEBPACK_IMPORTED_MODULE_6__["default"])(address, struct);
    const data = new struct();
    if (init) {
        common_util_object__WEBPACK_IMPORTED_MODULE_4__.extend(data, init);
    }
    common_util_object__WEBPACK_IMPORTED_MODULE_4__.each(data, (value, key) => {
        if ((0,common_function_isDef__WEBPACK_IMPORTED_MODULE_5__["default"])(value)) {
            target[key] = value;
        }
    });
    return target;
}


/***/ }),

/***/ "./src/cheap/std/memory.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/memory.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapSafeUint8Array: () => (/* binding */ mapSafeUint8Array),
/* harmony export */   mapUint16Array: () => (/* binding */ mapUint16Array),
/* harmony export */   mapUint8Array: () => (/* binding */ mapUint8Array),
/* harmony export */   memcpy: () => (/* binding */ memcpy),
/* harmony export */   memcpyFromUint8Array: () => (/* binding */ memcpyFromUint8Array),
/* harmony export */   memset: () => (/* binding */ memset),
/* harmony export */   readCString: () => (/* binding */ readCString),
/* harmony export */   writeCString: () => (/* binding */ writeCString)
/* harmony export */ });
/* unused harmony exports memmove, mapInt8Array, mapInt16Array, mapUint32Array, mapInt32Array, mapUint64Array, mapInt64Array, mapFloat32Array, mapFloat64Array */
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../heap */ "./src/cheap/heap.ts");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string */ "./src/cheap/std/string.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./buffer/SafeUint8Array */ "./src/cheap/std/buffer/SafeUint8Array.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");






function memcpy(dst, src, size) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().set((0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().subarray(src, src + size), dst);
}
function memcpyFromUint8Array(dst, max, data) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().set(data.subarray(0, max), dst);
}
function memmove(dst, src, size) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().copyWithin(dst, src, src + size);
}
function memset(src, c, n) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().subarray(src, src + n).fill(c);
}
function mapSafeUint8Array(src, n) {
    return _config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS ? mapUint8Array(src, n) : new _buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_4__["default"](src, n);
}
function mapUint8Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().subarray(src, src + n);
}
function mapInt8Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap8)().subarray(src, src + n);
}
function mapUint16Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU16)().subarray(src >>> 1, (src >>> 1) + n);
}
function mapInt16Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap16)().subarray(src >>> 1, (src >>> 1) + n);
}
function mapUint32Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU32)().subarray(src >>> 2, (src >>> 2) + n);
}
function mapInt32Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap32)().subarray(src >>> 2, (src >>> 2) + n);
}
function mapUint64Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU64)().subarray(src >>> 3, (src >>> 3) + n);
}
function mapInt64Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap64)().subarray(src >>> 3, (src >>> 3) + n);
}
function mapFloat32Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapF32)().subarray(src >>> 2, (src >>> 2) + n);
}
function mapFloat64Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapF64)().subarray(src >>> 3, (src >>> 3) + n);
}
function readCString(pointer, max) {
    const stringLen = (0,_string__WEBPACK_IMPORTED_MODULE_1__.strlen)(pointer);
    const len = Math.min(stringLen, max ?? stringLen);
    return common_util_text__WEBPACK_IMPORTED_MODULE_2__.decode(mapUint8Array(pointer, len));
}
function writeCString(dst, str, max, addNull = true) {
    const data = common_util_text__WEBPACK_IMPORTED_MODULE_2__.encode(str);
    let len = data.length;
    let remain = addNull ? 1 : 0;
    if (max && len - remain > max) {
        len = max - remain;
    }
    memcpyFromUint8Array(dst, len, data);
    if (addNull) {
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[11 /* CTypeEnum.int8 */](dst + len, 0);
    }
}


/***/ }),

/***/ "./src/cheap/std/sizeof.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/sizeof.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sizeof)
/* harmony export */ });
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typedef */ "./src/cheap/typedef.ts");



function sizeof(type) {
    if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(type)) {
        return _typedef__WEBPACK_IMPORTED_MODULE_2__.CTypeEnum2Bytes[type] || 0;
    }
    else if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.func(type) && type.prototype[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct]) {
        return type.prototype[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength];
    }
    return 0;
}


/***/ }),

/***/ "./src/cheap/std/string.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/string.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   strlen: () => (/* binding */ strlen)
/* harmony export */ });
/* unused harmony exports strcpy, strcat, strcmp */
/* harmony import */ var _memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");


/**
 * 获取字符串长度，不包括字符串末尾的空字符（\0）
 *
 * @param pointer
 */
function strlen(pointer) {
    let len = 0;
    while (_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[4 /* CTypeEnum.char */]((pointer = pointer + 1, pointer - 1))) {
        len++;
    }
    return len;
}
/**
 * 将一个字符串复制到另一个字符串
 *
 * @param destination
 * @param source
 */
function strcpy(destination, source) {
    const len = strlen(source) + 1;
    (0,_memory__WEBPACK_IMPORTED_MODULE_0__.memcpyFromUint8Array)(destination, len, (0,_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(source, len));
}
/**
 * 将一个字符串追加到另一个字符串的末尾
 *
 * @param destination
 * @param source
 */
function strcat(destination, source) {
    const len = strlen(source) + 1;
    const len1 = strlen(destination);
    (0,_memory__WEBPACK_IMPORTED_MODULE_0__.memcpyFromUint8Array)(destination + len1, len, (0,_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(source, len));
}
/**
 * 比较两个字符串的大小
 */
function strcmp(str1, str2) {
    const len1 = strlen(str1);
    const len2 = strlen(str2);
    const len = Math.min(len1, len2);
    for (let i = 0; i < len; i++) {
        const char1 = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[4 /* CTypeEnum.char */](str1 + i);
        const char2 = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[4 /* CTypeEnum.char */](str2 + i);
        if (char1 > char2) {
            return 1;
        }
        else if (char1 < char2) {
            return -1;
        }
    }
    if (len1 > len2) {
        return 1;
    }
    else if (len1 < len2) {
        return -1;
    }
    else {
        return 0;
    }
}


/***/ }),

/***/ "./src/cheap/std/structAccess.ts":
/*!***************************************!*\
  !*** ./src/cheap/std/structAccess.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ structAccess)
/* harmony export */ });
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _proxyStruct__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../proxyStruct */ "./src/cheap/proxyStruct.ts");
/* harmony import */ var _definedStruct__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../definedStruct */ "./src/cheap/definedStruct.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_keypath__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/keypath */ "./src/common/util/keypath.ts");






/**
 * 访问 struct 指针
 *
 * @param target
 * @param address
 * @returns
 */
function structAccess(address, struct) {
    if (arguments[2] && common_util_is__WEBPACK_IMPORTED_MODULE_4__.string(arguments[2])) {
        struct = struct.prototype;
        common_util_keypath__WEBPACK_IMPORTED_MODULE_5__.each(arguments[2], (key) => {
            const meta = struct[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta];
            struct = meta.get(key)[0 /* KeyMetaKey.Type */];
        });
    }
    return common_util_support__WEBPACK_IMPORTED_MODULE_3__["default"].proxy ? (0,_proxyStruct__WEBPACK_IMPORTED_MODULE_1__.proxyStruct)(address, struct) : (0,_definedStruct__WEBPACK_IMPORTED_MODULE_2__.definedStruct)(address, struct);
}


/***/ }),

/***/ "./src/cheap/std/unmake.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/unmake.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ unmake)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _proxyStruct__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proxyStruct */ "./src/cheap/proxyStruct.ts");
/* harmony import */ var _definedStruct__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definedStruct */ "./src/cheap/definedStruct.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");





/**
 * 销毁一个 struct 实例，调用 make 创建的对象必须调用 unmake，否则内存泄漏
 *
 * @param target
 */
function unmake(target) {
    const p = target[_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress];
    if (p) {
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(p);
        target[_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress] = 0;
        common_util_support__WEBPACK_IMPORTED_MODULE_4__["default"].proxy ? (0,_proxyStruct__WEBPACK_IMPORTED_MODULE_2__.revokeProxyStruct)(target) : (0,_definedStruct__WEBPACK_IMPORTED_MODULE_3__.revokeDefinedStruct)(target);
    }
}


/***/ }),

/***/ "./src/cheap/symbol.ts":
/*!*****************************!*\
  !*** ./src/cheap/symbol.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   symbolStruct: () => (/* binding */ symbolStruct),
/* harmony export */   symbolStructAddress: () => (/* binding */ symbolStructAddress),
/* harmony export */   symbolStructKeysMeta: () => (/* binding */ symbolStructKeysMeta),
/* harmony export */   symbolStructLength: () => (/* binding */ symbolStructLength),
/* harmony export */   symbolStructMaxBaseTypeByteLength: () => (/* binding */ symbolStructMaxBaseTypeByteLength),
/* harmony export */   symbolStructProxyRevoke: () => (/* binding */ symbolStructProxyRevoke)
/* harmony export */ });
/* unused harmony exports symbolStructKeysQueue, symbolStructKeysInstance */
const symbolStruct = Symbol('Struct');
const symbolStructLength = Symbol('StructLength');
const symbolStructMaxBaseTypeByteLength = Symbol('StructMaxBaseTypeByteLength');
const symbolStructAddress = Symbol('StructAddress');
const symbolStructKeysQueue = Symbol('StructKeysQueue');
const symbolStructKeysMeta = Symbol('StructKeysMeta');
const symbolStructKeysInstance = Symbol('StructKeysInstance');
const symbolStructProxyRevoke = Symbol('StructProxyRevoke');


/***/ }),

/***/ "./src/cheap/thread/asm/atomics.ts":
/*!*****************************************!*\
  !*** ./src/cheap/thread/asm/atomics.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init),
/* harmony export */   instance: () => (/* binding */ instance),
/* harmony export */   isSupport: () => (/* binding */ isSupport)
/* harmony export */ });
/* harmony import */ var common_util_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/base64 */ "./src/common/util/base64.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
/* harmony import */ var _atomics_asm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./atomics.asm */ "./src/cheap/thread/asm/atomics.asm");
/* harmony import */ var _atomics_asm__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_atomics_asm__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../atomics */ "./src/cheap/thread/atomics.ts");
var cheap__fileName__0 = "src\\cheap\\thread\\asm\\atomics.ts";





/**
 * WebAssembly runtime 实例
 */
let instance;
function isSupport() {
    return !!instance;
}
async function init(memory) {
    try {
        if (typeof SharedArrayBuffer === 'function' && memory.buffer instanceof SharedArrayBuffer) {
            const wasm = (0,common_util_base64__WEBPACK_IMPORTED_MODULE_0__.base64ToUint8Array)((_atomics_asm__WEBPACK_IMPORTED_MODULE_3___default()));
            common_util_wasm__WEBPACK_IMPORTED_MODULE_2__.setMemoryShared(wasm, true);
            instance = (await WebAssembly.instantiate(wasm, {
                env: {
                    memory
                }
            })).instance;
        }
        else {
            return;
        }
        (0,_atomics__WEBPACK_IMPORTED_MODULE_4__.override)({
            add: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.add8(address, value) & 0xff);
                    case 12:
                        return instance.exports.add8(address, value);
                    case 14:
                        return instance.exports.add16(address, value);
                    case 7:
                        return (instance.exports.add16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.add32(address, value);
                    case 9:
                        return (instance.exports.add32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.add64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.add64(address, value));
                }
            },
            sub: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.sub8(address, value) & 0xff);
                    case 12:
                        return instance.exports.sub8(address, value);
                    case 14:
                        return instance.exports.sub16(address, value);
                    case 7:
                        return (instance.exports.sub16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.sub32(address, value);
                    case 9:
                        return (instance.exports.sub32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.sub64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.sub64(address, value));
                }
            },
            and: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.and8(address, value) & 0xff);
                    case 12:
                        return instance.exports.and8(address, value);
                    case 14:
                        return instance.exports.and16(address, value);
                    case 7:
                        return (instance.exports.and16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.and32(address, value);
                    case 9:
                        return (instance.exports.and32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.and64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.and64(address, value));
                }
            },
            or: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.or8(address, value) & 0xff);
                    case 12:
                        return instance.exports.or8(address, value);
                    case 14:
                        return instance.exports.or16(address, value);
                    case 7:
                        return (instance.exports.or16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.or32(address, value);
                    case 9:
                        return instance.exports.or32(address, value);
                    case 21:
                        return instance.exports.or64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.or64(address, value));
                }
            },
            xor: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.xor8(address, value) & 0xff);
                    case 12:
                        return instance.exports.xor8(address, value);
                    case 14:
                        return instance.exports.xor16(address, value);
                    case 7:
                        return (instance.exports.xor16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.xor32(address, value);
                    case 9:
                        return instance.exports.xor32(address, value);
                    case 21:
                        return instance.exports.xor64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.xor64(address, value));
                }
            },
            store: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 12:
                    case 3:
                        return instance.exports.store8(address, value);
                    case 14:
                    case 7:
                        return instance.exports.store16(address, value);
                    case 16:
                    case 9:
                        return instance.exports.store32(address, value);
                    case 21:
                    case 22:
                        return instance.exports.store64(address, value);
                }
            },
            load: function (address, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.load8(address) & 0xff);
                    case 12:
                        return instance.exports.load8(address);
                    case 14:
                        return instance.exports.load16(address);
                    case 7:
                        return instance.exports.load16(address);
                    case 16:
                        return instance.exports.load32(address);
                    case 9:
                        return (instance.exports.load32(address) & 0xffffffff);
                    case 21:
                        return instance.exports.load64(address);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.load64(address));
                }
            },
            compareExchange: function (address, expectedValue, replacementValue, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.compare_exchange8(address, expectedValue, replacementValue) & 0xff);
                    case 12:
                        return instance.exports.compare_exchange8(address, expectedValue, replacementValue);
                    case 14:
                        return instance.exports.compare_exchange16(address, expectedValue, replacementValue);
                    case 7:
                        return (instance.exports.compare_exchange16(address, expectedValue, replacementValue) & 0xffff);
                    case 16:
                        return instance.exports.compare_exchange32(address, expectedValue, replacementValue);
                    case 9:
                        return (instance.exports.compare_exchange32(address, expectedValue, replacementValue) & 0xffffffff);
                    case 21:
                        return instance.exports.compare_exchange64(address, expectedValue, replacementValue);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.compare_exchange64(address, expectedValue, replacementValue));
                }
            },
            exchange: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.exchange8(address, value) & 0xff);
                    case 12:
                        return instance.exports.exchange8(address, value);
                    case 14:
                        return instance.exports.exchange16(address, value);
                    case 7:
                        return (instance.exports.exchange16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.exchange32(address, value);
                    case 9:
                        return (instance.exports.exchange32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.exchange64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.exchange64(address, value));
                }
            },
            notify: function (address, count) {
                return instance.exports.notify(address, count);
            },
            wait: function (address, value) {
                return instance.exports.wait(address, value);
            },
            waitTimeout: function (address, value, timeout) {
                return instance.exports.waitTimeout(address, value, BigInt(timeout >>> 0));
            }
        });
    }
    catch (error) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.warn('atomics asm not support, cannot use asm atomics function', cheap__fileName__0, 284);
    }
}


/***/ }),

/***/ "./src/cheap/thread/atomics.ts":
/*!*************************************!*\
  !*** ./src/cheap/thread/atomics.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   and: () => (/* binding */ and),
/* harmony export */   compareExchange: () => (/* binding */ compareExchange),
/* harmony export */   exchange: () => (/* binding */ exchange),
/* harmony export */   load: () => (/* binding */ load),
/* harmony export */   notify: () => (/* binding */ notify),
/* harmony export */   or: () => (/* binding */ or),
/* harmony export */   override: () => (/* binding */ override),
/* harmony export */   store: () => (/* binding */ store),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   wait: () => (/* binding */ wait),
/* harmony export */   waitAsync: () => (/* binding */ waitAsync),
/* harmony export */   waitTimeout: () => (/* binding */ waitTimeout),
/* harmony export */   waitTimeoutAsync: () => (/* binding */ waitTimeoutAsync),
/* harmony export */   xor: () => (/* binding */ xor)
/* harmony export */ });
/**
 * 给定的值加到指定位置上
 *
 * 返回该位置的旧值
 *
 */
let add;
/**
 * 给定的值与指定位置上的值相减
 *
 * 返回该位置的旧值
 *
 */
let sub;
/**
 * 给定的值与指定位置上的值进行与运算
 *
 * 返回该位置的旧值
 *
 */
let and;
/**
 * 给定的值与指定位置上的值进行或运算
 *
 * 返回该位置的旧值
 *
 */
let or;
/**
 * 给定的值与指定位置上的值进行异或运算
 *
 * 返回该位置的旧值
 *
 */
let xor;
/**
 * 给定的值存在给定位置上
 *
 * 返回该位置的旧值
 *
 */
let store;
/**
 * 读取给定位置上的值
 *
 * 返回该位置的旧值
 *
 */
let load;
/**
 * 如果指定位置的值与给定的值相等，则将其更新为新的值，并返回该元素原先的值
 *
 * 返回该位置的旧值
 *
 */
let compareExchange;
/**
 * 将指定位置的值更新为给定的值，并返回该元素更新前的值。
 *
 * 返回该位置的旧值
 *
 */
let exchange;
/**
 * 唤醒等待队列中正在指定位置上等待的线程。返回值为成功唤醒的线程数量。
 *
 * 返回被唤醒的代理的数量 0 将不会唤醒任何线程
 *
 */
let notify;
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒
 *
 * 0 "ok"、1 "not-equal"
 *
 */
let wait;
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时（毫秒）
 *
 * 0 "ok"、1 "not-equal" 或 2 "time-out"
 *
 */
let waitTimeout;
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒
 *
 * 异步非阻塞，适合在主线程上使用
 *
 * 0 "ok"、1 "not-equal"
 *
 */
let waitAsync;
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时
 *
 * 异步非阻塞，适合在主线程上使用
 *
 * 0 "ok"、1 "not-equal" 或 2 "time-out"
 *
 */
let waitTimeoutAsync;
function override(funcs) {
    if (funcs.add) {
        add = funcs.add;
    }
    if (funcs.sub) {
        sub = funcs.sub;
    }
    if (funcs.and) {
        and = funcs.and;
    }
    if (funcs.or) {
        or = funcs.or;
    }
    if (funcs.xor) {
        xor = funcs.xor;
    }
    if (funcs.store) {
        store = funcs.store;
    }
    if (funcs.load) {
        load = funcs.load;
    }
    if (funcs.compareExchange) {
        compareExchange = funcs.compareExchange;
    }
    if (funcs.exchange) {
        exchange = funcs.exchange;
    }
    if (funcs.notify) {
        notify = funcs.notify;
    }
    if (funcs.wait) {
        wait = funcs.wait;
    }
    if (funcs.waitTimeout) {
        waitTimeout = funcs.waitTimeout;
    }
    if (funcs.waitAsync) {
        waitAsync = funcs.waitAsync;
    }
    if (funcs.waitTimeoutAsync) {
        waitTimeoutAsync = funcs.waitTimeoutAsync;
    }
}


/***/ }),

/***/ "./src/cheap/thread/atomicsImpl.ts":
/*!*****************************************!*\
  !*** ./src/cheap/thread/atomicsImpl.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var common_function_nextTick__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/function/nextTick */ "./src/common/function/nextTick.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");






let getAtomicsBuffer;
const useAtomics = _config__WEBPACK_IMPORTED_MODULE_3__.USE_THREADS || (0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_4__["default"])() || (!common_util_browser__WEBPACK_IMPORTED_MODULE_5__["default"].chrome || common_util_browser__WEBPACK_IMPORTED_MODULE_5__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_5__["default"].majorVersion, '94', true));
/**
 * 给定的值加到指定位置上
 *
 * 返回该位置的旧值
 *
 */
function add(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.add(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] += value;
        return old;
    }
}
/**
 * 给定的值与指定位置上的值相减
 *
 * 返回该位置的旧值
 *
 */
function sub(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.sub(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] -= value;
        return old;
    }
}
/**
 * 给定的值与指定位置上的值进行与运算
 *
 * 返回该位置的旧值
 *
 */
function and(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.and(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] &= value;
        return old;
    }
}
/**
 * 给定的值与指定位置上的值进行或运算
 *
 * 返回该位置的旧值
 *
 */
function or(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.or(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] |= value;
        return old;
    }
}
/**
 * 给定的值与指定位置上的值进行异或运算
 *
 * 返回该位置的旧值
 *
 */
function xor(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.xor(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] ^= value;
        return old;
    }
}
/**
 * 给定的值存在给定位置上
 *
 * 返回该位置的旧值
 *
 */
function store(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.store(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] = value;
        return old;
    }
}
/**
 * 读取给定位置上的值
 *
 * 返回该位置的旧值
 *
 */
function load(address, type, shift) {
    if ( true && useAtomics) {
        return Atomics.load(getAtomicsBuffer(type), address >>> shift);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        return old;
    }
}
/**
 * 如果指定位置的值与给定的值相等，则将其更新为新的值，并返回该位置原先的值
 *
 * 返回该位置的旧值
 *
 */
function compareExchange(address, expectedValue, replacementValue, type, shift) {
    if ( true && useAtomics) {
        return Atomics.compareExchange(getAtomicsBuffer(type), address >>> shift, expectedValue, replacementValue);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        if (old === expectedValue) {
            buffer[index] = replacementValue;
        }
        return old;
    }
}
/**
 * 将指定位置的值更新为给定的值，并返回该位置更新前的值。
 *
 * 返回该位置的旧值
 *
 */
function exchange(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.exchange(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] = value;
        return old;
    }
}
/**
 * 唤醒等待队列中正在指定位置上等待的线程。返回值为成功唤醒的线程数量。
 *
 * 返回被唤醒的代理的数量
 *
 */
function notify(address, count) {
    if ( true && useAtomics) {
        return Atomics.notify(getAtomicsBuffer(16), address >>> 2, count);
    }
    else {
        return;
    }
}
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒
 *
 * 0 "ok"、1 "not-equal" 或 2 "timed-out"
 *
 */
const waitMap = {
    'ok': 0,
    'not-equal': 1,
    'timed-out': 2
};
function wait(address, value) {
    return waitMap[Atomics.wait(getAtomicsBuffer(16), address >>> 2, value)];
}
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时
 *
 * 0 "ok"、1 "not-equal" 或 2 "time-out"
 *
 */
function waitTimeout(address, value, timeout) {
    return waitMap[Atomics.wait(getAtomicsBuffer(16), address >>> 2, value, timeout)];
}
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒
 *
 * 0 "ok"、1 "not-equal" 或 2 "timed-out"
 *
 */
async function waitAsync(address, value) {
    if (Atomics.waitAsync) {
        const result = Atomics.waitAsync(getAtomicsBuffer(16), address >>> 2, value);
        if (result.async) {
            return waitMap[await result.value];
        }
        return waitMap[result.value];
    }
    else {
        if (load(address) !== value) {
            return 1;
        }
        else {
            while (load(address) === value) {
                // 跳过当前事件循环
                await new Promise((resolve) => {
                    (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_1__["default"])(() => {
                        resolve();
                    });
                });
            }
            return 0;
        }
    }
}
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时
 *
 * 0 "ok"、1 "not-equal" 或 2 "time-out"
 *
 */
async function waitTimeoutAsync(address, value, timeout) {
    if (Atomics.waitAsync) {
        const result = Atomics.waitAsync(getAtomicsBuffer(16), address >>> 2, value, timeout);
        if (result.async) {
            return waitMap[await result.value];
        }
        return waitMap[result.value];
    }
    else {
        if (load(address) !== value) {
            return 1;
        }
        else {
            const now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_0__["default"])();
            while (load(address) === value && ((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_0__["default"])() - now < timeout)) {
                // 跳过当前事件循环
                await new Promise((resolve) => {
                    (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_1__["default"])(() => {
                        resolve();
                    });
                });
            }
            return load(address) !== value ? 0 : 2;
        }
    }
}
function init(getAtomicsBuffer_) {
    getAtomicsBuffer = getAtomicsBuffer_;
    (0,_atomics__WEBPACK_IMPORTED_MODULE_2__.override)({
        add,
        sub,
        and,
        or,
        xor,
        store,
        load,
        compareExchange,
        exchange,
        notify,
        wait,
        waitTimeout,
        waitAsync,
        waitTimeoutAsync
    });
}


/***/ }),

/***/ "./src/cheap/thread/cond.ts":
/*!**********************************!*\
  !*** ./src/cheap/thread/cond.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cond: () => (/* binding */ Cond),
/* harmony export */   broadcast: () => (/* binding */ broadcast),
/* harmony export */   destroy: () => (/* binding */ destroy),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   signal: () => (/* binding */ signal),
/* harmony export */   timedWait: () => (/* binding */ timedWait),
/* harmony export */   wait: () => (/* binding */ wait)
/* harmony export */ });
/* unused harmony exports waitAsync, timedwaitAsync */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _mutex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");



/**
 * 参考 https://github.com/mozilla-spidermonkey/js-lock-and-condition
 */


class Cond {
    atomic;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(Cond.prototype);
/**
 * 初始化条件变量
 */
function init(cond, attr) {
    _atomics__WEBPACK_IMPORTED_MODULE_4__.store(cond, 0, 16, 2);
    return 0;
}
/**
 * 销毁条件变量
 */
function destroy(cond) {
    _atomics__WEBPACK_IMPORTED_MODULE_4__.store(cond, 0, 16, 2);
    return 0;
}
/**
 * 唤醒条件变量上的一个等待线程
 *
 * @param cond
 */
function signal(cond) {
    _atomics__WEBPACK_IMPORTED_MODULE_4__.add(cond, 1, 16, 2);
    _atomics__WEBPACK_IMPORTED_MODULE_4__.notify(cond, 1);
    return 0;
}
/**
 * 唤醒条件变量上的所有等待线程
 *
 * @param cond
 */
function broadcast(cond) {
    _atomics__WEBPACK_IMPORTED_MODULE_4__.add(cond, 1, 16, 2);
    _atomics__WEBPACK_IMPORTED_MODULE_4__.notify(cond, 1073741824);
    return 0;
}
/**
 * 线程在条件变量处等待
 *
 * @param cond
 * @param mutex
 * @returns
 */
function wait(cond, mutex) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_4__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    _atomics__WEBPACK_IMPORTED_MODULE_4__.wait(cond, c);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.lock(mutex);
    return 0;
}
/**
 * 线程在条件变量处异步等待
 *
 * @param cond
 * @param mutex
 */
async function waitAsync(cond, mutex) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_4__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    await _atomics__WEBPACK_IMPORTED_MODULE_4__.waitAsync(cond, c);
    await _mutex__WEBPACK_IMPORTED_MODULE_3__.lockAsync(mutex);
    return 0;
}
/**
 * 线程在条件变量处超时等待
 *
 * @param cond
 * @param mutex
 * @param timeout 毫秒
 */
function timedWait(cond, mutex, timeout) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_4__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    let ret = _atomics__WEBPACK_IMPORTED_MODULE_4__.waitTimeout(cond, c, timeout);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.lock(mutex);
    return ret === 2 ? 110 : 0;
}
/**
 * 线程在条件变量处超时异步等待
 *
 * @param cond
 * @param mutex
 * @param timeout 毫秒
 */
async function timedwaitAsync(cond, mutex, timeout) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_4__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    let ret = await _atomics__WEBPACK_IMPORTED_MODULE_4__.waitTimeoutAsync(cond, c, timeout);
    await _mutex__WEBPACK_IMPORTED_MODULE_3__.lockAsync(mutex);
    return ret === 2 ? 110 : 0;
}


/***/ }),

/***/ "./src/cheap/thread/initClass.ts":
/*!***************************************!*\
  !*** ./src/cheap/thread/initClass.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_network_NodeIPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/NodeIPCPort */ "./src/common/network/NodeIPCPort.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");




let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF;
function init(run) {
    let ipc;
    let target;
    function initIPC(port) {
        ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](port);
        ipc.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.REQUEST, async (data) => {
            const method = data.method;
            const params = data.params;
            if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.func(target[method])) {
                try {
                    if (!target[method].transfer) {
                        target[method].transfer = [];
                    }
                    const result = await target[method](...params.params);
                    ipc.reply(data, result, null, target[method].transfer);
                    target[method].transfer.length = 0;
                }
                catch (error) {
                    ipc.reply(data, -2097152 /* CHeapError.REQUEST_ERROR */, {
                        message: error.message
                    });
                }
            }
        });
    }
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        switch (type) {
            case 'init':
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.CHeap.initThread) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.CHeap.initThread(data).then(() => {
                        parentPort.postMessage({
                            type: 'ready'
                        });
                    });
                    return;
                }
                parentPort.postMessage({
                    type: 'ready'
                });
                break;
            case 'run':
                parentPort.postMessage({
                    type: 'running'
                });
                target = run(data.params);
                initIPC(data.port);
                break;
            case 'stop':
                if (ipc) {
                    ipc.destroy();
                }
                parentPort.postMessage({
                    type: 'stopped'
                });
                break;
            default:
                break;
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/thread/initFunction.ts":
/*!******************************************!*\
  !*** ./src/cheap/thread/initFunction.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");

let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF;
function init(run) {
    let retval;
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        switch (type) {
            case 'init':
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread(data).then(() => {
                        parentPort.postMessage({
                            type: 'ready'
                        });
                    });
                    return;
                }
                parentPort.postMessage({
                    type: 'ready'
                });
                break;
            case 'run':
                retval = run(data.params);
                break;
            case 'stop':
                if (retval && retval.then) {
                    retval.then((res) => {
                        parentPort.postMessage({
                            type: 'stopped',
                            data: res
                        });
                    });
                }
                else {
                    parentPort.postMessage({
                        type: 'stopped',
                        data: retval
                    });
                }
                break;
            default:
                break;
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/thread/initModule.ts":
/*!****************************************!*\
  !*** ./src/cheap/thread/initModule.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_network_NodeIPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/NodeIPCPort */ "./src/common/network/NodeIPCPort.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");




let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF;
function init(module) {
    let ipc;
    function initIPC(port) {
        ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](port);
        ipc.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.REQUEST, async (data) => {
            const method = data.method;
            const params = data.params;
            if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.func(module[method])) {
                try {
                    if (!module[method].transfer) {
                        module[method].transfer = [];
                    }
                    const result = await module[method](...params.params);
                    ipc.reply(data, result, null, module[method].transfer);
                    module[method].transfer.length = 0;
                }
                catch (error) {
                    ipc.reply(data, -2097152 /* CHeapError.REQUEST_ERROR */, {
                        message: error.message
                    });
                }
            }
        });
    }
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        switch (type) {
            case 'init':
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.CHeap.initThread) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.CHeap.initThread(data).then(() => {
                        parentPort.postMessage({
                            type: 'ready'
                        });
                    });
                    return;
                }
                parentPort.postMessage({
                    type: 'ready'
                });
                break;
            case 'run':
                parentPort.postMessage({
                    type: 'running'
                });
                initIPC(data.port);
                break;
            case 'stop':
                if (ipc) {
                    ipc.destroy();
                }
                parentPort.postMessage({
                    type: 'stopped'
                });
                break;
            default:
                break;
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/thread/mutex.ts":
/*!***********************************!*\
  !*** ./src/cheap/thread/mutex.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mutex: () => (/* binding */ Mutex),
/* harmony export */   destroy: () => (/* binding */ destroy),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   lock: () => (/* binding */ lock),
/* harmony export */   lockAsync: () => (/* binding */ lockAsync),
/* harmony export */   tryLock: () => (/* binding */ tryLock),
/* harmony export */   unlock: () => (/* binding */ unlock)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");





class Mutex {
    atomic;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(Mutex.prototype);
/**
 * 初始化锁
 *
 * @param mutex
 * @returns
 */
function init(mutex) {
    _atomics__WEBPACK_IMPORTED_MODULE_3__.store(mutex, 0 /* STATUS.UNLOCK */, 16, 2);
    return 0;
}
/**
 * 加锁
 *
 * @param mutex
 * @param spin 是否自旋
 */
function lock(mutex, spin = false) {
    let status;
    // 不为 UNLOCK，说明其他线程持锁，将锁置为 LOCKED 状态
    if ((status = _atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 1 /* STATUS.LOCKED */, 16, 2)) !== 0 /* STATUS.UNLOCK */) {
        do {
            // 如果依旧得不到锁，将锁置为 WAITED 状态
            if (status == 2 /* STATUS.WAITED */
                || _atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(mutex, 1 /* STATUS.LOCKED */, 2 /* STATUS.WAITED */, 16, 2) !== 0 /* STATUS.UNLOCK */) {
                // 主线程不能 wait，直接自旋（需要注意所有线程各自的持锁时间，避免出现忙等占用大量 cpu 时间）
                if (!spin && (0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_4__["default"])()) {
                    _atomics__WEBPACK_IMPORTED_MODULE_3__.wait(mutex, 2 /* STATUS.WAITED */);
                }
            }
        } 
        // 再次尝试获取锁
        while ((status = _atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 2 /* STATUS.WAITED */, 16, 2)) !== 0 /* STATUS.UNLOCK */);
    }
    return 0;
}
/**
 * 尝试加锁
 *
 * @param mutex
 */
function tryLock(mutex) {
    if (_atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 1 /* STATUS.LOCKED */, 16, 2) === 0 /* STATUS.UNLOCK */) {
        return 0;
    }
    // EBUSY
    return 16 /* POSIXError.EBUSY */;
}
/**
 * 异步加锁
 *
 * @param mutex
 */
async function lockAsync(mutex) {
    let status;
    // 不为 UNLOCK，说明其他线程持锁，将锁置为 LOCKED 状态
    if ((status = _atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 1 /* STATUS.LOCKED */, 16, 2)) !== 0 /* STATUS.UNLOCK */) {
        do {
            // 如果依旧得不到锁，将锁置为 WAITED 状态
            if (status == 2 /* STATUS.WAITED */
                || _atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(mutex, 1 /* STATUS.LOCKED */, 2 /* STATUS.WAITED */, 16, 2) !== 0 /* STATUS.UNLOCK */) {
                await _atomics__WEBPACK_IMPORTED_MODULE_3__.waitAsync(mutex, 2 /* STATUS.WAITED */);
            }
        } 
        // 再次尝试获取锁
        while ((status = _atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 2 /* STATUS.WAITED */, 16, 2)) !== 0 /* STATUS.UNLOCK */);
    }
    return 0;
}
/**
 * 释放锁
 *
 * @param mutex
 */
function unlock(mutex) {
    let status = _atomics__WEBPACK_IMPORTED_MODULE_3__.sub(mutex, 1, 16, 2);
    // 此时拥有锁，状态为 LOCKED 或 WAITED
    if (status !== 1 /* STATUS.LOCKED */) {
        // 释放锁
        _atomics__WEBPACK_IMPORTED_MODULE_3__.store(mutex, 0 /* STATUS.UNLOCK */, 16, 2);
        // 唤醒一个 wait 的线程
        _atomics__WEBPACK_IMPORTED_MODULE_3__.notify(mutex, 1);
    }
    return 0;
}
/**
 * 销毁锁
 *
 * @param mutex
 * @returns
 */
function destroy(mutex) {
    _atomics__WEBPACK_IMPORTED_MODULE_3__.store(mutex, 0 /* STATUS.UNLOCK */, 16, 2);
    return 0;
}


/***/ }),

/***/ "./src/cheap/thread/semaphore.ts":
/*!***************************************!*\
  !*** ./src/cheap/thread/semaphore.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   destroy: () => (/* binding */ destroy),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   post: () => (/* binding */ post),
/* harmony export */   timedWait: () => (/* binding */ timedWait),
/* harmony export */   tryWait: () => (/* binding */ tryWait),
/* harmony export */   wait: () => (/* binding */ wait)
/* harmony export */ });
/* unused harmony exports Sem, waitAsync, timedWaitAsync, set, get */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _mutex_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");








class Sem {
    atomic;
    mutex;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("mutex", { 0: _mutex_ts__WEBPACK_IMPORTED_MODULE_2__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(Sem.prototype);
/**
 * 初始化信号量
 *
 * @param sem
 * @param value 信号量初始值
 */
function init(sem, value) {
    _atomics__WEBPACK_IMPORTED_MODULE_6__.store(sem, (value >> 0), 16, 2);
    _mutex_ts__WEBPACK_IMPORTED_MODULE_2__.init(sem + 4);
    return 0;
}
function destroy(sem) {
    _mutex_ts__WEBPACK_IMPORTED_MODULE_2__.destroy(sem + 4);
    return 0;
}
/**
 * 生产信号量
 *
 * @param sem
 */
function post(sem) {
    _atomics__WEBPACK_IMPORTED_MODULE_6__.add(sem, 1, 16, 2);
    _atomics__WEBPACK_IMPORTED_MODULE_6__.notify(sem, 1);
    return 0;
}
/**
 * 消费信号量
 *
 * @param sem
 */
function wait(sem) {
    while (true) {
        _atomics__WEBPACK_IMPORTED_MODULE_6__.wait(sem, 0);
        let old = _atomics__WEBPACK_IMPORTED_MODULE_6__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 此时已经没有了，将减掉的加回来继续等待
            _atomics__WEBPACK_IMPORTED_MODULE_6__.add(sem, 1, 16, 2);
        }
        else {
            break;
        }
    }
    return 0;
}
/**
 * 消费信号量
 *
 * @param sem
 */
function tryWait(sem) {
    _mutex_ts__WEBPACK_IMPORTED_MODULE_2__.lock(sem + 4);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[16](sem) > 0) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[16](sem, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[16](sem) - 1);
        _mutex_ts__WEBPACK_IMPORTED_MODULE_2__.unlock(sem + 4);
        return 0;
    }
    _mutex_ts__WEBPACK_IMPORTED_MODULE_2__.unlock(sem + 4);
    return 11;
}
/**
 * 消费信号量，并设置一个超时
 *
 * @param sem
 * @param timeout 毫秒
 * @returns
 */
function timedWait(sem, timeout) {
    let ret = _atomics__WEBPACK_IMPORTED_MODULE_6__.waitTimeout(sem, 0, timeout);
    if (ret !== 2) {
        let old = _atomics__WEBPACK_IMPORTED_MODULE_6__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 此时已经没有了，将减掉的加回来
            _atomics__WEBPACK_IMPORTED_MODULE_6__.add(sem, 1, 16, 2);
            // ETIMEDOUT
            return 110;
        }
    }
    return 0;
}
/**
 * 异步消费信号量
 *
 * @param sem
 */
async function waitAsync(sem) {
    while (true) {
        await _atomics__WEBPACK_IMPORTED_MODULE_6__.waitAsync(sem, 0);
        let old = _atomics__WEBPACK_IMPORTED_MODULE_6__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 此时已经没有了，将减掉的加回来继续等待
            _atomics__WEBPACK_IMPORTED_MODULE_6__.add(sem, 1, 16, 2);
        }
        else {
            break;
        }
    }
    return 0;
}
/**
 * 异步消费信号量，并设置一个超时
 *
 * @param sem
 * @param timeout 毫秒
 */
async function timedWaitAsync(sem, timeout) {
    let ret = await _atomics__WEBPACK_IMPORTED_MODULE_6__.waitTimeoutAsync(sem, 0, timeout);
    if (ret !== 2) {
        let old = _atomics__WEBPACK_IMPORTED_MODULE_6__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 此时已经没有了，将减掉的加回来
            _atomics__WEBPACK_IMPORTED_MODULE_6__.add(sem, 1, 16, 2);
            // ETIMEDOUT
            return 110;
        }
    }
    return 0;
}
function set(sem, value) {
    _atomics__WEBPACK_IMPORTED_MODULE_6__.store(sem, value, 16, 2);
    return 0;
}
function get(sem) {
    return _atomics__WEBPACK_IMPORTED_MODULE_6__.load(sem, 16, 2);
}


/***/ }),

/***/ "./src/cheap/thread/thread.ts":
/*!************************************!*\
  !*** ./src/cheap/thread/thread.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   closeThread: () => (/* binding */ closeThread),
/* harmony export */   createThreadFromClass: () => (/* binding */ createThreadFromClass)
/* harmony export */ });
/* unused harmony exports createThreadFromFunction, createThreadFromModule, joinThread */
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../heap */ "./src/cheap/heap.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_network_NodeIPCPort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/network/NodeIPCPort */ "./src/common/network/NodeIPCPort.ts");
/* harmony import */ var common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/function/sourceLoad */ "./src/common/function/sourceLoad.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var common_function_generateUUID__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/function/generateUUID */ "./src/common/function/generateUUID.ts");
/* harmony import */ var common_function_toString__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/function/toString */ "./src/common/function/toString.ts");










// @ts-ignore
let Worker = common_util_constant__WEBPACK_IMPORTED_MODULE_6__.SELF.Worker;
// @ts-ignore
let MessageChannel = common_util_constant__WEBPACK_IMPORTED_MODULE_6__.SELF.MessageChannel;
{
    // 保证打包工具可以包含下面的模块代码
    __webpack_require__(/*! ./initClass */ "./src/cheap/thread/initClass.ts");
    __webpack_require__(/*! ./initFunction */ "./src/cheap/thread/initFunction.ts");
    __webpack_require__(/*! ./initModule */ "./src/cheap/thread/initModule.ts");
}
const initClass =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_3__["default"])(/*require.resolve*/(/*! ./initClass */ "./src/cheap/thread/initClass.ts"), {
    varName: 'init'
}) : 0;
const initFunction =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_3__["default"])(/*require.resolve*/(/*! ./initFunction */ "./src/cheap/thread/initFunction.ts"), {
    varName: 'init'
}) : 0;
const initModule =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_3__["default"])(/*require.resolve*/(/*! ./initModule */ "./src/cheap/thread/initModule.ts"), {
    varName: 'init'
}) : 0;
const symbolRevoke = Symbol('revoke');
const caches = new Map();
function getCacheKey(moduleId, type) {
    return `${moduleId}_${type}`;
}
function createThreadFromClass(entity, options = {}, moduleId) {
    let transferData = [];
    let runInWorker;
    {
        runInWorker = (...args) => {
            let worker;
            if (moduleId instanceof Worker) {
                worker = moduleId;
            }
            else {
                let workerUrl;
                const cacheKey = getCacheKey(moduleId, 'class');
                if (caches.has(cacheKey)) {
                    workerUrl = caches.get(cacheKey).url;
                    caches.get(cacheKey).refCount++;
                }
                else {
                    const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_3__["default"])(moduleId, {
                        varName: `__module_${entity.name}__`,
                        exportName: `__${entity.name}__`,
                        pointName: entity.name,
                        exportIsClass: true
                    });
                    const source = `
            ${module}
            function run(params) {
              params.unshift(null)
              return new (Function.prototype.bind.apply(__module_${entity.name}__.__${entity.name}__, params))()
            }
            ${initClass}
            init.default(run);
          `;
                    {
                        const blob = new Blob([source], { type: 'text/javascript' });
                        workerUrl = URL.createObjectURL(blob);
                    }
                    caches.set(cacheKey, {
                        url: workerUrl,
                        refCount: 1
                    });
                }
                worker = new Worker(workerUrl);
            }
            const channel = new MessageChannel();
            return new Promise((resolve, reject) => {
                const stackPointer = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT, options.stackSize
                    ? ((options.stackSize + _config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT) & ~_config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT)
                    : _config__WEBPACK_IMPORTED_MODULE_4__.STACK_SIZE);
                function running() {
                    const ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](channel.port1);
                    const obj = {
                        $worker: worker,
                        $ipc: ipc,
                        $channel: channel,
                        $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_8__["default"])(moduleId),
                        $stackPointer: stackPointer,
                        $type: 'class'
                    };
                    const { proxy, revoke } = Proxy.revocable(obj, {
                        get(target, propertyKey, receiver) {
                            if (target[propertyKey]) {
                                return obj[propertyKey];
                            }
                            if (propertyKey in entity.prototype && typeof entity.prototype[propertyKey] === 'function') {
                                const call = async function (...args) {
                                    return ipc.request(propertyKey, {
                                        params: args
                                    });
                                };
                                call.transfer = function (...transfer) {
                                    return {
                                        invoke: async function (...args) {
                                            return ipc.request(propertyKey, {
                                                params: args
                                            }, transfer);
                                        }
                                    };
                                };
                                target[propertyKey] = call;
                            }
                            return target[propertyKey];
                        }
                    });
                    obj[symbolRevoke] = revoke;
                    resolve(proxy);
                }
                const handler = (message) => {
                    const origin =  false ? 0 : message.data;
                    const type = origin.type;
                    const data = origin.data;
                    switch (type) {
                        case 'ready':
                            worker.postMessage({
                                type: 'run',
                                data: {
                                    port: channel.port2,
                                    params: args
                                }
                            }, [channel.port2, ...transferData]);
                            break;
                        case 'running':
                            running();
                            break;
                        default:
                            break;
                    }
                };
                {
                    worker.onmessage = handler;
                }
                worker.onmessage = handler;
                worker.postMessage({
                    type: 'init',
                    data: {
                        memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory,
                        name: options.name || entity.name,
                        stackPointer,
                        stackSize: options.stackSize ?? _config__WEBPACK_IMPORTED_MODULE_4__.STACK_SIZE
                    }
                });
            });
        };
    }
    function runInMain(...args) {
        const worker = new entity(...args);
        return new Promise((resolve) => {
            const obj = {
                $worker: null,
                $ipc: null,
                $channel: null,
                $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_8__["default"])(moduleId),
                $stackPointer: 0,
                $instance: worker,
                $type: 'class'
            };
            const { proxy, revoke } = Proxy.revocable(obj, {
                get(target, propertyKey, receiver) {
                    if (target[propertyKey]) {
                        return obj[propertyKey];
                    }
                    if (propertyKey in entity.prototype && typeof entity.prototype[propertyKey] === 'function') {
                        const call = function (...args) {
                            return worker[propertyKey](...args);
                        };
                        call.transfer = function (...transfer) {
                            return {
                                invoke: function (...args) {
                                    return worker[propertyKey](...args);
                                }
                            };
                        };
                        target[propertyKey] = call;
                    }
                    return target[propertyKey];
                }
            });
            obj[symbolRevoke] = revoke;
            resolve(proxy);
        });
    }
    function transfer(...transfer) {
        transferData = transfer;
        return {
            run:  true && (_config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS && !options.disableWorker) ? runInWorker : runInMain
        };
    }
    return {
        run:  true && (_config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS && !options.disableWorker) ? runInWorker : runInMain,
        transfer
    };
}
function createThreadFromFunction(entity, options = {}, moduleId) {
    let transferData = [];
    let runInWorker;
    {
        runInWorker = (...args) => {
            let worker;
            if (moduleId instanceof Worker) {
                worker = moduleId;
            }
            else {
                let workerUrl;
                const cacheKey = getCacheKey(moduleId, 'function');
                if (caches.has(cacheKey)) {
                    workerUrl = caches.get(cacheKey).url;
                    caches.get(cacheKey).refCount++;
                }
                else {
                    const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_3__["default"])(moduleId, {
                        varName: `__module_${entity.name}__`,
                        exportName: `__${entity.name}__`,
                        pointName: entity.name
                    });
                    const source = `
            ${module}
            function run(params) {
              return __module_${entity.name}__.__${entity.name}__.apply(${ false ? 0 : 'self'}, params)
            }
            ${initFunction}
            init.default(run);
          `;
                    {
                        const blob = new Blob([source], { type: 'text/javascript' });
                        workerUrl = URL.createObjectURL(blob);
                    }
                    caches.set(cacheKey, {
                        url: workerUrl,
                        refCount: 1
                    });
                }
                worker = new Worker(workerUrl);
            }
            return new Promise((resolve, reject) => {
                const stackPointer = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT, options.stackSize
                    ? ((options.stackSize + _config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT) & ~_config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT)
                    : _config__WEBPACK_IMPORTED_MODULE_4__.STACK_SIZE);
                function running() {
                    const obj = {
                        $worker: worker,
                        $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_8__["default"])(moduleId),
                        $stackPointer: stackPointer,
                        $type: 'function'
                    };
                    resolve(obj);
                }
                const handler = (message) => {
                    const origin =  false ? 0 : message.data;
                    const type = origin.type;
                    const data = origin.data;
                    switch (type) {
                        case 'ready':
                            worker.postMessage({
                                type: 'run',
                                data: {
                                    params: args
                                }
                            }, transferData);
                            running();
                            break;
                        default:
                            break;
                    }
                };
                {
                    worker.onmessage = handler;
                }
                worker.onmessage = handler;
                worker.postMessage({
                    type: 'init',
                    data: {
                        memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory,
                        name: options.name || entity.name,
                        stackPointer,
                        stackSize: options.stackSize ?? _config__WEBPACK_IMPORTED_MODULE_4__.STACK_SIZE
                    }
                });
            });
        };
    }
    function runInMain(...args) {
        return new Promise((resolve, reject) => {
            const obj = {
                $worker: null,
                $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_8__["default"])(moduleId),
                $stackPointer: null,
                $type: 'function'
            };
            resolve(obj);
            obj.$retval = new Promise((resolve) => {
                resolve(entity(...args));
            });
        });
    }
    function transfer(...transfer) {
        transferData = transfer;
        return {
            run:  true && (_config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS && !options.disableWorker) ? runInWorker : runInMain
        };
    }
    return {
        run:  true && (_config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS && !options.disableWorker) ? runInWorker : runInMain,
        transfer
    };
}
function createThreadFromModule(entity, options = {}, moduleId) {
    let runInWorker;
    {
        runInWorker = () => {
            let worker;
            let moduleName = `__module_${moduleId}__`.replace(/\.|\//g, '_');
            if (moduleId instanceof Worker) {
                worker = moduleId;
            }
            else {
                let workerUrl;
                const cacheKey = getCacheKey(moduleId, 'module');
                if (caches.has(cacheKey)) {
                    workerUrl = caches.get(cacheKey).url;
                    caches.get(cacheKey).refCount++;
                }
                else {
                    const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_3__["default"])(moduleId, {
                        varName: moduleName
                    });
                    const source = `
            ${module}
            ${initModule}
            init.default(${moduleName});
          `;
                    {
                        const blob = new Blob([source], { type: 'text/javascript' });
                        workerUrl = URL.createObjectURL(blob);
                    }
                    caches.set(cacheKey, {
                        url: workerUrl,
                        refCount: 1
                    });
                }
                worker = new Worker(workerUrl);
            }
            const channel = new MessageChannel();
            return new Promise((resolve, reject) => {
                const stackPointer = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT, options.stackSize
                    ? ((options.stackSize + _config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT) & ~_config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT)
                    : _config__WEBPACK_IMPORTED_MODULE_4__.STACK_SIZE);
                function running() {
                    const ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](channel.port1);
                    const obj = {
                        $worker: worker,
                        $ipc: ipc,
                        $channel: channel,
                        $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_8__["default"])(moduleId),
                        $stackPointer: stackPointer,
                        $type: 'module'
                    };
                    const { proxy, revoke } = Proxy.revocable(obj, {
                        get(target, propertyKey, receiver) {
                            if (target[propertyKey]) {
                                return obj[propertyKey];
                            }
                            if (propertyKey in entity && typeof entity[propertyKey] === 'function') {
                                const call = async function (...args) {
                                    return ipc.request(propertyKey, {
                                        params: args
                                    });
                                };
                                call.transfer = function (...transfer) {
                                    return {
                                        invoke: async function (...args) {
                                            return ipc.request(propertyKey, {
                                                params: args
                                            }, transfer);
                                        }
                                    };
                                };
                                target[propertyKey] = call;
                            }
                            return target[propertyKey];
                        }
                    });
                    obj[symbolRevoke] = revoke;
                    resolve(proxy);
                }
                const handler = (message) => {
                    const origin =  false ? 0 : message.data;
                    const type = origin.type;
                    const data = origin.data;
                    switch (type) {
                        case 'ready':
                            worker.postMessage({
                                type: 'run',
                                data: {
                                    port: channel.port2
                                }
                            }, [channel.port2]);
                            break;
                        case 'running':
                            running();
                            break;
                        default:
                            break;
                    }
                };
                {
                    worker.onmessage = handler;
                }
                worker.onmessage = handler;
                worker.postMessage({
                    type: 'init',
                    data: {
                        memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory,
                        name: options.name || moduleName,
                        stackPointer,
                        stackSize: options.stackSize ?? _config__WEBPACK_IMPORTED_MODULE_4__.STACK_SIZE
                    }
                });
            });
        };
    }
    function runInMain() {
        return new Promise((resolve, reject) => {
            const obj = {
                $worker: null,
                $ipc: null,
                $channel: null,
                $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_8__["default"])(moduleId),
                $stackPointer: 0,
                $instance: entity,
                $type: 'module'
            };
            const { proxy, revoke } = Proxy.revocable(obj, {
                get(target, propertyKey, receiver) {
                    if (target[propertyKey]) {
                        return obj[propertyKey];
                    }
                    if (propertyKey in entity && typeof entity[propertyKey] === 'function') {
                        const call = function (...args) {
                            return entity[propertyKey](...args);
                        };
                        call.transfer = function (...transfer) {
                            return {
                                invoke: function (...args) {
                                    return entity[propertyKey](...args);
                                }
                            };
                        };
                        target[propertyKey] = call;
                    }
                    return target[propertyKey];
                }
            });
            obj[symbolRevoke] = revoke;
            resolve(proxy);
        });
    }
    return {
        run:  true && (_config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS && !options.disableWorker) ? runInWorker : runInMain,
    };
}
function closeThread(thread) {
    if (thread.$worker) {
        thread.$worker.terminate();
        thread.$worker = null;
    }
    if (thread.$moduleId) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.string(thread.$moduleId)) {
            const cacheKey = getCacheKey(thread.$moduleId, thread.$type);
            if (caches.has(cacheKey)) {
                caches.get(cacheKey).refCount--;
                if (caches.get(cacheKey).refCount === 0) {
                    {
                        URL.revokeObjectURL(caches.get(cacheKey).url);
                    }
                    caches.delete(cacheKey);
                }
            }
        }
        thread.$moduleId = null;
    }
    if (thread.$ipc) {
        thread.$ipc.destroy();
        thread.$ipc = null;
    }
    if (thread.$stackPointer) {
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(thread.$stackPointer);
        thread.$stackPointer = 0;
    }
    thread.$channel = null;
    thread.$instance = null;
    if (thread[symbolRevoke]) {
        const revoke = thread[symbolRevoke];
        thread[symbolRevoke] = null;
        revoke();
    }
}
async function joinThread(thread) {
    if (thread.$worker) {
        return new Promise((resolve) => {
            function handler(message) {
                const origin =  false ? 0 : message.data;
                const type = origin.type;
                const data = origin.data;
                switch (type) {
                    case 'stopped':
                        closeThread(thread);
                        resolve(data);
                        break;
                    default:
                        break;
                }
            }
            {
                thread.$worker.onmessage = handler;
            }
            thread.$worker.postMessage({
                type: 'stop'
            });
        });
    }
    else if (thread.$retval) {
        return thread.$retval;
    }
}


/***/ }),

/***/ "./src/cheap/typedef.ts":
/*!******************************!*\
  !*** ./src/cheap/typedef.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CTypeEnum2Bytes: () => (/* binding */ CTypeEnum2Bytes),
/* harmony export */   CTypeEnumPointerShiftMap: () => (/* binding */ CTypeEnumPointerShiftMap)
/* harmony export */ });
const CTypeEnum2Bytes = {
    [2 /* CTypeEnum.uint8 */]: 1,
    [3 /* CTypeEnum.atomic_uint8 */]: 1,
    [4 /* CTypeEnum.char */]: 1,
    [5 /* CTypeEnum.atomic_char */]: 1,
    [6 /* CTypeEnum.uint16 */]: 2,
    [7 /* CTypeEnum.atomic_uint16 */]: 2,
    [8 /* CTypeEnum.uint32 */]: 4,
    [9 /* CTypeEnum.atomic_uint32 */]: 4,
    [10 /* CTypeEnum.uint64 */]: 8,
    [11 /* CTypeEnum.int8 */]: 1,
    [12 /* CTypeEnum.atomic_int8 */]: 1,
    [13 /* CTypeEnum.int16 */]: 2,
    [14 /* CTypeEnum.atomic_int16 */]: 2,
    [15 /* CTypeEnum.int32 */]: 4,
    [16 /* CTypeEnum.atomic_int32 */]: 4,
    [17 /* CTypeEnum.int64 */]: 8,
    [18 /* CTypeEnum.float */]: 4,
    [19 /* CTypeEnum.double */]: 8,
    [20 /* CTypeEnum.pointer */]: 4,
    [0 /* CTypeEnum.null */]: 4,
    [1 /* CTypeEnum.void */]: 4,
    [22 /* CTypeEnum.atomic_uint64 */]: 8,
    [21 /* CTypeEnum.atomic_int64 */]: 8,
    [23 /* CTypeEnum.bool */]: 1,
    [24 /* CTypeEnum.atomic_bool */]: 1
};
const CTypeEnumPointerShiftMap = {
    [2 /* CTypeEnum.uint8 */]: 0,
    [3 /* CTypeEnum.atomic_uint8 */]: 0,
    [4 /* CTypeEnum.char */]: 0,
    [5 /* CTypeEnum.atomic_char */]: 0,
    [6 /* CTypeEnum.uint16 */]: 1,
    [7 /* CTypeEnum.atomic_uint16 */]: 1,
    [8 /* CTypeEnum.uint32 */]: 2,
    [9 /* CTypeEnum.atomic_uint32 */]: 2,
    [10 /* CTypeEnum.uint64 */]: 4,
    [11 /* CTypeEnum.int8 */]: 0,
    [12 /* CTypeEnum.atomic_int8 */]: 0,
    [13 /* CTypeEnum.int16 */]: 1,
    [14 /* CTypeEnum.atomic_int16 */]: 1,
    [15 /* CTypeEnum.int32 */]: 2,
    [16 /* CTypeEnum.atomic_int32 */]: 2,
    [17 /* CTypeEnum.int64 */]: 4,
    [18 /* CTypeEnum.float */]: 2,
    [19 /* CTypeEnum.double */]: 4,
    [20 /* CTypeEnum.pointer */]: 2,
    [1 /* CTypeEnum.void */]: 2,
    [0 /* CTypeEnum.null */]: 2,
    [22 /* CTypeEnum.atomic_uint64 */]: 4,
    [21 /* CTypeEnum.atomic_int64 */]: 4,
    [23 /* CTypeEnum.bool */]: 0,
    [24 /* CTypeEnum.atomic_bool */]: 0
};


/***/ }),

/***/ "./src/cheap/webassembly/ThreadPool.ts":
/*!*********************************************!*\
  !*** ./src/cheap/webassembly/ThreadPool.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ThreadPool)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _thread_cond_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/thread/cond */ "./src/cheap/thread/cond.ts");
/* harmony import */ var _thread__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./thread */ "./src/cheap/webassembly/thread.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _thread_atomics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../thread/atomics */ "./src/cheap/thread/atomics.ts");













class ThreadPool {
    count;
    url;
    childThreads;
    constructor(count, url) {
        this.count = count;
        this.url = url;
        this.childThreads = [];
    }
    async createTheadPoolEntry(options) {
        return new Promise((resolve, reject) => {
            const worker = new Worker(this.url);
            const stackPointer = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_7__.STACK_ALIGNMENT, _config__WEBPACK_IMPORTED_MODULE_7__.STACK_SIZE);
            const threadDescriptor = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(8);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_8__.memset)(threadDescriptor, 0, 8);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](threadDescriptor + 4, 0 /* PthreadStatus.STOP */);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](threadDescriptor, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](threadDescriptor) | 2 /* PthreadFlags.POOL */);
            const id = (0,cheap_heap__WEBPACK_IMPORTED_MODULE_0__.allocThreadId)();
            worker.onmessage = (message) => {
                const origin = message.data;
                const type = origin.type;
                switch (type) {
                    case 'ready':
                        const wait = stackPointer;
                        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_8__.memset)(wait, 0, 20);
                        _thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.init(wait + 16);
                        _thread_cond_ts__WEBPACK_IMPORTED_MODULE_5__.init(wait + 12);
                        worker.postMessage({
                            type: 'wait'
                        });
                        resolve({
                            id,
                            thread: {
                                thread: 0,
                                worker,
                                stackPointer,
                                threadDescriptor
                            },
                            threadWait: wait
                        });
                        break;
                }
            };
            worker.postMessage({
                type: 'ready',
                data: {
                    cheap: {
                        memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory,
                        stackPointer,
                        stackSize: _config__WEBPACK_IMPORTED_MODULE_7__.STACK_SIZE,
                        id
                    },
                    runner: {
                        resource: {
                            tableSize: options.tableSize,
                            module: options.module,
                            initFuncs: options.initFuncs
                        },
                        options: {
                            memoryBase: options.memoryBase,
                            tableBase: options.tableBase,
                            threadDescriptor,
                            childImports: options.childImports
                        },
                        imports: options.childImports
                    }
                }
            });
        });
    }
    async ready(options) {
        this.childThreads = await Promise.all(new Array(this.count).fill(0).map(() => {
            return this.createTheadPoolEntry(options);
        }));
    }
    hasFree() {
        for (let i = 0; i < this.childThreads.length; i++) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](this.childThreads[i].thread.threadDescriptor + 4) === 0 /* PthreadStatus.STOP */) {
                return true;
            }
        }
        return false;
    }
    isPoolThread(thread) {
        for (let i = 0; i < this.childThreads.length; i++) {
            if (this.childThreads[i].thread.thread === thread) {
                return true;
            }
        }
        return false;
    }
    createThread(thread, attr, func, args) {
        for (let i = 0; i < this.childThreads.length; i++) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](this.childThreads[i].thread.threadDescriptor + 4) === 0 /* PthreadStatus.STOP */) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](this.childThreads[i].thread.threadDescriptor + 4, 1 /* PthreadStatus.RUN */);
                this.childThreads[i].thread.thread = thread;
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](thread + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](thread + 8) | 2 /* PthreadFlags.POOL */);
                _thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.lock(this.childThreads[i].threadWait + 16);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](this.childThreads[i].threadWait, thread);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](this.childThreads[i].threadWait + 4, func);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](this.childThreads[i].threadWait + 8, args);
                _thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.unlock(this.childThreads[i].threadWait + 16);
                _thread_cond_ts__WEBPACK_IMPORTED_MODULE_5__.signal(this.childThreads[i].threadWait + 12);
                return;
            }
        }
    }
    joinThread(thread, retval) {
        let entry;
        for (let i = 0; i < this.childThreads.length; i++) {
            if (this.childThreads[i].thread.thread === thread) {
                entry = this.childThreads[i];
                break;
            }
        }
        if (!entry) {
            return -1;
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](thread + 8) & 1 /* PthreadFlags.DETACH */) {
            return 0;
        }
        // 等待子线程退出
        _thread_atomics__WEBPACK_IMPORTED_MODULE_9__.wait(thread + 12, 1 /* PthreadStatus.RUN */);
        if (retval !== 0) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](retval, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](thread + 4));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](entry.thread.threadDescriptor + 4, 0 /* PthreadStatus.STOP */);
        return 0;
    }
    detachThread(thread) {
        let entry;
        for (let i = 0; i < this.childThreads.length; i++) {
            if (this.childThreads[i].thread.thread === thread) {
                entry = this.childThreads[i];
                break;
            }
        }
        if (!entry) {
            return -1;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](entry.thread.threadDescriptor, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](entry.thread.threadDescriptor) | 1 /* PthreadFlags.DETACH */);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](thread + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](thread + 8) | 1 /* PthreadFlags.DETACH */);
        return 0;
    }
    destroy() {
        for (let i = 0; i < this.childThreads.length; i++) {
            // 回收栈
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.childThreads[i].thread.stackPointer);
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.childThreads[i].thread.threadDescriptor);
            this.childThreads[i].thread.worker.terminate();
        }
        this.childThreads = [];
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/WebAssemblyRunner.ts":
/*!****************************************************!*\
  !*** ./src/cheap/webassembly/WebAssemblyRunner.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebAssemblyRunner)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../heap */ "./src/cheap/heap.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _std_memory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _runtime_clib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./runtime/clib */ "./src/cheap/webassembly/runtime/clib.ts");
/* harmony import */ var _runtime_atomic__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./runtime/atomic */ "./src/cheap/webassembly/runtime/atomic.ts");
/* harmony import */ var _runtime_pthread__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./runtime/pthread */ "./src/cheap/webassembly/runtime/pthread.ts");
/* harmony import */ var _runtime_semaphore__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./runtime/semaphore */ "./src/cheap/webassembly/runtime/semaphore.ts");
/* harmony import */ var common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/function/sourceLoad */ "./src/common/function/sourceLoad.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");
/* harmony import */ var _thread_atomics__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../thread/asm/atomics */ "./src/cheap/thread/asm/atomics.ts");
/* harmony import */ var _runtime_asm_libc__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./runtime/asm/libc */ "./src/cheap/webassembly/runtime/asm/libc.ts");
/* harmony import */ var _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./runtime/asm/thread */ "./src/cheap/webassembly/runtime/asm/thread.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var _thread__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./thread */ "./src/cheap/webassembly/thread.ts");
/* harmony import */ var _ThreadPool__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./ThreadPool */ "./src/cheap/webassembly/ThreadPool.ts");
/* harmony import */ var cheap_thread_cond__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! cheap/thread/cond */ "./src/cheap/thread/cond.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
var cheap__fileName__3 = "src\\cheap\\webassembly\\WebAssemblyRunner.ts";



/* eslint-disable camelcase */























{
    // 保证打包工具包含下面的模块代码
    __webpack_require__(/*! ./runThread */ "./src/cheap/webassembly/runThread.ts");
}
const runThread =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_12__["default"])(/*require.resolve*/(/*! ./runThread */ "./src/cheap/webassembly/runThread.ts"), {
    varName: 'init'
}) : 0;
function emptyFunction() { }
let atomicAsmOverride = false;
class WebAssemblyRunner {
    static getTable() {
        return cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Table;
    }
    static mutexLock(mux) {
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_22__.lock(mux);
    }
    static mutexUnlock(mux) {
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_22__.unlock(mux);
    }
    static condWait(cnd, mux) {
        cheap_thread_cond__WEBPACK_IMPORTED_MODULE_21__.wait(cnd, mux);
    }
    static readPointer(p) {
        return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](p);
    }
    static writePointer(p, v) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](p, v);
    }
    resource;
    /**
     * WebAssembly runtime 实例
     */
    instance;
    /**
     * 配置项
     */
    options;
    builtinMalloc;
    memoryBase;
    tableBase;
    childImports;
    childUrl;
    childBlob;
    childThreads;
    imports;
    childReadyPromises;
    threadPool;
    initCalling;
    promisingMap;
    constructor(resource, options = {}) {
        this.resource = resource;
        this.builtinMalloc = [];
        this.initCalling = false;
        this.childThreads = new Map();
        this.childReadyPromises = [];
        this.promisingMap = new Map();
        if (common_util_is__WEBPACK_IMPORTED_MODULE_6__.string(options.childImports)) {
            this.childImports = options.childImports;
        }
        else if (common_util_is__WEBPACK_IMPORTED_MODULE_6__.object(options.childImports) && options.childImports instanceof Blob) {
            this.childImports = URL.createObjectURL(options.childImports);
        }
        this.memoryBase = resource.dataSize ? cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc(resource.dataSize) : 0;
        // 子线程的 tableBase 需要和父线程一致
        if (options.thread && options.tableBase) {
            if (cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Table.getPointer() !== options.tableBase) {
                cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Table.alloc(options.tableBase - cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Table.getPointer());
            }
        }
        this.tableBase = resource.tableSize ? cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Table.alloc(resource.tableSize) : 0;
        this.options = options;
        this.imports = {
            env: {
                memory: cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Memory,
                __stack_pointer: cheap_heap__WEBPACK_IMPORTED_MODULE_2__.StackPointer,
                __indirect_function_table: cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Table.table,
                clock_time_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.clock_time_get,
                clock_res_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.clock_res_get,
                random_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.random_get,
                abort: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.abort,
                proc_exit: function (exitCode) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`wasm module exit, code: ${exitCode}`, cheap__fileName__3, 156);
                },
                __syscall_renameat: emptyFunction,
                __syscall_unlinkat: emptyFunction,
                environ_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.environ_get,
                environ_sizes_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.environ_sizes_get,
                fd_close: emptyFunction,
                fd_fdstat_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.fd_fdstat_get,
                fd_read: emptyFunction,
                fd_seek: emptyFunction,
                fd_write: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.fd_write,
                emscripten_builtin_malloc: (size) => {
                    const p = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc(size);
                    this.builtinMalloc.push(p);
                    return p;
                },
                emscripten_builtin_free: (pointer) => {
                    cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(pointer);
                },
                emscripten_builtin_memalign: (memptr, alignment, size) => {
                    const address = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.alignedAlloc(alignment, size);
                    if (address !== 0) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](memptr, address);
                        this.builtinMalloc.push(address);
                        return 0;
                    }
                    return -1;
                },
                emscripten_memcpy_big: function (dest, src, num) {
                    (0,_std_memory__WEBPACK_IMPORTED_MODULE_7__.memcpy)(dest, src, num);
                },
                __libc_malloc: function (size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc(size);
                },
                __libc_free: (pointer) => {
                    cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(pointer);
                },
                malloc: (size) => {
                    if (this.initCalling === true) {
                        const p = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc(size);
                        this.builtinMalloc.push(p);
                        return p;
                    }
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc(size);
                },
                calloc: function (num, size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.calloc(num, size);
                },
                realloc: function (pointer, size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.realloc(pointer, size);
                },
                aligned_alloc(alignment, size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.alignedAlloc(alignment, size);
                },
                free: function (pointer) {
                    cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(pointer);
                },
                posix_memalign: function (memptr, alignment, size) {
                    const address = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.alignedAlloc(alignment, size);
                    if (address !== 0) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](memptr, address);
                        return 0;
                    }
                    return -1;
                },
                memalign: function (alignment, size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.alignedAlloc(alignment, size);
                }
            },
            'GOT.func': {
                malloc: new WebAssembly.Global({ mutable: true, value: 'i32' }, 2 /* BuiltinTableSlot.MALLOC */),
                calloc: new WebAssembly.Global({ mutable: true, value: 'i32' }, 3 /* BuiltinTableSlot.CALLOC */),
                realloc: new WebAssembly.Global({ mutable: true, value: 'i32' }, 4 /* BuiltinTableSlot.REALLOC */),
                aligned_alloc: new WebAssembly.Global({ mutable: true, value: 'i32' }, 5 /* BuiltinTableSlot.ALIGNED_ALLOC */),
                free: new WebAssembly.Global({ mutable: true, value: 'i32' }, 1 /* BuiltinTableSlot.FREE */)
            }
        };
        {
            const createPthread = (thread, attr, func, args) => {
                if (this.threadPool && this.threadPool.hasFree()) {
                    this.threadPool.createThread(thread, attr, func, args);
                    return 0;
                }
                if (!this.childUrl) {
                    this.createChildUrl();
                }
                const worker = new Worker(this.childUrl);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](thread, (0,cheap_heap__WEBPACK_IMPORTED_MODULE_2__.allocThreadId)());
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[16](thread + 12, 1 /* PthreadStatus.RUN */);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](thread + 8, 0);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](thread + 4, 0);
                const stackPointer = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_13__.STACK_ALIGNMENT, _config__WEBPACK_IMPORTED_MODULE_13__.STACK_SIZE);
                const threadDescriptor = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc(8);
                (0,_std_memory__WEBPACK_IMPORTED_MODULE_7__.memset)(threadDescriptor, 0, 8);
                this.childThreads.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread), {
                    thread,
                    worker,
                    stackPointer,
                    threadDescriptor
                });
                let resolve;
                const promise = new Promise((r) => {
                    resolve = r;
                });
                if (!common_util_support__WEBPACK_IMPORTED_MODULE_23__["default"].jspi) {
                    this.childReadyPromises.push(promise);
                }
                worker.onmessage = (message) => {
                    const origin = message.data;
                    const type = origin.type;
                    const data = origin.data;
                    switch (type) {
                        case 'run':
                            resolve(0);
                            break;
                    }
                };
                /**
                 * postMessage 并不是同步的，而是在事件循环中处理的
                 * 因此父线程不能被阻塞在当前的事件循环中，否则子线程无法成功运行
                 * 只有 childReadyPromises 中的 Promise 都 resolve 了之后才能阻塞
                 */
                worker.postMessage({
                    type: 'run',
                    data: {
                        cheap: {
                            memory: cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Memory,
                            stackPointer,
                            stackSize: _config__WEBPACK_IMPORTED_MODULE_13__.STACK_SIZE,
                            id: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread)
                        },
                        runner: {
                            resource: {
                                tableSize: this.resource.tableSize,
                                module: this.resource.threadModule.module,
                                initFuncs: this.resource.threadModule.initFuncs
                            },
                            options: {
                                memoryBase: this.options.memoryBase || this.memoryBase,
                                tableBase: this.tableBase,
                                thread,
                                threadDescriptor,
                                childImports: this.childImports
                            },
                            func,
                            args,
                            imports: this.childImports,
                            thread
                        }
                    }
                });
                return common_util_support__WEBPACK_IMPORTED_MODULE_23__["default"].jspi ? promise : 0;
            };
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, {
                // @ts-ignore
                wasm_pthread_create: common_util_support__WEBPACK_IMPORTED_MODULE_23__["default"].jspi ? new WebAssembly.Suspending(createPthread) : createPthread,
                wasm_pthread_join2: (thread, retval) => {
                    if (this.threadPool && this.threadPool.isPoolThread(thread)) {
                        this.threadPool.joinThread(thread, retval);
                        return 0;
                    }
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread + 8) & 1 /* PthreadFlags.DETACH */) {
                        this.childThreads.delete(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread));
                        return 0;
                    }
                    // 等待子线程退出
                    _thread_atomics__WEBPACK_IMPORTED_MODULE_14__.wait(thread + 12, 1 /* PthreadStatus.RUN */);
                    if (retval !== 0) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](retval, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](thread + 4));
                    }
                    const child = this.childThreads.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread));
                    // 回收栈
                    cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(child.stackPointer);
                    cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(child.threadDescriptor);
                    child.worker.terminate();
                    this.childThreads.delete(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread));
                    (0,_std_memory__WEBPACK_IMPORTED_MODULE_7__.memset)(thread, 0, 16);
                    return 0;
                },
                wasm_pthread_detach2: (thread) => {
                    if (this.threadPool && this.threadPool.isPoolThread(thread)) {
                        this.threadPool.detachThread(thread);
                        return 0;
                    }
                    const child = this.childThreads.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread));
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](child.threadDescriptor, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](child.threadDescriptor) | 1 /* PthreadFlags.DETACH */);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](thread + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread + 8) | 1 /* PthreadFlags.DETACH */);
                }
            });
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, _runtime_atomic__WEBPACK_IMPORTED_MODULE_9__);
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, _runtime_pthread__WEBPACK_IMPORTED_MODULE_10__);
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, _runtime_semaphore__WEBPACK_IMPORTED_MODULE_11__);
        }
        if (this.memoryBase) {
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, {
                __memory_base: this.memoryBase
            });
        }
        // 使用父线程的 memoryBase
        else if (options.memoryBase) {
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, {
                __memory_base: options.memoryBase
            });
        }
        if (this.tableBase) {
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, {
                __table_base: this.tableBase
            });
        }
        if (options.imports?.env) {
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, options.imports.env);
            if (options.envKey && options.importMap) {
                const env = {};
                common_util_object__WEBPACK_IMPORTED_MODULE_3__.each(this.imports.env, (value, key) => {
                    if (options.importMap[key]) {
                        env[options.importMap[key]] = value;
                    }
                });
                this.imports[options.envKey] = env;
            }
        }
        this.imports['wasi_snapshot_preview1'] = this.imports.env;
    }
    createChildUrl() {
        const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_12__["default"])(/*require.resolve*/(/*! ./WebAssemblyRunner.ts */ "./src/cheap/webassembly/WebAssemblyRunner.ts"), {
            varName: '__WebAssemblyRunner__',
            exportName: '__WebAssemblyRunner__',
            pointName: WebAssemblyRunner.name,
            exportIsClass: true
        });
        const source = `
      ${module}
      ${runThread}
      var preRun;
      ${this.childImports ? `
      preRun = import('${this.childImports}')
      ` : ''}
      init.default(preRun);
    `;
        this.childBlob = new Blob([source], { type: 'text/javascript' });
        this.childUrl = URL.createObjectURL(this.childBlob);
    }
    overrideAtomic() {
        _runtime_atomic__WEBPACK_IMPORTED_MODULE_9__.override({
            atomic_add_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.add8,
            atomic_sub_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.sub8,
            atomic_and_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.and8,
            atomic_or_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.or8,
            atomic_xor_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.xor8,
            atomic_store_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.store8,
            atomic_load_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.load8,
            atomic_compare_exchange_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.compare_exchange8,
            atomic_exchange_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.exchange8,
            atomic_add_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.add16,
            atomic_sub_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.sub16,
            atomic_and_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.and16,
            atomic_or_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.or16,
            atomic_xor_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.xor16,
            atomic_store_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.store16,
            atomic_load_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.load16,
            atomic_compare_exchange_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.compare_exchange16,
            atomic_exchange_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.exchange16,
            atomic_add_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.add32,
            atomic_sub_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.sub32,
            atomic_and_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.and32,
            atomic_or_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.or32,
            atomic_xor_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.xor32,
            atomic_store_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.store32,
            atomic_load_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.load32,
            atomic_compare_exchange_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.compare_exchange32,
            atomic_exchange_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.exchange32,
            atomic_add_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.add64,
            atomic_sub_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.sub64,
            atomic_and_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.and64,
            atomic_or_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.or64,
            atomic_xor_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.xor64,
            atomic_store_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.store64,
            atomic_load_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.load64,
            atomic_compare_exchange_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.compare_exchange64,
            atomic_exchange_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.exchange64,
            atomics_notify: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.notify,
            atomics_wait: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.wait
        });
        common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, _runtime_atomic__WEBPACK_IMPORTED_MODULE_9__);
    }
    /**
     * 运行 wasm 实例
     */
    async run(imports, threadPoolCount) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_6__.object(imports)) {
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.options.imports, imports);
        }
        if ( true
            && (0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_18__["default"])()
            && !_runtime_asm_thread__WEBPACK_IMPORTED_MODULE_17__.wasmThreadProxy
            && _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_17__.isSupport()
            && this.resource.threadModule) {
            await _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_17__.init(cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Memory, _runtime_pthread__WEBPACK_IMPORTED_MODULE_10__.override);
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, _runtime_pthread__WEBPACK_IMPORTED_MODULE_10__);
        }
        if (!_runtime_asm_libc__WEBPACK_IMPORTED_MODULE_16__.wasmThreadProxy
            && _runtime_asm_libc__WEBPACK_IMPORTED_MODULE_16__.isSupport()) {
            await _runtime_asm_libc__WEBPACK_IMPORTED_MODULE_16__.init(cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Memory);
        }
        if (!atomicAsmOverride && _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.isSupport()) {
            atomicAsmOverride = true;
            this.overrideAtomic();
        }
        this.instance = await WebAssembly.instantiate(this.resource.module, this.imports);
        this.initRunTime();
        if ( true && this.resource.threadModule
            && this.resource.enableThreadPool
            && threadPoolCount > 0
            && !common_util_support__WEBPACK_IMPORTED_MODULE_23__["default"].jspi) {
            if (!this.childUrl) {
                this.createChildUrl();
            }
            let count = threadPoolCount;
            if (this.resource.enableThreadCountRate) {
                count *= this.resource.enableThreadCountRate;
            }
            this.threadPool = new _ThreadPool__WEBPACK_IMPORTED_MODULE_20__["default"](count, this.childUrl);
            await this.threadPool.ready({
                tableSize: this.resource.tableSize,
                module: this.resource.threadModule.module,
                initFuncs: this.resource.threadModule.initFuncs,
                memoryBase: this.options.memoryBase || this.memoryBase,
                tableBase: this.tableBase,
                childImports: this.childImports
            });
        }
    }
    async runAsChild(imports) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_6__.object(imports)) {
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.options.imports, imports);
        }
        if ( true && !_runtime_asm_thread__WEBPACK_IMPORTED_MODULE_17__.wasmThreadProxy && _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_17__.isSupport()) {
            await _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_17__.init(cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Memory, _runtime_pthread__WEBPACK_IMPORTED_MODULE_10__.override);
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, _runtime_pthread__WEBPACK_IMPORTED_MODULE_10__);
        }
        if (!atomicAsmOverride && _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.isSupport()) {
            atomicAsmOverride = true;
            this.overrideAtomic();
        }
        this.instance = new WebAssembly.Instance(this.resource.module, this.imports);
        this.initRunTime();
    }
    async childrenThreadReady() {
        if (!this.childReadyPromises.length) {
            return;
        }
        const promise = this.childReadyPromises;
        this.childReadyPromises = [];
        await Promise.all(promise);
    }
    initRunTime() {
        this.builtinMalloc = [];
        this.initCalling = true;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_6__.array(this.resource.initFuncs)) {
            common_util_array__WEBPACK_IMPORTED_MODULE_4__.each(this.resource.initFuncs, (func) => {
                let call;
                if (this.asm[func]) {
                    call = this.asm[func];
                }
                if (call) {
                    return call();
                }
            });
        }
        this.initCalling = false;
    }
    /**
     * 调用 wasm 模块暴露的方法
     *
     * @param func 方法名
     * @param args 参数，只能是 number 和 bigint( 有浏览器版本要求， 建议 64 位数据使用指针传递） 类型，如果是其他类型参数使用指针传递
     */
    call(func, ...args) {
        if (!this.asm) {
            return -1;
        }
        let call;
        if (this.asm[func]) {
            call = this.asm[func];
        }
        else if (this.options.exportMap && this.options.exportMap[func] && this.asm[this.options.exportMap[func]]) {
            call = this.asm[this.options.exportMap[func]];
        }
        if (call) {
            return call.apply(null, args);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`the wasm module has not function ${func} to call`, cheap__fileName__3, 597);
        }
    }
    /**
     * 异步调用 wasm 模块暴露的方法
     *
     * 适用于 wasm 内部会调用异步 js 函数的情况
     *
     * 需要支持 JSPI
     *
     * @param func 方法名
     * @param args 参数，只能是 number 和 bigint( 有浏览器版本要求， 建议 64 位数据使用指针传递） 类型，如果是其他类型参数使用指针传递
     */
    async callAsync(func, ...args) {
        if (!this.asm) {
            return -1;
        }
        if (!common_util_support__WEBPACK_IMPORTED_MODULE_23__["default"].jspi) {
            return this.call(func, ...args);
        }
        let call;
        if (this.promisingMap.has(func)) {
            call = this.promisingMap.get(func);
        }
        else {
            if (this.asm[func]) {
                call = this.asm[func];
            }
            else if (this.options.exportMap && this.options.exportMap[func] && this.asm[this.options.exportMap[func]]) {
                call = this.asm[this.options.exportMap[func]];
            }
            // @ts-ignore
            call = WebAssembly.promising(call);
            this.promisingMap.set(func, call);
        }
        if (call) {
            return call.apply(null, args);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`the wasm module has not function ${func} to call`, cheap__fileName__3, 639);
        }
    }
    get asm() {
        return this.instance && this.instance.exports;
    }
    getInstance() {
        return this.instance;
    }
    destroy() {
        if (this.builtinMalloc?.length) {
            common_util_array__WEBPACK_IMPORTED_MODULE_4__.each(this.builtinMalloc, (pointer) => {
                cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(pointer);
            });
            this.builtinMalloc.length = 0;
        }
        if (this.memoryBase) {
            cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(this.memoryBase);
            this.memoryBase = null;
        }
        if (this.tableBase) {
            cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Table.free(this.tableBase);
            this.tableBase = null;
        }
        if (this.childImports) {
            URL.revokeObjectURL(this.childImports);
            this.childImports = null;
        }
        if (this.childUrl) {
            URL.revokeObjectURL(this.childUrl);
            this.childUrl = null;
        }
        this.childBlob = null;
        this.childReadyPromises.length = 0;
        if (this.childThreads.size) {
            this.childThreads.forEach((thread, id) => {
                if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread.threadDescriptor) & 1 /* PthreadFlags.DETACH */)) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_5__.warn('has child thread running, maybe resource leakage', cheap__fileName__3, 684);
                    thread.worker.terminate();
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[16](thread.thread + 12, 0 /* PthreadStatus.STOP */);
                    if (thread.stackPointer) {
                        cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(thread.stackPointer);
                    }
                    cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(thread.threadDescriptor);
                    this.childThreads.delete(id);
                }
            });
        }
        this.builtinMalloc = null;
        this.instance = null;
        if (this.options.thread) {
            if (this.options.threadDescriptor) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.threadDescriptor + 4, 0 /* PthreadStatus.STOP */);
            }
            if (this.options.threadDescriptor
                && ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.threadDescriptor) & 1 /* PthreadFlags.DETACH */)
                    || (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.thread + 8) & 4 /* PthreadFlags.EXIT */))) {
                if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.threadDescriptor) & 2 /* PthreadFlags.POOL */)) {
                    if (cheap_heap__WEBPACK_IMPORTED_MODULE_2__.StackTop) {
                        cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(cheap_heap__WEBPACK_IMPORTED_MODULE_2__.StackTop);
                    }
                    cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(this.options.threadDescriptor);
                    (0,_std_memory__WEBPACK_IMPORTED_MODULE_7__.memset)(this.options.thread, 0, 16);
                    self.close();
                }
            }
            else {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[16](this.options.thread + 12, 0 /* PthreadStatus.STOP */
                // 唤醒父线程收回资源
                );
                // 唤醒父线程收回资源
                _thread_atomics__WEBPACK_IMPORTED_MODULE_14__.notify(this.options.thread + 12, 1);
            }
        }
        {
            if (this.threadPool) {
                this.threadPool.destroy();
            }
            this.threadPool = null;
        }
        if (this.promisingMap) {
            this.promisingMap.clear();
            this.promisingMap = null;
        }
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/compiler.ts":
/*!*******************************************!*\
  !*** ./src/cheap/webassembly/compiler.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ compile)
/* harmony export */ });
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_io_IOReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/IOReader */ "./src/common/io/IOReader.ts");
/* harmony import */ var common_io_IOWriter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/io/IOWriter */ "./src/common/io/IOWriter.ts");
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
/* harmony import */ var common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/function/concatTypeArray */ "./src/common/function/concatTypeArray.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");







async function process(context) {
    try {
        // `\0asm`
        await context.ioWriter.writeUint32(await context.ioReader.readUint32());
        // Version
        await context.ioWriter.writeUint32(await context.ioReader.readUint32());
        while (true) {
            if (context.compileStopped) {
                if (context.abortController) {
                    context.abortController.abort();
                }
                break;
            }
            const sectionId = await context.ioReader.readUint8();
            if (context.options.child) {
                if (sectionId === 11 /* SectionId.Data */) {
                    await context.ioWriter.writeUint8(sectionId);
                    // size
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, 7);
                    // count
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, 1);
                    // index
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, 0);
                    // init_expr i32_const 0
                    await context.ioWriter.writeUint8(0x41);
                    await context.ioWriter.writeUint8(0x00);
                    await context.ioWriter.writeUint8(0x0b);
                    // size
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, 1);
                    await context.ioWriter.writeUint8(0x00);
                    const size = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                    await context.ioReader.skip(size);
                    continue;
                }
            }
            await context.ioWriter.writeUint8(sectionId);
            const size = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, size);
            const now = context.ioReader.getPos();
            if (sectionId === 11 /* SectionId.Data */) {
                /**
                 * - count: varuint32
                 * - entries: data_segment*
                 *   - index varuint32 the linear memory index (0 in the MVP)
                 *   - offset init_expr
                 *   - size varuint32
                 *   - data bytes
                 */
                const count = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, count);
                if (count) {
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader));
                    while (true) {
                        const byte = await context.ioReader.readUint8();
                        await context.ioWriter.writeUint8(byte);
                        if (byte === 0x0b) {
                            break;
                        }
                    }
                    context.data.dataSize = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, context.data.dataSize);
                }
            }
            else if (sectionId === 2 /* SectionId.Import */) {
                /**
                 * - count: varuint32
                 * - entries: import_entry*
                 *   - module_len varuint32
                 *   - module_str bytes
                 *   - field_len varuint32
                 *   - field_str bytes
                 *   - external_kind
                 */
                let count = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, count);
                let counter = 0;
                while (count--) {
                    const moduleLen = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, moduleLen);
                    await context.ioWriter.writeBuffer(await context.ioReader.readBuffer(moduleLen));
                    const fieldLen = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, fieldLen);
                    await context.ioWriter.writeBuffer(await context.ioReader.readBuffer(fieldLen));
                    const externalKind = await context.ioReader.readUint8();
                    await context.ioWriter.writeUint8(externalKind);
                    switch (externalKind) {
                        case 0 /* ExternalKind.Function */: {
                            // type index of the function signature
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader));
                            break;
                        }
                        case 3 /* ExternalKind.Global */: {
                            // content_type
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeSleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readSLeb128Async)(context.ioReader));
                            // mutability
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader));
                            break;
                        }
                        case 2 /* ExternalKind.Memory */: {
                            let flags = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                            if (context.options.enableThread) {
                                flags |= 2;
                            }
                            else {
                                flags &= ~2;
                            }
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, flags);
                            // initial
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader));
                            if (flags & 0x01) {
                                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                                // maximum
                                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, _config__WEBPACK_IMPORTED_MODULE_6__.HEAP_MAXIMUM);
                            }
                            counter++;
                            break;
                        }
                        case 1 /* ExternalKind.Table */: {
                            // elem_type
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeSleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readSLeb128Async)(context.ioReader));
                            const flags = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, flags);
                            const initial = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, initial);
                            context.data.tableSize = initial;
                            if (flags & 0x01) {
                                // maximum
                                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader));
                            }
                            counter++;
                            break;
                        }
                    }
                    if (counter === 2) {
                        break;
                    }
                }
            }
            const remainingLength = size - Number(context.ioReader.getPos() - now);
            if (remainingLength) {
                await context.ioReader.pipe(context.ioWriter, size - Number(context.ioReader.getPos() - now));
            }
        }
    }
    catch (e) {
        if (context.ioReader.error === -1048576 /* IOError.END */) {
            context.bufferEnded = true;
        }
        else {
            context.error = e;
        }
        if (context.ioReader.remainingLength()) {
            await context.ioWriter.writeBuffer(await context.ioReader.readBuffer(context.ioReader.remainingLength()));
        }
        await context.ioWriter.flush();
    }
}
async function compile(source, options = {}) {
    let module;
    let tableSize;
    let dataSize;
    let buffer;
    options = common_util_object__WEBPACK_IMPORTED_MODULE_5__.extend({
        enableThread: _config__WEBPACK_IMPORTED_MODULE_6__.USE_THREADS,
        initFuncs: options.child ? [] : ['__wasm_apply_data_relocs', '_initialize']
    }, options);
    if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.number(source.dataSize) && common_util_is__WEBPACK_IMPORTED_MODULE_0__.number(source.tableSize)) {
        tableSize = source.dataSize;
        dataSize = source.dataSize;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.string(source.source)) {
            const params = {
                method: 'GET',
                headers: {},
                mode: 'cors',
                cache: 'default',
                referrerPolicy: 'no-referrer-when-downgrade'
            };
            if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.func(WebAssembly.compileStreaming)) {
                module = await WebAssembly.compileStreaming(fetch(source.source, params));
            }
            else {
                const response = await fetch(source.source, params);
                buffer = await response.arrayBuffer();
                module = await WebAssembly.compile(buffer);
            }
        }
        else {
            module = await WebAssembly.compile(source.source);
            buffer = common_util_is__WEBPACK_IMPORTED_MODULE_0__.arrayBuffer(source.source) ? source.source : source.source.buffer;
        }
    }
    else {
        const context = {
            ioReader: new common_io_IOReader__WEBPACK_IMPORTED_MODULE_1__["default"](1048576),
            ioWriter: new common_io_IOWriter__WEBPACK_IMPORTED_MODULE_2__["default"](1048576),
            bufferEnded: false,
            compileStopped: false,
            error: '',
            abortController: null,
            pullResolve: null,
            bufferResolve: null,
            buffers: [],
            data: {},
            options
        };
        const response = new Response(new ReadableStream({
            async start(controller) {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.string(source.source)) {
                    if (AbortController) {
                        context.abortController = new AbortController();
                    }
                    const params = {
                        method: 'GET',
                        headers: {},
                        mode: 'cors',
                        cache: 'default',
                        referrerPolicy: 'no-referrer-when-downgrade',
                        signal: context.abortController?.signal
                    };
                    const res = await fetch(source.source, params);
                    let reader;
                    if (res.ok && (res.status >= 200 && res.status <= 299)) {
                        reader = res.body.getReader();
                    }
                    else {
                        controller.error(`Http code invalid, ${res.status} ${res.statusText}`);
                    }
                    const buffers = [];
                    context.ioReader.onFlush = async (buffer) => {
                        let pos = 0;
                        while (buffers.length && pos < buffer.length) {
                            const cache = buffers.shift();
                            if (cache.length > buffer.length - pos) {
                                buffer.set(cache.subarray(0, buffer.length - pos), pos);
                                buffers.unshift(cache.subarray(buffer.length - pos));
                                pos = buffer.length;
                            }
                            else {
                                buffer.set(cache, pos);
                                pos += cache.length;
                            }
                        }
                        if (pos >= buffer.length) {
                            return buffer.length;
                        }
                        const { value, done } = await reader.read();
                        if (done) {
                            return pos > 0 ? pos : -1048576 /* IOError.END */;
                        }
                        else {
                            context.buffers.push(value);
                            if (value.length > buffer.length - pos) {
                                buffer.set(value.subarray(0, buffer.length - pos), pos);
                                buffers.push(value.subarray(buffer.length - pos));
                                return buffer.length;
                            }
                            else {
                                buffer.set(value, pos);
                                pos += value.length;
                                return pos;
                            }
                        }
                    };
                }
                else {
                    let readPos = 0;
                    let readFileLength = source.source.byteLength;
                    const wasm = common_util_is__WEBPACK_IMPORTED_MODULE_0__.arrayBuffer(source.source) ? new Uint8Array(source.source) : source.source;
                    context.ioReader.onFlush = async (buffer) => {
                        if (readPos >= readFileLength) {
                            return -1048576 /* IOError.END */;
                        }
                        const len = Math.min(buffer.length, readFileLength - readPos);
                        buffer.set(wasm.subarray(readPos, readPos + len), 0);
                        readPos += len;
                        return len;
                    };
                }
                context.ioWriter.onFlush = async (buffer) => {
                    if (context.pullResolve) {
                        context.pullResolve(buffer.slice());
                        context.pullResolve = null;
                        return 0;
                    }
                    (await new Promise((resolve, reject) => {
                        context.bufferResolve = resolve;
                    })).enqueue(buffer.slice());
                    return 0;
                };
                process(context);
            },
            async pull(controller) {
                if (context.error) {
                    controller.close();
                    return;
                }
                if (context.bufferResolve) {
                    context.bufferResolve(controller);
                    context.bufferResolve = null;
                    return;
                }
                controller.enqueue(await new Promise((resolve, reject) => {
                    context.pullResolve = resolve;
                }));
                if (context.bufferEnded) {
                    controller.close();
                }
                else if (context.error) {
                    controller.error(context.error);
                }
            },
            cancel(reason) {
                context.compileStopped = true;
            }
        }), {
            headers: {
                'Content-Type': 'application/wasm'
            }
        });
        if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.func(WebAssembly.compileStreaming)) {
            module = await WebAssembly.compileStreaming(response);
        }
        else {
            module = await WebAssembly.compile(await response.arrayBuffer());
        }
        buffer = common_util_is__WEBPACK_IMPORTED_MODULE_0__.string(source.source)
            ? (0,common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_4__["default"])(Uint8Array, context.buffers).buffer
            : (common_util_is__WEBPACK_IMPORTED_MODULE_0__.arrayBuffer(source.source) ? source.source : source.source.buffer);
        tableSize = context.data.tableSize;
        dataSize = context.data.dataSize;
    }
    if (options.child) {
        return {
            module,
            initFuncs: options.initFuncs || []
        };
    }
    return {
        module,
        tableSize,
        dataSize,
        initFuncs: options.initFuncs || [],
        buffer: buffer
    };
}


/***/ }),

/***/ "./src/cheap/webassembly/runThread.ts":
/*!********************************************!*\
  !*** ./src/cheap/webassembly/runThread.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var _thread_mutex_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./..\thread\mutex.ts */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _thread_cond_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./..\thread\cond.ts */ "./src/cheap/thread/cond.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");





// @ts-ignore
common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.imports = {
    env: {}
};
let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF;
let runner;
let runnerData;
let waitData = 0;
function init(preRun) {
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        switch (type) {
            case 'run': {
                parentPort.postMessage({
                    type: 'run'
                });
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.initThread) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.initThread(data.cheap).then(() => {
                        function run() {
                            common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.__SELF_THREAD__ = data.runner.thread;
                            // @ts-ignore
                            data.runner.options.imports = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.imports;
                            // @ts-ignore
                            runner = new __WebAssemblyRunner__.__WebAssemblyRunner__(data.runner.resource, data.runner.options);
                            runner.runAsChild().then(() => {
                                // @ts-ignore
                                __WebAssemblyRunner__.__WebAssemblyRunner__.getTable().get(data.runner.func)(data.runner.args);
                                runner.destroy();
                            });
                        }
                        if (preRun) {
                            preRun.then(() => {
                                run();
                            });
                        }
                        else {
                            run();
                        }
                    });
                }
                break;
            }
            case 'ready': {
                runnerData = data.runner;
                waitData = data.cheap.stackPointer;
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.initThread) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.initThread(data.cheap).then(() => {
                        if (preRun) {
                            preRun.then(() => {
                                parentPort.postMessage({
                                    type: 'ready'
                                });
                            });
                        }
                        else {
                            parentPort.postMessage({
                                type: 'ready'
                            });
                        }
                    });
                }
                break;
            }
            case 'wait': {
                async function run() {
                    while (true) {
                        // @ts-ignore
                        __WebAssemblyRunner__.__WebAssemblyRunner__.mutexLock(waitData + 16);
                        // @ts-ignore
                        while (__WebAssemblyRunner__.__WebAssemblyRunner__.readPointer(waitData) === 0) {
                            // @ts-ignore
                            __WebAssemblyRunner__.__WebAssemblyRunner__.condWait(waitData + 12, waitData + 16);
                        }
                        // @ts-ignore
                        common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.__SELF_THREAD__ = __WebAssemblyRunner__.__WebAssemblyRunner__.readPointer(waitData), runnerData.options.thread = __WebAssemblyRunner__.__WebAssemblyRunner__.readPointer(waitData), runnerData.thread = __WebAssemblyRunner__.__WebAssemblyRunner__.readPointer(waitData);
                        // @ts-ignore
                        runnerData.func = __WebAssemblyRunner__.__WebAssemblyRunner__.readPointer(waitData + 4);
                        // @ts-ignore
                        runnerData.args = __WebAssemblyRunner__.__WebAssemblyRunner__.readPointer(waitData + 8);
                        // @ts-ignore
                        runner = new __WebAssemblyRunner__.__WebAssemblyRunner__(runnerData.resource, runnerData.options);
                        await runner.runAsChild();
                        // @ts-ignore
                        __WebAssemblyRunner__.__WebAssemblyRunner__.getTable().get(runnerData.func)(runnerData.args);
                        runner.destroy();
                        // @ts-ignore
                        __WebAssemblyRunner__.__WebAssemblyRunner__.writePointer(waitData, 0);
                        // @ts-ignore
                        __WebAssemblyRunner__.__WebAssemblyRunner__.mutexUnlock(waitData + 16);
                    }
                }
                // @ts-ignore
                runnerData.options.imports = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.imports;
                run();
                break;
            }
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/asm/libc.ts":
/*!***************************************************!*\
  !*** ./src/cheap/webassembly/runtime/asm/libc.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   isSupport: () => (/* binding */ isSupport),
/* harmony export */   wasmThreadProxy: () => (/* binding */ wasmThreadProxy)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../heap */ "./src/cheap/heap.ts");
/* harmony import */ var common_util_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/base64 */ "./src/common/util/base64.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _libc_asm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libc.asm */ "./src/cheap/webassembly/runtime/asm/libc.asm");
/* harmony import */ var _libc_asm__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_libc_asm__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
var cheap__fileName__5 = "src\\cheap\\webassembly\\runtime\\asm\\libc.ts";

/* eslint-disable camelcase */





/**
 * WebAssembly runtime 实例
 */
let wasmThreadProxy;
let support = true;
function isSupport() {
    return support;
}
async function init(memory) {
    try {
        if (typeof SharedArrayBuffer === 'function' && memory.buffer instanceof SharedArrayBuffer) {
            const wasm = (0,common_util_base64__WEBPACK_IMPORTED_MODULE_1__.base64ToUint8Array)((_libc_asm__WEBPACK_IMPORTED_MODULE_3___default()));
            common_util_wasm__WEBPACK_IMPORTED_MODULE_4__.setMemoryShared(wasm, true);
            wasmThreadProxy = (await WebAssembly.instantiate(wasm, {
                env: {
                    memory,
                    malloc: function (size) {
                        return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(size);
                    },
                    calloc: function (num, size) {
                        return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.calloc(num, size);
                    },
                    realloc: function (pointer, size) {
                        return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.realloc(pointer, size);
                    },
                    aligned_alloc(alignment, size) {
                        return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(alignment, size);
                    },
                    free: function (pointer) {
                        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(pointer);
                    }
                }
            })).instance;
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.set(2 /* BuiltinTableSlot.MALLOC */, wasmThreadProxy.exports.malloc);
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.set(1 /* BuiltinTableSlot.FREE */, wasmThreadProxy.exports.free);
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.set(3 /* BuiltinTableSlot.CALLOC */, wasmThreadProxy.exports.calloc);
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.set(4 /* BuiltinTableSlot.REALLOC */, wasmThreadProxy.exports.realloc);
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.set(5 /* BuiltinTableSlot.ALIGNED_ALLOC */, wasmThreadProxy.exports.alignedAlloc);
        }
        else {
            support = false;
            return;
        }
    }
    catch (error) {
        support = false;
        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.warn('thread asm not support, cannot use asm thread function', cheap__fileName__5, 64);
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/asm/thread.ts":
/*!*****************************************************!*\
  !*** ./src/cheap/webassembly/runtime/asm/thread.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   isSupport: () => (/* binding */ isSupport),
/* harmony export */   wasmThreadProxy: () => (/* binding */ wasmThreadProxy)
/* harmony export */ });
/* harmony import */ var common_util_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/base64 */ "./src/common/util/base64.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _thread_asm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./thread.asm */ "./src/cheap/webassembly/runtime/asm/thread.asm");
/* harmony import */ var _thread_asm__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_thread_asm__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
var cheap__fileName__0 = "src\\cheap\\webassembly\\runtime\\asm\\thread.ts";
/* eslint-disable camelcase */




/**
 * WebAssembly runtime 实例
 */
let wasmThreadProxy;
let support = true;
function isSupport() {
    return support;
}
async function init(memory, override) {
    try {
        if (typeof SharedArrayBuffer === 'function' && memory.buffer instanceof SharedArrayBuffer) {
            const wasm = (0,common_util_base64__WEBPACK_IMPORTED_MODULE_0__.base64ToUint8Array)((_thread_asm__WEBPACK_IMPORTED_MODULE_2___default()));
            common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.setMemoryShared(wasm, true);
            wasmThreadProxy = (await WebAssembly.instantiate(wasm, {
                env: {
                    memory
                }
            })).instance;
        }
        else {
            support = false;
            return;
        }
        override({
            wasm_pthread_mutex_lock: wasmThreadProxy.exports.lock,
            wasm_pthread_mutex_trylock: wasmThreadProxy.exports.trylock,
            wasm_pthread_mutex_unlock: wasmThreadProxy.exports.unlock,
            wasm_pthread_cond_wait: wasmThreadProxy.exports.wait,
            wasm_pthread_cond_timedwait: wasmThreadProxy.exports.timedwait,
            wasm_pthread_cond_signal: wasmThreadProxy.exports.signal,
            wasm_pthread_cond_broadcast: wasmThreadProxy.exports.broadcast
        });
    }
    catch (error) {
        support = false;
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.warn('thread asm not support, cannot use asm thread function', cheap__fileName__0, 67);
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/atomic.ts":
/*!*************************************************!*\
  !*** ./src/cheap/webassembly/runtime/atomic.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   atomic_add_i16: () => (/* binding */ atomic_add_i16),
/* harmony export */   atomic_add_i32: () => (/* binding */ atomic_add_i32),
/* harmony export */   atomic_add_i64: () => (/* binding */ atomic_add_i64),
/* harmony export */   atomic_add_i8: () => (/* binding */ atomic_add_i8),
/* harmony export */   atomic_and_i16: () => (/* binding */ atomic_and_i16),
/* harmony export */   atomic_and_i32: () => (/* binding */ atomic_and_i32),
/* harmony export */   atomic_and_i64: () => (/* binding */ atomic_and_i64),
/* harmony export */   atomic_and_i8: () => (/* binding */ atomic_and_i8),
/* harmony export */   atomic_compare_exchange_i16: () => (/* binding */ atomic_compare_exchange_i16),
/* harmony export */   atomic_compare_exchange_i32: () => (/* binding */ atomic_compare_exchange_i32),
/* harmony export */   atomic_compare_exchange_i64: () => (/* binding */ atomic_compare_exchange_i64),
/* harmony export */   atomic_compare_exchange_i8: () => (/* binding */ atomic_compare_exchange_i8),
/* harmony export */   atomic_exchange_i16: () => (/* binding */ atomic_exchange_i16),
/* harmony export */   atomic_exchange_i32: () => (/* binding */ atomic_exchange_i32),
/* harmony export */   atomic_exchange_i64: () => (/* binding */ atomic_exchange_i64),
/* harmony export */   atomic_exchange_i8: () => (/* binding */ atomic_exchange_i8),
/* harmony export */   atomic_load_i16: () => (/* binding */ atomic_load_i16),
/* harmony export */   atomic_load_i32: () => (/* binding */ atomic_load_i32),
/* harmony export */   atomic_load_i64: () => (/* binding */ atomic_load_i64),
/* harmony export */   atomic_load_i8: () => (/* binding */ atomic_load_i8),
/* harmony export */   atomic_or_i16: () => (/* binding */ atomic_or_i16),
/* harmony export */   atomic_or_i32: () => (/* binding */ atomic_or_i32),
/* harmony export */   atomic_or_i64: () => (/* binding */ atomic_or_i64),
/* harmony export */   atomic_or_i8: () => (/* binding */ atomic_or_i8),
/* harmony export */   atomic_store_i16: () => (/* binding */ atomic_store_i16),
/* harmony export */   atomic_store_i32: () => (/* binding */ atomic_store_i32),
/* harmony export */   atomic_store_i64: () => (/* binding */ atomic_store_i64),
/* harmony export */   atomic_store_i8: () => (/* binding */ atomic_store_i8),
/* harmony export */   atomic_sub_i16: () => (/* binding */ atomic_sub_i16),
/* harmony export */   atomic_sub_i32: () => (/* binding */ atomic_sub_i32),
/* harmony export */   atomic_sub_i64: () => (/* binding */ atomic_sub_i64),
/* harmony export */   atomic_sub_i8: () => (/* binding */ atomic_sub_i8),
/* harmony export */   atomic_xor_i16: () => (/* binding */ atomic_xor_i16),
/* harmony export */   atomic_xor_i32: () => (/* binding */ atomic_xor_i32),
/* harmony export */   atomic_xor_i64: () => (/* binding */ atomic_xor_i64),
/* harmony export */   atomic_xor_i8: () => (/* binding */ atomic_xor_i8),
/* harmony export */   atomics_notify: () => (/* binding */ atomics_notify),
/* harmony export */   atomics_wait: () => (/* binding */ atomics_wait),
/* harmony export */   atomics_wait_timeout: () => (/* binding */ atomics_wait_timeout),
/* harmony export */   override: () => (/* binding */ override)
/* harmony export */ });
/* harmony import */ var _thread_atomics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../typedef */ "./src/cheap/typedef.ts");
/* eslint-disable camelcase */


let atomic_add_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_sub_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_and_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_or_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_xor_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_store_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_load_i8 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_compare_exchange_i8 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_exchange_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_add_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_sub_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_and_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_or_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_xor_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_store_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_load_i16 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_compare_exchange_i16 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_exchange_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_add_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_sub_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_and_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_or_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_xor_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_store_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_load_i32 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_compare_exchange_i32 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_exchange_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_add_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_sub_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_and_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_or_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_xor_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_store_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_load_i64 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_compare_exchange_i64 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_exchange_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomics_notify = function (p, count) {
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.notify(p, count);
};
let atomics_wait = function (p, value) {
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.wait(p, value);
};
let atomics_wait_timeout = function (p, value, timeout) {
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.waitTimeout(p, value, (Number(timeout & 0xffffffffn) >> 0));
};
function override(data) {
    if (data.atomic_add_i8) {
        atomic_add_i8 = data.atomic_add_i8;
    }
    if (data.atomic_sub_i8) {
        atomic_sub_i8 = data.atomic_sub_i8;
    }
    if (data.atomic_and_i8) {
        atomic_and_i8 = data.atomic_and_i8;
    }
    if (data.atomic_or_i8) {
        atomic_or_i8 = data.atomic_or_i8;
    }
    if (data.atomic_xor_i8) {
        atomic_xor_i8 = data.atomic_xor_i8;
    }
    if (data.atomic_store_i8) {
        atomic_store_i8 = data.atomic_store_i8;
    }
    if (data.atomic_load_i8) {
        atomic_load_i8 = data.atomic_load_i8;
    }
    if (data.atomic_compare_exchange_i8) {
        atomic_compare_exchange_i8 = data.atomic_compare_exchange_i8;
    }
    if (data.atomic_exchange_i8) {
        atomic_exchange_i8 = data.atomic_exchange_i8;
    }
    if (data.atomic_add_i16) {
        atomic_add_i16 = data.atomic_add_i16;
    }
    if (data.atomic_sub_i16) {
        atomic_sub_i16 = data.atomic_sub_i16;
    }
    if (data.atomic_and_i16) {
        atomic_and_i16 = data.atomic_and_i16;
    }
    if (data.atomic_or_i16) {
        atomic_or_i16 = data.atomic_or_i16;
    }
    if (data.atomic_xor_i16) {
        atomic_xor_i16 = data.atomic_xor_i16;
    }
    if (data.atomic_store_i16) {
        atomic_store_i16 = data.atomic_store_i16;
    }
    if (data.atomic_load_i16) {
        atomic_load_i16 = data.atomic_load_i16;
    }
    if (data.atomic_compare_exchange_i16) {
        atomic_compare_exchange_i16 = data.atomic_compare_exchange_i16;
    }
    if (data.atomic_exchange_i16) {
        atomic_exchange_i16 = data.atomic_exchange_i16;
    }
    if (data.atomic_add_i32) {
        atomic_add_i32 = data.atomic_add_i32;
    }
    if (data.atomic_sub_i32) {
        atomic_sub_i32 = data.atomic_sub_i32;
    }
    if (data.atomic_and_i32) {
        atomic_and_i32 = data.atomic_and_i32;
    }
    if (data.atomic_or_i32) {
        atomic_or_i32 = data.atomic_or_i32;
    }
    if (data.atomic_xor_i32) {
        atomic_xor_i32 = data.atomic_xor_i32;
    }
    if (data.atomic_store_i32) {
        atomic_store_i32 = data.atomic_store_i32;
    }
    if (data.atomic_load_i32) {
        atomic_load_i32 = data.atomic_load_i32;
    }
    if (data.atomic_compare_exchange_i32) {
        atomic_compare_exchange_i32 = data.atomic_compare_exchange_i32;
    }
    if (data.atomic_exchange_i32) {
        atomic_exchange_i32 = data.atomic_exchange_i32;
    }
    if (data.atomic_add_i64) {
        atomic_add_i64 = data.atomic_add_i64;
    }
    if (data.atomic_sub_i64) {
        atomic_sub_i64 = data.atomic_sub_i64;
    }
    if (data.atomic_and_i64) {
        atomic_and_i64 = data.atomic_and_i64;
    }
    if (data.atomic_or_i64) {
        atomic_or_i64 = data.atomic_or_i64;
    }
    if (data.atomic_xor_i64) {
        atomic_xor_i64 = data.atomic_xor_i64;
    }
    if (data.atomic_store_i64) {
        atomic_store_i64 = data.atomic_store_i64;
    }
    if (data.atomic_load_i64) {
        atomic_load_i64 = data.atomic_load_i64;
    }
    if (data.atomic_compare_exchange_i64) {
        atomic_compare_exchange_i64 = data.atomic_compare_exchange_i64;
    }
    if (data.atomic_exchange_i64) {
        atomic_exchange_i64 = data.atomic_exchange_i64;
    }
    if (data.atomics_notify) {
        atomics_notify = data.atomics_notify;
    }
    if (data.atomics_wait) {
        atomics_wait = data.atomics_wait;
    }
    if (data.atomics_wait_timeout) {
        atomics_wait_timeout = data.atomics_wait_timeout;
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/clib.ts":
/*!***********************************************!*\
  !*** ./src/cheap/webassembly/runtime/clib.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abort: () => (/* binding */ abort),
/* harmony export */   clock_res_get: () => (/* binding */ clock_res_get),
/* harmony export */   clock_time_get: () => (/* binding */ clock_time_get),
/* harmony export */   environ_get: () => (/* binding */ environ_get),
/* harmony export */   environ_sizes_get: () => (/* binding */ environ_sizes_get),
/* harmony export */   fd_fdstat_get: () => (/* binding */ fd_fdstat_get),
/* harmony export */   fd_write: () => (/* binding */ fd_write),
/* harmony export */   random_get: () => (/* binding */ random_get)
/* harmony export */ });
/* unused harmony exports printChar, writeAsciiToMemory, fd_read, fd_seek, fd_close */
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _std_memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");


/* eslint-disable camelcase */


const buffers = [null, [], []];
const WASI_ERRNO_SUCCESS = 0;
const WASI_ERRNO_NOSYS = 52;
const WASI_ERRNO_INVAL = 28;
function printChar(stream, curr) {
    const buffer = buffers[stream];
    if (curr === 0 || curr === 10) {
        (stream === 1 ? console.log.bind(console) : console.log.bind(console))(common_util_text__WEBPACK_IMPORTED_MODULE_3__.decode(buffer));
        buffer.length = 0;
    }
    else {
        buffer.push(curr);
    }
}
function writeAsciiToMemory(str, buffer, doNotAddNull) {
    for (let i = 0; i < str.length; ++i) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[4](buffer, (((((str.charCodeAt(i)) >> 0) & 0xff) & 0x80) ? -(0x100 - (((str.charCodeAt(i)) >> 0) & 0xff)) : (((str.charCodeAt(i)) >> 0) & 0xff)));
        buffer = buffer + 1;
    }
    if (!doNotAddNull) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[4](buffer, (( false) ? 0 : (0 & 0xff)));
    }
}
const ENV = {};
let thisProgram = './this.program';
let getEnvStringsStrings;
function getExecutableName() {
    return thisProgram || './this.program';
}
function getEnvStrings() {
    if (!getEnvStringsStrings) {
        const lang = (typeof navigator === 'object' && navigator.languages && navigator.languages[0] || 'C').replace('-', '_') + '.UTF-8';
        const env = {
            'USER': 'web_user',
            'LOGNAME': 'web_user',
            'PATH': '/',
            'PWD': '/',
            'HOME': '/home/web_user',
            'LANG': lang,
            '_': getExecutableName()
        };
        for (let x in ENV) {
            env[x] = ENV[x];
        }
        const strings = [];
        for (let x in env) {
            strings.push(x + '=' + env[x]);
        }
        getEnvStringsStrings = strings;
    }
    return getEnvStringsStrings;
}
function environ_get(environ, environBuf) {
    let bufSize = 0;
    getEnvStrings().forEach(function (string, i) {
        const ptr = environBuf + bufSize;
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[8](environ + (i * 4), ptr);
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
    });
    return 0;
}
function environ_sizes_get(penvironCount, penvironBufSize) {
    const strings = getEnvStrings();
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[8](penvironCount, (((strings.length) >> 0) >>> 0));
    let bufSize = 0;
    strings.forEach(function (string) {
        bufSize += string.length + 1;
    });
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[8](penvironBufSize, (((bufSize) >> 0) >>> 0));
    return 0;
}
function fd_fdstat_get(fd, pBuf) {
    let rightsBase = 0;
    if (fd == 0) {
        rightsBase = 2;
    }
    else if (fd == 1 || fd == 2) {
        rightsBase = 64;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[11](pBuf, (( false) ? 0 : (2 & 0xff)));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[13](pBuf + 2, (( false) ? 0 : (1 & 0xffff)));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](pBuf + 8, ((rightsBase) >> 0));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](pBuf + 12, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[17](pBuf + 16, BigInt(0));
    return WASI_ERRNO_SUCCESS;
}
function fd_read(fd, iov, iovCnt, pNum) {
    return WASI_ERRNO_NOSYS;
}
function fd_seek(fd, offsetLow, offsetHigh, whence, newOffset) {
    return WASI_ERRNO_NOSYS;
}
function fd_write(fd, iov, iovCnt, pNum) {
    let num = 0;
    for (let i = 0; i < iovCnt; i++) {
        let ptr = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[8](iov);
        let len = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[8](iov + 4);
        iov = iov + 8;
        for (let j = 0; j < len; j++) {
            printChar(fd, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[4](ptr + j));
        }
        num += len;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[8](pNum, (((num) >> 0) >>> 0));
    return WASI_ERRNO_SUCCESS;
}
function fd_close(fd) {
    return WASI_ERRNO_NOSYS;
}
function abort(what) {
    what += '';
    what = `abort(${what}). Build with -s ASSERTIONS=1 for more info.`;
    throw new WebAssembly.RuntimeError(what);
}
function clock_time_get(id, precision, timeOut) {
    if (id !== 0) {
        return WASI_ERRNO_INVAL;
    }
    const now = new Date().getTime();
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[10](timeOut, BigInt(now) * BigInt(1000000));
    return WASI_ERRNO_SUCCESS;
}
function clock_res_get(id, resOut) {
    if (id !== 0) {
        return WASI_ERRNO_INVAL;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[10](resOut, BigInt(1000000));
    return WASI_ERRNO_SUCCESS;
}
function random_get(pointer, size) {
    const buffer = (0,_std_memory__WEBPACK_IMPORTED_MODULE_2__.mapUint8Array)(pointer, size);
    {
        crypto.getRandomValues(buffer);
    }
    return WASI_ERRNO_SUCCESS;
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/pthread.ts":
/*!**************************************************!*\
  !*** ./src/cheap/webassembly/runtime/pthread.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   override: () => (/* binding */ override),
/* harmony export */   wasm_cpu_core_count: () => (/* binding */ wasm_cpu_core_count),
/* harmony export */   wasm_pthread_cond_broadcast: () => (/* binding */ wasm_pthread_cond_broadcast),
/* harmony export */   wasm_pthread_cond_destroy: () => (/* binding */ wasm_pthread_cond_destroy),
/* harmony export */   wasm_pthread_cond_init: () => (/* binding */ wasm_pthread_cond_init),
/* harmony export */   wasm_pthread_cond_signal: () => (/* binding */ wasm_pthread_cond_signal),
/* harmony export */   wasm_pthread_cond_timedwait: () => (/* binding */ wasm_pthread_cond_timedwait),
/* harmony export */   wasm_pthread_cond_wait: () => (/* binding */ wasm_pthread_cond_wait),
/* harmony export */   wasm_pthread_equal2: () => (/* binding */ wasm_pthread_equal2),
/* harmony export */   wasm_pthread_exit: () => (/* binding */ wasm_pthread_exit),
/* harmony export */   wasm_pthread_mutex_destroy: () => (/* binding */ wasm_pthread_mutex_destroy),
/* harmony export */   wasm_pthread_mutex_init: () => (/* binding */ wasm_pthread_mutex_init),
/* harmony export */   wasm_pthread_mutex_lock: () => (/* binding */ wasm_pthread_mutex_lock),
/* harmony export */   wasm_pthread_mutex_trylock: () => (/* binding */ wasm_pthread_mutex_trylock),
/* harmony export */   wasm_pthread_mutex_unlock: () => (/* binding */ wasm_pthread_mutex_unlock),
/* harmony export */   wasm_pthread_once: () => (/* binding */ wasm_pthread_once),
/* harmony export */   wasm_pthread_self2: () => (/* binding */ wasm_pthread_self2),
/* harmony export */   wasm_pthread_support: () => (/* binding */ wasm_pthread_support),
/* harmony export */   wasm_threw_error: () => (/* binding */ wasm_threw_error)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _thread_mutex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _thread_cond__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../thread/cond */ "./src/cheap/thread/cond.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../config */ "./src/cheap/config.ts");
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../heap */ "./src/cheap/heap.ts");
/* harmony import */ var _thread_atomics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var _std_memory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../std/memory */ "./src/cheap/std/memory.ts");


/* eslint-disable camelcase */







let wasm_pthread_mutex_init;
let wasm_pthread_mutex_destroy;
let wasm_pthread_mutex_lock;
let wasm_pthread_mutex_trylock;
let wasm_pthread_mutex_unlock;
let wasm_pthread_cond_init;
let wasm_pthread_cond_destroy;
let wasm_pthread_cond_wait;
let wasm_pthread_cond_timedwait;
let wasm_pthread_cond_signal;
let wasm_pthread_cond_broadcast;
let wasm_pthread_once;
function wasm_pthread_self2() {
    return common_util_constant__WEBPACK_IMPORTED_MODULE_7__.SELF.__SELF_THREAD__;
}
function wasm_pthread_exit(retval) {
    const thread = common_util_constant__WEBPACK_IMPORTED_MODULE_7__.SELF.__SELF_THREAD__;
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](thread + 4, retval);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](thread + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread + 8) | 4 /* PthreadFlags.EXIT */);
}
function wasm_pthread_equal2(t1, t2) {
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](t1) === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](t2) ? 1 : 0;
}
function wasm_pthread_support() {
    return _config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS ? 1 : 0;
}
function wasm_cpu_core_count() {
    return navigator.hardwareConcurrency;
}
function wasm_threw_error(code, msg) {
    throw new Error((0,_std_memory__WEBPACK_IMPORTED_MODULE_8__.readCString)(msg));
}
wasm_pthread_mutex_init = function (mutex, attr) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_2__.init(mutex);
};
wasm_pthread_mutex_destroy = function (mutex) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_2__.destroy(mutex);
};
wasm_pthread_mutex_lock = function (mutex) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_2__.lock(mutex);
};
wasm_pthread_mutex_trylock = function (mutex) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_2__.tryLock(mutex);
};
wasm_pthread_mutex_unlock = function (mutex) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock(mutex);
};
wasm_pthread_cond_init = function (cond, attr) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_3__.init(cond, attr);
};
wasm_pthread_cond_destroy = function (cond) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_3__.destroy(cond);
};
wasm_pthread_cond_wait = function (cond, mutex) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_3__.wait(cond, mutex);
};
wasm_pthread_cond_timedwait = function (cond, mutex, abstime) {
    let timeout = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](abstime)) * 1000 + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](abstime + 8) / 1000000;
    return _thread_cond__WEBPACK_IMPORTED_MODULE_3__.timedWait(cond, mutex, timeout);
};
wasm_pthread_cond_signal = function (cond) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_3__.signal(cond);
};
wasm_pthread_cond_broadcast = function (cond) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_3__.broadcast(cond);
};
wasm_pthread_once = function (control, func) {
    if (_thread_atomics__WEBPACK_IMPORTED_MODULE_6__.add(control, 1, 16, 2) === 0) {
        _heap__WEBPACK_IMPORTED_MODULE_5__.Table.get(func)();
    }
    return 0;
};
function override(data) {
    if (data.wasm_pthread_mutex_lock) {
        wasm_pthread_mutex_lock = data.wasm_pthread_mutex_lock;
    }
    if (data.wasm_pthread_mutex_trylock) {
        wasm_pthread_mutex_trylock = data.wasm_pthread_mutex_trylock;
    }
    if (data.wasm_pthread_mutex_unlock) {
        wasm_pthread_mutex_unlock = data.wasm_pthread_mutex_unlock;
    }
    if (data.wasm_pthread_cond_wait) {
        wasm_pthread_cond_wait = data.wasm_pthread_cond_wait;
    }
    if (data.wasm_pthread_cond_timedwait) {
        wasm_pthread_cond_timedwait = data.wasm_pthread_cond_timedwait;
    }
    if (data.wasm_pthread_cond_signal) {
        wasm_pthread_cond_signal = data.wasm_pthread_cond_signal;
    }
    if (data.wasm_pthread_cond_broadcast) {
        wasm_pthread_cond_broadcast = data.wasm_pthread_cond_broadcast;
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/semaphore.ts":
/*!****************************************************!*\
  !*** ./src/cheap/webassembly/runtime/semaphore.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timespec: () => (/* binding */ Timespec),
/* harmony export */   wasm_sem_destroy: () => (/* binding */ wasm_sem_destroy),
/* harmony export */   wasm_sem_init: () => (/* binding */ wasm_sem_init),
/* harmony export */   wasm_sem_post: () => (/* binding */ wasm_sem_post),
/* harmony export */   wasm_sem_timedwait: () => (/* binding */ wasm_sem_timedwait),
/* harmony export */   wasm_sem_trywait: () => (/* binding */ wasm_sem_trywait),
/* harmony export */   wasm_sem_wait: () => (/* binding */ wasm_sem_wait)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _thread_semaphore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../thread/semaphore */ "./src/cheap/thread/semaphore.ts");



/* eslint-disable camelcase */

class Timespec {
    tvSec;
    tvNSec;
}
(function (prototype) {
    var map = new Map();
    map.set("tvSec", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("tvNSec", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 16);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(Timespec.prototype);
function wasm_sem_init(sem, pshared, value) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_3__.init(sem, value);
}
function wasm_sem_destroy(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_3__.destroy(sem);
}
function wasm_sem_wait(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_3__.wait(sem);
}
function wasm_sem_trywait(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_3__.tryWait(sem);
}
function wasm_sem_timedwait(sem, abstime) {
    let timeout = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](abstime)) * 1000 + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](abstime + 8) / 1000000;
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_3__.timedWait(sem, timeout);
}
function wasm_sem_post(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_3__.post(sem);
}


/***/ }),

/***/ "./src/cheap/webassembly/thread.ts":
/*!*****************************************!*\
  !*** ./src/cheap/webassembly/thread.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports PthreadOnce, Pthread, ThreadDescriptor, ThreadWait */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _thread_cond_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\thread\cond.ts */ "./src/cheap/thread/cond.ts");
/* harmony import */ var _thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./..\thread\mutex.ts */ "./src/cheap/thread/mutex.ts");




class PthreadOnce {
    atomic;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(PthreadOnce.prototype);
class Pthread {
    id;
    retval;
    flags;
    status;
}
(function (prototype) {
    var map = new Map();
    map.set("id", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("retval", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("status", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 16);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(Pthread.prototype);
class ThreadDescriptor {
    flags;
    status;
}
(function (prototype) {
    var map = new Map();
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("status", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(ThreadDescriptor.prototype);
class ThreadWait {
    thread;
    func;
    args;
    cond;
    mutex;
}
(function (prototype) {
    var map = new Map();
    map.set("thread", { 0: Pthread, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("func", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("args", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("cond", { 0: _thread_cond_ts__WEBPACK_IMPORTED_MODULE_2__.Cond, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("mutex", { 0: _thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 20);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(ThreadWait.prototype);


/***/ }),

/***/ "./src/common/event/CustomEvent.ts":
/*!*****************************************!*\
  !*** ./src/common/event/CustomEvent.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CustomEvent)
/* harmony export */ });
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * https://github.com/yoxjs/yox-common/blob/master/src/util/CustomEvent.ts
 * MIT License
 *
 * @file 事件
 */

class CustomEvent {
    static PHASE_CURRENT = 0;
    static PHASE_UPWARD = 1;
    static PHASE_DOWNWARD = _util_constant__WEBPACK_IMPORTED_MODULE_0__.MINUS_ONE;
    // 事件名称
    type;
    // 事件当前阶段
    phase;
    // 事件命名空间
    ns;
    // 哪个组件发出的事件
    target;
    // 原始事件，比如 DOM 事件
    originalEvent;
    // 是否已阻止事件的默认行为
    isPrevented;
    // 是否已停止事件冒泡
    isStopped;
    // 处理当前事件的监听器，方便外部获取 listener 进行解绑
    listener;
    /**
     * 构造函数
     *
     * 可以传事件名称，也可以传原生事件对象
     */
    constructor(type, originalEvent) {
        /*
         * 这里不设置命名空间
         * 因为有没有命名空间取决于 Emitter 的构造函数有没有传 true
         * CustomEvent 自己无法决定
         */
        this.type = type;
        this.phase = CustomEvent.PHASE_CURRENT;
        if (originalEvent) {
            this.originalEvent = originalEvent;
        }
    }
    /**
     * 阻止事件的默认行为
     */
    preventDefault() {
        const instance = this;
        if (!instance.isPrevented) {
            const { originalEvent } = instance;
            if (originalEvent) {
                originalEvent.preventDefault();
            }
            instance.isPrevented = _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE;
        }
        return instance;
    }
    /**
     * 停止事件广播
     */
    stopPropagation() {
        const instance = this;
        if (!instance.isStopped) {
            const { originalEvent } = instance;
            if (originalEvent) {
                originalEvent.stopPropagation();
            }
            instance.isStopped = _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE;
        }
        return instance;
    }
    prevent() {
        return this.preventDefault();
    }
    stop() {
        return this.stopPropagation();
    }
}


/***/ }),

/***/ "./src/common/event/Emitter.ts":
/*!*************************************!*\
  !*** ./src/common/event/Emitter.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Emitter)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _CustomEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CustomEvent */ "./src/common/event/CustomEvent.ts");
/* harmony import */ var _util_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/object */ "./src/common/util/object.ts");
/* harmony import */ var _util_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/string */ "./src/common/util/string.ts");
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _function_execute__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../function/execute */ "./src/common/function/execute.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
var cheap__fileName__0 = "src\\common\\event\\Emitter.ts";
/**
 * https://github.com/yoxjs/yox-common/blob/master/src/util/Emitter.ts
 * MIT License
 *
 * @file 事件代理
 */








class Emitter {
    /**
     * 是否开启命名空间
     */
    ns;
    /**
     * 已注册的事件监听
     */
    listeners;
    /**
     * 原生事件监听，一个事件对应一个 listener
     */
    nativeListeners;
    constructor(ns) {
        this.ns = ns || _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE;
        this.listeners = {};
    }
    /**
     * 发射事件
     *
     * @param type 事件名称或命名空间
     * @param args 事件处理函数的参数列表
     * @param filter 自定义过滤器
     */
    fire(type, args, filter) {
        let instance = this, namespace = _util_is__WEBPACK_IMPORTED_MODULE_0__.string(type) ? instance.parse(type) : type, list = instance.listeners[namespace.type], isComplete = _util_constant__WEBPACK_IMPORTED_MODULE_7__.TRUE;
        if (list) {
            // 避免遍历过程中，数组发生变化，比如增删了
            list = _util_object__WEBPACK_IMPORTED_MODULE_3__.copy(list);
            /*
             * 判断是否是发射事件
             * 如果 args 的第一个参数是 CustomEvent 类型，表示发射事件
             * 因为事件处理函数的参数列表是 (event, data)
             */
            const event = args && args[0] instanceof _CustomEvent__WEBPACK_IMPORTED_MODULE_2__["default"]
                ? args[0]
                : _util_constant__WEBPACK_IMPORTED_MODULE_7__.UNDEFINED;
            _util_array__WEBPACK_IMPORTED_MODULE_1__.each(list, function (options) {
                // 命名空间不匹配
                if (!matchNamespace(namespace.ns, options, _util_constant__WEBPACK_IMPORTED_MODULE_7__.TRUE)
                    // 在 fire 过程中被移除了
                    || !_util_array__WEBPACK_IMPORTED_MODULE_1__.has(list, options)
                    // 传了 filter，则用 filter 判断是否过滤此 options
                    || (filter && !filter(namespace, args, options))) {
                    return;
                }
                /*
                 * 为 event 对象加上当前正在处理的 listener
                 * 这样方便业务层移除事件绑定
                 * 比如 on('xx', function) 这样定义了匿名 listener
                 * 在这个 listener 里面获取不到当前 listener 的引用
                 * 为了能引用到，有时候会先定义 var listener = function
                 * 然后再 on('xx', listener) 这样其实是没有必要的
                 */
                if (event) {
                    event.listener = options.fn;
                }
                let result = (0,_function_execute__WEBPACK_IMPORTED_MODULE_6__["default"])(options.fn, options.ctx, args);
                if (event) {
                    event.listener = _util_constant__WEBPACK_IMPORTED_MODULE_7__.UNDEFINED;
                }
                // 执行次数
                options.num = options.num ? (options.num + 1) : 1;
                // 注册的 listener 可以指定最大执行次数
                if (options.num === options.max) {
                    instance.off(namespace, options.fn);
                }
                // 如果没有返回 false，而是调用了 event.stop 也算是返回 false
                if (event) {
                    if (result === _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE) {
                        event.prevent().stop();
                    }
                    else if (event.isStopped) {
                        result = _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE;
                    }
                }
                if (result === _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE) {
                    return isComplete = _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE;
                }
            });
        }
        return isComplete;
    }
    /**
     * 注册监听
     *
     * @param type
     * @param listener
     */
    on(type, listener) {
        const instance = this, listeners = instance.listeners, options = _util_is__WEBPACK_IMPORTED_MODULE_0__.func(listener)
            ? { fn: listener }
            : listener;
        if (_util_is__WEBPACK_IMPORTED_MODULE_0__.object(options) && _util_is__WEBPACK_IMPORTED_MODULE_0__.func(options.fn)) {
            const namespace = _util_is__WEBPACK_IMPORTED_MODULE_0__.string(type) ? instance.parse(type) : type;
            options.ns = namespace.ns;
            _util_array__WEBPACK_IMPORTED_MODULE_1__.push(listeners[namespace.type] || (listeners[namespace.type] = []), options);
        }
        else if (true) {
            _util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal('emitter.on(type, listener) invoke failed：\n\n"listener" is expected to be a Function or an EmitterOptions.\n', cheap__fileName__0, 196);
        }
        return this;
    }
    one(type, listener) {
        if (_util_is__WEBPACK_IMPORTED_MODULE_0__.func(listener)) {
            listener = {
                fn: listener,
                max: 1
            };
        }
        else {
            listener.max = 1;
        }
        return this.on(type, listener);
    }
    /**
     * 取消监听
     *
     * @param type
     * @param listener
     */
    off(type, listener) {
        const instance = this, listeners = instance.listeners;
        if (type) {
            const namespace = _util_is__WEBPACK_IMPORTED_MODULE_0__.string(type) ? instance.parse(type) : type, name = namespace.type, ns = namespace.ns, matchListener = createMatchListener(listener), each = function (list, name) {
                _util_array__WEBPACK_IMPORTED_MODULE_1__.each(list, function (options, index) {
                    if (matchListener(options)) {
                        list.splice(index, 1);
                    }
                }, _util_constant__WEBPACK_IMPORTED_MODULE_7__.TRUE);
                if (!list.length) {
                    delete listeners[name];
                }
            }, eachNS = function (list, name) {
                _util_array__WEBPACK_IMPORTED_MODULE_1__.each(list, function (options, index) {
                    if (matchNamespace(ns, options)) {
                        list.splice(index, 1);
                    }
                }, _util_constant__WEBPACK_IMPORTED_MODULE_7__.TRUE);
                if (!list.length) {
                    delete listeners[name];
                }
            };
            if (name) {
                if (listeners[name]) {
                    each(listeners[name], name);
                }
            }
            else if (ns) {
                _util_object__WEBPACK_IMPORTED_MODULE_3__.each(listeners, eachNS);
            }
            /*
             * 在开发阶段进行警告，比如传了 listener 进来，listener 是个空值
             * 但你不知道它是空值
             */
            if (true) {
                if (arguments.length > 1 && listener == _util_constant__WEBPACK_IMPORTED_MODULE_7__.NULL) {
                    _util_logger__WEBPACK_IMPORTED_MODULE_5__.warn(`emitter.off(type, listener) is invoked, but "listener" is ${listener}.`, cheap__fileName__0, 288);
                }
            }
        }
        else {
            // 清空
            instance.listeners = {};
            /*
             * 在开发阶段进行警告，比如传了 type 进来，type 是个空值
             * 但你不知道它是空值
             */
            if (true) {
                if (arguments.length > 0) {
                    _util_logger__WEBPACK_IMPORTED_MODULE_5__.warn(`emitter.off(type) is invoked, but "type" is ${type}.`, cheap__fileName__0, 302);
                }
            }
        }
    }
    /**
     * 是否已监听某个事件
     *
     * @param type
     * @param listener
     */
    has(type, listener) {
        let instance = this, listeners = instance.listeners, namespace = _util_is__WEBPACK_IMPORTED_MODULE_0__.string(type) ? instance.parse(type) : type, name = namespace.type, ns = namespace.ns, result = _util_constant__WEBPACK_IMPORTED_MODULE_7__.TRUE, matchListener = createMatchListener(listener), each = function (list) {
            _util_array__WEBPACK_IMPORTED_MODULE_1__.each(list, function (options) {
                if (matchListener(options)) {
                    return result = _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE;
                }
            });
            return result;
        }, eachNS = function (list) {
            _util_array__WEBPACK_IMPORTED_MODULE_1__.each(list, function (options) {
                if (matchNamespace(ns, options)) {
                    return result = _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE;
                }
            });
            return result;
        };
        if (name) {
            if (listeners[name]) {
                each(listeners[name]);
            }
        }
        else if (ns) {
            _util_object__WEBPACK_IMPORTED_MODULE_3__.each(listeners, eachNS);
        }
        return !result;
    }
    /**
     * 把事件类型解析成命名空间格式
     *
     * @param type
     */
    parse(type) {
        /*
         * 这里 ns 必须为字符串
         * 用于区分 event 对象是否已完成命名空间的解析
         */
        const result = {
            type,
            ns: _util_constant__WEBPACK_IMPORTED_MODULE_7__.EMPTY_STRING,
        };
        // 是否开启命名空间
        if (this.ns) {
            const index = _util_string__WEBPACK_IMPORTED_MODULE_4__.indexOf(type, _util_constant__WEBPACK_IMPORTED_MODULE_7__.RAW_DOT);
            if (index >= 0) {
                result.type = _util_string__WEBPACK_IMPORTED_MODULE_4__.slice(type, 0, index);
                result.ns = _util_string__WEBPACK_IMPORTED_MODULE_4__.slice(type, index + 1);
            }
        }
        return result;
    }
}
function matchTrue() {
    return _util_constant__WEBPACK_IMPORTED_MODULE_7__.TRUE;
}
/**
 * 外部会传入 Function 或 EmitterOptions 或 空
 *
 * 这里根据传入值的不同类型，创建不同的判断函数
 *
 * 如果传入的是 EmitterOptions，则全等判断
 *
 * 如果传入的是 Function，则判断函数是否全等
 *
 * 如果传入的是空，则直接返回 true
 *
 * @param listener
 */
function createMatchListener(listener) {
    return _util_is__WEBPACK_IMPORTED_MODULE_0__.func(listener)
        ? function (options) {
            return listener === options.fn;
        }
        : matchTrue;
}
/**
 * 判断 options 是否能匹配命名空间
 *
 * 如果 namespace 和 options.ns 都不为空，则需完全匹配
 *
 * 如果他们两个其中任何一个为空，则不判断命名空间
 *
 * @param namespace
 * @param options
 */
function matchNamespace(namespace, options, isFire) {
    const { ns } = options;
    return ns && namespace
        ? ns === namespace
        : (isFire ? _util_constant__WEBPACK_IMPORTED_MODULE_7__.TRUE : _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE);
}


/***/ }),

/***/ "./src/common/function/checkVersion.ts":
/*!*********************************************!*\
  !*** ./src/common/function/checkVersion.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ checkVersion)
/* harmony export */ });
/* harmony import */ var _toNumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toNumber */ "./src/common/function/toNumber.ts");
/**
 * @file 判断版本
 */

/**
 * 判断给定版本是否符合条件
 *
 * @param version 待检查版本
 * @param checkVersion 版本基准
 * @param equal 是否判等
 *
 * @returns 是否符合条件
 */
function checkVersion(version, checkVersion, equal = false) {
    const checkVersionArr = checkVersion.split('.');
    const versionArr = version.split('.');
    for (let i = 0; i < versionArr.length; i++) {
        if (equal && i == (versionArr.length - 1) && (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(versionArr[i]) >= (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(checkVersionArr[i])) {
            return versionArr.length >= checkVersionArr.length;
        }
        if ((0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(versionArr[i]) > (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(checkVersionArr[i])) {
            return true;
        }
        else if ((0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(versionArr[i]) < (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(checkVersionArr[i])) {
            return false;
        }
        if (i === checkVersionArr.length - 1 && i === versionArr.length - 1) {
            return equal;
        }
        if (i === checkVersionArr.length - 1) {
            return true;
        }
        else if (i === versionArr.length - 1) {
            return false;
        }
    }
    return true;
}


/***/ }),

/***/ "./src/common/function/concatTypeArray.ts":
/*!************************************************!*\
  !*** ./src/common/function/concatTypeArray.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ concatTypeArray)
/* harmony export */ });
/**
 * @file 合并 TypeArray
 */
function concatTypeArray(constructor, arrays) {
    if (!arrays.length) {
        return null;
    }
    if (arrays.length === 1) {
        return arrays[0];
    }
    let totalLength = 0;
    let array;
    for (array of arrays) {
        totalLength += array.length;
    }
    let result = new constructor(totalLength);
    let offset = 0;
    for (array of arrays) {
        result.set(array, offset);
        offset += array.length;
    }
    return result;
}


/***/ }),

/***/ "./src/common/function/debounce.ts":
/*!*****************************************!*\
  !*** ./src/common/function/debounce.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ debounce)
/* harmony export */ });
/* harmony import */ var _execute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./execute */ "./src/common/function/execute.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 防抖函数
 */



/**
 * 防抖函数
 *
 * @param fn 需要节制调用的函数
 * @param delay 调用的时间间隔，单位毫秒
 * @param immediate 是否立即触发
 * @return 节流函数
 */
function debounce(fn, delay, immediate, last = false) {
    let timer;
    let args;
    return function () {
        let context = this;
        if (last) {
            args = _util_array__WEBPACK_IMPORTED_MODULE_1__.toArray(arguments);
        }
        if (!timer) {
            if (!last) {
                args = _util_array__WEBPACK_IMPORTED_MODULE_1__.toArray(arguments);
            }
            if (immediate) {
                (0,_execute__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, context, args);
            }
            timer = setTimeout(function () {
                timer = _util_constant__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED;
                if (!immediate) {
                    (0,_execute__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, context, args);
                }
            }, delay);
        }
    };
}


/***/ }),

/***/ "./src/common/function/execute.ts":
/*!****************************************!*\
  !*** ./src/common/function/execute.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ execute)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 使用指定上下文执行函数
 */


/**
 * 任性地执行一个函数，不管它有没有、是不是
 *
 * @param fn 调用的函数
 * @param context 执行函数时的 this 指向
 * @param args 调用函数的参数，多参数时传入数组
 * @return 调用函数的返回值
 */
function execute(fn, context, args) {
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.func(fn)) {
        return _util_is__WEBPACK_IMPORTED_MODULE_0__.array(args)
            ? fn.apply(context, args)
            : context !== _util_constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED
                ? fn.call(context, args)
                : args !== _util_constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED
                    ? fn(args)
                    : fn();
    }
}


/***/ }),

/***/ "./src/common/function/generateUUID.ts":
/*!*********************************************!*\
  !*** ./src/common/function/generateUUID.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ generateUUID)
/* harmony export */ });
/**
 * 生成唯一 id
 *
 * @internal
 * @returns id
 */
function generateUUID() {
    let d = new Date().getTime();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        let r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
}


/***/ }),

/***/ "./src/common/function/getTimestamp.ts":
/*!*********************************************!*\
  !*** ./src/common/function/getTimestamp.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getTimestamp)
/* harmony export */ });
function getTimestamp() {
    return Date.now();
}


/***/ }),

/***/ "./src/common/function/isAudioWorklet.ts":
/*!***********************************************!*\
  !*** ./src/common/function/isAudioWorklet.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isAudioWorklet)
/* harmony export */ });
function isAudioWorklet() {
    // @ts-ignore
    return typeof registerProcessor === 'function' && typeof sampleRate === 'number' && typeof currentFrame === 'number' && typeof currentTime === 'number';
}


/***/ }),

/***/ "./src/common/function/isDef.ts":
/*!**************************************!*\
  !*** ./src/common/function/isDef.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isDef)
/* harmony export */ });
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 判断是否定义
 */

/**
 * 判断是否定义
 *
 * @param target 待判定变量
 */
function isDef(target) {
    return target !== _util_constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED;
}


/***/ }),

/***/ "./src/common/function/isLittleEndian.ts":
/*!***********************************************!*\
  !*** ./src/common/function/isLittleEndian.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isLittleEndian)
/* harmony export */ });
/* harmony import */ var _isDef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isDef */ "./src/common/function/isDef.ts");

let _isLittleEndian;
function isLittleEndian() {
    if ((0,_isDef__WEBPACK_IMPORTED_MODULE_0__["default"])(_isLittleEndian)) {
        return _isLittleEndian;
    }
    const buf = new ArrayBuffer(2);
    const view = new DataView(buf);
    // little-endian write
    view.setInt16(0, 256, true);
    // platform-spec read, if equal then LE
    _isLittleEndian = (new Int16Array(buf))[0] === 256;
    return _isLittleEndian;
}


/***/ }),

/***/ "./src/common/function/isNative.ts":
/*!*****************************************!*\
  !*** ./src/common/function/isNative.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isNative)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toString */ "./src/common/function/toString.ts");
/* harmony import */ var _util_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/string */ "./src/common/util/string.ts");
/**
 * @file 判断是否是 native 方法
 */



/**
 * 判断是否是 native 方法
 *
 * @param target 待判定函数
 */
function isNative(target) {
    return _util_is__WEBPACK_IMPORTED_MODULE_0__.func(target) && _util_string__WEBPACK_IMPORTED_MODULE_2__.has((0,_toString__WEBPACK_IMPORTED_MODULE_1__["default"])(target), '[native code]');
}


/***/ }),

/***/ "./src/common/function/isWorker.ts":
/*!*****************************************!*\
  !*** ./src/common/function/isWorker.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isWorker)
/* harmony export */ });
/* harmony import */ var _isDef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isDef */ "./src/common/function/isDef.ts");
/* harmony import */ var _isAudioWorklet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isAudioWorklet */ "./src/common/function/isAudioWorklet.ts");


function isWorker() {
    return !(typeof window === 'object' && (0,_isDef__WEBPACK_IMPORTED_MODULE_0__["default"])(window.document)) && !(0,_isAudioWorklet__WEBPACK_IMPORTED_MODULE_1__["default"])();
}


/***/ }),

/***/ "./src/common/function/nextTick.ts":
/*!*****************************************!*\
  !*** ./src/common/function/nextTick.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isNative__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isNative */ "./src/common/function/isNative.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 下一个时间片
 */


let nextTick;
// IE (10+) 和 node
if (typeof setImmediate === _util_constant__WEBPACK_IMPORTED_MODULE_1__.RAW_FUNCTION && (0,_isNative__WEBPACK_IMPORTED_MODULE_0__["default"])(setImmediate)) {
    nextTick = setImmediate;
}
/*
 * 用 MessageChannel 去做 setImmediate 的 polyfill
 * 原理是将新的 message 事件加入到原有的 dom events 之后
 * 兼容性 IE10+ 和其他标准浏览器
 */
if (typeof MessageChannel === _util_constant__WEBPACK_IMPORTED_MODULE_1__.RAW_FUNCTION && (0,_isNative__WEBPACK_IMPORTED_MODULE_0__["default"])(MessageChannel)) {
    nextTick = function (fn) {
        const channel = new MessageChannel();
        channel.port1.onmessage = fn;
        channel.port2.postMessage(1);
    };
}
else if (typeof setTimeout === 'function') {
    nextTick = setTimeout;
}
// 没有 setTimeout 是环境，比如 WorkletGlobalScope，先固定一个插槽
else {
    nextTick = function (fn) {
        setTimeout(fn);
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nextTick);


/***/ }),

/***/ "./src/common/function/restrain.ts":
/*!*****************************************!*\
  !*** ./src/common/function/restrain.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ restrain)
/* harmony export */ });
/**
 * @file 对值的范围进行约束
 */
/**
 * 对值的范围进行约束
 *
 * @param value 值
 * @param min 最小值
 * @param max 最大值
 *
 * @returns 约束之后的值
 */
function restrain(value, min, max) {
    if (value < min) {
        value = min;
    }
    else if (value > max) {
        value = max;
    }
    return value;
}


/***/ }),

/***/ "./src/common/function/sourceLoad.ts":
/*!*******************************************!*\
  !*** ./src/common/function/sourceLoad.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * 将某个文件的代码变成字符串（Webpack 使用）
 */
const webpackBootstrapFunc = `
function webpackBootstrapFunc (modules) {
  var installedModules = {};
  function __webpack_require__(moduleId) {
    if(installedModules[moduleId])
    return installedModules[moduleId].exports;
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: false,
      exports: {}
    };
    if (!modules[moduleId]) {
      console.log('can not found module:', moduleId)
    }
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    module.l = true;
    return module.exports;
  }
  __webpack_require__.m = modules;
  __webpack_require__.c = installedModules;
  __webpack_require__.i = function(value) { return value; };
  __webpack_require__.d = function(exports, definition, getter) {
    if (typeof definition === 'string') {
      if(!__webpack_require__.o(exports, definition)) {
        Object.defineProperty(exports, definition, {
          enumerable: true,
          get: getter
        });
      }
    }
    else {
      for(var key in definition) {
        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          });
        }
      }
    }
  };
  __webpack_require__.r = function(exports) {
    if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    	Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
    }
    Object.defineProperty(exports, '__esModule', { value: true });
  };
  __webpack_require__.f = {};
  __webpack_require__.e = function(chunkId) {
    return Promise.all(Object.keys(__webpack_require__.f).reduce(function (promises, key) {
      __webpack_require__.f[key](chunkId, promises);
        return promises;
    	}, []));
	};
  __webpack_require__.u = function(chunkId) {
    return chunkId + "LIB_NAME";
  };
  __webpack_require__.n = function(module) {
    var getter = module && module.__esModule ?
      function getDefault() { return module['default']; } :
      function getModuleExports() { return module; };
    __webpack_require__.d(getter, 'a', getter);
    return getter;
  };
  (function() {
    var installedChunks = {
      "main": 0
    };
    __webpack_require__.f.j = function(chunkId, promises) {
      var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
      if (installedChunkData !== 0) {
        if(installedChunkData) {
          promises.push(installedChunkData[2]);
        } else {
          if (true) {
            var promise = new Promise(function(resolve, reject){installedChunkData = installedChunks[chunkId] = [resolve, reject]});
            promises.push(installedChunkData[2] = promise);
            var url = __webpack_require__.p + __webpack_require__.u(chunkId);
            var error = new Error();
            var loadingEnded = function(event) {
              if(__webpack_require__.o(installedChunks, chunkId)) {
                installedChunkData = installedChunks[chunkId];
                if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
                if(installedChunkData) {
                  var errorType = event && (event.type === 'load' ? 'missing' : event.type);
                  var realSrc = url;
                  error.message = "Loading chunk " + chunkId + " failed.\\n(" + errorType + ": " + realSrc + ")";
                  error.name = "ChunkLoadError";
                  error.type = errorType;
                  error.request = realSrc;
                  installedChunkData[1](error);
                }
              }
            };
            __webpack_require__.l(url, loadingEnded);
          }
        }
      }
    };
    var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
    var [chunkIds, moreModules, runtime] = data;
    var moduleId, chunkId, i = 0;
    if (chunkIds.some(function(id){return installedChunks[id] !== 0})) {
      for(moduleId in moreModules) {
        if(__webpack_require__.o(moreModules, moduleId)) {
          __webpack_require__.m[moduleId] = moreModules[moduleId];
        }
      }
      if(runtime) runtime(__webpack_require__);
    }
    if (parentChunkLoadingFunction) parentChunkLoadingFunction(data);
      for (;i < chunkIds.length; i++) {
        chunkId = chunkIds[i];
        if (__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
          installedChunks[chunkId][0]();
        }
        installedChunks[chunkId] = 0;
      }
    }
    var self = typeof globalThis !== undefined ? globalThis : self
    var exportName = 'LIBRARY_EXPORT_NAME'
    var chunkLoadingGlobal = self["webpackChunk" + exportName] = self["webpackChunk" + exportName] || [];
    chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
    chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
  })();
  (function() {
    var inProgress = {};
    __webpack_require__.l = function(url, done) {
      if (inProgress[url]) { inProgress[url].push(done); return; }
        inProgress[url] = [done];
        var onComplete = function(event) {
          clearTimeout(timeout);
          var doneFns = inProgress[url];
          delete inProgress[url];
          doneFns && doneFns.forEach(function(fn){fn(event)});
        }
        var timeout = setTimeout(onComplete.bind(null, undefined, { type: "timeout" }), 120000);
      import(url).then(function() {
        onComplete({
          type: "load"
        })
      }, function (error) {
        onComplete({
          type: "missing"
        })
      });
    };
  })();
  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  __webpack_require__.p = "ROOT_URL";
  __webpack_require__.oe = function(err) { console.error(err); throw err; };
  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE);
  return f;
}
`;
const moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@|!]+';
// additional chars when output.path info is true
const dependencyRegExp = '\\(\\s*(\/\\*.*?\\*\/)?\\s*.*?(' + moduleNameReqExp + ').*?\\)';
// http://stackoverflow.com/a/2593661/130442
function quoteRegExp(str) {
    return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}
function isNumeric(n) {
    // 1 * n converts integers, integers as string ("123"), 1e3 and "1e3" to integers and strings to NaN
    return !isNaN(n);
}
function getModuleDependencies(sources, module, queueName, requiredModules) {
    const retval = {};
    retval[queueName] = [];
    let fnString = module.toString();
    const wrapperSignature = fnString.match(/^(function)?\s?\w*\(\w+,\s*(\w+),\s*(\w+)\)/);
    if (!wrapperSignature) {
        return retval;
    }
    const webpackRequireName = wrapperSignature[3];
    if (!requiredModules.__webpack_exports_process__) {
        requiredModules.__webpack_require__ = webpackRequireName;
        requiredModules.__webpack_exports__ = wrapperSignature[2];
        requiredModules.__webpack_exports_process__ = true;
    }
    // main bundle deps
    let re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g');
    let match;
    while ((match = re.exec(fnString))) {
        if (match[3] === 'dll-reference') {
            continue;
        }
        retval[queueName].push(match[3]);
    }
    // dll deps
    re = new RegExp('\\(' + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, 'g');
    while ((match = re.exec(fnString))) {
        if (!sources[match[2]]) {
            retval[queueName].push(match[1]);
            // @ts-ignore
            sources[match[2]] = __webpack_require__(match[1]).m;
        }
        retval[match[2]] = retval[match[2]] || [];
        retval[match[2]].push(match[4]);
    }
    // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3
    const keys = Object.keys(retval);
    for (let i = 0; i < keys.length; i++) {
        for (let j = 0; j < retval[keys[i]].length; j++) {
            if (isNumeric(+retval[keys[i]][j])) {
                retval[keys[i]][j] = +retval[keys[i]][j];
            }
        }
    }
    return retval;
}
function hasValuesInQueues(queues) {
    const keys = Object.keys(queues);
    return keys.reduce(function (hasValues, key) {
        return hasValues || queues[key].length > 0;
    }, false);
}
function getRequiredModules(sources, moduleId) {
    const modulesQueue = {
        main: [moduleId]
    };
    const requiredModules = {
        main: [],
        __webpack_exports__: '__webpack_exports__',
        __webpack_require__: '__webpack_require__',
        __webpack_exports_process__: false
    };
    const seenModules = {
        main: {}
    };
    while (hasValuesInQueues(modulesQueue)) {
        const queues = Object.keys(modulesQueue);
        for (let i = 0; i < queues.length; i++) {
            let queueName = queues[i];
            let queue = modulesQueue[queueName];
            let moduleToCheck = queue.pop();
            seenModules[queueName] = seenModules[queueName] || {};
            if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) {
                continue;
            }
            seenModules[queueName][moduleToCheck] = true;
            requiredModules[queueName] = requiredModules[queueName] || [];
            requiredModules[queueName].push(moduleToCheck);
            let newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName, requiredModules);
            let newModulesKeys = Object.keys(newModules);
            for (let j = 0; j < newModulesKeys.length; j++) {
                modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || [];
                modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]]);
            }
        }
    }
    return requiredModules;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(moduleId, options) {
    const sources = {
        // @ts-ignore
        main: __webpack_require__.m
    };
    const requiredModules = getRequiredModules(sources, moduleId);
    let src = '';
    let stringifyModuleId = JSON.stringify(moduleId);
    return src + 'var ' + options.varName + '=(' + webpackBootstrapFunc.replace('ENTRY_MODULE', stringifyModuleId)
        // @ts-ignore
        .replace('ROOT_URL', __webpack_require__.p || '')
        // @ts-ignore
        .replace('LIBRARY_EXPORT_NAME', 'AVPlayer')
        // @ts-ignore
        .replace('LIB_NAME', __webpack_require__.u && __webpack_require__.u('') || '')
        + ')({' + requiredModules.main.map(function (id) {
        const stringifyId = JSON.stringify(id);
        let source = '' + stringifyId + ': ' + sources.main[id].toString();
        if (stringifyId === stringifyModuleId && options.exportName && options.pointName) {
            const line = `;${requiredModules.__webpack_require__}.d(
          ${requiredModules.__webpack_exports__},
          "${options.exportName}",
          function() {
            if (${options.exportIsClass}) {
              for (var key in ${requiredModules.__webpack_exports__}) {
                if (key === '${options.exportName}') {
                  continue;
                }
                var v = ${requiredModules.__webpack_exports__}[key];
                if (typeof v === 'function' && v.name === '${options.pointName}') {
                  return v;
                }
              }
            }
            return ${options.pointName};
          }
        );`;
            source = source.slice(0, source.length - 1) + line + '}';
        }
        return source;
    }).join(',') + '});';
}


/***/ }),

/***/ "./src/common/function/split.ts":
/*!**************************************!*\
  !*** ./src/common/function/split.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ split)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/**
 * @file 拆解字符串，并 trim 每个部分
 */


/**
 * 拆解字符串，并 trim 每个部分
 *
 * @param str 字符串
 * @param sep 分隔符
 */
function split(str, sep) {
    const result = [];
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.number(str)) {
        str = str + '';
    }
    if (str && _util_is__WEBPACK_IMPORTED_MODULE_0__.string(str)) {
        _util_array__WEBPACK_IMPORTED_MODULE_1__.each(str.split(sep), (part, index) => {
            part = part.trim();
            if (part) {
                result.push(part);
            }
        });
    }
    return result;
}


/***/ }),

/***/ "./src/common/function/toNumber.ts":
/*!*****************************************!*\
  !*** ./src/common/function/toNumber.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toNumber)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 强转为 number
 */


/**
 * 强转为 number
 *
 * @param target 待转换值
 * @param defaultValue 默认值
 *
 * @returns 转换之后的值
 */
function toNumber(target, defaultValue) {
    return _util_is__WEBPACK_IMPORTED_MODULE_0__.numeric(target)
        ? +target
        : defaultValue !== _util_constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED
            ? defaultValue
            : 0;
}


/***/ }),

/***/ "./src/common/function/toString.ts":
/*!*****************************************!*\
  !*** ./src/common/function/toString.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toString)
/* harmony export */ });
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 强转为 string
 */

/**
 * 强转为 string
 *
 * @param target 待转换的值
 * @param defaultValue 默认值
 * @returns 转换之后的值
 */
function toString(target, defaultValue) {
    return target != _util_constant__WEBPACK_IMPORTED_MODULE_0__.NULL && target.toString
        ? target.toString()
        : defaultValue !== _util_constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED
            ? defaultValue
            : _util_constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STRING;
}


/***/ }),

/***/ "./src/common/interface/ArrayLike.ts":
/*!*******************************************!*\
  !*** ./src/common/interface/ArrayLike.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ArrayLike)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");

class ArrayLike {
    proxy;
    constructor() {
        this.proxy = new Proxy(this, {
            get(target, p, receiver) {
                if (_util_is__WEBPACK_IMPORTED_MODULE_0__.numeric(p)) {
                    return target.getIndexValue(+p);
                }
                else {
                    return target[p];
                }
            },
            set(target, p, newValue, receiver) {
                if (_util_is__WEBPACK_IMPORTED_MODULE_0__.numeric(p)) {
                    target.setIndexValue(+p, newValue);
                }
                else {
                    target[p] = newValue;
                }
                return true;
            }
        });
    }
}


/***/ }),

/***/ "./src/common/io/BitReader.ts":
/*!************************************!*\
  !*** ./src/common/io/BitReader.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BitReader)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\common\\io\\BitReader.ts";

class BitReader {
    buffer;
    pointer;
    bitsLeft;
    size;
    endPointer;
    error;
    onFlush;
    /**
     * @param data 待读取的字节
     * @param bigEndian 是否按大端字节序读取，默认大端字节序（网络字节序）
     */
    constructor(size = 1048576) {
        this.pointer = 0;
        this.bitsLeft = 8;
        this.size = size;
        this.endPointer = 0;
        this.error = 0;
        this.buffer = new Uint8Array(this.size);
    }
    /**
     * 不影响原读取操作的情况下，读取 1 个比特
     */
    peekU1() {
        let result = 0;
        if (this.remainingLength() < 1 || this.remainingLength() === 1 && this.bitsLeft === 0) {
            this.flush();
        }
        let pointer = this.pointer;
        let bitsLeft = this.bitsLeft;
        if (bitsLeft === 0) {
            pointer++;
            bitsLeft = 8;
        }
        result = (this.buffer[pointer] >> (bitsLeft - 1)) & 0x01;
        return result;
    }
    /**
     * 读取 1 个比特
     */
    readU1() {
        let result = 0;
        if (this.remainingLength() < 1 || this.remainingLength() === 1 && this.bitsLeft === 0) {
            this.flush();
        }
        this.bitsLeft--;
        result = (this.buffer[this.pointer] >> this.bitsLeft) & 0x01;
        if (this.bitsLeft === 0) {
            this.pointer++;
            this.bitsLeft = 8;
        }
        return result;
    }
    /**
     * 读取 n 个比特
     *
     * @param n
     */
    readU(n) {
        let result = 0;
        for (let i = 0; i < n; i++) {
            result |= (this.readU1() << (n - i - 1));
        }
        return result;
    }
    /**
     * 获取剩余可读字节数
     *
     * @returns
     */
    remainingLength() {
        return this.endPointer - this.pointer;
    }
    getPos() {
        return this.pointer;
    }
    skip(n) {
        const byte = (n - (n % 8)) / 8;
        this.pointer += byte;
        const bitsLeft = n % 8;
        if (this.bitsLeft <= bitsLeft) {
            this.pointer++;
            this.bitsLeft = 8 - (bitsLeft - this.bitsLeft);
        }
        else {
            this.bitsLeft -= bitsLeft;
        }
    }
    flush() {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOReader error, flush failed because of no flush callback');
        }
        if (this.bitsLeft === 0) {
            this.pointer++;
        }
        if (this.size - this.remainingLength() <= 0) {
            return;
        }
        if (this.pointer < this.endPointer) {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            const len = this.onFlush(this.buffer.subarray(this.endPointer - this.pointer, this.size));
            if (len < 0) {
                this.error = len;
                throw Error('IOReader error, flush failed');
            }
            this.endPointer = this.endPointer - this.pointer + len;
            this.pointer = 0;
        }
        else {
            const len = this.onFlush(this.buffer);
            this.endPointer = len;
            this.pointer = 0;
            this.bitsLeft = 8;
            if (len < 0) {
                this.error = len;
                throw Error('IOReader error, flush failed');
            }
        }
    }
    getBuffer() {
        return this.buffer;
    }
    appendBuffer(buffer) {
        if (this.size - this.endPointer >= buffer.length) {
            this.buffer.set(buffer, this.endPointer);
            this.endPointer += buffer.length;
        }
        else {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            this.endPointer = this.endPointer - this.pointer;
            this.pointer = 0;
            if (this.size - this.endPointer >= buffer.length) {
                this.buffer.set(buffer, this.endPointer);
                this.endPointer += buffer.length;
            }
            else {
                const len = Math.min(this.size - this.endPointer, buffer.length);
                this.buffer.set(buffer.subarray(0, len), this.endPointer);
                this.endPointer += len;
                _util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('BSReader, call appendBuffer but the buffer\'s size is lagger then the remaining size', cheap__fileName__0, 190);
            }
        }
    }
    clear() {
        this.pointer = this.endPointer = 0;
        this.bitsLeft = 8;
        this.error = 0;
    }
    skipPadding() {
        if (this.bitsLeft < 8) {
            this.bitsLeft = 8;
            this.pointer++;
        }
    }
}


/***/ }),

/***/ "./src/common/io/BitWriter.ts":
/*!************************************!*\
  !*** ./src/common/io/BitWriter.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BitWriter)
/* harmony export */ });
/**
 * bit 写存器
 */
/**
 * 写字节流工具
 */
class BitWriter {
    buffer;
    pointer;
    bitPointer;
    size;
    error;
    onFlush;
    /**
     * @param data 待写的 Uint8Array
     */
    constructor(size = 1048576) {
        this.pointer = 0;
        this.bitPointer = 0;
        this.size = size;
        this.error = 0;
        this.buffer = new Uint8Array(this.size);
    }
    /**
     * 写一个 bit
     *
     * @param bit
     */
    writeU1(bit) {
        if (this.remainingLength() < 1 || this.remainingLength() === 1 && this.bitPointer >= 8) {
            this.flush();
        }
        if (bit & 0x01) {
            this.buffer[this.pointer] |= (1 << (7 - this.bitPointer));
        }
        else {
            this.buffer[this.pointer] &= ~(1 << (7 - this.bitPointer));
        }
        this.bitPointer++;
        if (this.bitPointer === 8) {
            this.pointer++;
            this.bitPointer = 0;
        }
    }
    /**
     * 写 n 个比特
     *
     * @param n
     */
    writeU(n, v) {
        for (let i = 0; i < n; i++) {
            this.writeU1(v >> (n - i - 1) & 0x01);
        }
    }
    /**
     * 获取剩余可写节数
     *
     * @returns
     */
    remainingLength() {
        return this.size - this.pointer;
    }
    flush() {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('BSWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            if (this.bitPointer && this.pointer > 1) {
                const ret = this.onFlush(this.buffer.subarray(0, this.pointer - 1));
                if (ret !== 0) {
                    this.error = ret;
                    throw Error('BSWriter error, flush failed');
                }
                this.buffer[0] = this.buffer[this.pointer];
            }
            else if (this.bitPointer === 0) {
                const ret = this.onFlush(this.buffer.subarray(0, this.pointer));
                if (ret !== 0) {
                    this.error = ret;
                    throw Error('BSWriter error, flush failed');
                }
            }
        }
        this.pointer = 0;
    }
    padding() {
        while (this.bitPointer !== 0) {
            this.writeU1(0);
        }
    }
    clear() {
        this.pointer = 0;
        this.bitPointer = 0;
        this.error = 0;
    }
    getBuffer() {
        return this.buffer;
    }
    getPointer() {
        return this.pointer;
    }
}


/***/ }),

/***/ "./src/common/io/BufferReader.ts":
/*!***************************************!*\
  !*** ./src/common/io/BufferReader.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BufferReader)
/* harmony export */ });
/* harmony import */ var _function_concatTypeArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function/concatTypeArray */ "./src/common/function/concatTypeArray.ts");
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/**
 * 读字节流工具
 */


class BufferReader {
    data;
    buffer;
    byteStart;
    pos;
    size;
    littleEndian;
    /**
     * @param data 待读取的字节
     * @param bigEndian 是否按大端字节序读取，默认大端字节序（网络字节序）
     */
    constructor(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
    /**
     * 读取 8 位无符号整数
     *
     * @returns
     */
    readUint8() {
        return this.data.getUint8(this.pos++ + this.byteStart);
    }
    /**
     * 读取 16 位无符号整数
     *
     * @returns
     */
    readUint16() {
        const value = this.data.getUint16(this.pos + this.byteStart, this.littleEndian);
        this.pos += 2;
        return value;
    }
    /**
     * 读取 24 位无符号整数
     *
     * @returns
     */
    readUint24() {
        const high = this.readUint16();
        const low = this.readUint8();
        return high << 8 | low;
    }
    /**
     * 读取 32 位无符号整数
     *
     * @returns
     */
    readUint32() {
        const value = this.data.getUint32(this.pos + this.byteStart, this.littleEndian);
        this.pos += 4;
        return value;
    }
    /**
     * 读取 64 位无符号整数
     *
     * @returns
     */
    readUint64() {
        const high = BigInt(this.readUint32());
        const low = BigInt(this.readUint32());
        if (this.littleEndian) {
            return low << BigInt(32) | high;
        }
        else {
            return high << BigInt(32) | low;
        }
    }
    /**
     * 读取 8 位有符号整数
     *
     * @returns
     */
    readInt8() {
        return this.data.getInt8(this.pos++ + this.byteStart);
    }
    /**
     * 读取 16 位有符号整数
     *
     * @returns
     */
    readInt16() {
        const value = this.data.getInt16(this.pos + this.byteStart, this.littleEndian);
        this.pos += 2;
        return value;
    }
    /**
     * 读取 32 位有符号整数
     *
     * @returns
     */
    readInt32() {
        const value = this.data.getInt32(this.pos + this.byteStart, this.littleEndian);
        this.pos += 4;
        return value;
    }
    /**
     * 读取 64 位有符号整数
     *
     * @returns
     */
    readInt64() {
        const high = BigInt(this.readInt32());
        const low = BigInt(this.readInt32());
        if (this.littleEndian) {
            return low << BigInt(32) | high;
        }
        else {
            return high << BigInt(32) | low;
        }
    }
    /**
     * 读取单精度浮点数
     *
     * @returns
     */
    readFloat() {
        const value = this.data.getFloat32(this.pos + this.byteStart, this.littleEndian);
        this.pos += 4;
        return value;
    }
    /**
     * 读取双精度浮点数
     *
     * @returns
     */
    readDouble() {
        const value = this.data.getFloat64(this.pos + this.byteStart, this.littleEndian);
        this.pos += 8;
        return value;
    }
    /**
     * 读取指定长度的字节，并以 16 进制字符串返回
     *
     * @param length 默认 1
     * @returns
     */
    readHex(length = 1) {
        let hexStr = '';
        for (let i = 0; i < length; i++) {
            const hex = this.readUint8().toString(16);
            hexStr += (hex.length === 1 ? '0' + hex : hex);
        }
        return hexStr;
    }
    /**
     * 读取指定长度的字符串
     *
     * @param length 默认 1
     * @returns
     */
    readString(length = 1) {
        let str = '';
        if (length) {
            let start = this.pos;
            for (let i = 0; i < length; i++) {
                if (this.buffer[this.pos + i] === 0) {
                    start++;
                }
                else {
                    break;
                }
            }
            str = _util_text__WEBPACK_IMPORTED_MODULE_1__.decode(this.buffer.subarray(start, start + length));
        }
        this.pos += length;
        return str;
    }
    /**
     * 读取一行字符
     */
    readLine() {
        let str = '';
        for (let i = this.pos; i < this.size; i++) {
            if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                str += this.readString(i - this.pos);
                break;
            }
        }
        for (let i = this.pos; i < this.size; i++) {
            if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                this.readUint8();
            }
            else {
                break;
            }
        }
        return str;
    }
    /**
     * 获取当前读取指针
     *
     * @returns
     */
    getPos() {
        return BigInt(this.pos);
    }
    /**
     * seek 读取指针
     *
     * @param pos
     */
    seek(pos) {
        if (pos > this.size) {
            pos = this.size;
        }
        this.pos = Math.max(0, pos);
    }
    /**
     * 跳过指定字节长度
     *
     * @param length
     */
    skip(length) {
        this.seek(this.pos + length);
    }
    /**
     * 返回指定字节长度
     *
     * @param length
     */
    back(length) {
        this.seek(this.pos - length);
    }
    /**
     * 获取剩余可读字节数
     *
     * @returns
     */
    remainingSize() {
        return this.size - this.pos;
    }
    /**
     * 读取指定长度的二进制 buffer 数据
     *
     * @param length
     * @returns
     */
    readBuffer(length) {
        length = Math.min(length, this.remainingSize());
        const buffer = this.buffer.slice(this.pos, this.pos + length);
        this.pos += length;
        return buffer;
    }
    /**
     * 追加 buffer
     *
     * @param buffer
     */
    appendBuffer(buffer) {
        this.buffer = (0,_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_0__["default"])(Uint8Array, [
            this.buffer.slice(),
            buffer.slice()
        ]);
        this.data = new DataView(this.buffer.buffer);
        this.size += buffer.byteLength;
        this.byteStart = 0;
    }
    resetBuffer(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
}


/***/ }),

/***/ "./src/common/io/BufferWriter.ts":
/*!***************************************!*\
  !*** ./src/common/io/BufferWriter.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BufferWriter)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
var cheap__fileName__0 = "src\\common\\io\\BufferWriter.ts";
/**
 * 写字节流工具
 */


class BufferWriter {
    data;
    buffer;
    byteStart;
    pos;
    size;
    littleEndian;
    /**
     * @param data 待写的 Uint8Array
     * @param bigEndian 是否按大端字节序写，默认大端字节序（网络字节序）
     */
    constructor(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
    /**
     * 写 8 位无符号整数
     */
    writeUint8(value) {
        this.data.setUint8(this.pos++ + this.byteStart, value);
    }
    /**
     * 读取 16 位无符号整数
     */
    writeUint16(value) {
        this.data.setUint16(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 2;
    }
    /**
     * 写 24 位无符号整数
     */
    writeUint24(value) {
        const high = value & 0xf00;
        const middle = value & 0x0f0;
        const low = value & 0x00f;
        if (this.littleEndian) {
            this.writeUint8(low);
            this.writeUint8(middle);
            this.writeUint8(high);
        }
        else {
            this.writeUint8(high);
            this.writeUint8(middle);
            this.writeUint8(low);
        }
    }
    /**
     * 写 32 位无符号整数
     */
    writeUint32(value) {
        this.data.setUint32(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 4;
    }
    /**
     * 写 64 位无符号整数
     */
    writeUint64(value) {
        const low = value & BigInt(0xffffffff);
        const high = (value & (BigInt(0xffffffff) << BigInt(32))) >> BigInt(32);
        if (this.littleEndian) {
            this.writeUint32(Number(low));
            this.writeUint32(Number(high));
        }
        else {
            this.writeUint32(Number(high));
            this.writeUint32(Number(low));
        }
    }
    /**
     * 写 8 位有符号整数
     *
     * @returns
     */
    writeInt8(value) {
        this.data.setInt8(this.pos++ + this.byteStart, value);
    }
    /**
     * 写 16 位有符号整数
     */
    writeInt16(value) {
        this.data.setInt16(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 2;
    }
    /**
     * 写 32 位有符号整数
     */
    writeInt32(value) {
        this.data.setInt32(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 4;
    }
    /**
     * 写 64 位有符号整数
     */
    writeInt64(value) {
        const low = value & BigInt(0xffffffff);
        const high = (value & (BigInt(0xffffffff) << BigInt(32))) >> BigInt(32);
        if (this.littleEndian) {
            this.writeInt32(Number(low));
            this.writeInt32(Number(high));
        }
        else {
            this.writeInt32(Number(high));
            this.writeInt32(Number(low));
        }
    }
    /**
     * 写单精度浮点数
     *
     * @returns
     */
    writeFloat(value) {
        this.data.setFloat32(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 4;
    }
    /**
     * 写双精度浮点数
     */
    writeDouble(value) {
        this.data.setFloat64(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 8;
    }
    /**
     * 获取当前写指针
     *
     * @returns
     */
    getPos() {
        return this.pos;
    }
    /**
     * seek 写指针
     *
     * @param pos
     */
    seek(pos) {
        if (pos > this.size) {
            pos = this.size;
        }
        this.pos = Math.max(0, pos);
    }
    /**
     * 跳过指定字节长度
     *
     * @param length
     */
    skip(length) {
        this.seek(this.pos + length);
    }
    /**
     * 返回指定字节长度
     *
     * @param length
     */
    back(length) {
        this.seek(this.pos - length);
    }
    /**
     * 获取剩余可写节数
     *
     * @returns
     */
    remainingSize() {
        return this.size - this.pos;
    }
    /**
     * 写指定长度的二进制 buffer 数据
     *
     * @param length
     * @returns
     */
    writeBuffer(buffer) {
        let length = buffer.length;
        if (this.remainingSize() < length) {
            length = this.remainingSize();
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.warn(`the remaining buffer size is smaller then the wrote buffer, hope set ${buffer.length}, but set ${length}`, cheap__fileName__0, 211);
        }
        this.buffer.set(buffer, this.pos);
        this.pos += buffer.length;
    }
    /**
     * 写一个字符串
     */
    writeString(str) {
        const buffer = _util_text__WEBPACK_IMPORTED_MODULE_1__.encode(str);
        this.writeBuffer(buffer);
        return buffer.length;
    }
    getWroteBuffer() {
        return this.buffer.subarray(0, this.pos);
    }
    resetBuffer(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
}


/***/ }),

/***/ "./src/common/io/IOReader.ts":
/*!***********************************!*\
  !*** ./src/common/io/IOReader.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOReader)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/* harmony import */ var _timer_Sleep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../timer/Sleep */ "./src/common/timer/Sleep.ts");
var cheap__fileName__0 = "src\\common\\io\\IOReader.ts";



class IOReader {
    data;
    buffer;
    pointer;
    endPointer;
    pos;
    size;
    littleEndian;
    fileSize_;
    error;
    onFlush;
    onSeek;
    onSize;
    flags;
    /**
     * @param data 待读取的字节
     * @param bigEndian 是否按大端字节序读取，默认大端字节序（网络字节序）
     */
    constructor(size = 1048576, bigEndian = true, map) {
        this.pos = BigInt(0);
        this.pointer = 0;
        this.error = 0;
        this.endPointer = 0;
        this.littleEndian = !bigEndian;
        this.flags = 0;
        if (map && map.view) {
            this.size = map.length;
            this.buffer = map;
            this.data = map.view;
        }
        else if (map && !map.byteOffset) {
            this.size = map.length;
            this.buffer = map;
            this.data = new DataView(this.buffer.buffer);
        }
        else {
            if (map) {
                throw new Error('not support subarray of ArrayBuffer');
            }
            this.size = Math.max(size, 102400);
            this.buffer = new Uint8Array(this.size);
            this.data = new DataView(this.buffer.buffer);
        }
    }
    /**
     * 读取 8 位无符号整数
     *
     * @returns
     */
    async readUint8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        const value = this.data.getUint8(this.pointer);
        this.pointer++;
        this.pos++;
        return value;
    }
    async peekUint8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        return this.data.getUint8(this.pointer);
    }
    /**
     * 读取 16 位无符号整数
     *
     * @returns
     */
    async readUint16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        const value = this.data.getUint16(this.pointer, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
        return value;
    }
    async peekUint16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        return this.data.getUint16(this.pointer, this.littleEndian);
    }
    /**
     * 读取 24 位无符号整数
     *
     * @returns
     */
    async readUint24() {
        if (this.remainingLength() < 3) {
            await this.flush(3);
        }
        const high = await this.readUint16();
        const low = await this.readUint8();
        return high << 8 | low;
    }
    async peekUint24() {
        if (this.remainingLength() < 3) {
            await this.flush(3);
        }
        const pointer = this.pointer;
        const pos = this.pos;
        const high = await this.readUint16();
        const low = await this.readUint8();
        const value = high << 8 | low;
        this.pointer = pointer;
        this.pos = pos;
        return value;
    }
    /**
     * 读取 32 位无符号整数
     *
     * @returns
     */
    async readUint32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        const value = this.data.getUint32(this.pointer, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
        return value;
    }
    async peekUint32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        return this.data.getUint32(this.pointer, this.littleEndian);
    }
    /**
     * 读取 64 位无符号整数
     *
     * @returns
     */
    async readUint64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        const value = this.data.getBigUint64(this.pointer, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
        return value;
    }
    async peekUint64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        return this.data.getBigUint64(this.pointer, this.littleEndian);
    }
    /**
     * 读取 8 位有符号整数
     *
     * @returns
     */
    async readInt8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        const value = this.data.getInt8(this.pointer);
        this.pointer++;
        this.pos++;
        return value;
    }
    async peekInt8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        return this.data.getInt8(this.pointer);
    }
    /**
     * 读取 16 位有符号整数
     *
     * @returns
     */
    async readInt16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        const value = this.data.getInt16(this.pointer, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
        return value;
    }
    async peekInt16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        return this.data.getInt16(this.pointer, this.littleEndian);
    }
    /**
     * 读取 32 位有符号整数
     *
     * @returns
     */
    async readInt32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        const value = this.data.getInt32(this.pointer, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
        return value;
    }
    async peekInt32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        return this.data.getInt32(this.pointer, this.littleEndian);
    }
    /**
     * 读取 64 位有符号整数
     *
     * @returns
     */
    async readInt64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        const value = this.data.getBigInt64(this.pointer, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
        return value;
    }
    async peekInt64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        return this.data.getBigInt64(this.pointer, this.littleEndian);
    }
    /**
     * 读取单精度浮点数
     *
     * @returns
     */
    async readFloat() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        const value = this.data.getFloat32(this.pointer, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
        return value;
    }
    async peekFloat() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        return this.data.getFloat32(this.pointer, this.littleEndian);
    }
    /**
     * 读取双精度浮点数
     *
     * @returns
     */
    async readDouble() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        const value = this.data.getFloat64(this.pointer, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
        return value;
    }
    async peekDouble() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        return this.data.getFloat64(this.pointer, this.littleEndian);
    }
    /**
     * 读取指定长度的字节，并以 16 进制字符串返回
     *
     * @param length 默认 1
     * @returns
     */
    async readHex(length = 1) {
        let hexStr = '';
        for (let i = 0; i < length; i++) {
            const hex = (await this.readUint8()).toString(16);
            hexStr += (hex.length === 1 ? '0' + hex : hex);
        }
        return hexStr;
    }
    async peekHex(length = 1) {
        if (length > this.size) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('peekHex, length too large', cheap__fileName__0, 334);
        }
        if (this.remainingLength() < length) {
            await this.flush(length);
        }
        const pointer = this.pointer;
        const pos = this.pos;
        let hexStr = '';
        for (let i = 0; i < length; i++) {
            const hex = (await this.readUint8()).toString(16);
            hexStr += (hex.length === 1 ? '0' + hex : hex);
        }
        this.pointer = pointer;
        this.pos = pos;
        return hexStr;
    }
    async readBuffer(length, buffer) {
        if (!buffer) {
            buffer = new Uint8Array(length);
        }
        if (this.remainingLength() < length) {
            let index = 0;
            if (this.remainingLength() > 0) {
                const len = this.remainingLength();
                buffer.set(this.buffer.subarray(this.pointer, this.pointer + len), index);
                index += len;
                this.pointer += len;
                this.pos += BigInt(len);
                length -= len;
            }
            while (length > 0) {
                await this.flush();
                const len = Math.min(this.endPointer - this.pointer, length);
                buffer.set(this.buffer.subarray(this.pointer, this.pointer + len), index);
                index += len;
                this.pointer += len;
                this.pos += BigInt(len);
                length -= len;
            }
        }
        else {
            buffer.set(this.buffer.subarray(this.pointer, this.pointer + length), 0);
            this.pointer += length;
            this.pos += BigInt(length);
        }
        return buffer;
    }
    async readToBuffer(length, buffer) {
        if (this.remainingLength() < length) {
            let index = 0;
            if (this.remainingLength() > 0) {
                const len = this.remainingLength();
                buffer.set(this.buffer.subarray(this.pointer, this.pointer + len), index);
                index += len;
                this.pointer += len;
                this.pos += BigInt(len);
                length -= len;
            }
            while (length > 0) {
                try {
                    await this.flush();
                }
                catch (error) {
                    if (this.error === -1048576 /* IOError.END */ && index) {
                        return index;
                    }
                    else {
                        throw error;
                    }
                }
                const len = Math.min(this.endPointer - this.pointer, length);
                buffer.set(this.buffer.subarray(this.pointer, this.pointer + len), index);
                index += len;
                this.pointer += len;
                this.pos += BigInt(len);
                length -= len;
            }
            return index;
        }
        else {
            buffer.set(this.buffer.subarray(this.pointer, this.pointer + length), 0);
            this.pointer += length;
            this.pos += BigInt(length);
            return length;
        }
    }
    async peekBuffer(length, buffer) {
        if (length > this.size) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('peekBuffer, length too large', cheap__fileName__0, 455);
        }
        if (this.remainingLength() < length) {
            await this.flush(length);
        }
        if (!buffer) {
            buffer = new Uint8Array(length);
        }
        buffer.set(this.buffer.subarray(this.pointer, this.pointer + length), 0);
        return buffer;
    }
    /**
     * 读取指定长度的字符串
     *
     * @param length 默认 1
     * @returns
     */
    async readString(length = 1) {
        const buffer = await this.readBuffer(length);
        return _util_text__WEBPACK_IMPORTED_MODULE_1__.decode(buffer);
    }
    async peekString(length = 1) {
        const buffer = await this.peekBuffer(length);
        return _util_text__WEBPACK_IMPORTED_MODULE_1__.decode(buffer);
    }
    /**
     * 读取一行字符
     */
    async readLine() {
        let str = '';
        while (true) {
            let got = false;
            for (let i = this.pointer; i < this.endPointer; i++) {
                if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                    if (i !== this.pointer) {
                        str += await this.readString(i - this.pointer);
                    }
                    got = true;
                    break;
                }
            }
            if (!got) {
                str += await this.readString(this.remainingLength());
                await this.flush();
            }
            else {
                break;
            }
        }
        let next = await this.peekUint8();
        if (next === 0x0a || next === 0x0d) {
            this.pointer++;
            if (next === 0x0d) {
                next = await this.peekUint8();
                // \r\n
                if (next === 0x0a) {
                    this.pointer++;
                }
            }
        }
        return str;
    }
    async peekLine() {
        if (this.remainingLength() < this.size) {
            try {
                await this.flush();
            }
            catch (error) {
                if (this.error !== -1048576 /* IOError.END */) {
                    throw error;
                }
            }
        }
        let str = '';
        let got = false;
        for (let i = this.pointer; i < this.endPointer; i++) {
            if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                str += await this.peekString(i - this.pointer);
                got = true;
                break;
            }
        }
        if (!got) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('peekLine, out of buffer', cheap__fileName__0, 552);
        }
        return str;
    }
    /**
     * 获取当前读取指针
     *
     * @returns
     */
    getPointer() {
        return this.pointer;
    }
    /**
     * 获取已读字节偏移
     *
     * @returns
     */
    getPos() {
        return this.pos;
    }
    /**
     * 跳过指定字节长度
     *
     * @param length
     */
    async skip(length) {
        const backup = length;
        while (this.remainingLength() < length) {
            length -= this.remainingLength();
            this.pointer = this.endPointer;
            await this.flush();
        }
        if (this.remainingLength() >= length) {
            this.pointer += length;
        }
        this.pos += BigInt(backup);
    }
    /**
     * 获取剩余可读字节数
     *
     * @returns
     */
    remainingLength() {
        return this.endPointer - this.pointer;
    }
    async flush_(buffer) {
        while (true) {
            const len = await this.onFlush(buffer);
            if (len !== -1048575 /* IOError.AGAIN */) {
                return len;
            }
            await new _timer_Sleep__WEBPACK_IMPORTED_MODULE_2__["default"](0);
        }
    }
    async flush(need = 0) {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('IOReader error, flush failed because of no flush callback', cheap__fileName__0, 620);
        }
        if (this.size - this.remainingLength() <= 0) {
            return;
        }
        need = Math.min(need, this.size);
        if (this.pointer < this.endPointer) {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            this.endPointer = this.endPointer - this.pointer;
        }
        else {
            this.endPointer = 0;
        }
        this.pointer = 0;
        if (need) {
            while (this.remainingLength() < need) {
                const len = await this.flush_(this.buffer.subarray(this.endPointer));
                if (len < 0) {
                    this.error = len;
                    throw new Error(`IOReader error, flush ${len === -1048576 /* IOError.END */ ? 'ended' : 'failed'}, ret: ${len}`);
                }
                this.endPointer += len;
            }
        }
        else {
            const len = await this.flush_(this.buffer.subarray(this.endPointer));
            if (len < 0) {
                this.error = len;
                throw new Error(`IOReader error, flush ${len === -1048576 /* IOError.END */ ? 'ended' : 'failed'}, ret: ${len}`);
            }
            this.endPointer += len;
        }
    }
    async seek(pos, force = false, flush = true) {
        if (!force) {
            const len = Number(pos - this.pos);
            // 可以往回 seek
            if (len < 0 && Math.abs(len) < this.pointer) {
                this.pointer += len;
                this.pos = pos;
                return;
            }
            // 可以直接往后 seek
            else if (len > 0 && this.pointer + len < this.endPointer) {
                this.pointer += len;
                this.pos = pos;
                return;
            }
            else if (len === 0) {
                return;
            }
        }
        if (!this.onSeek) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('IOReader error, seek failed because of no seek callback', cheap__fileName__0, 681);
        }
        this.pointer = this.endPointer = 0;
        this.pos = pos;
        const ret = await this.onSeek(pos);
        if (ret !== 0) {
            this.error = ret;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('IOReader error, seek failed', cheap__fileName__0, 690);
        }
        if (flush) {
            await this.flush();
        }
    }
    getBuffer() {
        return this.buffer;
    }
    appendBuffer(buffer) {
        if (this.size - this.endPointer >= buffer.length) {
            this.buffer.set(buffer, this.endPointer);
            this.endPointer += buffer.length;
        }
        else {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            this.endPointer = this.endPointer - this.pointer;
            this.pointer = 0;
            if (this.size - this.endPointer >= buffer.length) {
                this.buffer.set(buffer, this.endPointer);
                this.endPointer += buffer.length;
            }
            else {
                const len = Math.min(this.size - this.endPointer, buffer.length);
                this.buffer.set(buffer.subarray(0, len), this.endPointer);
                this.endPointer += len;
                _util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('IOReader, call appendBuffer but the buffer\'s size is lagger then the remaining size', cheap__fileName__0, 720);
            }
        }
    }
    reset() {
        this.pointer = this.endPointer = 0;
        this.pos = BigInt(0);
        this.error = 0;
    }
    setEndian(bigEndian) {
        this.littleEndian = !bigEndian;
    }
    async fileSize() {
        if (this.fileSize_) {
            return this.fileSize_;
        }
        if (!this.onSize) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('IOReader error, fileSize failed because of no onSize callback', cheap__fileName__0, 741);
        }
        this.fileSize_ = await this.onSize();
        return this.fileSize_;
    }
    getBufferSize() {
        return this.size;
    }
    async pipe(ioWriter, length) {
        if (length) {
            if (this.remainingLength() < length) {
                if (this.remainingLength() > 0) {
                    const len = this.remainingLength();
                    await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                    this.pointer += len;
                    this.pos += BigInt(len);
                    length -= len;
                }
                while (length > 0) {
                    await this.flush();
                    const len = Math.min(this.remainingLength(), length);
                    await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                    this.pointer += len;
                    this.pos += BigInt(len);
                    length -= len;
                }
            }
            else {
                await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + length));
                this.pointer += length;
                this.pos += BigInt(length);
            }
        }
        else {
            if (this.remainingLength() > 0) {
                const len = this.remainingLength();
                await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                this.pointer += len;
                this.pos += BigInt(len);
            }
            while (await this.flush_(this.buffer.subarray(0)) > 0) {
                const len = this.remainingLength();
                await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                this.pointer += len;
                this.pos += BigInt(len);
            }
        }
    }
}


/***/ }),

/***/ "./src/common/io/IOWriter.ts":
/*!***********************************!*\
  !*** ./src/common/io/IOWriter.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOWriter)
/* harmony export */ });
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/**
 * 写字节流工具
 */

class IOWriter {
    data;
    buffer;
    pointer;
    pos;
    size;
    littleEndian;
    error;
    onFlush;
    onSeek;
    /**
     * @param data 待写的 Uint8Array
     * @param bigEndian 是否按大端字节序写，默认大端字节序（网络字节序）
     */
    constructor(size = 1048576, bigEndian = true, map) {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.size = size;
        this.littleEndian = !bigEndian;
        this.error = 0;
        if (map && map.view) {
            this.size = map.length;
            this.buffer = map;
            this.data = map.view;
        }
        else if (map && !map.byteOffset) {
            this.size = map.length;
            this.buffer = map;
            this.data = new DataView(this.buffer.buffer);
        }
        else {
            if (map) {
                throw new Error('not support subarray of ArrayBuffer');
            }
            this.buffer = new Uint8Array(this.size);
            this.data = new DataView(this.buffer.buffer);
        }
    }
    /**
     * 写 8 位无符号整数
     */
    async writeUint8(value) {
        if (this.remainingLength() < 1) {
            await this.flush();
        }
        this.data.setUint8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     * 读取 16 位无符号整数
     */
    async writeUint16(value) {
        if (this.remainingLength() < 2) {
            await this.flush();
        }
        this.data.setUint16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     * 写 24 位无符号整数
     */
    async writeUint24(value) {
        if (this.remainingLength() < 3) {
            await this.flush();
        }
        const high = (value & 0xff0000) >> 16;
        const middle = (value & 0x00ff00) >> 8;
        const low = value & 0x0000ff;
        if (this.littleEndian) {
            await this.writeUint8(low);
            await this.writeUint8(middle);
            await this.writeUint8(high);
        }
        else {
            await this.writeUint8(high);
            await this.writeUint8(middle);
            await this.writeUint8(low);
        }
    }
    /**
     * 写 32 位无符号整数
     */
    async writeUint32(value) {
        if (this.remainingLength() < 4) {
            await this.flush();
        }
        this.data.setUint32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写 64 位无符号整数
     */
    async writeUint64(value) {
        if (this.remainingLength() < 8) {
            await this.flush();
        }
        this.data.setBigUint64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 写 8 位有符号整数
     *
     * @returns
     */
    async writeInt8(value) {
        if (this.remainingLength() < 1) {
            await this.flush();
        }
        this.data.setInt8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     * 写 16 位有符号整数
     */
    async writeInt16(value) {
        if (this.remainingLength() < 2) {
            await this.flush();
        }
        this.data.setInt16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     * 写 32 位有符号整数
     */
    async writeInt32(value) {
        if (this.remainingLength() < 4) {
            await this.flush();
        }
        this.data.setInt32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写 64 位有符号整数
     */
    async writeInt64(value) {
        if (this.remainingLength() < 8) {
            await this.flush();
        }
        this.data.setBigInt64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 写单精度浮点数
     *
     * @returns
     */
    async writeFloat(value) {
        if (this.remainingLength() < 4) {
            await this.flush();
        }
        this.data.setFloat32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写双精度浮点数
     */
    async writeDouble(value) {
        if (this.remainingLength() < 8) {
            await this.flush();
        }
        this.data.setFloat64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 获取当前写指针
     *
     * @returns
     */
    getPointer() {
        return this.pointer;
    }
    getPos() {
        return this.pos;
    }
    /**
     * 获取剩余可写节数
     *
     * @returns
     */
    remainingLength() {
        return this.size - this.pointer;
    }
    /**
     * 写指定长度的二进制 buffer 数据
     *
     * @param length
     * @returns
     */
    async writeBuffer(buffer) {
        if (!buffer.length) {
            return;
        }
        let length = buffer.length;
        if (this.remainingLength() < length) {
            let index = 0;
            while (length > 0) {
                await this.flush();
                const len = Math.min(this.size, length);
                this.buffer.set(buffer.subarray(index, index + len), this.pointer);
                this.pointer += len;
                this.pos += BigInt(len);
                index += len;
                length -= len;
            }
        }
        else {
            this.buffer.set(buffer, this.pointer);
            this.pointer += length;
            this.pos += BigInt(length);
        }
    }
    /**
     * 写一个字符串
     */
    async writeString(str) {
        const buffer = _util_text__WEBPACK_IMPORTED_MODULE_0__.encode(str);
        await this.writeBuffer(buffer);
        return buffer.length;
    }
    encodeString(str) {
        return _util_text__WEBPACK_IMPORTED_MODULE_0__.encode(str);
    }
    async flush() {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = await this.onFlush(this.buffer.subarray(0, this.pointer));
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    async flushToPos(pos) {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = await this.onFlush(this.buffer.subarray(0, this.pointer), pos);
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    async seek(pos) {
        if (!this.onSeek) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, seek failed because of no seek callback');
        }
        await this.flush();
        const ret = await this.onSeek(pos);
        if (ret !== 0) {
            this.error = ret;
            throw Error('IOWriter error, seek failed');
        }
        this.pos = pos;
    }
    seekInline(pos) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, Math.min(this.size, pos));
        this.pos += BigInt(this.pointer - pointer);
    }
    skip(length) {
        const pointer = this.pointer;
        this.pointer = Math.min(this.size, this.pointer + length);
        this.pos += BigInt(this.pointer - pointer);
    }
    back(length) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, this.pointer - length);
        this.pos += BigInt(this.pointer - pointer);
    }
    getBuffer() {
        return this.buffer.subarray(0, this.pointer);
    }
    setEndian(bigEndian) {
        this.littleEndian = !bigEndian;
    }
    reset() {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.error = 0;
    }
    getBufferSize() {
        return this.size;
    }
}


/***/ }),

/***/ "./src/common/io/IOWriterSync.ts":
/*!***************************************!*\
  !*** ./src/common/io/IOWriterSync.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOWriterSync)
/* harmony export */ });
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/**
 * 写字节流工具
 */

class IOWriterSync {
    data;
    buffer;
    pointer;
    pos;
    size;
    littleEndian;
    error;
    onFlush;
    onSeek;
    /**
     * @param data 待写的 Uint8Array
     * @param bigEndian 是否按大端字节序写，默认大端字节序（网络字节序）
     */
    constructor(size = 1048576, bigEndian = true, map) {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.size = size;
        this.littleEndian = !bigEndian;
        this.error = 0;
        if (map && map.view) {
            this.size = map.length;
            this.buffer = map;
            this.data = map.view;
        }
        else if (map && !map.byteOffset) {
            this.size = map.length;
            this.buffer = map;
            this.data = new DataView(this.buffer.buffer);
        }
        else {
            if (map) {
                throw new Error('not support subarray of ArrayBuffer');
            }
            this.buffer = new Uint8Array(this.size);
            this.data = new DataView(this.buffer.buffer);
        }
    }
    /**
     * 写 8 位无符号整数
     */
    writeUint8(value) {
        if (this.remainingLength() < 1) {
            this.flush();
        }
        this.data.setUint8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     * 读取 16 位无符号整数
     */
    writeUint16(value) {
        if (this.remainingLength() < 2) {
            this.flush();
        }
        this.data.setUint16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     * 写 24 位无符号整数
     */
    writeUint24(value) {
        if (this.remainingLength() < 3) {
            this.flush();
        }
        const high = (value & 0xff0000) >> 16;
        const middle = (value & 0x00ff00) >> 8;
        const low = value & 0x0000ff;
        if (this.littleEndian) {
            this.writeUint8(low);
            this.writeUint8(middle);
            this.writeUint8(high);
        }
        else {
            this.writeUint8(high);
            this.writeUint8(middle);
            this.writeUint8(low);
        }
    }
    /**
     * 写 32 位无符号整数
     */
    writeUint32(value) {
        if (this.remainingLength() < 4) {
            this.flush();
        }
        this.data.setUint32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写 64 位无符号整数
     */
    writeUint64(value) {
        if (this.remainingLength() < 8) {
            this.flush();
        }
        this.data.setBigUint64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 写 8 位有符号整数
     *
     * @returns
     */
    writeInt8(value) {
        if (this.remainingLength() < 1) {
            this.flush();
        }
        this.data.setInt8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     * 写 16 位有符号整数
     */
    writeInt16(value) {
        if (this.remainingLength() < 2) {
            this.flush();
        }
        this.data.setInt16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     * 写 32 位有符号整数
     */
    writeInt32(value) {
        if (this.remainingLength() < 4) {
            this.flush();
        }
        this.data.setInt32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写 64 位有符号整数
     */
    writeInt64(value) {
        if (this.remainingLength() < 8) {
            this.flush();
        }
        this.data.setBigInt64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 写单精度浮点数
     *
     * @returns
     */
    writeFloat(value) {
        if (this.remainingLength() < 4) {
            this.flush();
        }
        this.data.setFloat32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写双精度浮点数
     */
    writeDouble(value) {
        if (this.remainingLength() < 8) {
            this.flush();
        }
        this.data.setFloat64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 获取当前写指针
     *
     * @returns
     */
    getPointer() {
        return this.pointer;
    }
    getPos() {
        return this.pos;
    }
    /**
     * 获取剩余可写节数
     *
     * @returns
     */
    remainingLength() {
        return this.size - this.pointer;
    }
    /**
     * 写指定长度的二进制 buffer 数据
     *
     * @param length
     * @returns
     */
    writeBuffer(buffer) {
        if (!buffer.length) {
            return;
        }
        let length = buffer.length;
        if (this.remainingLength() < length) {
            let index = 0;
            while (length > 0) {
                this.flush();
                const len = Math.min(this.size, length);
                this.buffer.set(buffer.subarray(index, index + len), this.pointer);
                this.pointer += len;
                this.pos += BigInt(len);
                index += len;
                length -= len;
            }
        }
        else {
            this.buffer.set(buffer, this.pointer);
            this.pointer += length;
            this.pos += BigInt(length);
        }
    }
    /**
     * 写一个字符串
     */
    writeString(str) {
        const buffer = _util_text__WEBPACK_IMPORTED_MODULE_0__.encode(str);
        this.writeBuffer(buffer);
        return buffer.length;
    }
    encodeString(str) {
        return _util_text__WEBPACK_IMPORTED_MODULE_0__.encode(str);
    }
    flush() {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = this.onFlush(this.buffer.subarray(0, this.pointer));
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    flushToPos(pos) {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = this.onFlush(this.buffer.subarray(0, this.pointer), pos);
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    seek(pos) {
        if (!this.onSeek) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, seek failed because of no seek callback');
        }
        this.flush();
        const ret = this.onSeek(pos);
        if (ret !== 0) {
            this.error = ret;
            throw Error('IOWriter error, seek failed');
        }
        this.pos = pos;
    }
    seekInline(pos) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, Math.min(this.size, pos));
        this.pos += BigInt(this.pointer - pointer);
    }
    skip(length) {
        const pointer = this.pointer;
        this.pointer = Math.min(this.size, this.pointer + length);
        this.pos += BigInt(this.pointer - pointer);
    }
    back(length) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, this.pointer - length);
        this.pos += BigInt(this.pointer - pointer);
    }
    getBuffer() {
        return this.buffer.subarray(0, this.pointer);
    }
    setEndian(bigEndian) {
        this.littleEndian = !bigEndian;
    }
    reset() {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.error = 0;
    }
    getBufferSize() {
        return this.size;
    }
}


/***/ }),

/***/ "./src/common/io/SeekableWriteBufferQueue.ts":
/*!***************************************************!*\
  !*** ./src/common/io/SeekableWriteBufferQueue.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SeekableWriteBufferQueue)
/* harmony export */ });
/* harmony import */ var _function_concatTypeArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function/concatTypeArray */ "./src/common/function/concatTypeArray.ts");

class SeekableWriteBufferQueue {
    queue;
    pos;
    startPos;
    endPos;
    index;
    offset;
    constructor() {
        this.queue = [];
        this.startPos = BigInt(0);
        this.endPos = BigInt(0);
        this.pos = BigInt(0);
    }
    push(buffer) {
        if (this.pos === this.endPos) {
            this.queue.push(buffer);
            this.endPos += BigInt(buffer.length);
            this.pos += BigInt(buffer.length);
        }
        else {
            if (buffer.length < this.queue[this.index].length - this.offset) {
                this.queue[this.index].set(buffer, this.offset);
                this.offset += buffer.length;
                this.pos += BigInt(buffer.length);
                if (this.offset === this.queue[this.index].length) {
                    this.index++;
                    this.offset = 0;
                }
                if (this.index === this.queue.length) {
                    this.index = -1;
                    this.offset = -1;
                    this.pos = this.endPos;
                }
            }
            else {
                let offset = 0;
                while (offset < buffer.length) {
                    const length = Math.min(this.queue[this.index].length - this.offset, buffer.length - offset);
                    this.queue[this.index].set(buffer.subarray(offset, offset + length), this.offset);
                    offset += length;
                    this.offset += length;
                    this.pos += BigInt(length);
                    if (this.offset === this.queue[this.index].length) {
                        if (this.index + 1 === this.queue.length) {
                            if (offset < buffer.length) {
                                const remain = buffer.subarray(buffer.length - offset);
                                this.queue.push(remain);
                                this.endPos += BigInt(remain.length);
                            }
                            this.pos = this.endPos;
                            this.index = -1;
                            this.offset = -1;
                            break;
                        }
                        else {
                            this.index++;
                            this.offset = 0;
                        }
                    }
                }
            }
        }
    }
    seek(pos) {
        if (pos < this.startPos || pos > this.endPos) {
            return false;
        }
        this.pos = pos;
        this.index = -1;
        this.offset = -1;
        let now = this.startPos;
        for (let i = 0; i < this.queue.length; i++) {
            if (pos <= now + BigInt(this.queue[i].length)) {
                this.index = i;
                this.offset = Number(pos - now);
                break;
            }
            now += BigInt(this.queue[i].length);
        }
        if (this.index < 0) {
            this.pos = this.endPos;
        }
        return true;
    }
    flush() {
        this.startPos = this.endPos;
        this.pos = this.endPos;
        this.index = -1;
        this.offset = -1;
        const buffer = (0,_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_0__["default"])(Uint8Array, this.queue);
        this.queue.length = 0;
        return buffer;
    }
    get size() {
        return this.queue.length;
    }
}


/***/ }),

/***/ "./src/common/math/Matrix3.ts":
/*!************************************!*\
  !*** ./src/common/math/Matrix3.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Matrix3)
/* harmony export */ });
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\common\\math\\Matrix3.ts";


class Matrix3 {
    element;
    static RowMajor(matrix) {
        return new Matrix3([
            matrix[0], matrix[3], matrix[6],
            matrix[1], matrix[4], matrix[7],
            matrix[2], matrix[5], matrix[8],
        ]);
    }
    static ColMajor(matrix) {
        return new Matrix3(matrix);
    }
    constructor(matrix) {
        if (matrix) {
            this.element = new Float32Array(9);
            this.set(matrix);
        }
        else {
            this.element = new Float32Array([
                1, 0, 0,
                0, 1, 0,
                0, 0, 1,
            ]);
        }
    }
    rc(r, c) {
        return this.getValue(c * 3 + r);
    }
    setRC(r, c, value) {
        this.setValue(c * 3 + r, value);
    }
    getValue(index) {
        if (index >= 0 && index < 9) {
            return this.element[index];
        }
        else {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.error('index out of Matrix4\'s rang [0 - 9]', cheap__fileName__0, 47);
        }
    }
    setValue(index, value) {
        if (index >= 0 && index < 9) {
            this.element[index] = value;
        }
        else {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.error('index out of Matrix4\'s rang [0 - 9]', cheap__fileName__0, 56);
        }
    }
    /**
     * 设置成单位矩阵
     */
    setIdentity() {
        this.element = new Float32Array([
            1, 0, 0,
            0, 1, 0,
            0, 0, 1,
        ]);
        return this;
    }
    /**
     * 设置矩阵值
     * @param matrix
     */
    set(matrix) {
        _util_array__WEBPACK_IMPORTED_MODULE_0__.each(matrix, (value, index) => {
            this.element[index] = value;
        });
        return this;
    }
    invert() {
        const te = this.element, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) {
            return this.set([0, 0, 0, 0, 0, 0, 0, 0, 0]);
        }
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
    }
    toArray() {
        let result = [];
        for (let i = 0; i < 9; i++) {
            result[i] = this.element[i];
        }
        return result;
    }
    copy() {
        return new Matrix3().set(this.toArray());
    }
}


/***/ }),

/***/ "./src/common/math/Matrix4.ts":
/*!************************************!*\
  !*** ./src/common/math/Matrix4.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Matrix4)
/* harmony export */ });
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vector3 */ "./src/common/math/Vector3.ts");
var cheap__fileName__0 = "src\\common\\math\\Matrix4.ts";



let shared;
class Matrix4 {
    /**
     * 全局单例
     */
    static shared() {
        return shared || (shared = new Matrix4());
    }
    static RowMajor(matrix) {
        return new Matrix4([
            matrix[0], matrix[4], matrix[8], matrix[12],
            matrix[1], matrix[5], matrix[9], matrix[13],
            matrix[2], matrix[6], matrix[10], matrix[14],
            matrix[3], matrix[7], matrix[11], matrix[15]
        ]);
    }
    static ColMajor(matrix) {
        return new Matrix4(matrix);
    }
    element;
    constructor(matrix) {
        if (matrix) {
            this.element = new Float32Array(16);
            this.set(matrix);
        }
        else {
            this.element = new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
        }
    }
    rc(r, c) {
        return this.getValue(c * 4 + r);
    }
    setRC(r, c, value) {
        this.setValue(c * 4 + r, value);
    }
    getValue(index) {
        if (index >= 0 && index <= 15) {
            return this.element[index];
        }
        else {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.error('index out of Matrix4\'s rang [0 - 15]', cheap__fileName__0, 58);
        }
    }
    setValue(index, value) {
        if (index >= 0 && index <= 15) {
            this.element[index] = value;
        }
        else {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.error('index out of Matrix4\'s rang [0 - 15]', cheap__fileName__0, 67);
        }
    }
    /**
     * 设置成单位矩阵
     */
    setIdentity() {
        this.element = new Float32Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ]);
        return this;
    }
    /**
     * 设置矩阵值
     * @param matrix
     */
    set(matrix) {
        _util_array__WEBPACK_IMPORTED_MODULE_0__.each(matrix, (value, index) => {
            this.element[index] = value;
        });
        return this;
    }
    /**
     * 矩阵乘法
     * @param matrix
     */
    multiply(matrix) {
        let i, a, b, e, ai0, ai1, ai2, ai3;
        e = a = this.element;
        b = matrix.element;
        if (e === b) {
            b = new Float32Array(16);
            for (i = 0; i < 16; i++) {
                b[i] = e[i];
            }
        }
        for (i = 0; i < 4; i++) {
            ai0 = a[i];
            ai1 = a[i + 4];
            ai2 = a[i + 8];
            ai3 = a[i + 12];
            e[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
            e[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
            e[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
            e[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
        }
        return this;
    }
    /**
     * 矩阵乘以 3 维向量
     * @param vector3
     */
    multiplyVector3(vector3) {
        let e = this.element;
        let p = vector3.element;
        return new _Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector3([
            p[0] * e[0] + p[1] * e[4] + p[2] * e[8] + e[12],
            p[0] * e[1] + p[1] * e[5] + p[2] * e[9] + e[13],
            p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + e[14]
        ]);
    }
    /**
     * 矩阵乘以 4 维向量
     * @param vector4
     */
    multiplyVector4(vector4) {
        let e = this.element;
        let p = vector4.element;
        return new _Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector4([
            p[0] * e[0] + p[1] * e[4] + p[2] * e[8] + p[3] * e[12],
            p[0] * e[1] + p[1] * e[5] + p[2] * e[9] + p[3] * e[13],
            p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + p[3] * e[14],
            p[0] * e[3] + p[1] * e[7] + p[2] * e[11] + p[3] * e[15]
        ]);
    }
    /**
     * 矩阵转置
     */
    transpose() {
        let e, t;
        e = this.element;
        t = e[1], e[1] = e[4], e[4] = t;
        t = e[2], e[2] = e[8], e[8] = t;
        t = e[3], e[3] = e[12], e[12] = t;
        t = e[6], e[6] = e[9], e[9] = t;
        t = e[7], e[7] = e[13], e[13] = t;
        t = e[11], e[11] = e[14], e[14] = t;
        return this;
    }
    /**
     * 求特定矩阵的逆矩阵，并设置成当前矩阵
     * @param matrix
     */
    setInverseOf(matrix) {
        let i, s, d, inv, det;
        s = matrix.element;
        d = this.element;
        inv = new Float32Array(16);
        inv[0] = s[5] * s[10] * s[15] - s[5] * s[11] * s[14] - s[9] * s[6] * s[15] + s[9] * s[7] * s[14] + s[13] * s[6] * s[11] - s[13] * s[7] * s[10];
        inv[1] = -s[1] * s[10] * s[15] + s[1] * s[11] * s[14] + s[9] * s[2] * s[15] - s[9] * s[3] * s[14] - s[13] * s[2] * s[11] + s[13] * s[3] * s[10];
        inv[2] = s[1] * s[6] * s[15] - s[1] * s[7] * s[14] - s[5] * s[2] * s[15] + s[5] * s[3] * s[14] + s[13] * s[2] * s[7] - s[13] * s[3] * s[6];
        inv[3] = -s[1] * s[6] * s[11] + s[1] * s[7] * s[10] + s[5] * s[2] * s[11] - s[5] * s[3] * s[10] - s[9] * s[2] * s[7] + s[9] * s[3] * s[6];
        inv[4] = -s[4] * s[10] * s[15] + s[4] * s[11] * s[14] + s[8] * s[6] * s[15] - s[8] * s[7] * s[14] - s[12] * s[6] * s[11] + s[12] * s[7] * s[10];
        inv[5] = s[0] * s[10] * s[15] - s[0] * s[11] * s[14] - s[8] * s[2] * s[15] + s[8] * s[3] * s[14] + s[12] * s[2] * s[11] - s[12] * s[3] * s[10];
        inv[6] = -s[0] * s[6] * s[15] + s[0] * s[7] * s[14] + s[4] * s[2] * s[15] - s[4] * s[3] * s[14] - s[12] * s[2] * s[7] + s[12] * s[3] * s[6];
        inv[7] = s[0] * s[6] * s[11] - s[0] * s[7] * s[10] - s[4] * s[2] * s[11] + s[4] * s[3] * s[10] + s[8] * s[2] * s[7] - s[8] * s[3] * s[6];
        inv[8] = s[4] * s[9] * s[15] - s[4] * s[11] * s[13] - s[8] * s[5] * s[15] + s[8] * s[7] * s[13] + s[12] * s[5] * s[11] - s[12] * s[7] * s[9];
        inv[9] = -s[0] * s[9] * s[15] + s[0] * s[11] * s[13] + s[8] * s[1] * s[15] - s[8] * s[3] * s[13] - s[12] * s[1] * s[11] + s[12] * s[3] * s[9];
        inv[10] = s[0] * s[5] * s[15] - s[0] * s[7] * s[13] - s[4] * s[1] * s[15] + s[4] * s[3] * s[13] + s[12] * s[1] * s[7] - s[12] * s[3] * s[5];
        inv[11] = -s[0] * s[5] * s[11] + s[0] * s[7] * s[9] + s[4] * s[1] * s[11] - s[4] * s[3] * s[9] - s[8] * s[1] * s[7] + s[8] * s[3] * s[5];
        inv[12] = -s[4] * s[9] * s[14] + s[4] * s[10] * s[13] + s[8] * s[5] * s[14] - s[8] * s[6] * s[13] - s[12] * s[5] * s[10] + s[12] * s[6] * s[9];
        inv[13] = s[0] * s[9] * s[14] - s[0] * s[10] * s[13] - s[8] * s[1] * s[14] + s[8] * s[2] * s[13] + s[12] * s[1] * s[10] - s[12] * s[2] * s[9];
        inv[14] = -s[0] * s[5] * s[14] + s[0] * s[6] * s[13] + s[4] * s[1] * s[14] - s[4] * s[2] * s[13] - s[12] * s[1] * s[6] + s[12] * s[2] * s[5];
        inv[15] = s[0] * s[5] * s[10] - s[0] * s[6] * s[9] - s[4] * s[1] * s[10] + s[4] * s[2] * s[9] + s[8] * s[1] * s[6] - s[8] * s[2] * s[5];
        det = s[0] * inv[0] + s[1] * inv[4] + s[2] * inv[8] + s[3] * inv[12];
        if (det === 0) {
            return this;
        }
        det = 1 / det;
        for (i = 0; i < 16; i++) {
            d[i] = inv[i] * det;
        }
        return this;
    }
    /**
     * 求自身的逆矩阵
     */
    invert() {
        this.setInverseOf(this);
        return this;
    }
    /**
     * 设置成正射投影矩阵
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    setOrtho(left, right, bottom, top, near, far) {
        let rw, rh, rd;
        if (left === right || bottom === top || near === far) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('null frustum', cheap__fileName__0, 240);
        }
        rw = 1 / (right - left);
        rh = 1 / (top - bottom);
        rd = 1 / (far - near);
        this.set([
            2 * rw, 0, 0, 0,
            0, 2 * rh, 0, 0,
            0, 0, -2 * rd, 0,
            -(right + left) * rw, -(top + bottom) * rh, -(far + near) * rd, 1
        ]);
        return this;
    }
    /**
     * 右乘正射投影矩阵
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    ortho(left, right, bottom, top, near, far) {
        return this.multiply(new Matrix4().setOrtho(left, right, bottom, top, near, far));
    }
    /**
     * 设置成透视投影矩阵
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    setFrustum(left, right, bottom, top, near, far) {
        let rw, rh, rd;
        if (left === right || bottom === top || near === far) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.error('null frustum', cheap__fileName__0, 281);
        }
        if (near <= 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('near <= 0', cheap__fileName__0, 284);
        }
        if (far <= 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('far <= 0', cheap__fileName__0, 287);
        }
        rw = 1 / (right - left);
        rh = 1 / (top - bottom);
        rd = 1 / (far - near);
        this.set([
            2 * near * rw, 0, 0, 0,
            0, 2 * near * rh, 0, 0,
            (right + left) * rw, (top + bottom) * rh, -(far + near) * rd, -1,
            0, 0, -2 * near * far * rd, 0
        ]);
        return this;
    }
    /**
     * 右乘透视投影矩阵
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    frustum(left, right, bottom, top, near, far) {
        return this.multiply(new Matrix4().setOrtho(left, right, bottom, top, near, far));
    }
    /**
     * 设置成透视投影矩阵
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    setPerspective(fovy, aspect, near, far) {
        let rd, s, ct;
        if (near === far || aspect === 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('null frustum', cheap__fileName__0, 328);
        }
        if (near <= 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('near <= 0', cheap__fileName__0, 331);
        }
        if (far <= 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('far <= 0', cheap__fileName__0, 334);
        }
        fovy = Math.PI * fovy / 180 / 2;
        s = Math.sin(fovy);
        if (s === 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('null frustum', cheap__fileName__0, 342);
        }
        rd = 1 / (far - near);
        ct = Math.cos(fovy) / s;
        this.set([
            ct / aspect, 0, 0, 0,
            0, ct, 0, 0,
            0, 0, -(far + near) * rd, -1,
            0, 0, -2 * near * far * rd, 0
        ]);
        return this;
    }
    /**
     * 右乘透视投影矩阵
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    perspective(fovy, aspect, near, far) {
        return this.multiply(new Matrix4().setPerspective(fovy, aspect, near, far));
    }
    /**
     * 将 Matrix4 实例设置为缩放变换矩阵
     * @param vector3 缩放因子
     */
    setScale(vector3) {
        this.set([
            vector3.x, 0, 0, 0,
            0, vector3.y, 0, 0,
            0, 0, vector3.z, 0,
            0, 0, 0, 1
        ]);
        return this;
    }
    /**
     * 右乘缩放变换矩阵
     * @param vector3 缩放因子
     */
    scale(vector3) {
        let e = this.element;
        e[0] *= vector3.x, e[1] *= vector3.x, e[2] *= vector3.x, e[3] *= vector3.x;
        e[4] *= vector3.y, e[5] *= vector3.y, e[6] *= vector3.y, e[7] *= vector3.y;
        e[8] *= vector3.z, e[9] *= vector3.z, e[10] *= vector3.z, e[11] *= vector3.z;
        return this;
    }
    /**
     * 将 Matrix4 实例设置为平移变换矩阵
     * @param vector3 平移因子
     */
    setTranslate(vector3) {
        this.set([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            vector3.x, vector3.y, vector3.z, 1
        ]);
        return this;
    }
    /**
     * 右乘平移变换矩阵
     * @param vector3 平移因子
     */
    preTranslate(vector3) {
        let e = this.element;
        e[12] += e[0] * vector3.x + e[4] * vector3.y + e[8] * vector3.z;
        e[13] += e[1] * vector3.x + e[5] * vector3.y + e[9] * vector3.z;
        e[14] += e[2] * vector3.x + e[6] * vector3.y + e[10] * vector3.z;
        e[15] += e[3] * vector3.x + e[7] * vector3.y + e[11] * vector3.z;
        return this;
    }
    /**
     * 右乘平移变换矩阵
     * @param vector3 平移因子
     */
    postTranslate(vector3) {
        let e = this.element;
        e[0] += vector3.x * e[3];
        e[1] += vector3.y * e[3];
        e[2] += vector3.z * e[3];
        e[4] += vector3.x * e[7];
        e[5] += vector3.y * e[7];
        e[6] += vector3.z * e[7];
        e[8] += vector3.x * e[11];
        e[9] += vector3.y * e[11];
        e[10] += vector3.z * e[11];
        e[12] += vector3.x * e[15];
        e[13] += vector3.y * e[15];
        e[14] += vector3.z * e[15];
        return this;
    }
    /**
     * 将 Matrix4  实例设置为旋转变换矩阵
     * @param angle 旋转角度（角度制 0-360）
     * @param vector3 旋转轴
     */
    setRotate(angle, vector3) {
        let x, y, z, s, c, len, rlen, nc, xy, yz, zx, xs, ys, zs;
        angle = Math.PI * angle / 180;
        x = vector3.x;
        y = vector3.y;
        z = vector3.z;
        s = Math.sin(angle);
        c = Math.cos(angle);
        if (0 !== vector3.x && 0 === vector3.y && 0 === vector3.z) {
            // Rotation around X axis
            if (vector3.x < 0) {
                s = -s;
            }
            this.set([
                1, 0, 0, 0,
                0, c, -s, 0,
                0, s, c, 0,
                0, 0, 0, 1
            ]);
        }
        else if (0 === vector3.x && 0 !== vector3.y && 0 === vector3.z) {
            // Rotation around Y axis
            if (vector3.y < 0) {
                s = -s;
            }
            this.set([
                c, 0, s, 0,
                0, 1, 0, 0,
                -s, 0, c, 0,
                0, 0, 0, 1
            ]);
        }
        else if (0 === vector3.x && 0 === vector3.y && 0 !== vector3.z) {
            // Rotation around Z axis
            if (vector3.z < 0) {
                s = -s;
            }
            this.set([
                c, -s, 0, 0,
                s, c, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
        }
        else {
            // Rotation around another axis
            len = vector3.magnitude;
            if (len !== 1) {
                rlen = 1 / len;
                x *= rlen;
                y *= rlen;
                z *= rlen;
            }
            nc = 1 - c;
            xy = x * y;
            yz = y * z;
            zx = z * x;
            xs = x * s;
            ys = y * s;
            zs = z * s;
            this.set([
                x * x * nc + c, xy * nc + zs, zx * nc - ys, 0,
                xy * nc - zs, y * y * nc + c, yz * nc + xs, 0,
                zx * nc + ys, yz * nc - xs, z * z * nc + c, 0,
                0, 0, 0, 1
            ]);
        }
        return this;
    }
    /**
     * 右乘旋转矩阵
     * @param angle 旋转角度（角度制 0-360）
     * @param vector3 旋转轴
     */
    rotate(angle, vector3) {
        this.multiply(new Matrix4().setRotate(angle, vector3));
        return this;
    }
    /**
     * 设置成一个观察矩阵
     * @param eye 视点
     * @param center 目标
     * @param up 上方向
     */
    setLookAt(eye, center, up) {
        let fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;
        fx = center.x - eye.x;
        fy = center.y - eye.y;
        fz = center.z - eye.z;
        // Normalize f.
        rlf = 1 / Math.sqrt(fx * fx + fy * fy + fz * fz);
        fx *= rlf;
        fy *= rlf;
        fz *= rlf;
        // Calculate cross product of f and up.
        sx = fy * up.z - fz * up.y;
        sy = fz * up.x - fx * up.z;
        sz = fx * up.y - fy * up.x;
        // Normalize s.
        rls = 1 / Math.sqrt(sx * sx + sy * sy + sz * sz);
        sx *= rls;
        sy *= rls;
        sz *= rls;
        // Calculate cross product of s and f.
        ux = sy * fz - sz * fy;
        uy = sz * fx - sx * fz;
        uz = sx * fy - sy * fx;
        this.set([
            sx, ux, -fx, 0,
            sy, uy, -fy, 0,
            sz, uz, -fz, 0,
            0, 0, 0, 1
        ]);
        // Translate.
        return this.preTranslate(new _Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector3([-eye.x, -eye.y, -eye.z]));
    }
    /**
     * 右乘视图矩阵
     * @param eye 视点
     * @param center 目标
     * @param up 上方向
     */
    lookAt(eye, center, up) {
        return this.multiply(new Matrix4().setLookAt(eye, center, up));
    }
    toArray() {
        let result = [];
        for (let i = 0; i < 16; i++) {
            result[i] = this.element[i];
        }
        return result;
    }
    copy() {
        return new Matrix4().set(this.toArray());
    }
}


/***/ }),

/***/ "./src/common/math/Vector3.ts":
/*!************************************!*\
  !*** ./src/common/math/Vector3.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Vector3: () => (/* binding */ Vector3),
/* harmony export */   Vector4: () => (/* binding */ Vector4)
/* harmony export */ });
class Vector3 {
    element;
    constructor(vector) {
        this.element = new Float32Array(3);
        if (vector) {
            this.element[0] = vector[0];
            this.element[1] = vector[1];
            this.element[2] = vector[2];
        }
    }
    /**
     * 归一化
     */
    normalize() {
        let c = this.x, d = this.y, e = this.z, g = this.magnitude;
        if (g) {
            if (g === 1) {
                return this;
            }
            else {
                g = 1 / g;
                this.x = c * g;
                this.y = d * g;
                this.z = e * g;
                return this;
            }
        }
        else {
            this.x = this.y = this.z = 0;
            return this;
        }
    }
    toArray() {
        return [this.x, this.y, this.z];
    }
    get magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    get sqrMagnitude() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    get x() {
        return this.element[0];
    }
    set x(value) {
        this.element[0] = value;
    }
    get y() {
        return this.element[1];
    }
    set y(value) {
        this.element[1] = value;
    }
    get z() {
        return this.element[2];
    }
    set z(value) {
        this.element[2] = value;
    }
}
class Vector4 {
    element;
    constructor(vector) {
        this.element = new Float32Array(4);
        if (vector) {
            this.element[0] = vector[0];
            this.element[1] = vector[1];
            this.element[2] = vector[2];
            this.element[4] = vector[3];
        }
    }
}


/***/ }),

/***/ "./src/common/math/gcd.ts":
/*!********************************!*\
  !*** ./src/common/math/gcd.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ gcd)
/* harmony export */ });
/**
 * // 计算最大公约数（GCD）
 *
 * @param a
 * @param b
 * @returns
 */
function gcd(a, b) {
    while (b !== 0) {
        [a, b] = [b, a % b];
    }
    return a;
}


/***/ }),

/***/ "./src/common/math/matrix.ts":
/*!***********************************!*\
  !*** ./src/common/math/matrix.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concat3x3: () => (/* binding */ concat3x3)
/* harmony export */ });
/* unused harmony export concat4x4 */
/* harmony import */ var _Matrix3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix3 */ "./src/common/math/Matrix3.ts");
/* harmony import */ var _Matrix4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Matrix4 */ "./src/common/math/Matrix4.ts");


function concat3x3(a, b) {
    const m = new _Matrix3__WEBPACK_IMPORTED_MODULE_0__["default"]([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
            let value = a.rc(r, 0) * b.rc(0, c) + a.rc(r, 1) * b.rc(1, c) + a.rc(r, 2) * b.rc(2, c);
            m.setRC(r, c, value);
        }
    }
    return m;
}
function concat4x4(a, b) {
    const m = new _Matrix4__WEBPACK_IMPORTED_MODULE_1__["default"]([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
            let value = a.rc(r, 0) * b.rc(0, c) + a.rc(r, 1) * b.rc(1, c) + a.rc(r, 2) * b.rc(2, c) + a.rc(r, 3) * b.rc(3, c);
            m.setRC(r, c, value);
        }
    }
    return m;
}


/***/ }),

/***/ "./src/common/math/vector.ts":
/*!***********************************!*\
  !*** ./src/common/math/vector.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mvMul: () => (/* binding */ mvMul)
/* harmony export */ });
/* unused harmony exports add, minus, scalarProduct, dotProduct, crossProduct, rotate, vertical, angleCos, angle, extendPoint */
/* harmony import */ var _Matrix4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix4 */ "./src/common/math/Matrix4.ts");
/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector3 */ "./src/common/math/Vector3.ts");


/**
 * 向量加法
 */
function add(a, b) {
    return new _Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([
        a.x + b.x,
        a.y + b.y,
        a.z + b.z
    ]);
}
/**
 * 向量减法
 */
function minus(a, b) {
    return new _Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([
        a.x - b.x,
        a.y - b.y,
        a.z - b.z
    ]);
}
/**
 * 向量乘以标量
 */
function scalarProduct(vector, scalar) {
    return new _Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([
        vector.x * scalar,
        vector.y * scalar,
        vector.z * scalar
    ]);
}
/**
 * 向量点乘
 */
function dotProduct(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}
/**
 * 向量叉乘
 */
function crossProduct(a, b) {
    return new _Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([
        a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    ]);
}
/**
 * 向量旋转
 */
function rotate(vector, angle, axis) {
    return new _Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]().setRotate(angle, axis).multiplyVector3(vector);
}
/**
 * 求两个向量的单位法向量
 */
function vertical(a, b) {
    return crossProduct(a, b).normalize();
}
/**
 * 求两个向量的夹角余弦值
 */
function angleCos(a, b) {
    return dotProduct(a, b) / (a.magnitude * b.magnitude);
}
/**
 * 求两个向量的夹角
 */
function angle(a, b) {
    return Math.acos(angleCos(a, b));
}
/**
 * 求两个向量的线段拓展向量
 */
function extendPoint(a, b) {
    let sum = add(a, b);
    // 如果向量 a 和向量 b 方向相反，长度相等，则直接使用向量 a 或者向量 b 计算，因为其合向量为 0，使用其中一个即可计算出正交向量
    if (sum.magnitude === 0) {
        sum = a;
    }
    return crossProduct(sum, new _Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([0, 0, 1])).normalize();
}
/**
 * 矩阵向量相乘
 */
function mvMul(m, v) {
    const dst = new _Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([0, 0, 0]);
    for (let row = 0; row < 3; row++) {
        dst.element[row] = m.rc(row, 0) * v.x + m.rc(row, 1) * v.y + m.rc(row, 2) * v.z;
    }
    return dst;
}


/***/ }),

/***/ "./src/common/network/FakeMessageChannel.ts":
/*!**************************************************!*\
  !*** ./src/common/network/FakeMessageChannel.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FakeMessageChannel)
/* harmony export */ });
class FakeMessageChannelPort extends EventTarget {
    peer;
    postMessage(message, transfer) {
        if (this.peer?.onmessage) {
            this.peer.onmessage({
                data: message
            });
        }
    }
    onmessage;
    onmessageerror;
    close() {
        this.peer = null;
    }
    start() {
    }
}
class FakeMessageChannel {
    port1;
    port2;
    constructor() {
        this.port1 = new FakeMessageChannelPort();
        this.port2 = new FakeMessageChannelPort();
        this.port1.peer = this.port2;
        this.port2.peer = this.port1;
    }
}


/***/ }),

/***/ "./src/common/network/IPCPort.ts":
/*!***************************************!*\
  !*** ./src/common/network/IPCPort.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NOTIFY: () => (/* binding */ NOTIFY),
/* harmony export */   REQUEST: () => (/* binding */ REQUEST),
/* harmony export */   "default": () => (/* binding */ IPCPort)
/* harmony export */ });
/* harmony import */ var _event_Emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../event/Emitter */ "./src/common/event/Emitter.ts");
/* harmony import */ var _function_isDef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/isDef */ "./src/common/function/isDef.ts");


const NOTIFY = 'notify';
const REQUEST = 'request';
class IPCPort extends _event_Emitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
    port;
    requestMap;
    seq;
    closed;
    constructor(port) {
        super(true);
        this.port = port;
        this.port.onmessage = this.handle.bind(this);
        this.seq = 0;
        this.requestMap = new Map();
        this.port.start();
        this.closed = false;
    }
    handle(event) {
        const origin = event.data;
        const type = origin.type;
        const data = origin.data;
        if (type === 'notify') {
            this.fire(NOTIFY, data);
        }
        else if (type === 'reply') {
            const request = this.requestMap.get(data.seq);
            if (request) {
                if ((0,_function_isDef__WEBPACK_IMPORTED_MODULE_1__["default"])(data.result)) {
                    request.resolve(data.result);
                }
                else if (data.error) {
                    request.reject(data.error);
                }
                else {
                    request.resolve(undefined);
                }
                this.requestMap.delete(data.seq);
            }
        }
        else if (type === 'request') {
            this.fire(REQUEST, data);
        }
    }
    notify(method, params = {}, transfer = []) {
        this.port.postMessage({
            type: 'notify',
            data: {
                method,
                params
            }
        }, transfer);
    }
    async request(method, params = {}, transfer = []) {
        return new Promise((resolve, reject) => {
            const id = this.seq++;
            this.requestMap.set(id, {
                resolve,
                reject
            });
            this.port.postMessage({
                type: 'request',
                data: {
                    seq: id,
                    method,
                    params
                }
            }, transfer);
        });
    }
    reply(request, result, error, transfer = []) {
        const data = {
            seq: request.seq
        };
        if ((0,_function_isDef__WEBPACK_IMPORTED_MODULE_1__["default"])(result)) {
            data.result = result;
        }
        else if (error) {
            data.error = error;
        }
        if (transfer?.length) {
            this.port.postMessage({
                type: 'reply',
                data
            }, transfer);
        }
        else {
            this.port.postMessage({
                type: 'reply',
                data
            });
        }
    }
    getPort() {
        return this.port;
    }
    destroy() {
        if (this.requestMap.size) {
            this.requestMap.forEach((req) => {
                req.reject('ipc port close');
            });
            this.requestMap.clear();
        }
        if (this.port) {
            this.port.close();
            this.port = null;
        }
        this.closed = true;
    }
}


/***/ }),

/***/ "./src/common/network/NodeIPCPort.ts":
/*!*******************************************!*\
  !*** ./src/common/network/NodeIPCPort.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IPCPort */ "./src/common/network/IPCPort.ts");

class NodeIPCPort extends _IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(port) {
        super(port);
        // @ts-ignore
        this.port.on('message', this.handle.bind(this));
    }
}


/***/ }),

/***/ "./src/common/timer/Clock.ts":
/*!***********************************!*\
  !*** ./src/common/timer/Clock.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Clock)
/* harmony export */ });
/* harmony import */ var _function_isWorker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var _function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var _WorkerSetTimeout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WorkerSetTimeout */ "./src/common/timer/WorkerSetTimeout.ts");
/* harmony import */ var _function_debounce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../function/debounce */ "./src/common/function/debounce.ts");




let workerSetTimeout;
let workerSetTimeoutCounter = 0;
function createWorkerSetTimeout() {
    if (workerSetTimeout) {
        workerSetTimeoutCounter++;
        return workerSetTimeout;
    }
    workerSetTimeout = new _WorkerSetTimeout__WEBPACK_IMPORTED_MODULE_2__["default"]();
    workerSetTimeoutCounter = 1;
    return workerSetTimeout;
}
function deleteWorkerSetTimeout() {
    if (workerSetTimeoutCounter === 0) {
        return;
    }
    workerSetTimeoutCounter--;
    if (workerSetTimeoutCounter === 0) {
        workerSetTimeout.destroy();
        workerSetTimeout = null;
    }
}
class Clock {
    messageChannel;
    interval;
    started;
    timer;
    workerTimer;
    workerSetTimeout;
    onClock;
    nextTick;
    /**
     * messageChannel 执行间隔，默认 0.2
     */
    a;
    /**
     * setTimeout 最小执行间隔，默认 4
     */
    b;
    /**
     * 50 毫秒内  messageChannel 执行次数
     */
    beta;
    /**
     * 50 毫秒内  setTimeout 执行次数
     */
    alpha;
    count;
    /**
     * 等效时间
     */
    equivalent;
    timestamp;
    onVisibilityChange;
    timeoutNext;
    running;
    highPerformance;
    constructor(interval, highPerformance = true) {
        this.started = false;
        this.interval = interval;
        this.highPerformance = highPerformance;
        this.a = 0.2;
        this.b = 4;
        this.equivalent = 50;
        this.timestamp = 0;
        this.nextTick = () => {
            if (!this.started || this.running) {
                return;
            }
            this.running = true;
            if (this.interval >= 4 || !this.highPerformance) {
                this.timeoutTick();
            }
            else if (this.interval <= 0) {
                this.messageChannel.port1.postMessage(null);
            }
            else {
                const now = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
                if (now - this.timestamp > this.equivalent) {
                    this.count = 0;
                    this.timestamp = now;
                }
                if (this.count < this.beta) {
                    this.messageChannel.port1.postMessage(null);
                }
                else {
                    this.timeoutTick();
                }
            }
        };
        this.compute();
        this.messageChannel = new MessageChannel();
        this.handleEvent();
        this.timeoutNext = (worker) => {
            if (worker) {
                this.workerTimer = null;
            }
            else {
                this.timer = null;
            }
            this.running = false;
            this.count++;
            if (this.onClock) {
                this.onClock(this.nextTick);
            }
            else {
                this.nextTick();
            }
        };
        if (!(0,_function_isWorker__WEBPACK_IMPORTED_MODULE_0__["default"])() && document.visibilityState === 'hidden') {
            this.workerSetTimeout = createWorkerSetTimeout();
        }
        this.running = false;
    }
    compute(clear = true) {
        if (this.interval > 0) {
            this.beta = Math.ceil(this.equivalent * (1 - this.b / this.interval) / (this.a - this.b));
            this.alpha = Math.floor(this.equivalent / this.interval - this.beta);
            if (clear) {
                this.count = 0;
            }
        }
    }
    timeoutTick() {
        if (this.workerSetTimeout
            && document.visibilityState === 'hidden'
            && this.interval < 1000) {
            this.workerTimer = this.workerSetTimeout.setTimeout(this.timeoutNext, this.interval);
        }
        else {
            this.timer = setTimeout(this.timeoutNext, this.interval);
        }
    }
    start() {
        if (this.started) {
            return;
        }
        this.started = true;
        this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
        this.nextTick();
    }
    stop() {
        this.started = false;
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        if (this.workerTimer && this.workerSetTimeout) {
            this.workerSetTimeout.clearTimeout(this.workerTimer);
        }
        this.running = false;
    }
    isStarted() {
        return this.started;
    }
    setInterval(interval) {
        this.interval = Math.max(interval, 0);
        this.compute();
    }
    getInterval() {
        return this.interval;
    }
    isZeroTimeout() {
        return this.interval < 4;
    }
    destroy() {
        this.stop();
        if (this.workerSetTimeout) {
            deleteWorkerSetTimeout();
            this.workerSetTimeout = null;
        }
        if (this.onVisibilityChange) {
            document.removeEventListener('visibilitychange', this.onVisibilityChange);
            this.onVisibilityChange = null;
        }
    }
    handleEvent() {
        this.messageChannel.port2.onmessage = () => {
            if (!this.started) {
                return;
            }
            this.running = false;
            this.count++;
            if (this.onClock) {
                this.onClock(this.nextTick);
            }
            else {
                this.nextTick();
            }
        };
        if (!(0,_function_isWorker__WEBPACK_IMPORTED_MODULE_0__["default"])()) {
            this.onVisibilityChange = (0,_function_debounce__WEBPACK_IMPORTED_MODULE_3__["default"])((event) => {
                if (document.visibilityState === 'hidden') {
                    this.workerSetTimeout = createWorkerSetTimeout();
                    if (this.timer) {
                        clearTimeout(this.timer);
                        this.timer = null;
                        this.running = false;
                    }
                    this.nextTick();
                }
                else {
                    if (this.workerTimer) {
                        this.workerSetTimeout.clearTimeout(this.workerTimer);
                        this.workerTimer = null;
                        this.running = false;
                    }
                    if (this.timer) {
                        clearTimeout(this.timer);
                        this.timer = null;
                        this.running = false;
                    }
                    deleteWorkerSetTimeout();
                    this.workerSetTimeout = null;
                    this.nextTick();
                }
            }, 20);
            document.addEventListener('visibilitychange', this.onVisibilityChange);
        }
    }
}


/***/ }),

/***/ "./src/common/timer/LoopTask.ts":
/*!**************************************!*\
  !*** ./src/common/timer/LoopTask.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LoopTask)
/* harmony export */ });
/* harmony import */ var _Clock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Clock */ "./src/common/timer/Clock.ts");
/* harmony import */ var _function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/**
 * @file 可伸缩循环任务队列
 */


class LoopTask {
    task;
    count;
    emptyCount;
    started;
    clock;
    timestamp;
    timeout;
    interval;
    startTimer;
    autoInterval;
    sync;
    tickAfter;
    processing;
    constructor(task, timeout = 0, interval = 0, autoInterval = true, sync = true) {
        this.task = task;
        this.timeout = timeout;
        this.interval = interval;
        this.autoInterval = autoInterval;
        this.sync = sync;
        this.count = 0;
        this.emptyCount = 0;
        this.timestamp = 0;
        this.started = false;
        this.processing = false;
        this.clock = new _Clock__WEBPACK_IMPORTED_MODULE_0__["default"](this.interval);
        this.clock.onClock = (next) => {
            if (!this.started) {
                return;
            }
            this.count++;
            if (this.sync) {
                if (this.tickAfter) {
                    this.tickAfter();
                    this.tickAfter = null;
                }
                if (this.task() === false) {
                    this.stop();
                }
                else {
                    this.next(next);
                }
            }
            else {
                if (this.processing) {
                    return;
                }
                this.processing = true;
                this.task().then((result) => {
                    this.processing = false;
                    if (this.tickAfter) {
                        this.tickAfter();
                        this.tickAfter = null;
                    }
                    if (result === false) {
                        this.stop();
                    }
                    else {
                        this.next(next);
                    }
                });
            }
        };
    }
    next(next) {
        if (!this.started) {
            return;
        }
        const now = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
        if (this.autoInterval && now - this.timestamp > 50) {
            const load = this.emptyCount / this.count;
            /**
             * 1000 毫秒被空闲任务调用超过 10%，将间隔减一
             * 没有空闲任务，将间隔重新置为 0
             */
            if (this.emptyCount === 0) {
                this.clock.setInterval(Math.max(this.clock.getInterval() >> 1, this.interval));
            }
            else if (load < 0.1) {
                this.clock.setInterval(this.clock.getInterval() - 1);
            }
            else if (load > 0.2) {
                this.clock.setInterval(Math.min(this.clock.getInterval() + 1, 20));
            }
            else if (load > 0.5) {
                this.clock.setInterval(this.clock.getInterval() << 1);
            }
            this.count = 0;
            this.emptyCount = 0;
            this.timestamp = now;
        }
        next();
    }
    start() {
        this.started = true;
        if (this.timeout) {
            this.startTimer = setTimeout(() => {
                this.count = 0;
                this.emptyCount = 0;
                this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
                this.clock.start();
                this.startTimer = null;
            }, this.timeout);
        }
        else {
            this.count = 0;
            this.emptyCount = 0;
            this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
            this.clock.start();
        }
    }
    stop() {
        this.started = false;
        this.processing = false;
        if (this.startTimer) {
            clearTimeout(this.startTimer);
            this.startTimer = null;
        }
        this.clock.stop();
    }
    async stopBeforeNextTick() {
        if (this.startTimer) {
            clearTimeout(this.startTimer);
            this.startTimer = null;
        }
        if (!this.clock.isStarted()) {
            return;
        }
        if (this.sync) {
            this.started = false;
            this.processing = false;
            this.clock.stop();
        }
        else {
            return new Promise((resolve) => {
                this.tickAfter = () => {
                    this.started = false;
                    this.processing = false;
                    this.clock.stop();
                    resolve();
                };
            });
        }
    }
    isStarted() {
        return this.started;
    }
    emptyTask() {
        this.emptyCount++;
    }
    isZeroTimeout() {
        return this.clock?.isZeroTimeout();
    }
    restart() {
        if (this.clock) {
            this.stop();
            this.clock.setInterval(this.interval);
            this.start();
        }
    }
    resetInterval() {
        this.clock.setInterval(Math.max(this.clock.getInterval() >> 1, this.interval));
        this.emptyCount = 0;
        this.count = 0;
        this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
    }
    destroy() {
        this.stop();
        this.task = null;
        this.timeout = null;
        this.interval = null;
    }
}


/***/ }),

/***/ "./src/common/timer/Sleep.ts":
/*!***********************************!*\
  !*** ./src/common/timer/Sleep.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Sleep)
/* harmony export */ });
/**
 * @file sleep
 */
class Sleep {
    timeout;
    timer;
    resolve;
    reject;
    startTime;
    /**
     *
     * @param timeout 时间（秒）
     */
    constructor(timeout) {
        this.timeout = timeout;
    }
    then(res, rej) {
        this.resolve = res;
        this.reject = rej;
        this.startTime = Date.now();
        this.timer = setTimeout(() => {
            this.resolve(Date.now() - this.startTime);
            this.timer = null;
        }, this.timeout * 1000);
    }
    stop(resolve = true) {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
            if (this.resolve && resolve) {
                this.resolve(Date.now() - this.startTime);
            }
            else if (this.reject && !resolve) {
                this.reject(Date.now() - this.startTime);
            }
        }
    }
    reset(timeout) {
        if (timeout) {
            this.timeout = timeout;
        }
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = setTimeout(() => {
                this.resolve(Date.now() - this.startTime);
                this.timer = null;
            }, this.timeout * 1000);
        }
    }
}


/***/ }),

/***/ "./src/common/timer/Timer.ts":
/*!***********************************!*\
  !*** ./src/common/timer/Timer.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Timer)
/* harmony export */ });
/**
 * @file 定时任务
 */
class Timer {
    task;
    timeout;
    interval;
    timer;
    /**
     *
     * @param task 定时任务
     * @param timeout 多久之后开始
     * @param interval 执行间隔
     */
    constructor(task, timeout, interval) {
        this.task = task;
        this.timeout = timeout;
        this.interval = interval;
    }
    /**
     * 开始执行
     */
    start() {
        const me = this;
        me.stop();
        let timeout = me.timeout;
        const interval = me.interval;
        const next = function () {
            if (me.task() !== false
                && me.timer) {
                me.timer = setTimeout(next, me.interval);
            }
            else {
                me.stop();
            }
        };
        if (timeout == null) {
            timeout = interval;
        }
        me.timer = setTimeout(next, timeout);
    }
    /**
     * 停止执行
     */
    stop() {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    }
    updateInterval(interval) {
        this.interval = interval;
    }
    /**
     * 是否正在执行
     */
    isStarted() {
        return !!this.timer;
    }
    /**
     * 销毁定时任务
     */
    destroy() {
        this.stop();
        this.task = this.timeout = this.interval = null;
    }
}


/***/ }),

/***/ "./src/common/timer/WorkerSetTimeout.ts":
/*!**********************************************!*\
  !*** ./src/common/timer/WorkerSetTimeout.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerSetTimeout)
/* harmony export */ });
/* harmony import */ var _function_sourceLoad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function/sourceLoad */ "./src/common/function/sourceLoad.ts");

__webpack_require__(/*! ./workerSetTimeoutTask */ "./src/common/timer/workerSetTimeoutTask.ts");
class WorkerSetTimeout {
    worker;
    workerUrl;
    taskMap;
    id;
    constructor() {
        this.id = 0;
        this.taskMap = new Map();
        const workerSource = `
      ${(0,_function_sourceLoad__WEBPACK_IMPORTED_MODULE_0__["default"])(/*require.resolve*/(/*! ./workerSetTimeoutTask */ "./src/common/timer/workerSetTimeoutTask.ts"), { varName: 'workerSetTimeoutTask' })}
      workerSetTimeoutTask.default(self)
    `;
        const blob = new Blob([workerSource], { type: 'text/javascript' });
        this.workerUrl = URL.createObjectURL(blob);
        this.worker = new Worker(this.workerUrl);
        this.worker.addEventListener('message', (message) => {
            const origin = message.data;
            const type = origin.type;
            const id = origin.id;
            switch (type) {
                case 'pong':
                    const task = this.taskMap.get(id);
                    if (task) {
                        task(true);
                    }
                    break;
            }
        });
    }
    setTimeout(task, timeout = 0) {
        const id = this.id++;
        this.taskMap.set(id, task);
        this.worker.postMessage({
            type: 'ping',
            data: {
                timeout,
                id
            }
        });
        return id;
    }
    clearTimeout(id) {
        this.taskMap.delete(id);
    }
    destroy() {
        if (this.worker) {
            this.worker.terminate();
            this.worker = null;
        }
        if (this.workerUrl) {
            URL.revokeObjectURL(this.workerUrl);
            this.workerUrl = null;
        }
        if (this.taskMap) {
            this.taskMap.clear();
            this.taskMap = null;
        }
    }
}


/***/ }),

/***/ "./src/common/timer/WorkerTimer.ts":
/*!*****************************************!*\
  !*** ./src/common/timer/WorkerTimer.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerTimer)
/* harmony export */ });
/* harmony import */ var _Clock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Clock */ "./src/common/timer/Clock.ts");
/**
 * @file worker 定时任务，规避后台 settimeout 最小间隔 1s 的问题
 */

class WorkerTimer {
    task;
    timeout;
    interval;
    clock;
    started;
    timer;
    constructor(task, timeout, interval) {
        this.task = task;
        this.timeout = timeout;
        this.interval = interval;
        this.started = false;
        this.clock = new _Clock__WEBPACK_IMPORTED_MODULE_0__["default"](this.interval, false);
        this.clock.onClock = (next) => {
            if (this.started && this.task() === false) {
                this.stop();
            }
            else {
                next();
            }
        };
    }
    start() {
        this.started = true;
        if (this.timeout > 0) {
            this.timer = setTimeout(() => {
                this.timer = null;
                this.clock.start();
            }, this.timeout);
        }
        else {
            this.clock.start();
        }
    }
    stop() {
        this.started = false;
        this.clock.stop();
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    }
    isStarted() {
        return this.started;
    }
    updateInterval(interval) {
        this.interval = interval;
        this.clock.setInterval(interval);
    }
    destroy() {
        if (this.clock) {
            this.stop();
            this.clock.destroy();
            this.clock = null;
        }
        this.started = false;
        this.task = this.timeout = this.interval = null;
    }
}


/***/ }),

/***/ "./src/common/timer/workerSetTimeoutTask.ts":
/*!**************************************************!*\
  !*** ./src/common/timer/workerSetTimeoutTask.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ run)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\common\\timer\\workerSetTimeoutTask.ts";

class WorkerSetTimeout {
    worker;
    constructor(self) {
        this.worker = self;
        this.handleEvents();
    }
    handleEvents() {
        this.worker.addEventListener('message', (message) => {
            const origin = message.data;
            let data = origin.data;
            setTimeout(() => {
                this.worker.postMessage({
                    type: 'pong',
                    id: data.id
                });
            }, Math.max(data.timeout ?? 0, 4));
        });
    }
}
function run(self) {
    try {
        new WorkerSetTimeout(self);
    }
    catch (error) {
        _util_logger__WEBPACK_IMPORTED_MODULE_0__.error('new WorkerSetTimeout failed', cheap__fileName__0, 32);
    }
}


/***/ }),

/***/ "./src/common/util/array.ts":
/*!**********************************!*\
  !*** ./src/common/util/array.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   binarySearch: () => (/* binding */ binarySearch),
/* harmony export */   each: () => (/* binding */ each),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   push: () => (/* binding */ push),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   sortInsert: () => (/* binding */ sortInsert),
/* harmony export */   toArray: () => (/* binding */ toArray)
/* harmony export */ });
/* unused harmony exports unshift, indexOf, last, pop, toObject, join, falsy, exclude */
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _function_execute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/execute */ "./src/common/function/execute.ts");
/**
 * @file 数组操作
 */



/**
 * 遍历数组
 *
 * @param array
 * @param callback 返回 false 可停止遍历
 * @param reversed 是否逆序遍历
 */
function each(array, callback, reversed) {
    if (!array) {
        return;
    }
    const { length } = array;
    if (length) {
        if (reversed) {
            for (let i = length - 1; i >= 0; i--) {
                if (callback(array[i], i) === _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE) {
                    break;
                }
            }
        }
        else {
            for (let i = 0; i < length; i++) {
                if (callback(array[i], i) === _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE) {
                    break;
                }
            }
        }
    }
}
function nativePush(array, item) {
    array[array.length] = item;
}
function nativeUnshift(array, item) {
    array.unshift(item);
}
/**
 * 添加
 *
 * @param array
 * @param value
 * @param action
 */
function addItem(array, value, action) {
    if (_is__WEBPACK_IMPORTED_MODULE_0__.array(value)) {
        each(value, function (item) {
            action(array, item);
        });
    }
    else {
        action(array, value);
    }
}
/**
 * 往后加
 *
 * @param array
 * @param target
 */
function push(array, target) {
    addItem(array, target, nativePush);
}
/**
 * 往前加
 *
 * @param array
 * @param target
 */
function unshift(array, target) {
    addItem(array, target, nativeUnshift);
}
/**
 * 数组项在数组中的位置
 *
 * @param array 数组
 * @param target 数组项
 * @param strict 是否全等判断，默认是全等
 * @return 如果未找到，返回 -1
 */
function indexOf(array, target, strict) {
    let result = _constant__WEBPACK_IMPORTED_MODULE_1__.MINUS_ONE;
    each(array, function (item, index) {
        if (strict === _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE ? item == target : item === target) {
            result = index;
            return _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE;
        }
    });
    return result;
}
/**
 * 获取数组最后一项
 *
 * @param array 数组
 * @return
 */
function last(array) {
    const { length } = array;
    if (length > 0) {
        return array[length - 1];
    }
}
/**
 * 弹出数组最后一项
 *
 * 项目里用的太多，仅用于节省字符
 *
 * @param array 数组
 * @return 弹出的数组项
 */
function pop(array) {
    const { length } = array;
    if (length > 0) {
        return array.pop();
    }
}
/**
 * 删除数组项
 *
 * @param array 数组
 * @param item 待删除项
 * @param strict 是否全等判断，默认是全等
 * @return 删除的数量
 */
function remove(array, target, strict) {
    let result = 0;
    each(array, function (item, index) {
        if (strict === _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE ? item == target : item === target) {
            array.splice(index, 1);
            result++;
        }
    }, _constant__WEBPACK_IMPORTED_MODULE_1__.TRUE);
    return result;
}
/**
 * 数组是否包含 item
 *
 * @param array 数组
 * @param target 可能包含的数组项
 * @param strict 是否全等判断，默认是全等
 * @return
 */
function has(array, target, strict) {
    return indexOf(array, target, strict) >= 0;
}
/**
 * 把类数组转成数组
 *
 * @param array 类数组
 * @return
 */
function toArray(array) {
    return _is__WEBPACK_IMPORTED_MODULE_0__.array(array)
        ? array
        : (0,_function_execute__WEBPACK_IMPORTED_MODULE_2__["default"])(_constant__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY.slice, array);
}
/**
 * 把数组转成对象
 *
 * @param array 数组
 * @param key 数组项包含的字段名称，如果数组项是基本类型，可不传
 * @param value
 * @return
 */
function toObject(array, key, value) {
    let result = {};
    each(array, function (item) {
        result[key ? item[key] : item] = value || item;
    });
    return result;
}
/**
 * 把数组合并成字符串
 *
 * @param array
 * @param separator
 * @return
 */
function join(array, separator) {
    return array.join(separator);
}
/**
 * 用于判断长度大于 0 的数组
 *
 * @param array
 * @return
 */
function falsy(array) {
    return !_is__WEBPACK_IMPORTED_MODULE_0__.array(array) || !array.length;
}
/**
 * 排除数组元素返回新数组
 *
 * @param source
 * @param exc
 * @returns
 */
function exclude(source, exc) {
    const items = [];
    each(source, (item, index) => {
        if (!has(exc, item)) {
            items.push(item);
        }
    });
    return items;
}
/**
 * 二分查找
 *
 * @param array
 * @param callback 相等返回 0， 往左边查返回 -1， 往右边查返回 1
 * @returns
 */
function binarySearch(array, callback) {
    let left = 0;
    let right = array.length - 1;
    let index = -1;
    while (left <= right) {
        let mid = ((left + right) / 2) >>> 0;
        const ret = callback(array[mid]);
        if (ret === 0) {
            index = mid;
            break;
        }
        else if (ret === 1) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
            index = mid;
        }
    }
    return index;
}
function sortInsert(array, item, callback) {
    const index = binarySearch(array, callback);
    if (index > -1) {
        array.splice(index, 0, item);
    }
    else {
        array.push(item);
    }
}


/***/ }),

/***/ "./src/common/util/base32.ts":
/*!***********************************!*\
  !*** ./src/common/util/base32.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   encode: () => (/* binding */ encode)
/* harmony export */ });
/* unused harmony export decode */
const base32 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
/**
 * base32 解密
 */
function decode(text) {
    text = text.toUpperCase().replace(/=+$/, '');
    let bits = 0;
    let value = 0;
    let index = 0;
    const output = new Uint8Array(((text.length * 5) / 8) | 0);
    for (let i = 0; i < length; i++) {
        value = (value << 5) | base32.indexOf(text[i]);
        bits += 5;
        if (bits >= 8) {
            output[index++] = (value >>> (bits - 8)) & 255;
            bits -= 8;
        }
    }
    return output;
}
/**
 * base32 加密
 */
function encode(buffer, padding = true) {
    const length = buffer.length;
    let bits = 0;
    let value = 0;
    let output = '';
    for (let i = 0; i < length; i++) {
        value = (value << 8) | buffer[i];
        bits += 8;
        while (bits >= 5) {
            output += base32[(value >>> (bits - 5)) & 31];
            bits -= 5;
        }
    }
    if (bits > 0) {
        output += base32[(value << (5 - bits)) & 31];
    }
    if (padding) {
        while (output.length % 8 !== 0) {
            output += '=';
        }
    }
    return output;
}


/***/ }),

/***/ "./src/common/util/base64.ts":
/*!***********************************!*\
  !*** ./src/common/util/base64.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base64ToUint8Array: () => (/* binding */ base64ToUint8Array)
/* harmony export */ });
/* unused harmony exports base64Decode, list, map */
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./src/common/util/array.ts");

const base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
/**
 * utf8 编码
 * @param text
 */
function utf8Decode(text) {
    let string = '', i = 0, c = 0, c1 = 0, c2 = 0, c3 = 0;
    while (i < text.length) {
        c = text.charCodeAt(i);
        if (c < 128) {
            string += String.fromCharCode(c);
            i++;
        }
        else if ((c > 191) && (c < 224)) {
            c2 = text.charCodeAt(i + 1);
            string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            i += 2;
        }
        else {
            c2 = text.charCodeAt(i + 1);
            c3 = text.charCodeAt(i + 2);
            string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            i += 3;
        }
    }
    return string;
}
/**
 * base64 解密
 */
function base64Decode(text) {
    let output = '';
    let chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
    text = text.replace(/[^A-Za-z0-9\+\/\=]/g, '');
    // 不是 4 的倍数补齐 =
    while (text.length % 4) {
        text += '=';
    }
    while (i < text.length) {
        enc1 = base64.indexOf(text.charAt(i++));
        enc2 = base64.indexOf(text.charAt(i++));
        enc3 = base64.indexOf(text.charAt(i++));
        enc4 = base64.indexOf(text.charAt(i++));
        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;
        output += String.fromCharCode(chr1);
        if (enc3 !== 64) {
            output += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
            output += String.fromCharCode(chr3);
        }
    }
    return utf8Decode(output);
}
function atobCustom(encodedString) {
    function decodeBase64(char) {
        const index = base64.indexOf(char);
        return index === -1 ? 0 : index;
    }
    let decodedString = '';
    for (let i = 0; i < encodedString.length;) {
        const enc1 = decodeBase64(encodedString[i++]);
        const enc2 = decodeBase64(encodedString[i++]);
        const enc3 = decodeBase64(encodedString[i++]);
        const enc4 = decodeBase64(encodedString[i++]);
        const chr1 = (enc1 << 2) | (enc2 >> 4);
        const chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        const chr3 = ((enc3 & 3) << 6) | enc4;
        decodedString += String.fromCharCode(chr1);
        if (enc3 !== 64) {
            decodedString += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
            decodedString += String.fromCharCode(chr3);
        }
    }
    return decodedString;
}
function base64ToUint8Array(string) {
    const binaryData = typeof atob === 'function' ? atob(string) : atobCustom(string);
    const uint8Array = new Uint8Array(binaryData.length);
    for (let i = 0; i < binaryData.length; i++) {
        uint8Array[i] = binaryData.charCodeAt(i);
    }
    return uint8Array;
}
const list = [
    'A', 'B', 'C', 'D', 'E', 'F',
    'G', 'H', 'I', 'J', 'K', 'L',
    'M', 'N', 'O', 'P', 'Q', 'R',
    'S', 'T', 'U', 'V', 'W', 'X',
    'Y', 'Z', 'a', 'b', 'c', 'd',
    'e', 'f', 'g', 'h', 'i', 'j',
    'k', 'l', 'm', 'n', 'o', 'p',
    'q', 'r', 's', 't', 'u', 'v',
    'w', 'x', 'y', 'z', '0', '1',
    '2', '3', '4', '5', '6', '7',
    '8', '9', '+', '/'
];
const _map = {};
_array__WEBPACK_IMPORTED_MODULE_0__.each(list, (char, index) => {
    _map[char] = index;
});
const map = _map;


/***/ }),

/***/ "./src/common/util/bigint.ts":
/*!***********************************!*\
  !*** ./src/common/util/bigint.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min)
/* harmony export */ });
function abs(a) {
    return a > 0 ? a : -a;
}
function max(a, b) {
    return a > b ? a : b;
}
function min(a, b) {
    return a > b ? b : a;
}


/***/ }),

/***/ "./src/common/util/browser.ts":
/*!************************************!*\
  !*** ./src/common/util/browser.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _function_checkVersion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/checkVersion */ "./src/common/function/checkVersion.ts");
/**
 * @file browser
 */



function getMajorVersion(version) {
    if (!_is__WEBPACK_IMPORTED_MODULE_1__.string(version)) {
        return '';
    }
    return version.split('.').shift() || '';
}
/**
 * UA 检测浏览器
 *
 * 返回结果如下：
 *
 * {
 *    name: 'ie',     // 判断多个浏览器时，便于用 name 去 switch
 *    ie: true,       // 判断某一个浏览器时，便于 if (ie) { ... }
 *    version: '8.0'  // 版本号，string 类型
 * }
 *
 */
// http://www.fynas.com/ua/search
const list = [
    ["alipay" /* BrowserType.ALIPAY */, /alipay/],
    ["wechat" /* BrowserType.WECHAT */, /micromessenger/],
    ["dingtalk" /* BrowserType.DING_TALK */, /dingtalk[ \/]([\d_.]+)/],
    ["baiduApp" /* BrowserType.BAIDU_APP */, /baiduboxapp/],
    ["baidu" /* BrowserType.BAIDU */, /baidubrowser/],
    ["baidu" /* BrowserType.BAIDU */, /bdbrowser/],
    ["uc" /* BrowserType.UC */, /ucbrowser/],
    ["uc" /* BrowserType.UC */, /ucweb/],
    ["qq" /* BrowserType.QQ */, /qqbrowser/],
    ["qqApp" /* BrowserType.QQ_APP */, /qq/],
    ["ie" /* BrowserType.IE */, /iemobile[ \/]([\d_.]+)/],
    // IE10- 所有版本都有的信息是 MSIE x.0
    ["ie" /* BrowserType.IE */, /msie[ \/]([\d_.]+)/],
    ["ie" /* BrowserType.IE */, /trident[ \/]([\d_.]+)/, 4],
    ["edge" /* BrowserType.EDGE */, /edge[ \/]([\d_.]+)/],
    ["newEdge" /* BrowserType.NEW_EDGE */, /edg[ \/]([\d_.]+)/],
    ["chrome" /* BrowserType.CHROME */, /chrome[ \/]([\d_.]+)/],
    ["firefox" /* BrowserType.FIREFOX */, /firefox[ \/]([\d_.]+)/],
    ["opera" /* BrowserType.OPERA */, /opera(?:.*version)?[ \/]([\d_.]+)/],
    ["safari" /* BrowserType.SAFARI */, /version[ \/]([\d_.]+) safari/],
    // 新版 Safari UA
    ["safari" /* BrowserType.SAFARI */, /version[ \/]([\d_.]+) \S* safari/],
    ["safari" /* BrowserType.SAFARI */, /safari/]
];
const getMajorVersionMap = {};
const checkVersionMap = {};
/**
 * 获取 UA 的结构化信息
 *
 * @inner
 * @param {string} ua
 * @return {Object}
 */
function parseUA(ua) {
    let name;
    let version;
    (0,_util_array__WEBPACK_IMPORTED_MODULE_0__.each)(list, (item) => {
        let match = item[1].exec(ua);
        if (match) {
            name = item[0];
            version = match[1];
            if (version) {
                version = version.replace(/_/g, '.');
                if (item[2]) {
                    version = (parseInt(version, 10) + item[2]) + '.0';
                }
            }
            return false;
        }
    });
    return {
        name: name || '',
        version: version || '',
        majorVersion: (getMajorVersionMap[name] || getMajorVersion)(version),
        checkVersion: checkVersionMap[name] || _function_checkVersion__WEBPACK_IMPORTED_MODULE_2__["default"]
    };
}
const browser = parseUA((typeof navigator === 'object' && navigator.userAgent || '').toLowerCase());
if (browser.name) {
    browser[browser.name] = true;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (browser);


/***/ }),

/***/ "./src/common/util/constant.ts":
/*!*************************************!*\
  !*** ./src/common/util/constant.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_ARRAY: () => (/* binding */ EMPTY_ARRAY),
/* harmony export */   EMPTY_FUNCTION: () => (/* binding */ EMPTY_FUNCTION),
/* harmony export */   EMPTY_STRING: () => (/* binding */ EMPTY_STRING),
/* harmony export */   FALSE: () => (/* binding */ FALSE),
/* harmony export */   GLOBAL: () => (/* binding */ GLOBAL),
/* harmony export */   MINUS_ONE: () => (/* binding */ MINUS_ONE),
/* harmony export */   NULL: () => (/* binding */ NULL),
/* harmony export */   RAW_DOT: () => (/* binding */ RAW_DOT),
/* harmony export */   RAW_FUNCTION: () => (/* binding */ RAW_FUNCTION),
/* harmony export */   RAW_UNDEFINED: () => (/* binding */ RAW_UNDEFINED),
/* harmony export */   RAW_WILDCARD: () => (/* binding */ RAW_WILDCARD),
/* harmony export */   SELF: () => (/* binding */ SELF),
/* harmony export */   TRUE: () => (/* binding */ TRUE),
/* harmony export */   UNDEFINED: () => (/* binding */ UNDEFINED),
/* harmony export */   WINDOW: () => (/* binding */ WINDOW)
/* harmony export */ });
/* unused harmony exports RAW_TRUE, RAW_FALSE, RAW_NULL, RAW_THIS, RAW_VALUE, RAW_LENGTH, RAW_SLASH, RAW_TAG, KEYPATH_PARENT, KEYPATH_CURRENT, DOCUMENT, EMPTY_OBJECT */
/**
 * @file 为了压缩，定义的常量
 */
const TRUE = true;
const FALSE = false;
const NULL = null;
const UNDEFINED = void 0;
const MINUS_ONE = -1;
const RAW_TRUE = 'true';
const RAW_FALSE = 'false';
const RAW_NULL = 'null';
const RAW_UNDEFINED = 'undefined';
const RAW_THIS = 'this';
const RAW_VALUE = 'value';
const RAW_LENGTH = 'length';
const RAW_FUNCTION = 'function';
const RAW_WILDCARD = '*';
const RAW_DOT = '.';
const RAW_SLASH = '/';
const RAW_TAG = 'tag';
const KEYPATH_PARENT = '..';
const KEYPATH_CURRENT = RAW_THIS;
/**
 * Single instance for window in browser
 */
const WINDOW = typeof window !== RAW_UNDEFINED ? window : UNDEFINED;
/**
 * Single instance for document in browser
 */
const DOCUMENT = typeof document !== RAW_UNDEFINED ? document : UNDEFINED;
/**
 * Single instance for global in nodejs or browser
 */
// @ts-ignore
const GLOBAL = typeof globalThis !== RAW_UNDEFINED ? globalThis : (typeof __webpack_require__.g !== RAW_UNDEFINED ? __webpack_require__.g : WINDOW);
/**
 * Single instance for self in nodejs or browser
 */
// @ts-ignore
const SELF = typeof self !== RAW_UNDEFINED ? self : GLOBAL;
/**
 * Single instance for noop function
 */
const EMPTY_FUNCTION = function () {
    /** common */
};
/**
 * 空对象，很多地方会用到，比如 `a || EMPTY_OBJECT` 确保是个对象
 */
const EMPTY_OBJECT = Object.freeze({});
/**
 * 空数组
 */
const EMPTY_ARRAY = Object.freeze([]);
/**
 * 空字符串
 */
const EMPTY_STRING = '';


/***/ }),

/***/ "./src/common/util/is.ts":
/*!*******************************!*\
  !*** ./src/common/util/is.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   array: () => (/* binding */ array),
/* harmony export */   arrayBuffer: () => (/* binding */ arrayBuffer),
/* harmony export */   bigint: () => (/* binding */ bigint),
/* harmony export */   boolean: () => (/* binding */ boolean),
/* harmony export */   func: () => (/* binding */ func),
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),
/* harmony export */   number: () => (/* binding */ number),
/* harmony export */   numeric: () => (/* binding */ numeric),
/* harmony export */   object: () => (/* binding */ object),
/* harmony export */   string: () => (/* binding */ string)
/* harmony export */ });
/* unused harmony export range */
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/**
 * @file 判断
 */

/**
 * Check if value is a function.
 *
 * @param value
 * @return
 */
function func(value) {
    return typeof value === _constant__WEBPACK_IMPORTED_MODULE_0__.RAW_FUNCTION;
}
/**
 * Check if value is an array.
 *
 * @param value
 * @return
 */
function array(value) {
    return Array.isArray(value);
}
/**
 * Check if value is an object.
 *
 * @param value
 * @return
 */
function object(value) {
    // 低版本 IE 会把 null 当作 object
    return value !== _constant__WEBPACK_IMPORTED_MODULE_0__.NULL && typeof value === 'object';
}
/**
 * Check if value is a string.
 *
 * @param value
 * @return
 */
function string(value) {
    return typeof value === 'string';
}
/**
 * Check if value is a number.
 *
 * @param value
 * @return
 */
function number(value) {
    return typeof value === 'number' && !isNaN(value);
}
/**
 * Check if value is a bigint.
 *
 * @param value
 * @return
 */
function bigint(value) {
    return typeof value === 'bigint';
}
/**
 * Check if value is boolean.
 *
 * @param value
 * @return
 */
function boolean(value) {
    return typeof value === 'boolean';
}
/**
 * Check if value is numeric.
 *
 * @param value
 * @return
 */
function numeric(value) {
    return number(value)
        || (string(value) && !isNaN(parseFloat(value)) && isFinite(+value));
}
const hasOwn = {}.hasOwnProperty;
/**
 * 判断是不是普通字面量对象
 *
 * @param {*} target
 * @return {boolean}
 */
function isPlainObject(target) {
    if (!object(target) || target.nodeType || target === target.window) {
        return false;
    }
    if (target.constructor
        && !hasOwn.call(target, 'constructor')
        && !hasOwn.call(target.constructor.prototype || {}, 'isPrototypeOf')) {
        return false;
    }
    let key;
    for (key in target) {
        /* empty */
    }
    return key === undefined || hasOwn.call(target, key);
}
/**
 * 判断 value 是否在指定范围中
 *
 * @param value 待判断值
 * @param min 范围左区间
 * @param max 范围右区间
 */
function range(value, min, max) {
    return value >= min && value <= max;
}
/**
 * Check if value is ArrayBuffer.
 *
 * @param value
 * @returns
 */
function arrayBuffer(value) {
    return value instanceof ArrayBuffer;
}


/***/ }),

/***/ "./src/common/util/keypath.ts":
/*!************************************!*\
  !*** ./src/common/util/keypath.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   each: () => (/* binding */ each)
/* harmony export */ });
/* unused harmony exports match, join, isFuzzy, matchFuzzy, rootPath */
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./string */ "./src/common/util/string.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/**
 * @file 路径操作
 */


const dotPattern = /\./g, asteriskPattern = /\*/g, doubleAsteriskPattern = /\*\*/g, splitCache = {}, patternCache = {};
/**
 * 判断 keypath 是否以 prefix 开头，如果是，返回匹配上的前缀长度，否则返回 -1
 *
 * @param keypath
 * @param prefix
 * @return
 */
function match(keypath, prefix) {
    if (keypath === prefix) {
        return prefix.length;
    }
    prefix += _constant__WEBPACK_IMPORTED_MODULE_1__.RAW_DOT;
    return _string__WEBPACK_IMPORTED_MODULE_0__.startsWith(keypath, prefix)
        ? prefix.length
        : _constant__WEBPACK_IMPORTED_MODULE_1__.MINUS_ONE;
}
/**
 * 遍历 keypath 的每个部分
 *
 * @param keypath
 * @param callback 返回 false 可中断遍历
 */
function each(keypath, callback) {
    /*
     * 如果 keypath 是 toString 之类的原型字段
     * splitCache[keypath] 会取到原型链上的对象
     */
    const list = splitCache.hasOwnProperty(keypath)
        ? splitCache[keypath]
        : (splitCache[keypath] = keypath.split(_constant__WEBPACK_IMPORTED_MODULE_1__.RAW_DOT));
    for (let i = 0, lastIndex = list.length - 1; i <= lastIndex; i++) {
        if (callback(list[i], i === lastIndex) === _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE) {
            break;
        }
    }
}
/**
 * 路径组合
 *
 * @param keypath1
 * @param keypath2
 */
function join(keypath1, keypath2) {
    return keypath1 && keypath2
        ? keypath1 + _constant__WEBPACK_IMPORTED_MODULE_1__.RAW_DOT + keypath2
        : keypath1 || keypath2;
}
/**
 * 是否是模糊匹配
 *
 * @param keypath
 */
function isFuzzy(keypath) {
    return _string__WEBPACK_IMPORTED_MODULE_0__.has(keypath, _constant__WEBPACK_IMPORTED_MODULE_1__.RAW_WILDCARD);
}
/**
 * 模糊匹配 keypath
 *
 * @param keypath 待匹配路径
 * @param pattern 匹配规则
 */
function matchFuzzy(keypath, pattern) {
    let cache = patternCache[pattern];
    if (!cache) {
        const str = pattern
            .replace(dotPattern, '\\.')
            .replace(asteriskPattern, '(\\w+)')
            .replace(doubleAsteriskPattern, '([\.\\w]+?)');
        cache = patternCache[pattern] = new RegExp(`^${str}$`);
    }
    const result = keypath.match(cache);
    if (result) {
        return result[1];
    }
}
/**
 * 返回 keypath 的根路径
 *
 * @param keypath
 */
function rootPath(keypath) {
    return keypath && keypath.split(_constant__WEBPACK_IMPORTED_MODULE_1__.RAW_DOT).shift();
}


/***/ }),

/***/ "./src/common/util/logger.ts":
/*!***********************************!*\
  !*** ./src/common/util/logger.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   INFO: () => (/* binding */ INFO),
/* harmony export */   debug: () => (/* binding */ debug),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   fatal: () => (/* binding */ fatal),
/* harmony export */   info: () => (/* binding */ info),
/* harmony export */   setLevel: () => (/* binding */ setLevel),
/* harmony export */   warn: () => (/* binding */ warn)
/* harmony export */ });
/* unused harmony exports TRACE, DEBUG, WARN, ERROR, FATAL, trace, log, enableUploadLog, disableUploadLog, canUploadLog, setUploadLevel, getUploadLevel */
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _function_toString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/toString */ "./src/common/function/toString.ts");
/**
 * @file 日志
 */


const TRACE = 0;
const DEBUG = 1;
const INFO = 2;
const WARN = 3;
const ERROR = 4;
const FATAL = 5;
const nativeConsole = typeof console !== _constant__WEBPACK_IMPORTED_MODULE_0__.RAW_UNDEFINED ? console : _constant__WEBPACK_IMPORTED_MODULE_0__.NULL, 
/**
 * 当前是否是源码调试，如果开启了代码压缩，empty function 里的注释会被干掉
 */
defaultLogLevel = /common/.test((0,_function_toString__WEBPACK_IMPORTED_MODULE_1__["default"])(_constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_FUNCTION)) ? INFO : WARN, 
/**
 * console 样式前缀
 * ie 和 edge 不支持 console.log 样式
 */
stylePrefix = _constant__WEBPACK_IMPORTED_MODULE_0__.WINDOW && /edge|msie|trident/i.test(_constant__WEBPACK_IMPORTED_MODULE_0__.WINDOW.navigator.userAgent) || true
    ? _constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STRING
    : 0, 
/**
 * 日志打印函数
 */
printLog = nativeConsole
    ? stylePrefix
        ? function (tag, msg, style) {
            nativeConsole.log(stylePrefix + tag, style, msg);
        }
        : function (tag, msg) {
            nativeConsole.log(tag, msg);
        }
    : _constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_FUNCTION;
/**
 * 全局调试开关
 */
function getLogLevel() {
    if (_constant__WEBPACK_IMPORTED_MODULE_0__.GLOBAL) {
        const logLevel = _constant__WEBPACK_IMPORTED_MODULE_0__.SELF['COMMON_LOG_LEVEL'];
        if (logLevel >= TRACE && logLevel <= FATAL) {
            return logLevel;
        }
    }
    return defaultLogLevel;
}
/**
 * 设置日志输出级别
 *
 * @param level 日志输出级别
 */
function setLevel(level) {
    _constant__WEBPACK_IMPORTED_MODULE_0__.SELF['COMMON_LOG_LEVEL'] = level;
}
function getStyle(backgroundColor) {
    return `background-color:${backgroundColor};border-radius:12px;color:#fff;font-size:10px;padding:3px 6px;`;
}
function trace(msg, file, line) {
    if (getLogLevel() <= TRACE) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [trace]`, msg, getStyle('#999'));
    }
}
function debug(msg, file, line) {
    if (getLogLevel() <= DEBUG) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [debug]`, msg, getStyle('#999'));
    }
}
function info(msg, file, line) {
    if (getLogLevel() <= INFO) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [info]`, msg, getStyle('#2db7f5'));
    }
}
function warn(msg, file, line) {
    if (getLogLevel() <= WARN) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [warn]`, msg, getStyle('#f90'));
    }
}
function error(msg, file, line) {
    if (getLogLevel() <= ERROR) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [error]`, msg, getStyle('#ed4014'));
    }
}
function fatal(msg, file, line) {
    if (getLogLevel() <= FATAL) {
        error(msg, file, line);
        throw new Error(`[${arguments[1]}][line ${arguments[2]}] [fatal]: ${msg}`);
    }
}
function log(level, msg, file, line) {
    if (level === TRACE) {
        trace(msg, arguments[2], arguments[3]);
    }
    else if (level === DEBUG) {
        debug(msg, arguments[2], arguments[3]);
    }
    else if (level === INFO) {
        info(msg, arguments[2], arguments[3]);
    }
    else if (level === WARN) {
        warn(msg, arguments[2], arguments[3]);
    }
    else if (level === ERROR) {
        error(msg, arguments[2], arguments[3]);
    }
    else if (level === FATAL) {
        fatal(msg, arguments[2], arguments[3]);
    }
}
/**
 * @internal
 * 是否上传，全局配置
 */
let enableUpload = true;
/**
 * @internal
 * 日志上传等级，全局配置
 */
let uploadLevel = WARN;
/**
 * 打开日志上传
 *
 */
function enableUploadLog() {
    enableUpload = true;
}
/**
 * 关闭日志上传
 */
function disableUploadLog() {
    enableUpload = false;
}
/**
 * 是否可以上传日志
 */
function canUploadLog() {
    return enableUpload;
}
/**
 * 设置日志上传等级
 */
function setUploadLevel(level) {
    uploadLevel = level;
}
/**
 * 获取日志上传等级
 */
function getUploadLevel() {
    return uploadLevel;
}


/***/ }),

/***/ "./src/common/util/object.ts":
/*!***********************************!*\
  !*** ./src/common/util/object.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   each: () => (/* binding */ each),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   keys: () => (/* binding */ keys),
/* harmony export */   param: () => (/* binding */ param)
/* harmony export */ });
/* unused harmony exports sort, clear, merge, get, set, has, falsy, diff, toArray, update, reverse */
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./src/common/util/array.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _keypath__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keypath */ "./src/common/util/keypath.ts");
/* harmony import */ var _function_isDef__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../function/isDef */ "./src/common/function/isDef.ts");
/**
 * @file 对象操作
 */





/**
 * 获取对象的 key 的数组
 *
 * @param object
 * @return
 */
function keys(object) {
    if (!(0,_function_isDef__WEBPACK_IMPORTED_MODULE_4__["default"])(object)) {
        return [];
    }
    return Object.keys(object);
}
function sortKeyByAsc(a, b) {
    return a.length - b.length;
}
function sortKeyByDesc(a, b) {
    return b.length - a.length;
}
/**
 * 排序对象的 key
 *
 * @param object
 * @param desc 是否逆序，默认从小到大排序
 * @return
 */
function sort(object, desc) {
    return keys(object).sort(desc ? sortKeyByDesc : sortKeyByAsc);
}
/**
 * 遍历对象
 *
 * @param object
 * @param callback 返回 false 可停止遍历
 */
function each(object, callback) {
    for (let key in object) {
        if (callback(object[key], key) === _constant__WEBPACK_IMPORTED_MODULE_2__.FALSE) {
            break;
        }
    }
}
/**
 * 清空对象所有的键值对
 *
 * @param object
 */
function clear(object) {
    each(object, function (_, key) {
        delete object[key];
    });
}
function _extend(original, object) {
    if (!_is__WEBPACK_IMPORTED_MODULE_0__.object(original)) {
        return object;
    }
    else if (!_is__WEBPACK_IMPORTED_MODULE_0__.object(object)) {
        return original;
    }
    each(object, function (value, key) {
        original[key] = value;
    });
    return original;
}
/**
 * 扩展对象
 *
 * @return
 */
function extend(original, object, object2) {
    return _extend(_extend(original, object), object2);
}
/**
 * 合并对象
 *
 * @return
 */
function merge(object1, object2) {
    return object1 && object2
        ? extend(extend({}, object1), object2)
        : object1 || object2;
}
/**
 * 拷贝对象
 *
 * @param object
 * @param deep 是否需要深拷贝
 * @return
 */
function copy(object, deep) {
    let result = object;
    if (_is__WEBPACK_IMPORTED_MODULE_0__.array(object)) {
        if (deep) {
            result = [];
            _array__WEBPACK_IMPORTED_MODULE_1__.each(object, function (item, index) {
                result[index] = copy(item, deep);
            });
        }
        else {
            result = object.slice();
        }
    }
    else if (_is__WEBPACK_IMPORTED_MODULE_0__.object(object)) {
        result = {};
        each(object, function (value, key) {
            result[key] = deep ? copy(value, deep) : value;
        });
    }
    return result;
}
/**
 * 从对象中查找一个 keypath
 *
 * 返回值是空时，表示没找到值
 *
 * @param object
 * @param keypath
 * @return
 */
function get(object, keypath, defaultValue) {
    let result;
    _keypath__WEBPACK_IMPORTED_MODULE_3__.each(keypath, function (key, isLast) {
        if (object != _constant__WEBPACK_IMPORTED_MODULE_2__.NULL) {
            // 先直接取值
            let value = object[key], 
            // 紧接着判断值是否存在
            hasValue = value !== _constant__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED;
            if (isLast) {
                if (hasValue) {
                    result = value;
                }
                else {
                    result = _constant__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED;
                }
            }
            else {
                object = value;
            }
        }
        else {
            result = _constant__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED;
            return _constant__WEBPACK_IMPORTED_MODULE_2__.FALSE;
        }
    });
    // 没找到使用默认值
    if (result === _constant__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED) {
        result = defaultValue;
    }
    return result;
}
/**
 * 为对象设置一个键值对
 *
 * @param object
 * @param keypath
 * @param value
 * @param autofill 是否自动填充不存在的对象，默认自动填充
 */
function set(object, keypath, value, autofill) {
    _keypath__WEBPACK_IMPORTED_MODULE_3__.each(keypath, function (key, isLast) {
        if (isLast) {
            object[key] = value;
        }
        else if (object[key]) {
            object = object[key];
        }
        else if (autofill) {
            object = object[key] = {};
        }
        else {
            return _constant__WEBPACK_IMPORTED_MODULE_2__.FALSE;
        }
    });
}
/**
 * 对象是否包含某个 key
 *
 * @param object
 * @param key
 * @return
 */
function has(object, key) {
    // 不用 hasOwnProperty，性能差
    return object[key] !== _constant__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED;
}
/**
 * 是否是空对象
 *
 * @param object
 * @return
 */
function falsy(object) {
    return !_is__WEBPACK_IMPORTED_MODULE_0__.object(object)
        || _is__WEBPACK_IMPORTED_MODULE_0__.array(object)
        || !keys(object).length;
}
/**
 * 获取两个对象的 value 不同的 key
 *
 * @param obj1
 * @param obj2
 */
function diff(obj1, obj2) {
    let differences = [];
    each(obj1, (value, key) => {
        if (_is__WEBPACK_IMPORTED_MODULE_0__.array(value) || _is__WEBPACK_IMPORTED_MODULE_0__.isPlainObject(value)) {
            if (obj2[key] == null || diff(value, obj2[key]).length > 0) {
                differences.push(key);
            }
        }
        else if (value !== obj2[key]) {
            differences.push(key);
        }
    });
    return differences;
}
/**
 * 序列化对象
 *
 * @param data
 */
function param(data) {
    let result = [];
    const add = (key, value) => {
        value = _is__WEBPACK_IMPORTED_MODULE_0__.func(value) ? value() : (value == null ? '' : value);
        result[result.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
    };
    if (_is__WEBPACK_IMPORTED_MODULE_0__.array(data) || _is__WEBPACK_IMPORTED_MODULE_0__.isPlainObject(data)) {
        if (_is__WEBPACK_IMPORTED_MODULE_0__.array(data)) {
            _array__WEBPACK_IMPORTED_MODULE_1__.each(data, (value, key) => {
                add(key, value);
            });
        }
        else {
            each(data, (value, key) => {
                add(key, value);
            });
        }
    }
    return result.join('&').replace(/%20/g, '+');
}
/**
 * 将 object 的 value 变成数组
 */
function toArray(data) {
    const result = [];
    each(data, (value) => {
        result.push(value);
    });
    return result;
}
/**
 *
 * 更新两个同一类型的对象
 *
 * @param obj1
 * @param obj2
 * @returns
 */
function update(obj1, obj2) {
    if (!_is__WEBPACK_IMPORTED_MODULE_0__.object(obj1) || !_is__WEBPACK_IMPORTED_MODULE_0__.object(obj2)) {
        return;
    }
    each(obj2, (value, key) => {
        if (_is__WEBPACK_IMPORTED_MODULE_0__.object(value) && _is__WEBPACK_IMPORTED_MODULE_0__.object(obj1[key])) {
            update(obj1[key], value);
        }
        else {
            obj1[key] = obj2[key];
        }
    });
    return obj1;
}
/**
 * 反转 object 的 key value
 */
function reverse(obj) {
    const result = {};
    each(obj, (value, key) => {
        result[value] = key;
    });
    return result;
}


/***/ }),

/***/ "./src/common/util/os.ts":
/*!*******************************!*\
  !*** ./src/common/util/os.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/**
 * UA 检测操作系统
 *
 * 返回结果如下：
 *
 * {
 *    name: 'mac',     // 判断多个浏览器时，便于用 name 去 switch
 *    mac: true,       // 判断某一个浏览器时，便于 if (mac) { ... }
 *    version: '8.0'   // 版本号，string 类型
 * }
 *
 */

/**
 * linux 发行版太多了，很多是没有版本信息的，只匹配 Linux 标识
 */
// 优先判断移动版，因为移动版通常会带着 PC 的标识，反过来则不会
const list = [
    ['iphone', /iphone os ([\d_.]+)/],
    ['ipad', /ipad; cpu os ([\d_.]+)/],
    ['itouch', /itouch; cpu os ([\d_.]+)/],
    ['android', /android ([\d_.]+)/],
    ['wp', /windows phone ([\d_.]+)/],
    ['windows', /windows nt ([\d_.]+)/],
    ['linux', /linux/],
    ['mac', /mac os x ([\d_.]+)/]
];
const iosMap = {
    iphone: 1,
    ipad: 1,
    itouch: 1
};
/**
 * 获取 UA 的结构化信息
 *
 * @inner
 * @param {string} ua
 * @return {Object}
 */
function parseUA(ua) {
    let name;
    let version;
    (0,_util_array__WEBPACK_IMPORTED_MODULE_0__.each)(list, (item) => {
        let match = item[1].exec(ua);
        if (match) {
            name = item[0];
            version = match[1];
            if (version) {
                version = version.replace(/_/g, '.');
            }
            return false;
        }
    });
    return {
        name: name || '',
        version: version || ''
    };
}
const os = parseUA((typeof navigator === 'object' && navigator.userAgent || '').toLowerCase());
if (os.name) {
    os[os.name] = true;
    if (iosMap[os.name]) {
        os.ios = true;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (os);


/***/ }),

/***/ "./src/common/util/string.ts":
/*!***********************************!*\
  !*** ./src/common/util/string.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   indexOf: () => (/* binding */ indexOf),
/* harmony export */   slice: () => (/* binding */ slice),
/* harmony export */   startsWith: () => (/* binding */ startsWith)
/* harmony export */ });
/* unused harmony exports capitalize, trim, lastIndexOf, endsWith, charAt, codeAt, upper, lower, falsy */
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _function_toString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/toString */ "./src/common/function/toString.ts");
/**
 * @file string 操作
 */



const capitalizePattern = /^[a-z]/, capitalizeCache = {};
/**
 * 首字母大写
 *
 * @param str
 * @return
 */
function capitalize(str) {
    if (!capitalizeCache[str]) {
        capitalizeCache[str] = str.replace(capitalizePattern, upper);
    }
    return capitalizeCache[str];
}
/**
 * 清除两侧空白符
 *
 * @param str
 * @return 清除两侧空白符的字符串
 */
function trim(str) {
    return falsy(str)
        ? _constant__WEBPACK_IMPORTED_MODULE_1__.EMPTY_STRING
        : str.trim();
}
/**
 * 截取字符串
 *
 * @param str
 * @param start
 * @param end
 * @return
 */
function slice(str, start, end) {
    return _is__WEBPACK_IMPORTED_MODULE_0__.number(end)
        ? start === end
            ? _constant__WEBPACK_IMPORTED_MODULE_1__.EMPTY_STRING
            : str.slice(start, end)
        : str.slice(start);
}
/**
 * 获取子串的起始位置
 *
 * @param str
 * @param part
 * @param start
 * @return
 */
function indexOf(str, part, start) {
    return str.indexOf(part, start !== _constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED ? start : 0);
}
/**
 * 获取子串的起始位置
 *
 * @param str
 * @param part
 * @param end
 * @return
 */
function lastIndexOf(str, part, end) {
    return str.lastIndexOf(part, end !== _constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED ? end : str.length);
}
/**
 * str 是否以 part 开头
 *
 * @param str
 * @param part
 * @return
 */
function startsWith(str, part) {
    return indexOf(str, part) === 0;
}
/**
 * str 是否以 part 结束
 *
 * @param str
 * @param part
 * @return
 */
function endsWith(str, part) {
    const offset = str.length - part.length;
    return offset >= 0 && lastIndexOf(str, part) === offset;
}
/**
 * 获取某个位置的字符
 */
function charAt(str, index) {
    return str.charAt(index || 0);
}
/**
 * 获取某个位置的字符编码
 */
function codeAt(str, index) {
    return str.charCodeAt(index || 0);
}
/**
 * 大写格式
 */
function upper(str) {
    return str.toUpperCase();
}
/**
 * 小写格式
 */
function lower(str) {
    return str.toLowerCase();
}
/**
 * str 是否包含 part
 *
 * @param str
 * @param part
 * @return 是否包含
 */
function has(str, part) {
    return indexOf(str, part) >= 0;
}
/**
 * 判断长度大于 0 的字符串
 *
 * @param str
 * @return
 */
function falsy(str) {
    return !_is__WEBPACK_IMPORTED_MODULE_0__.string(str) || !str.length;
}
/**
 * 格式化输出
 *
 * @param string
 * @param args
 * @returns
 */
function format(string, ...args) {
    let i = 0;
    const length = args.length;
    return string.replace(/(%[sdvx%])|(%0(\d)+[dx])/g, (str) => {
        if (i >= length) {
            // missing argument
            return str;
        }
        const arg = args[i++];
        if (/%0(\d)+[dx]/g.test(str)) {
            const length = parseInt(str.substring(1));
            let result = str[str.length - 1] === 'd' ? (0,_function_toString__WEBPACK_IMPORTED_MODULE_2__["default"])(Number(arg)) : Number(arg).toString(16);
            if (length > result.length) {
                result = new Array(length - result.length).fill('0').join('') + result;
            }
            return result;
        }
        switch (str) {
            case '%%':
                return '%';
            case '%s':
                return String(arg);
            case '%d':
                return (0,_function_toString__WEBPACK_IMPORTED_MODULE_2__["default"])(Number(arg));
            case '%v':
                return '';
            case '%x':
                return Number(arg).toString(16);
        }
        return str;
    });
}


/***/ }),

/***/ "./src/common/util/support.ts":
/*!************************************!*\
  !*** ./src/common/util/support.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browser */ "./src/common/util/browser.ts");

function supportedFeatures() {
    let blob = typeof Blob === 'function';
    let wasm = typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function';
    let fetchSupported = typeof fetch === 'function';
    let documentSupport = typeof document === 'object';
    let canvas = documentSupport && document.createElement('canvas');
    let webgl = canvas && !!canvas.getContext('webgl');
    let offscreenCanvas = typeof OffscreenCanvas === 'function';
    let worker = typeof Worker === 'function';
    let arrayBuffer = typeof ArrayBuffer === 'function';
    let atomics = typeof Atomics === 'object';
    let audioContext = typeof AudioContext === 'function' || typeof webkitAudioContext === 'function';
    let audioWorklet = typeof AudioWorklet === 'function';
    let videoDecoder = typeof VideoDecoder === 'function';
    let videoEncoder = typeof VideoEncoder === 'function';
    let audioDecoder = typeof AudioDecoder === 'function';
    let audioEncoder = typeof AudioEncoder === 'function';
    let shareArrayBuffer = typeof SharedArrayBuffer === 'function';
    let mse = typeof MediaSource == 'function' || typeof ManagedMediaSource === 'function';
    let proxy = typeof Proxy === 'function';
    let thread = worker && shareArrayBuffer && atomics && proxy;
    let jspi = typeof WebAssembly.Suspending === 'function' && typeof WebAssembly.promising === 'function';
    // safari 低于 11 不支持
    if (_browser__WEBPACK_IMPORTED_MODULE_0__["default"].safari && !_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '11', true)) {
        wasm = false;
    }
    // chrome 94 以上才支持 webcodec
    if (_browser__WEBPACK_IMPORTED_MODULE_0__["default"].chrome && !_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '94', true)) {
        videoDecoder = false;
        audioDecoder = false;
    }
    // safari 17 之前渲染 VideoFrame 有问题
    if (_browser__WEBPACK_IMPORTED_MODULE_0__["default"].safari && !_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '17', true)) {
        videoDecoder = false;
    }
    let webgpu = typeof navigator === 'object' && typeof navigator.gpu === 'object';
    let workerMSE = typeof MediaSourceHandle === 'function';
    let webAssemblyGlobal = wasm && typeof WebAssembly.Global === 'function';
    return {
        browser: _browser__WEBPACK_IMPORTED_MODULE_0__["default"],
        blob,
        wasm,
        fetch: fetchSupported,
        webgl,
        worker,
        mse,
        arrayBuffer,
        audioContext,
        audioWorklet,
        videoDecoder,
        videoEncoder,
        audioDecoder,
        audioEncoder,
        atomics,
        shareArrayBuffer,
        thread,
        webgpu,
        offscreenCanvas,
        workerMSE,
        webAssemblyGlobal,
        jspi,
        proxy,
        simd: (_browser__WEBPACK_IMPORTED_MODULE_0__["default"].chrome || _browser__WEBPACK_IMPORTED_MODULE_0__["default"].newEdge) && _browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '91', true)
            || _browser__WEBPACK_IMPORTED_MODULE_0__["default"].firefox && _browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '89', true)
            || _browser__WEBPACK_IMPORTED_MODULE_0__["default"].safari && _browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].version, '16.4', true),
        wasmBaseSupported: fetchSupported && wasm && webgl && audioContext && arrayBuffer && webAssemblyGlobal
    };
}
const support = supportedFeatures();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (support);


/***/ }),

/***/ "./src/common/util/text.ts":
/*!*********************************!*\
  !*** ./src/common/util/text.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   encode: () => (/* binding */ encode)
/* harmony export */ });
const encoder = typeof TextEncoder === 'function' ? new TextEncoder() : null;
const decoder = typeof TextDecoder === 'function' ? new TextDecoder() : null;
function encode(data) {
    if (encoder) {
        return encoder.encode(data);
    }
    const array = [];
    for (let i = 0; i < data.length; ++i) {
        let u = data.charCodeAt(i);
        if (u >= 55296 && u <= 57343) {
            let u1 = data.charCodeAt(++i);
            u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }
        if (u <= 127) {
            array.push(u);
        }
        else if (u <= 2047) {
            array.push(192 | u >> 6);
            array.push(128 | u & 63);
        }
        else if (u <= 65535) {
            array.push(224 | u >> 12);
            array.push(128 | u >> 6 & 63);
            array.push(128 | u & 63);
        }
        else {
            array.push(240 | u >> 18);
            array.push(128 | u >> 12 & 63);
            array.push(128 | u >> 6 & 63);
            array.push(128 | u & 63);
        }
    }
    return new Uint8Array(array);
}
function decode(data) {
    if (data instanceof Uint8Array && decoder && !(typeof SharedArrayBuffer === 'function' && data.buffer instanceof SharedArrayBuffer)) {
        return decoder.decode(data);
    }
    let result = '';
    for (let i = 0; i < data.length;) {
        let u0 = data[i++ >>> 0];
        if (!(u0 & 128)) {
            result += String.fromCharCode(u0);
            continue;
        }
        let u1 = data[i++ >>> 0] & 63;
        if ((u0 & 224) == 192) {
            result += String.fromCharCode((u0 & 31) << 6 | u1);
            continue;
        }
        let u2 = data[i++ >>> 0] & 63;
        if ((u0 & 240) == 224) {
            u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        }
        else {
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | data[i++ >>> 0] & 63;
        }
        if (u0 < 65536) {
            result += String.fromCharCode(u0);
        }
        else {
            let ch = u0 - 65536;
            result += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
    }
    return result;
}


/***/ }),

/***/ "./src/common/util/time.ts":
/*!*********************************!*\
  !*** ./src/common/util/time.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hhColonDDColonSSCommaMill2Int64: () => (/* binding */ hhColonDDColonSSCommaMill2Int64),
/* harmony export */   hhColonDDColonSSDotMill2Int64: () => (/* binding */ hhColonDDColonSSDotMill2Int64)
/* harmony export */ });
function hhColonDDColonSSDotMill2Int64(time) {
    time = time.trim();
    if (!time) {
        return -BigInt(1);
    }
    let list = time.split(':');
    let ts = BigInt(0);
    if (list.length === 3) {
        ts += BigInt(+(list.shift().trim())) * BigInt(3600000);
    }
    ts += BigInt(+(list.shift().trim())) * BigInt(60000);
    list = list.shift().trim().split('.');
    ts += BigInt(+(list.shift().trim())) * BigInt(1000);
    ts += BigInt(+(list.shift().trim()));
    return ts;
}
function hhColonDDColonSSCommaMill2Int64(time) {
    time = time.trim();
    if (!time) {
        return -BigInt(1);
    }
    let list = time.split(':');
    let ts = BigInt(0);
    if (list.length === 3) {
        ts += BigInt(+(list.shift().trim())) * BigInt(3600000);
    }
    ts += BigInt(+(list.shift().trim())) * BigInt(60000);
    list = list.shift().trim().split(',');
    ts += BigInt(+(list.shift().trim())) * BigInt(1000);
    ts += BigInt(+(list.shift().trim()));
    return ts;
}


/***/ }),

/***/ "./src/common/util/url.ts":
/*!********************************!*\
  !*** ./src/common/util/url.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildAbsoluteURL: () => (/* binding */ buildAbsoluteURL),
/* harmony export */   parse: () => (/* binding */ parse)
/* harmony export */ });
/* unused harmony exports parseQuery, stringifyQuery, mixin, normalizePath */
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _function_split__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/split */ "./src/common/function/split.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/object */ "./src/common/util/object.ts");
/**
 * @file url 操作
 */




/**
 * 把查询字符串解析成对象
 * @param queryStr
 */
function parseQuery(queryStr, separator = '&') {
    const result = {};
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.string(queryStr) && queryStr.indexOf('=') >= 0) {
        let firstChar = queryStr.charAt(0);
        let startIndex = (firstChar === '?' || firstChar === '#') ? 1 : 0;
        if (startIndex > 0) {
            queryStr = queryStr.substr(startIndex);
        }
        _util_array__WEBPACK_IMPORTED_MODULE_2__.each((0,_function_split__WEBPACK_IMPORTED_MODULE_1__["default"])(queryStr, separator), (item) => {
            let terms = item.split('=');
            if (terms.length === 2) {
                let key = terms[0]?.trim();
                if (key) {
                    result[key] = decodeURIComponent(terms[1]);
                }
            }
        });
    }
    return result;
}
/**
 * 把对象序列化成查询字符串
 *
 * @param query
 * @return
 */
function stringifyQuery(query, separator = '&') {
    const result = [];
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.isPlainObject(query)) {
        _util_object__WEBPACK_IMPORTED_MODULE_3__.each(query, (value, key) => {
            result.push(key + '=' + encodeURIComponent(_util_is__WEBPACK_IMPORTED_MODULE_0__.object(value) ? JSON.stringify(value) : value));
        });
    }
    return result.join(separator);
}
/**
 * 解析 url，返回格式遵循 location 属性的命名
 *
 * @param url 如果不传，使用当前地址
 */
function parse(url) {
    const key = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
    const parser = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    const result = {};
    const m = parser.exec(url);
    let i = 14;
    while (i--) {
        result[key[i]] = m[i] ?? '';
    }
    return {
        protocol: result.protocol,
        file: result.file,
        host: result.host,
        port: result.port,
        user: result.user,
        password: result.password,
        origin: `${result.protocol}://${result.authority}`,
        pathname: result.path,
        search: `?${result.query}`,
        hash: result.anchor ? `#${result.anchor}` : ''
    };
}
/**
 * 把参数混入一个 url
 *
 * @param query
 * @param url
 * @param applyHash
 */
function mixin(query, applyHash, url) {
    if (url == null) {
        url = document.URL;
    }
    let scheme = parse(url);
    let params = parseQuery(applyHash ? scheme.hash : scheme.search);
    _util_object__WEBPACK_IMPORTED_MODULE_3__.extend(params, query);
    let paramStr = _util_object__WEBPACK_IMPORTED_MODULE_3__.param(params);
    url = scheme.origin + scheme.pathname;
    if (applyHash) {
        url += scheme.search;
    }
    else if (paramStr) {
        url += '?' + paramStr;
    }
    if (!applyHash) {
        url += scheme.hash;
    }
    else if (paramStr) {
        url += '#' + paramStr;
    }
    return url;
}
const SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
const SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
const FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
const URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
function buildURLFromParts(parts) {
    return (parts.scheme +
        parts.netLoc +
        parts.path +
        parts.params +
        parts.query +
        parts.fragment);
}
function parseURL(url) {
    const parts = URL_REGEX.exec(url);
    if (!parts) {
        return null;
    }
    return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || ''
    };
}
function normalizePath(path) {
    // The following operations are
    // then applied, in order, to the new path:
    // 6a) All occurrences of "./", where "." is a complete path
    // segment, are removed.
    // 6b) If the path ends with "." as a complete path segment,
    // that "." is removed.
    path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
    // 6c) All occurrences of "<segment>/../", where <segment> is a
    // complete path segment not equal to "..", are removed.
    // Removal of these path segments is performed iteratively,
    // removing the leftmost matching pattern on each iteration,
    // until no matching pattern remains.
    // 6d) If the path ends with "<segment>/..", where <segment> is a
    // complete path segment not equal to "..", that
    // "<segment>/.." is removed.
    while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) { }
    return path.split('').reverse().join('');
}
/**
 * from https://github.com/tjenkinson/url-toolkit
 *
 */
function buildAbsoluteURL(baseURL, relativeURL, opts) {
    opts = opts || {};
    // remove any remaining space and CRLF
    baseURL = baseURL.trim();
    relativeURL = relativeURL.trim();
    if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
            return baseURL;
        }
        let basePartsForNormalize = parseURL(baseURL);
        if (!basePartsForNormalize) {
            throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalize.path = normalizePath(basePartsForNormalize.path);
        return buildURLFromParts(basePartsForNormalize);
    }
    let relativeParts = parseURL(relativeURL);
    if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
    }
    if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
            return relativeURL;
        }
        relativeParts.path = normalizePath(relativeParts.path);
        return buildURLFromParts(relativeParts);
    }
    let baseParts = parseURL(baseURL);
    if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
    }
    if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everything before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        let pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
    }
    if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
    }
    const builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment,
    };
    if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
            if (!relativeParts.path) {
                // 5) If the embedded URL path is empty (and not preceded by a
                // slash), then the embedded URL inherits the base URL path
                builtParts.path = baseParts.path;
                // 5a) if the embedded URL's <params> is non-empty, we skip to
                // step 7; otherwise, it inherits the <params> of the base
                // URL (if any) and
                if (!relativeParts.params) {
                    builtParts.params = baseParts.params;
                    // 5b) if the embedded URL's <query> is non-empty, we skip to
                    // step 7; otherwise, it inherits the <query> of the base
                    // URL (if any) and we skip to step 7.
                    if (!relativeParts.query) {
                        builtParts.query = baseParts.query;
                    }
                }
            }
            else {
                // 6) The last segment of the base URL's path (anything
                // following the rightmost slash "/", or the entire path if no
                // slash is present) is removed and the embedded URL's path is
                // appended in its place.
                let baseURLPath = baseParts.path;
                let newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +
                    relativeParts.path;
                builtParts.path = normalizePath(newPath);
            }
        }
    }
    if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize
            ? normalizePath(relativeParts.path)
            : relativeParts.path;
    }
    return buildURLFromParts(builtParts);
}


/***/ }),

/***/ "./src/common/util/wasm.ts":
/*!*********************************!*\
  !*** ./src/common/util/wasm.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readSLeb128Async: () => (/* binding */ readSLeb128Async),
/* harmony export */   readULeb128Async: () => (/* binding */ readULeb128Async),
/* harmony export */   setMemoryShared: () => (/* binding */ setMemoryShared),
/* harmony export */   writeSleb128Async: () => (/* binding */ writeSleb128Async),
/* harmony export */   writeUleb128Async: () => (/* binding */ writeUleb128Async)
/* harmony export */ });
/* unused harmony exports readULeb128, readSLeb128, writeSleb128, writeUleb128 */
/* harmony import */ var _io_BufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../io/BufferReader */ "./src/common/io/BufferReader.ts");

function readULeb128(reader) {
    let result = 0;
    let shift = 0;
    while (true) {
        const byte = reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    return result;
}
async function readULeb128Async(reader) {
    let result = 0;
    let shift = 0;
    while (true) {
        const byte = await reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    return result;
}
function readSLeb128(reader) {
    let result = 0;
    let shift = 0;
    let byte;
    while (true) {
        byte = reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    // 符号扩展，将最高有效位的符号位扩展到高位
    if (byte & 0x40) {
        // 如果最高有效位是 1（负数），则将高位全部置为 1
        result |= (~0 << shift);
    }
    return result;
}
async function readSLeb128Async(reader) {
    let result = 0;
    let shift = 0;
    let byte;
    while (true) {
        byte = await reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    // 符号扩展，将最高有效位的符号位扩展到高位
    if (byte & 0x40) {
        // 如果最高有效位是 1（负数），则将高位全部置为 1
        result |= (~0 << shift);
    }
    return result;
}
function writeSleb128(writer, value) {
    let more = true;
    while (more) {
        let byte = value & 0x7f;
        value >>= 7;
        // 如果还有未编码的位，设置高位为 1
        if ((value === 0 && (byte & 0x40) === 0) || (value === -1 && (byte & 0x40) !== 0)) {
            more = false;
        }
        else {
            byte |= 0x80;
        }
        writer.writeUint8(byte);
    }
}
async function writeSleb128Async(writer, value) {
    let more = true;
    while (more) {
        let byte = value & 0x7f;
        value >>= 7;
        // 如果还有未编码的位，设置高位为 1
        if ((value === 0 && (byte & 0x40) === 0) || (value === -1 && (byte & 0x40) !== 0)) {
            more = false;
        }
        else {
            byte |= 0x80;
        }
        await writer.writeUint8(byte);
    }
}
function writeUleb128(writer, value) {
    do {
        let byte = value & 0x7f;
        value >>= 7;
        // 如果还有未编码的位，设置高位为 1
        if (value !== 0) {
            byte |= 0x80;
        }
        writer.writeUint8(byte);
    } while (value !== 0);
}
async function writeUleb128Async(writer, value) {
    do {
        let byte = value & 0x7f;
        value >>= 7;
        // 如果还有未编码的位，设置高位为 1
        if (value !== 0) {
            byte |= 0x80;
        }
        await writer.writeUint8(byte);
    } while (value !== 0);
}
function setMemoryShared(wasm, shared) {
    const reader = new _io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](wasm, true);
    reader.skip(8);
    while (reader.remainingSize()) {
        const sectionId = reader.readUint8();
        const size = readULeb128(reader);
        if (sectionId === 2 /* SectionId.Import */) {
            let count = readULeb128(reader);
            while (count--) {
                const moduleLen = readULeb128(reader);
                reader.skip(moduleLen);
                const fieldLen = readULeb128(reader);
                reader.skip(fieldLen);
                const externalKind = reader.readUint8();
                switch (externalKind) {
                    case 0 /* ExternalKind.Function */: {
                        // type index of the function signature
                        readULeb128(reader);
                        break;
                    }
                    case 3 /* ExternalKind.Global */: {
                        // content_type
                        readSLeb128(reader);
                        // mutability
                        readULeb128(reader);
                        break;
                    }
                    case 2 /* ExternalKind.Memory */: {
                        const pos = Number(reader.getPos());
                        if (shared) {
                            wasm[pos] = wasm[pos] | 2;
                        }
                        else {
                            wasm[pos] = wasm[pos] & ~2;
                        }
                        return;
                    }
                    case 1 /* ExternalKind.Table */: {
                        // elem_type
                        readSLeb128(reader);
                        const flags = readULeb128(reader);
                        readULeb128(reader);
                        if (flags & 0x01) {
                            // maximum
                            readULeb128(reader);
                        }
                        break;
                    }
                }
            }
            return;
        }
        else {
            reader.skip(size);
        }
    }
}


/***/ }),

/***/ "./src/common/util/xml2Json.ts":
/*!*************************************!*\
  !*** ./src/common/util/xml2Json.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ xml2Json)
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./src/common/util/array.ts");

const defaultOptions = {
    aloneValueName: '_@attribute'
};
const splitChar = [' ', '/', '"', '\'', '<', '>'];
function xml2Json(xmlStr, options = defaultOptions) {
    // remove commented lines
    xmlStr = xmlStr.replace(/<!--[\s\S]*?-->/g, '');
    // replace special characters
    xmlStr = xmlStr.replace(/[\n\t\r]/g, '');
    // replace leading spaces and tabs between elements
    xmlStr = xmlStr.replace(/>[ \t]+</g, '><');
    // delete docType tags
    xmlStr = xmlStr.replace(/<\?[^>]*\?>/g, '');
    const stack = [];
    let pos = 0;
    function addData(key, value) {
        const item = stack[stack.length - 1];
        if (!item) {
            return;
        }
        if (key !== options.aloneValueName && item.obj[options.aloneValueName] != null) {
            item.obj[options.aloneValueName] = [item.obj[options.aloneValueName], {
                    tagName: key,
                    ...value
                }];
            return;
        }
        if (item.obj[key] == null) {
            item.obj[key] = value;
        }
        else if (Array.isArray(item.obj[key])) {
            item.obj[key].push(value);
        }
        else {
            item.obj[key] = [item.obj[key], value];
        }
    }
    function gotoToken(token) {
        while (pos < xmlStr.length) {
            if (xmlStr[pos] === token) {
                return true;
            }
            pos++;
        }
        return false;
    }
    function readIdentity() {
        skipSpace();
        let key = '';
        while (pos < xmlStr.length) {
            if (_array__WEBPACK_IMPORTED_MODULE_0__.has(splitChar, xmlStr[pos])) {
                break;
            }
            key += xmlStr[pos];
            pos++;
        }
        return key;
    }
    function skipSpace() {
        while (pos < xmlStr.length) {
            if (!/\s|\r|\n/.test(xmlStr[pos])) {
                break;
            }
            pos++;
        }
    }
    const emptyEndReg = /\s/;
    const singleQuotation = /'/;
    const doubleQuotation = /"/;
    function readAttrValue() {
        if (pos >= xmlStr.length) {
            return true;
        }
        skipSpace();
        // 默认属性值结束符为空格
        let end = emptyEndReg;
        if (xmlStr[pos] === '"' || xmlStr[pos] == '\'') {
            // 属性值是引号开始则结束符也是引号
            end = xmlStr[pos] === '"' ? doubleQuotation : singleQuotation;
            pos++;
        }
        let value = '';
        while (pos < xmlStr.length) {
            if (end.test(xmlStr[pos])) {
                pos++;
                break;
            }
            value += xmlStr[pos];
            pos++;
        }
        return value;
    }
    function readAttr() {
        while (true) {
            skipSpace();
            // 判断标签属性结束
            if (xmlStr[pos] === '>' || xmlStr[pos] === '/') {
                break;
            }
            let key = readIdentity();
            if (!key) {
                break;
            }
            if (key[key.length - 1] === '=') {
                key = key.substring(0, key.length - 1);
            }
            else {
                gotoToken('=');
                pos++;
            }
            const value = readAttrValue();
            addData(key, value);
        }
    }
    // innerText 当前位置到 < 之前
    function readText() {
        skipSpace();
        let text = '';
        while (pos < xmlStr.length) {
            if (xmlStr[pos] === '<') {
                break;
            }
            text += xmlStr[pos];
            pos++;
        }
        return text;
    }
    function pop() {
        // 处理 </> 跳出当前 tag
        // 若是 <xx 则是子标签，进入下一次处理 
        while (xmlStr[pos] === '<') {
            const now = pos;
            pos++;
            skipSpace();
            if (xmlStr[pos] === '/') {
                pos++;
                const tag = readIdentity();
                if (tag === stack[stack.length - 1].tag) {
                    if (stack.length > 1) {
                        const item = stack.pop();
                        addData(item.tag, item.obj);
                    }
                    gotoToken('>');
                    pos++;
                    skipSpace();
                }
                else {
                    stack.pop();
                    gotoToken('>');
                    pos++;
                    skipSpace();
                }
            }
            else {
                pos = now;
                break;
            }
        }
    }
    function readTag() {
        if (pos >= xmlStr.length) {
            return;
        }
        let start = pos;
        skipSpace();
        // innerText 的后面部分，中间被标签分割出现这种情况，将其加入 context 中
        if (xmlStr[pos] !== '<') {
            pos = start;
            addData(options.aloneValueName, readText());
            pop();
            return readTag();
        }
        let has = gotoToken('<');
        if (!has) {
            return;
        }
        start = pos;
        pos++;
        const tag = readIdentity();
        stack.push({
            obj: {},
            tag,
            start
        });
        readAttr();
        skipSpace();
        // 自闭合 tag
        if (xmlStr[pos] === '/') {
            pos++;
            if (stack.length > 1) {
                const item = stack.pop();
                addData(item.tag, item.obj);
            }
            gotoToken('>');
            pos++;
            pop();
            return readTag();
        }
        has = gotoToken('>');
        if (!has) {
            return;
        }
        pos++;
        skipSpace();
        // 检查有 innerText 内容
        if (xmlStr[pos] !== '<') {
            addData(options.aloneValueName, readText());
            skipSpace();
        }
        pop();
        readTag();
    }
    readTag();
    return {
        [stack[0].tag]: stack[0].obj
    };
}


/***/ }),

/***/ "./src/cheap/asm/memory.asm":
/*!**********************************!*\
  !*** ./src/cheap/asm/memory.asm ***!
  \**********************************/
/***/ ((module) => {

module.exports = "AGFzbQEAAAABKQhgAn9/AGACf34AYAJ/fQBgAn98AGABfwF/YAF/AX5gAX8BfWABfwF8AhIBA2VudgZtZW1vcnkCAwGAgAQDDw4AAAABAgMEBAQEBAUGBweIAQ4Gd3JpdGU4AAAHd3JpdGUxNgABB3dyaXRlMzIAAgd3cml0ZTY0AAMId3JpdGVmMzIABAh3cml0ZWY2NAAFBXJlYWQ4AAYGcmVhZFU4AAcGcmVhZDE2AAgHcmVhZFUxNgAJBnJlYWQzMgAKBnJlYWQ2NAALB3JlYWRmMzIADAdyZWFkZjY0AA0KfQ4JACAAIAE6AAALCQAgACABOwEACwkAIAAgATYCAAsJACAAIAE3AwALCQAgACABOAIACwkAIAAgATkDAAsHACAALAAACwcAIAAtAAALBwAgAC4BAAsHACAALwEACwcAIAAoAgALBwAgACkDAAsHACAAKgIACwcAIAArAwAL";

/***/ }),

/***/ "./src/cheap/thread/asm/atomics.asm":
/*!******************************************!*\
  !*** ./src/cheap/thread/asm/atomics.asm ***!
  \******************************************/
/***/ ((module) => {

module.exports = "AGFzbQEAAAABLAdgAX8Bf2ABfwF+YAJ/fwF/YAJ/fgF+YAN/f38Bf2ADf35+AX5gA39/fgF/AhIBA2VudgZtZW1vcnkCAwGAgAQDKCcAAAABAgICAwICAgMCAgIDAgICAwICAgMCAgIDAgICAwQEBAUCAgYHhgMnBWxvYWQ4AAAGbG9hZDE2AAEGbG9hZDMyAAIGbG9hZDY0AAMGc3RvcmU4AAQHc3RvcmUxNgAFB3N0b3JlMzIABgdzdG9yZTY0AAcEYWRkOAAIBWFkZDE2AAkFYWRkMzIACgVhZGQ2NAALBHN1YjgADAVzdWIxNgANBXN1YjMyAA4Fc3ViNjQADwRhbmQ4ABAFYW5kMTYAEQVhbmQzMgASBWFuZDY0ABMDb3I4ABQEb3IxNgAVBG9yMzIAFgRvcjY0ABcEeG9yOAAYBXhvcjE2ABkFeG9yMzIAGgV4b3I2NAAbCWV4Y2hhbmdlOAAcCmV4Y2hhbmdlMTYAHQpleGNoYW5nZTMyAB4KZXhjaGFuZ2U2NAAfEWNvbXBhcmVfZXhjaGFuZ2U4ACASY29tcGFyZV9leGNoYW5nZTE2ACESY29tcGFyZV9leGNoYW5nZTMyACISY29tcGFyZV9leGNoYW5nZTY0ACMGbm90aWZ5ACQEd2FpdAAlC3dhaXRUaW1lb3V0ACYKugMnCAAgAP4SAAALCAAgAP4TAQALCAAgAP4QAgALCAAgAP4RAwALDAAgACAB/hkAACABCwwAIAAgAf4aAQAgAQsMACAAIAH+FwIAIAELDAAgACAB/hgDACABCwoAIAAgAf4gAAALCgAgACAB/iEBAAsKACAAIAH+HgIACwoAIAAgAf4fAwALCgAgACAB/icAAAsKACAAIAH+KAEACwoAIAAgAf4lAgALCgAgACAB/iYDAAsKACAAIAH+LgAACwoAIAAgAf4vAQALCgAgACAB/iwCAAsKACAAIAH+LQMACwoAIAAgAf41AAALCgAgACAB/jYBAAsKACAAIAH+MwIACwoAIAAgAf40AwALCgAgACAB/jwAAAsKACAAIAH+PQEACwoAIAAgAf46AgALCgAgACAB/jsDAAsKACAAIAH+QwAACwoAIAAgAf5EAQALCgAgACAB/kECAAsKACAAIAH+QgMACwwAIAAgASAC/koAAAsMACAAIAEgAv5LAQALDAAgACABIAL+SAIACwwAIAAgASAC/kkDAAsKACAAIAH+AAIACwwAIAAgAUJ//gECAAsMACAAIAEgAv4BAgAL";

/***/ }),

/***/ "./src/cheap/webassembly/runtime/asm/libc.asm":
/*!****************************************************!*\
  !*** ./src/cheap/webassembly/runtime/asm/libc.asm ***!
  \****************************************************/
/***/ ((module) => {

module.exports = "AGFzbQEAAAABEANgAX8Bf2ABfwBgAn9/AX8CWQYDZW52Bm1lbW9yeQIDAYCABANlbnYGbWFsbG9jAAADZW52BGZyZWUAAQNlbnYGY2FsbG9jAAIDZW52B3JlYWxsb2MAAgNlbnYNYWxpZ25lZF9hbGxvYwACAwYFAAECAgIHMwUGbWFsbG9jAAUEZnJlZQAGBmNhbGxvYwAHB3JlYWxsb2MACAxhbGlnbmVkQWxsb2MACQoqBQYAIAAQAAsGACAAEAELCAAgACABEAILCAAgACABEAMLCAAgACABEAML";

/***/ }),

/***/ "./src/cheap/webassembly/runtime/asm/thread.asm":
/*!******************************************************!*\
  !*** ./src/cheap/webassembly/runtime/asm/thread.asm ***!
  \******************************************************/
/***/ ((module) => {

module.exports = "AGFzbQEAAAABEwNgAX8Bf2ACf38Bf2ADf39/AX8CEgEDZW52Bm1lbW9yeQIDAYCABAMIBwAAAAECAAAHQwcEbG9jawAAB3RyeWxvY2sAAQZ1bmxvY2sAAgR3YWl0AAMJdGltZWR3YWl0AAQGc2lnbmFsAAUJYnJvYWRjYXN0AAYKjgIHVgEBfyAAQQBBAf5IAgAhASABQQBHBEADQCABQQJGBH9BAQUgAEEBQQL+SAIAQQBHCwRAIABBAkJ//gECABoLIABBAEEC/kgCACEBIAFBAEcNAAsLQQALFwAgAEEAQQH+SAIAQQBGBH9BAAVBEAsLIwAgAEEB/iUCAEEBRwRAIABBAP4XAgAgAEEB/gACABoLQQALHQAgACAA/hACACABEAIaQn/+AQIAGiABEAAaQQALKQAgACAA/hACACABEAIaIAIpAwD+AQIAIAEQABpBAkYEf0HwAAVBAAsLFgAgAEEB/h4CABogAEEB/gACABpBAAsaACAAQQH+HgIAGiAAQYCAgIAE/gACABpBAAs=";

/***/ }),

/***/ "./node_modules/ass-compiler/dist/esm/ass-compiler.js":
/*!************************************************************!*\
  !*** ./node_modules/ass-compiler/dist/esm/ass-compiler.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compile: () => (/* binding */ compile)
/* harmony export */ });
/* unused harmony exports decompile, parse, stringify */
function parseEffect(text) {
  var param = text
    .toLowerCase()
    .trim()
    .split(/\s*;\s*/);
  if (param[0] === 'banner') {
    return {
      name: param[0],
      delay: param[1] * 1 || 0,
      leftToRight: param[2] * 1 || 0,
      fadeAwayWidth: param[3] * 1 || 0,
    };
  }
  if (/^scroll\s/.test(param[0])) {
    return {
      name: param[0],
      y1: Math.min(param[1] * 1, param[2] * 1),
      y2: Math.max(param[1] * 1, param[2] * 1),
      delay: param[3] * 1 || 0,
      fadeAwayHeight: param[4] * 1 || 0,
    };
  }
  if (text !== '') {
    return { name: text };
  }
  return null;
}

function parseDrawing(text) {
  if (!text) { return []; }
  return text
    .toLowerCase()
    // numbers
    .replace(/([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)/g, ' $1 ')
    // commands
    .replace(/([mnlbspc])/g, ' $1 ')
    .trim()
    .replace(/\s+/g, ' ')
    .split(/\s(?=[mnlbspc])/)
    .map(function (cmd) { return (
      cmd.split(' ')
        .filter(function (x, i) { return !(i && isNaN(x * 1)); })
    ); });
}

var numTags = [
  'b', 'i', 'u', 's', 'fsp',
  'k', 'K', 'kf', 'ko', 'kt',
  'fe', 'q', 'p', 'pbo', 'a', 'an',
  'fscx', 'fscy', 'fax', 'fay', 'frx', 'fry', 'frz', 'fr',
  'be', 'blur', 'bord', 'xbord', 'ybord', 'shad', 'xshad', 'yshad' ];

var numRegexs = numTags.map(function (nt) { return ({ name: nt, regex: new RegExp(("^" + nt + "-?\\d")) }); });

function parseTag(text) {
  var assign;

  var tag = {};
  for (var i = 0; i < numRegexs.length; i++) {
    var ref = numRegexs[i];
    var name = ref.name;
    var regex = ref.regex;
    if (regex.test(text)) {
      tag[name] = text.slice(name.length) * 1;
      return tag;
    }
  }
  if (/^fn/.test(text)) {
    tag.fn = text.slice(2);
  } else if (/^r/.test(text)) {
    tag.r = text.slice(1);
  } else if (/^fs[\d+-]/.test(text)) {
    tag.fs = text.slice(2);
  } else if (/^\d?c&?H?[0-9a-fA-F]+|^\d?c$/.test(text)) {
    var ref$1 = text.match(/^(\d?)c&?H?(\w*)/);
    var num = ref$1[1];
    var color = ref$1[2];
    tag[("c" + (num || 1))] = color && ("000000" + color).slice(-6);
  } else if (/^\da&?H?[0-9a-fA-F]+/.test(text)) {
    var ref$2 = text.match(/^(\d)a&?H?([0-9a-f]+)/i);
    var num$1 = ref$2[1];
    var alpha = ref$2[2];
    tag[("a" + num$1)] = ("00" + alpha).slice(-2);
  } else if (/^alpha&?H?[0-9a-fA-F]+/.test(text)) {
    (assign = text.match(/^alpha&?H?([0-9a-f]+)/i), tag.alpha = assign[1]);
    tag.alpha = ("00" + (tag.alpha)).slice(-2);
  } else if (/^(?:pos|org|move|fad|fade)\([^)]+/.test(text)) {
    var ref$3 = text.match(/^(\w+)\((.*?)\)?$/);
    var key = ref$3[1];
    var value = ref$3[2];
    tag[key] = value
      .trim()
      .split(/\s*,\s*/)
      .map(Number);
  } else if (/^i?clip\([^)]+/.test(text)) {
    var p = text
      .match(/^i?clip\((.*?)\)?$/)[1]
      .trim()
      .split(/\s*,\s*/);
    tag.clip = {
      inverse: /iclip/.test(text),
      scale: 1,
      drawing: null,
      dots: null,
    };
    if (p.length === 1) {
      tag.clip.drawing = parseDrawing(p[0]);
    }
    if (p.length === 2) {
      tag.clip.scale = p[0] * 1;
      tag.clip.drawing = parseDrawing(p[1]);
    }
    if (p.length === 4) {
      tag.clip.dots = p.map(Number);
    }
  } else if (/^t\(/.test(text)) {
    var p$1 = text
      .match(/^t\((.*?)\)?$/)[1]
      .trim()
      .replace(/\\.*/, function (x) { return x.replace(/,/g, '\n'); })
      .split(/\s*,\s*/);
    if (!p$1[0]) { return tag; }
    tag.t = {
      t1: 0,
      t2: 0,
      accel: 1,
      tags: p$1[p$1.length - 1]
        .replace(/\n/g, ',')
        .split('\\')
        .slice(1)
        .map(parseTag),
    };
    if (p$1.length === 2) {
      tag.t.accel = p$1[0] * 1;
    }
    if (p$1.length === 3) {
      tag.t.t1 = p$1[0] * 1;
      tag.t.t2 = p$1[1] * 1;
    }
    if (p$1.length === 4) {
      tag.t.t1 = p$1[0] * 1;
      tag.t.t2 = p$1[1] * 1;
      tag.t.accel = p$1[2] * 1;
    }
  }

  return tag;
}

function parseTags(text) {
  var tags = [];
  var depth = 0;
  var str = '';
  // `\b\c` -> `b\c\`
  // `a\b\c` -> `b\c\`
  var transText = text.split('\\').slice(1).concat('').join('\\');
  for (var i = 0; i < transText.length; i++) {
    var x = transText[i];
    if (x === '(') { depth++; }
    if (x === ')') { depth--; }
    if (depth < 0) { depth = 0; }
    if (!depth && x === '\\') {
      if (str) {
        tags.push(str);
      }
      str = '';
    } else {
      str += x;
    }
  }
  return tags.map(parseTag);
}

function parseText(text) {
  var pairs = text.split(/{([^{}]*?)}/);
  var parsed = [];
  if (pairs[0].length) {
    parsed.push({ tags: [], text: pairs[0], drawing: [] });
  }
  for (var i = 1; i < pairs.length; i += 2) {
    var tags = parseTags(pairs[i]);
    var isDrawing = tags.reduce(function (v, tag) { return (tag.p === undefined ? v : !!tag.p); }, false);
    parsed.push({
      tags: tags,
      text: isDrawing ? '' : pairs[i + 1],
      drawing: isDrawing ? parseDrawing(pairs[i + 1]) : [],
    });
  }
  return {
    raw: text,
    combined: parsed.map(function (frag) { return frag.text; }).join(''),
    parsed: parsed,
  };
}

function parseTime(time) {
  var t = time.split(':');
  return t[0] * 3600 + t[1] * 60 + t[2] * 1;
}

function parseDialogue(text, format) {
  var fields = text.split(',');
  if (fields.length > format.length) {
    var textField = fields.slice(format.length - 1).join();
    fields = fields.slice(0, format.length - 1);
    fields.push(textField);
  }

  var dia = {};
  for (var i = 0; i < fields.length; i++) {
    var fmt = format[i];
    var fld = fields[i].trim();
    switch (fmt) {
      case 'Layer':
      case 'MarginL':
      case 'MarginR':
      case 'MarginV':
        dia[fmt] = fld * 1;
        break;
      case 'Start':
      case 'End':
        dia[fmt] = parseTime(fld);
        break;
      case 'Effect':
        dia[fmt] = parseEffect(fld);
        break;
      case 'Text':
        dia[fmt] = parseText(fld);
        break;
      default:
        dia[fmt] = fld;
    }
  }

  return dia;
}

var stylesFormat = ['Name', 'Fontname', 'Fontsize', 'PrimaryColour', 'SecondaryColour', 'OutlineColour', 'BackColour', 'Bold', 'Italic', 'Underline', 'StrikeOut', 'ScaleX', 'ScaleY', 'Spacing', 'Angle', 'BorderStyle', 'Outline', 'Shadow', 'Alignment', 'MarginL', 'MarginR', 'MarginV', 'Encoding'];
var eventsFormat = ['Layer', 'Start', 'End', 'Style', 'Name', 'MarginL', 'MarginR', 'MarginV', 'Effect', 'Text'];

function parseFormat(text) {
  var fields = stylesFormat.concat(eventsFormat);
  return text.match(/Format\s*:\s*(.*)/i)[1]
    .split(/\s*,\s*/)
    .map(function (field) {
      var caseField = fields.find(function (f) { return f.toLowerCase() === field.toLowerCase(); });
      return caseField || field;
    });
}

function parseStyle(text, format) {
  var values = text.match(/Style\s*:\s*(.*)/i)[1].split(/\s*,\s*/);
  return Object.assign.apply(Object, [ {} ].concat( format.map(function (fmt, idx) {
    var obj;

    return (( obj = {}, obj[fmt] = values[idx], obj ));
  }) ));
}

function parse(text) {
  var tree = {
    info: {},
    styles: { format: [], style: [] },
    events: { format: [], comment: [], dialogue: [] },
  };
  var lines = text.split(/\r?\n/);
  var state = 0;
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i].trim();
    if (/^;/.test(line)) { continue; }

    if (/^\[Script Info\]/i.test(line)) { state = 1; }
    else if (/^\[V4\+? Styles\]/i.test(line)) { state = 2; }
    else if (/^\[Events\]/i.test(line)) { state = 3; }
    else if (/^\[.*\]/.test(line)) { state = 0; }

    if (state === 0) { continue; }
    if (state === 1) {
      if (/:/.test(line)) {
        var ref = line.match(/(.*?)\s*:\s*(.*)/);
        var key = ref[1];
        var value = ref[2];
        tree.info[key] = value;
      }
    }
    if (state === 2) {
      if (/^Format\s*:/i.test(line)) {
        tree.styles.format = parseFormat(line);
      }
      if (/^Style\s*:/i.test(line)) {
        tree.styles.style.push(parseStyle(line, tree.styles.format));
      }
    }
    if (state === 3) {
      if (/^Format\s*:/i.test(line)) {
        tree.events.format = parseFormat(line);
      }
      if (/^(?:Comment|Dialogue)\s*:/i.test(line)) {
        var ref$1 = line.match(/^(\w+?)\s*:\s*(.*)/i);
        var key$1 = ref$1[1];
        var value$1 = ref$1[2];
        tree.events[key$1.toLowerCase()].push(parseDialogue(value$1, tree.events.format));
      }
    }
  }

  return tree;
}

function stringifyInfo(info) {
  return Object.keys(info).map(function (key) { return (key + ": " + (info[key])); }).join('\n');
}

function pad00(n) {
  return ("00" + n).slice(-2);
}

function stringifyTime(tf) {
  var t = Number.parseFloat(tf.toFixed(2));
  var ms = t.toFixed(2).slice(-2);
  var s = (t | 0) % 60;
  var m = (t / 60 | 0) % 60;
  var h = t / 3600 | 0;
  return (h + ":" + (pad00(m)) + ":" + (pad00(s)) + "." + ms);
}

function stringifyEffect(eff) {
  if (!eff) { return ''; }
  if (eff.name === 'banner') {
    return ("Banner;" + (eff.delay) + ";" + (eff.leftToRight) + ";" + (eff.fadeAwayWidth));
  }
  if (/^scroll\s/.test(eff.name)) {
    return ((eff.name.replace(/^\w/, function (x) { return x.toUpperCase(); })) + ";" + (eff.y1) + ";" + (eff.y2) + ";" + (eff.delay) + ";" + (eff.fadeAwayHeight));
  }
  return eff.name;
}

function stringifyDrawing(drawing) {
  return drawing.map(function (cmds) { return cmds.join(' '); }).join(' ');
}

function stringifyTag(tag) {
  var ref = Object.keys(tag);
  var key = ref[0];
  if (!key) { return ''; }
  var _ = tag[key];
  if (['pos', 'org', 'move', 'fad', 'fade'].some(function (ft) { return ft === key; })) {
    return ("\\" + key + "(" + _ + ")");
  }
  if (/^[ac]\d$/.test(key)) {
    return ("\\" + (key[1]) + (key[0]) + "&H" + _ + "&");
  }
  if (key === 'alpha') {
    return ("\\alpha&H" + _ + "&");
  }
  if (key === 'clip') {
    return ("\\" + (_.inverse ? 'i' : '') + "clip(" + (_.dots || ("" + (_.scale === 1 ? '' : ((_.scale) + ",")) + (stringifyDrawing(_.drawing)))) + ")");
  }
  if (key === 't') {
    return ("\\t(" + ([_.t1, _.t2, _.accel, _.tags.map(stringifyTag).join('')]) + ")");
  }
  return ("\\" + key + _);
}

function stringifyText(Text) {
  return Text.parsed.map(function (ref) {
    var tags = ref.tags;
    var text = ref.text;
    var drawing = ref.drawing;

    var tagText = tags.map(stringifyTag).join('');
    var content = drawing.length ? stringifyDrawing(drawing) : text;
    return ("" + (tagText ? ("{" + tagText + "}") : '') + content);
  }).join('');
}

function stringifyEvent(event, format) {
  return format.map(function (fmt) {
    switch (fmt) {
      case 'Start':
      case 'End':
        return stringifyTime(event[fmt]);
      case 'MarginL':
      case 'MarginR':
      case 'MarginV':
        return event[fmt] || '0000';
      case 'Effect':
        return stringifyEffect(event[fmt]);
      case 'Text':
        return stringifyText(event.Text);
      default:
        return event[fmt];
    }
  }).join();
}

function stringify(ref) {
  var ref$1;

  var info = ref.info;
  var styles = ref.styles;
  var events = ref.events;
  return [
    '[Script Info]',
    stringifyInfo(info),
    '',
    '[V4+ Styles]',
    ("Format: " + (styles.format.join(', '))) ].concat( styles.style.map(function (style) { return ("Style: " + (styles.format.map(function (fmt) { return style[fmt]; }).join())); }),
    [''],
    ['[Events]'],
    [("Format: " + (events.format.join(', ')))],
    (ref$1 = [])
      .concat.apply(ref$1, ['Comment', 'Dialogue'].map(function (type) { return (
        events[type.toLowerCase()].map(function (dia) { return ({
          start: dia.Start,
          end: dia.End,
          string: (type + ": " + (stringifyEvent(dia, events.format))),
        }); })
      ); }))
      .sort(function (a, b) { return (a.start - b.start) || (a.end - b.end); })
      .map(function (x) { return x.string; }),
    [''] ).join('\n');
}

function createCommand(arr) {
  var cmd = {
    type: null,
    prev: null,
    next: null,
    points: [],
  };
  if (/[mnlbs]/.test(arr[0])) {
    cmd.type = arr[0]
      .toUpperCase()
      .replace('N', 'L')
      .replace('B', 'C');
  }
  for (var len = arr.length - !(arr.length & 1), i = 1; i < len; i += 2) {
    cmd.points.push({ x: arr[i] * 1, y: arr[i + 1] * 1 });
  }
  return cmd;
}

function isValid(cmd) {
  if (!cmd.points.length || !cmd.type) {
    return false;
  }
  if (/C|S/.test(cmd.type) && cmd.points.length < 3) {
    return false;
  }
  return true;
}

function getViewBox(commands) {
  var ref;

  var minX = Infinity;
  var minY = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;
  (ref = []).concat.apply(ref, commands.map(function (ref) {
    var points = ref.points;

    return points;
  })).forEach(function (ref) {
    var x = ref.x;
    var y = ref.y;

    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x);
    maxY = Math.max(maxY, y);
  });
  return {
    minX: minX,
    minY: minY,
    width: maxX - minX,
    height: maxY - minY,
  };
}

/**
 * Convert S command to B command
 * Reference from https://github.com/d3/d3/blob/v3.5.17/src/svg/line.js#L259
 * @param  {Array}  points points
 * @param  {String} prev   type of previous command
 * @param  {String} next   type of next command
 * @return {Array}         converted commands
 */
function s2b(points, prev, next) {
  var results = [];
  var bb1 = [0, 2 / 3, 1 / 3, 0];
  var bb2 = [0, 1 / 3, 2 / 3, 0];
  var bb3 = [0, 1 / 6, 2 / 3, 1 / 6];
  var dot4 = function (a, b) { return (a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]); };
  var px = [points[points.length - 1].x, points[0].x, points[1].x, points[2].x];
  var py = [points[points.length - 1].y, points[0].y, points[1].y, points[2].y];
  results.push({
    type: prev === 'M' ? 'M' : 'L',
    points: [{ x: dot4(bb3, px), y: dot4(bb3, py) }],
  });
  for (var i = 3; i < points.length; i++) {
    px = [points[i - 3].x, points[i - 2].x, points[i - 1].x, points[i].x];
    py = [points[i - 3].y, points[i - 2].y, points[i - 1].y, points[i].y];
    results.push({
      type: 'C',
      points: [
        { x: dot4(bb1, px), y: dot4(bb1, py) },
        { x: dot4(bb2, px), y: dot4(bb2, py) },
        { x: dot4(bb3, px), y: dot4(bb3, py) } ],
    });
  }
  if (next === 'L' || next === 'C') {
    var last = points[points.length - 1];
    results.push({ type: 'L', points: [{ x: last.x, y: last.y }] });
  }
  return results;
}

function toSVGPath(instructions) {
  return instructions.map(function (ref) {
    var type = ref.type;
    var points = ref.points;

    return (
    type + points.map(function (ref) {
      var x = ref.x;
      var y = ref.y;

      return (x + "," + y);
    }).join(',')
  );
  }).join('');
}

function compileDrawing(rawCommands) {
  var ref$1;

  var commands = [];
  var i = 0;
  while (i < rawCommands.length) {
    var arr = rawCommands[i];
    var cmd = createCommand(arr);
    if (isValid(cmd)) {
      if (cmd.type === 'S') {
        var ref = (commands[i - 1] || { points: [{ x: 0, y: 0 }] }).points.slice(-1)[0];
        var x = ref.x;
        var y = ref.y;
        cmd.points.unshift({ x: x, y: y });
      }
      if (i) {
        cmd.prev = commands[i - 1].type;
        commands[i - 1].next = cmd.type;
      }
      commands.push(cmd);
      i++;
    } else {
      if (i && commands[i - 1].type === 'S') {
        var additionPoints = {
          p: cmd.points,
          c: commands[i - 1].points.slice(0, 3),
        };
        commands[i - 1].points = commands[i - 1].points.concat(
          (additionPoints[arr[0]] || []).map(function (ref) {
            var x = ref.x;
            var y = ref.y;

            return ({ x: x, y: y });
        })
        );
      }
      rawCommands.splice(i, 1);
    }
  }
  var instructions = (ref$1 = []).concat.apply(
    ref$1, commands.map(function (ref) {
      var type = ref.type;
      var points = ref.points;
      var prev = ref.prev;
      var next = ref.next;

      return (
      type === 'S'
        ? s2b(points, prev, next)
        : { type: type, points: points }
    );
  })
  );

  return Object.assign({ instructions: instructions, d: toSVGPath(instructions) }, getViewBox(commands));
}

var tTags = [
  'fs', 'fsp', 'clip',
  'c1', 'c2', 'c3', 'c4', 'a1', 'a2', 'a3', 'a4', 'alpha',
  'fscx', 'fscy', 'fax', 'fay', 'frx', 'fry', 'frz', 'fr',
  'be', 'blur', 'bord', 'xbord', 'ybord', 'shad', 'xshad', 'yshad' ];

function compileTag(tag, key, presets) {
  var obj, obj$1, obj$2;

  if ( presets === void 0 ) presets = {};
  var value = tag[key];
  if (value === undefined) {
    return null;
  }
  if (key === 'pos' || key === 'org') {
    return value.length === 2 ? ( obj = {}, obj[key] = { x: value[0], y: value[1] }, obj ) : null;
  }
  if (key === 'move') {
    var x1 = value[0];
    var y1 = value[1];
    var x2 = value[2];
    var y2 = value[3];
    var t1 = value[4]; if ( t1 === void 0 ) t1 = 0;
    var t2 = value[5]; if ( t2 === void 0 ) t2 = 0;
    return value.length === 4 || value.length === 6
      ? { move: { x1: x1, y1: y1, x2: x2, y2: y2, t1: t1, t2: t2 } }
      : null;
  }
  if (key === 'fad' || key === 'fade') {
    if (value.length === 2) {
      var t1$1 = value[0];
      var t2$1 = value[1];
      return { fade: { type: 'fad', t1: t1$1, t2: t2$1 } };
    }
    if (value.length === 7) {
      var a1 = value[0];
      var a2 = value[1];
      var a3 = value[2];
      var t1$2 = value[3];
      var t2$2 = value[4];
      var t3 = value[5];
      var t4 = value[6];
      return { fade: { type: 'fade', a1: a1, a2: a2, a3: a3, t1: t1$2, t2: t2$2, t3: t3, t4: t4 } };
    }
    return null;
  }
  if (key === 'clip') {
    var inverse = value.inverse;
    var scale = value.scale;
    var drawing = value.drawing;
    var dots = value.dots;
    if (drawing) {
      return { clip: { inverse: inverse, scale: scale, drawing: compileDrawing(drawing), dots: dots } };
    }
    if (dots) {
      var x1$1 = dots[0];
      var y1$1 = dots[1];
      var x2$1 = dots[2];
      var y2$1 = dots[3];
      return { clip: { inverse: inverse, scale: scale, drawing: drawing, dots: { x1: x1$1, y1: y1$1, x2: x2$1, y2: y2$1 } } };
    }
    return null;
  }
  if (/^[xy]?(bord|shad)$/.test(key)) {
    value = Math.max(value, 0);
  }
  if (key === 'bord') {
    return { xbord: value, ybord: value };
  }
  if (key === 'shad') {
    return { xshad: value, yshad: value };
  }
  if (/^c\d$/.test(key)) {
    return ( obj$1 = {}, obj$1[key] = value || presets[key], obj$1 );
  }
  if (key === 'alpha') {
    return { a1: value, a2: value, a3: value, a4: value };
  }
  if (key === 'fr') {
    return { frz: value };
  }
  if (key === 'fs') {
    return {
      fs: /^\+|-/.test(value)
        ? (value * 1 > -10 ? (1 + value / 10) : 1) * presets.fs
        : value * 1,
    };
  }
  if (key === 'K') {
    return { kf: value };
  }
  if (key === 't') {
    var t1$3 = value.t1;
    var accel = value.accel;
    var tags = value.tags;
    var t2$3 = value.t2 || (presets.end - presets.start) * 1e3;
    var compiledTag = {};
    tags.forEach(function (t) {
      var k = Object.keys(t)[0];
      if (~tTags.indexOf(k) && !(k === 'clip' && !t[k].dots)) {
        Object.assign(compiledTag, compileTag(t, k, presets));
      }
    });
    return { t: { t1: t1$3, t2: t2$3, accel: accel, tag: compiledTag } };
  }
  return ( obj$2 = {}, obj$2[key] = value, obj$2 );
}

var a2an = [
  null, 1, 2, 3,
  null, 7, 8, 9,
  null, 4, 5, 6 ];

var globalTags = ['r', 'a', 'an', 'pos', 'org', 'move', 'fade', 'fad', 'clip'];

function inheritTag(pTag) {
  return JSON.parse(JSON.stringify(Object.assign({}, pTag, {
    k: undefined,
    kf: undefined,
    ko: undefined,
    kt: undefined,
  })));
}

function compileText(ref) {
  var styles = ref.styles;
  var style = ref.style;
  var parsed = ref.parsed;
  var start = ref.start;
  var end = ref.end;

  var alignment;
  var pos;
  var org;
  var move;
  var fade;
  var clip;
  var slices = [];
  var slice = { style: style, fragments: [] };
  var prevTag = {};
  for (var i = 0; i < parsed.length; i++) {
    var ref$1 = parsed[i];
    var tags = ref$1.tags;
    var text = ref$1.text;
    var drawing = ref$1.drawing;
    var reset = (void 0);
    for (var j = 0; j < tags.length; j++) {
      var tag = tags[j];
      reset = tag.r === undefined ? reset : tag.r;
    }
    var fragment = {
      tag: reset === undefined ? inheritTag(prevTag) : {},
      text: text,
      drawing: drawing.length ? compileDrawing(drawing) : null,
    };
    for (var j$1 = 0; j$1 < tags.length; j$1++) {
      var tag$1 = tags[j$1];
      alignment = alignment || a2an[tag$1.a || 0] || tag$1.an;
      pos = pos || compileTag(tag$1, 'pos');
      org = org || compileTag(tag$1, 'org');
      move = move || compileTag(tag$1, 'move');
      fade = fade || compileTag(tag$1, 'fade') || compileTag(tag$1, 'fad');
      clip = compileTag(tag$1, 'clip') || clip;
      var key = Object.keys(tag$1)[0];
      if (key && !~globalTags.indexOf(key)) {
        var sliceTag = styles[style].tag;
        var c1 = sliceTag.c1;
        var c2 = sliceTag.c2;
        var c3 = sliceTag.c3;
        var c4 = sliceTag.c4;
        var fs = prevTag.fs || sliceTag.fs;
        var compiledTag = compileTag(tag$1, key, { start: start, end: end, c1: c1, c2: c2, c3: c3, c4: c4, fs: fs });
        if (key === 't') {
          fragment.tag.t = fragment.tag.t || [];
          fragment.tag.t.push(compiledTag.t);
        } else {
          Object.assign(fragment.tag, compiledTag);
        }
      }
    }
    prevTag = fragment.tag;
    if (reset !== undefined) {
      slices.push(slice);
      slice = { style: styles[reset] ? reset : style, fragments: [] };
    }
    if (fragment.text || fragment.drawing) {
      var prev = slice.fragments[slice.fragments.length - 1] || {};
      if (prev.text && fragment.text && !Object.keys(fragment.tag).length) {
        // merge fragment to previous if its tag is empty
        prev.text += fragment.text;
      } else {
        slice.fragments.push(fragment);
      }
    }
  }
  slices.push(slice);

  return Object.assign({ alignment: alignment, slices: slices }, pos, org, move, fade, clip);
}

function compileDialogues(ref) {
  var styles = ref.styles;
  var dialogues = ref.dialogues;

  var minLayer = Infinity;
  var results = [];
  for (var i = 0; i < dialogues.length; i++) {
    var dia = dialogues[i];
    if (dia.Start >= dia.End) {
      continue;
    }
    if (!styles[dia.Style]) {
      dia.Style = 'Default';
    }
    var stl = styles[dia.Style].style;
    var compiledText = compileText({
      styles: styles,
      style: dia.Style,
      parsed: dia.Text.parsed,
      start: dia.Start,
      end: dia.End,
    });
    var alignment = compiledText.alignment || stl.Alignment;
    minLayer = Math.min(minLayer, dia.Layer);
    results.push(Object.assign({
      layer: dia.Layer,
      start: dia.Start,
      end: dia.End,
      style: dia.Style,
      name: dia.Name,
      // reset style by `\r` will not effect margin and alignment
      margin: {
        left: dia.MarginL || stl.MarginL,
        right: dia.MarginR || stl.MarginR,
        vertical: dia.MarginV || stl.MarginV,
      },
      effect: dia.Effect,
    }, compiledText, { alignment: alignment }));
  }
  for (var i$1 = 0; i$1 < results.length; i$1++) {
    results[i$1].layer -= minLayer;
  }
  return results.sort(function (a, b) { return a.start - b.start || a.end - b.end; });
}

// same as Aegisub
// https://github.com/Aegisub/Aegisub/blob/master/src/ass_style.h
var DEFAULT_STYLE = {
  Name: 'Default',
  Fontname: 'Arial',
  Fontsize: '20',
  PrimaryColour: '&H00FFFFFF&',
  SecondaryColour: '&H000000FF&',
  OutlineColour: '&H00000000&',
  BackColour: '&H00000000&',
  Bold: '0',
  Italic: '0',
  Underline: '0',
  StrikeOut: '0',
  ScaleX: '100',
  ScaleY: '100',
  Spacing: '0',
  Angle: '0',
  BorderStyle: '1',
  Outline: '2',
  Shadow: '2',
  Alignment: '2',
  MarginL: '10',
  MarginR: '10',
  MarginV: '10',
  Encoding: '1',
};

/**
 * @param {String} color
 * @returns {Array} [AA, BBGGRR]
 */
function parseStyleColor(color) {
  if (/^(&|H|&H)[0-9a-f]{6,}/i.test(color)) {
    var ref = color.match(/&?H?([0-9a-f]{2})?([0-9a-f]{6})/i);
    var a = ref[1];
    var c = ref[2];
    return [a || '00', c];
  }
  var num = parseInt(color, 10);
  if (!isNaN(num)) {
    var min = -2147483648;
    var max = 2147483647;
    if (num < min) {
      return ['00', '000000'];
    }
    var aabbggrr = (min <= num && num <= max)
      ? ("00000000" + ((num < 0 ? num + 4294967296 : num).toString(16))).slice(-8)
      : String(num).slice(0, 8);
    return [aabbggrr.slice(0, 2), aabbggrr.slice(2)];
  }
  return ['00', '000000'];
}

function compileStyles(ref) {
  var info = ref.info;
  var style = ref.style;
  var defaultStyle = ref.defaultStyle;

  var result = {};
  var styles = [Object.assign({}, defaultStyle, { Name: 'Default' })].concat(style);
  var loop = function ( i ) {
    var s = Object.assign({}, DEFAULT_STYLE, styles[i]);
    // this behavior is same as Aegisub by black-box testing
    if (/^(\*+)Default$/.test(s.Name)) {
      s.Name = 'Default';
    }
    Object.keys(s).forEach(function (key) {
      if (key !== 'Name' && key !== 'Fontname' && !/Colour/.test(key)) {
        s[key] *= 1;
      }
    });
    var ref$1 = parseStyleColor(s.PrimaryColour);
    var a1 = ref$1[0];
    var c1 = ref$1[1];
    var ref$2 = parseStyleColor(s.SecondaryColour);
    var a2 = ref$2[0];
    var c2 = ref$2[1];
    var ref$3 = parseStyleColor(s.OutlineColour);
    var a3 = ref$3[0];
    var c3 = ref$3[1];
    var ref$4 = parseStyleColor(s.BackColour);
    var a4 = ref$4[0];
    var c4 = ref$4[1];
    var tag = {
      fn: s.Fontname,
      fs: s.Fontsize,
      c1: c1,
      a1: a1,
      c2: c2,
      a2: a2,
      c3: c3,
      a3: a3,
      c4: c4,
      a4: a4,
      b: Math.abs(s.Bold),
      i: Math.abs(s.Italic),
      u: Math.abs(s.Underline),
      s: Math.abs(s.StrikeOut),
      fscx: s.ScaleX,
      fscy: s.ScaleY,
      fsp: s.Spacing,
      frz: s.Angle,
      xbord: s.Outline,
      ybord: s.Outline,
      xshad: s.Shadow,
      yshad: s.Shadow,
      fe: s.Encoding,
      q: /^[0-3]$/.test(info.WrapStyle) ? info.WrapStyle * 1 : 2,
    };
    result[s.Name] = { style: s, tag: tag };
  };

  for (var i = 0; i < styles.length; i++) loop( i );
  return result;
}

function compile(text, options) {
  if ( options === void 0 ) options = {};

  var tree = parse(text);
  var styles = compileStyles({
    info: tree.info,
    style: tree.styles.style,
    defaultStyle: options.defaultStyle || {},
  });
  return {
    info: tree.info,
    width: tree.info.PlayResX * 1 || null,
    height: tree.info.PlayResY * 1 || null,
    collisions: tree.info.Collisions || 'Normal',
    styles: styles,
    dialogues: compileDialogues({
      styles: styles,
      dialogues: tree.events.dialogue,
    }),
  };
}

function decompileStyle(ref) {
  var style = ref.style;
  var tag = ref.tag;

  var obj = Object.assign({}, style, {
    PrimaryColour: ("&H" + (tag.a1) + (tag.c1)),
    SecondaryColour: ("&H" + (tag.a2) + (tag.c2)),
    OutlineColour: ("&H" + (tag.a3) + (tag.c3)),
    BackColour: ("&H" + (tag.a4) + (tag.c4)),
  });
  return ("Style: " + (stylesFormat.map(function (fmt) { return obj[fmt]; }).join()));
}

var drawingInstructionMap = {
  M: 'm',
  L: 'l',
  C: 'b',
};

function decompileDrawing(ref) {
  var instructions = ref.instructions;

  return instructions.map(function (ref) {
    var ref$1;

    var type = ref.type;
    var points = ref.points;
    return (
    (ref$1 = [drawingInstructionMap[type]])
      .concat.apply(ref$1, points.map(function (ref) {
        var x = ref.x;
        var y = ref.y;

        return [x, y];
    }))
      .join(' ')
  );
  }).join(' ');
}

var ca = function (x) { return function (n) { return function (_) { return ("" + n + x + "&H" + _ + "&"); }; }; };
var c = ca('c');
var a = ca('a');

var tagDecompiler = {
  c1: c(1),
  c2: c(2),
  c3: c(3),
  c4: c(4),
  a1: a(1),
  a2: a(2),
  a3: a(3),
  a4: a(4),
  pos: function (_) { return ("pos(" + ([_.x, _.y]) + ")"); },
  org: function (_) { return ("org(" + ([_.x, _.y]) + ")"); },
  move: function (_) { return ("move(" + ([_.x1, _.y1, _.x2, _.y2, _.t1, _.t2]) + ")"); },
  fade: function (_) { return (
    _.type === 'fad'
      ? ("fad(" + ([_.t1, _.t2]) + ")")
      : ("fade(" + ([_.a1, _.a2, _.a3, _.t1, _.t2, _.t3, _.t4]) + ")")
  ); },
  clip: function (_) { return ((_.inverse ? 'i' : '') + "clip(" + (_.dots
      ? ("" + ([_.dots.x1, _.dots.y1, _.dots.x2, _.dots.y2]))
      : ("" + (_.scale === 1 ? '' : ((_.scale) + ",")) + (decompileDrawing(_.drawing)))) + ")"); },
  // eslint-disable-next-line no-use-before-define
  t: function (arr) { return arr.map(function (_) { return ("t(" + ([_.t1, _.t2, _.accel, decompileTag(_.tag)]) + ")"); }).join('\\'); },
};

function decompileTag(tag) {
  return Object.keys(tag).map(function (key) {
    var fn = tagDecompiler[key] || (function (_) { return ("" + key + _); });
    return ("\\" + (fn(tag[key])));
  }).join('');
}

function decompileSlice(slice) {
  return slice.fragments.map(function (ref) {
    var tag = ref.tag;
    var text = ref.text;
    var drawing = ref.drawing;

    var tagText = decompileTag(tag);
    return ("" + (tagText ? ("{" + tagText + "}") : '') + (drawing ? decompileDrawing(drawing) : text));
  }).join('');
}

function decompileText(dia, style) {
  return dia.slices
    .filter(function (slice) { return slice.fragments.length; })
    .map(function (slice, idx) {
      var sliceCopy = JSON.parse(JSON.stringify(slice));
      var tag = {};
      if (idx) {
        tag.r = slice.style === dia.style ? '' : slice.style;
      } else {
        if (style.Alignment !== dia.alignment) {
          tag.an = dia.alignment;
        }
        ['pos', 'org', 'move', 'fade', 'clip'].forEach(function (key) {
          if (dia[key]) {
            tag[key] = dia[key];
          }
        });
      }
      // make sure additional tags are first
      sliceCopy.fragments[0].tag = Object.assign(tag, sliceCopy.fragments[0].tag);
      return sliceCopy;
    })
    .map(decompileSlice)
    .join('');
}

function getMargin(margin, styleMargin) {
  return margin === styleMargin ? '0000' : margin;
}

function decompileDialogue(dia, style) {
  return ("Dialogue: " + ([
    dia.layer,
    stringifyTime(dia.start),
    stringifyTime(dia.end),
    dia.style,
    dia.name,
    getMargin(dia.margin.left, style.MarginL),
    getMargin(dia.margin.right, style.MarginR),
    getMargin(dia.margin.vertical, style.MarginV),
    stringifyEffect(dia.effect),
    decompileText(dia, style) ].join()));
}

function decompile(ref) {
  var info = ref.info;
  var width = ref.width;
  var height = ref.height;
  var collisions = ref.collisions;
  var styles = ref.styles;
  var dialogues = ref.dialogues;

  return [
    '[Script Info]',
    stringifyInfo(Object.assign({}, info, {
      PlayResX: width,
      PlayResY: height,
      Collisions: collisions,
    })),
    '',
    '[V4+ Styles]',
    ("Format: " + (stylesFormat.join(', '))) ].concat( Object.keys(styles).map(function (name) { return decompileStyle(styles[name]); }),
    [''],
    ['[Events]'],
    [("Format: " + (eventsFormat.join(', ')))],
    dialogues
      .sort(function (x, y) { return x.start - y.start || x.end - y.end; })
      .map(function (dia) { return decompileDialogue(dia, styles[dia.style].style); }),
    [''] ).join('\n');
}




/***/ }),

/***/ "./node_modules/ass-compiler/src/compiler/dialogues.js":
/*!*************************************************************!*\
  !*** ./node_modules/ass-compiler/src/compiler/dialogues.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileDialogues: () => (/* binding */ compileDialogues)
/* harmony export */ });
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text.js */ "./node_modules/ass-compiler/src/compiler/text.js");


function compileDialogues({ styles, dialogues }) {
  let minLayer = Infinity;
  const results = [];
  for (let i = 0; i < dialogues.length; i++) {
    const dia = dialogues[i];
    if (dia.Start >= dia.End) {
      continue;
    }
    if (!styles[dia.Style]) {
      dia.Style = 'Default';
    }
    const stl = styles[dia.Style].style;
    const compiledText = (0,_text_js__WEBPACK_IMPORTED_MODULE_0__.compileText)({
      styles,
      style: dia.Style,
      parsed: dia.Text.parsed,
      start: dia.Start,
      end: dia.End,
    });
    const alignment = compiledText.alignment || stl.Alignment;
    minLayer = Math.min(minLayer, dia.Layer);
    results.push(Object.assign({
      layer: dia.Layer,
      start: dia.Start,
      end: dia.End,
      style: dia.Style,
      name: dia.Name,
      // reset style by `\r` will not effect margin and alignment
      margin: {
        left: dia.MarginL || stl.MarginL,
        right: dia.MarginR || stl.MarginR,
        vertical: dia.MarginV || stl.MarginV,
      },
      effect: dia.Effect,
    }, compiledText, { alignment }));
  }
  for (let i = 0; i < results.length; i++) {
    results[i].layer -= minLayer;
  }
  return results.sort((a, b) => a.start - b.start || a.end - b.end);
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/compiler/drawing.js":
/*!***********************************************************!*\
  !*** ./node_modules/ass-compiler/src/compiler/drawing.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileDrawing: () => (/* binding */ compileDrawing)
/* harmony export */ });
/* unused harmony exports s2b, toSVGPath */
function createCommand(arr) {
  const cmd = {
    type: null,
    prev: null,
    next: null,
    points: [],
  };
  if (/[mnlbs]/.test(arr[0])) {
    cmd.type = arr[0]
      .toUpperCase()
      .replace('N', 'L')
      .replace('B', 'C');
  }
  for (let len = arr.length - !(arr.length & 1), i = 1; i < len; i += 2) {
    cmd.points.push({ x: arr[i] * 1, y: arr[i + 1] * 1 });
  }
  return cmd;
}

function isValid(cmd) {
  if (!cmd.points.length || !cmd.type) {
    return false;
  }
  if (/C|S/.test(cmd.type) && cmd.points.length < 3) {
    return false;
  }
  return true;
}

function getViewBox(commands) {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  [].concat(...commands.map(({ points }) => points)).forEach(({ x, y }) => {
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x);
    maxY = Math.max(maxY, y);
  });
  return {
    minX,
    minY,
    width: maxX - minX,
    height: maxY - minY,
  };
}

/**
 * Convert S command to B command
 * Reference from https://github.com/d3/d3/blob/v3.5.17/src/svg/line.js#L259
 * @param  {Array}  points points
 * @param  {String} prev   type of previous command
 * @param  {String} next   type of next command
 * @return {Array}         converted commands
 */
function s2b(points, prev, next) {
  const results = [];
  const bb1 = [0, 2 / 3, 1 / 3, 0];
  const bb2 = [0, 1 / 3, 2 / 3, 0];
  const bb3 = [0, 1 / 6, 2 / 3, 1 / 6];
  const dot4 = (a, b) => (a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]);
  let px = [points[points.length - 1].x, points[0].x, points[1].x, points[2].x];
  let py = [points[points.length - 1].y, points[0].y, points[1].y, points[2].y];
  results.push({
    type: prev === 'M' ? 'M' : 'L',
    points: [{ x: dot4(bb3, px), y: dot4(bb3, py) }],
  });
  for (let i = 3; i < points.length; i++) {
    px = [points[i - 3].x, points[i - 2].x, points[i - 1].x, points[i].x];
    py = [points[i - 3].y, points[i - 2].y, points[i - 1].y, points[i].y];
    results.push({
      type: 'C',
      points: [
        { x: dot4(bb1, px), y: dot4(bb1, py) },
        { x: dot4(bb2, px), y: dot4(bb2, py) },
        { x: dot4(bb3, px), y: dot4(bb3, py) },
      ],
    });
  }
  if (next === 'L' || next === 'C') {
    const last = points[points.length - 1];
    results.push({ type: 'L', points: [{ x: last.x, y: last.y }] });
  }
  return results;
}

function toSVGPath(instructions) {
  return instructions.map(({ type, points }) => (
    type + points.map(({ x, y }) => `${x},${y}`).join(',')
  )).join('');
}

function compileDrawing(rawCommands) {
  const commands = [];
  let i = 0;
  while (i < rawCommands.length) {
    const arr = rawCommands[i];
    const cmd = createCommand(arr);
    if (isValid(cmd)) {
      if (cmd.type === 'S') {
        const { x, y } = (commands[i - 1] || { points: [{ x: 0, y: 0 }] }).points.slice(-1)[0];
        cmd.points.unshift({ x, y });
      }
      if (i) {
        cmd.prev = commands[i - 1].type;
        commands[i - 1].next = cmd.type;
      }
      commands.push(cmd);
      i++;
    } else {
      if (i && commands[i - 1].type === 'S') {
        const additionPoints = {
          p: cmd.points,
          c: commands[i - 1].points.slice(0, 3),
        };
        commands[i - 1].points = commands[i - 1].points.concat(
          (additionPoints[arr[0]] || []).map(({ x, y }) => ({ x, y })),
        );
      }
      rawCommands.splice(i, 1);
    }
  }
  const instructions = [].concat(
    ...commands.map(({ type, points, prev, next }) => (
      type === 'S'
        ? s2b(points, prev, next)
        : { type, points }
    )),
  );

  return Object.assign({ instructions, d: toSVGPath(instructions) }, getViewBox(commands));
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/compiler/styles.js":
/*!**********************************************************!*\
  !*** ./node_modules/ass-compiler/src/compiler/styles.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileStyles: () => (/* binding */ compileStyles)
/* harmony export */ });
/* unused harmony export parseStyleColor */
// same as Aegisub
// https://github.com/Aegisub/Aegisub/blob/master/src/ass_style.h
const DEFAULT_STYLE = {
  Name: 'Default',
  Fontname: 'Arial',
  Fontsize: '20',
  PrimaryColour: '&H00FFFFFF&',
  SecondaryColour: '&H000000FF&',
  OutlineColour: '&H00000000&',
  BackColour: '&H00000000&',
  Bold: '0',
  Italic: '0',
  Underline: '0',
  StrikeOut: '0',
  ScaleX: '100',
  ScaleY: '100',
  Spacing: '0',
  Angle: '0',
  BorderStyle: '1',
  Outline: '2',
  Shadow: '2',
  Alignment: '2',
  MarginL: '10',
  MarginR: '10',
  MarginV: '10',
  Encoding: '1',
};

/**
 * @param {String} color
 * @returns {Array} [AA, BBGGRR]
 */
function parseStyleColor(color) {
  if (/^(&|H|&H)[0-9a-f]{6,}/i.test(color)) {
    const [, a, c] = color.match(/&?H?([0-9a-f]{2})?([0-9a-f]{6})/i);
    return [a || '00', c];
  }
  const num = parseInt(color, 10);
  if (!Number.isNaN(num)) {
    const min = -2147483648;
    const max = 2147483647;
    if (num < min) {
      return ['00', '000000'];
    }
    const aabbggrr = (min <= num && num <= max)
      ? `00000000${(num < 0 ? num + 4294967296 : num).toString(16)}`.slice(-8)
      : String(num).slice(0, 8);
    return [aabbggrr.slice(0, 2), aabbggrr.slice(2)];
  }
  return ['00', '000000'];
}

function compileStyles({ info, style, defaultStyle }) {
  const result = {};
  const styles = [Object.assign({}, defaultStyle, { Name: 'Default' })].concat(style);
  for (let i = 0; i < styles.length; i++) {
    const s = Object.assign({}, DEFAULT_STYLE, styles[i]);
    // this behavior is same as Aegisub by black-box testing
    if (/^(\*+)Default$/.test(s.Name)) {
      s.Name = 'Default';
    }
    Object.keys(s).forEach((key) => {
      if (key !== 'Name' && key !== 'Fontname' && !/Colour/.test(key)) {
        s[key] *= 1;
      }
    });
    const [a1, c1] = parseStyleColor(s.PrimaryColour);
    const [a2, c2] = parseStyleColor(s.SecondaryColour);
    const [a3, c3] = parseStyleColor(s.OutlineColour);
    const [a4, c4] = parseStyleColor(s.BackColour);
    const tag = {
      fn: s.Fontname,
      fs: s.Fontsize,
      c1,
      a1,
      c2,
      a2,
      c3,
      a3,
      c4,
      a4,
      b: Math.abs(s.Bold),
      i: Math.abs(s.Italic),
      u: Math.abs(s.Underline),
      s: Math.abs(s.StrikeOut),
      fscx: s.ScaleX,
      fscy: s.ScaleY,
      fsp: s.Spacing,
      frz: s.Angle,
      xbord: s.Outline,
      ybord: s.Outline,
      xshad: s.Shadow,
      yshad: s.Shadow,
      fe: s.Encoding,
      q: /^[0-3]$/.test(info.WrapStyle) ? info.WrapStyle * 1 : 2,
    };
    result[s.Name] = { style: s, tag };
  }
  return result;
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/compiler/tag.js":
/*!*******************************************************!*\
  !*** ./node_modules/ass-compiler/src/compiler/tag.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileTag: () => (/* binding */ compileTag)
/* harmony export */ });
/* harmony import */ var _drawing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawing.js */ "./node_modules/ass-compiler/src/compiler/drawing.js");


const tTags = [
  'fs', 'fsp', 'clip',
  'c1', 'c2', 'c3', 'c4', 'a1', 'a2', 'a3', 'a4', 'alpha',
  'fscx', 'fscy', 'fax', 'fay', 'frx', 'fry', 'frz', 'fr',
  'be', 'blur', 'bord', 'xbord', 'ybord', 'shad', 'xshad', 'yshad',
];

function compileTag(tag, key, presets = {}) {
  let value = tag[key];
  if (value === undefined) {
    return null;
  }
  if (key === 'pos' || key === 'org') {
    return value.length === 2 ? { [key]: { x: value[0], y: value[1] } } : null;
  }
  if (key === 'move') {
    const [x1, y1, x2, y2, t1 = 0, t2 = 0] = value;
    return value.length === 4 || value.length === 6
      ? { move: { x1, y1, x2, y2, t1, t2 } }
      : null;
  }
  if (key === 'fad' || key === 'fade') {
    if (value.length === 2) {
      const [t1, t2] = value;
      return { fade: { type: 'fad', t1, t2 } };
    }
    if (value.length === 7) {
      const [a1, a2, a3, t1, t2, t3, t4] = value;
      return { fade: { type: 'fade', a1, a2, a3, t1, t2, t3, t4 } };
    }
    return null;
  }
  if (key === 'clip') {
    const { inverse, scale, drawing, dots } = value;
    if (drawing) {
      return { clip: { inverse, scale, drawing: (0,_drawing_js__WEBPACK_IMPORTED_MODULE_0__.compileDrawing)(drawing), dots } };
    }
    if (dots) {
      const [x1, y1, x2, y2] = dots;
      return { clip: { inverse, scale, drawing, dots: { x1, y1, x2, y2 } } };
    }
    return null;
  }
  if (/^[xy]?(bord|shad)$/.test(key)) {
    value = Math.max(value, 0);
  }
  if (key === 'bord') {
    return { xbord: value, ybord: value };
  }
  if (key === 'shad') {
    return { xshad: value, yshad: value };
  }
  if (/^c\d$/.test(key)) {
    return { [key]: value || presets[key] };
  }
  if (key === 'alpha') {
    return { a1: value, a2: value, a3: value, a4: value };
  }
  if (key === 'fr') {
    return { frz: value };
  }
  if (key === 'fs') {
    return {
      fs: /^\+|-/.test(value)
        ? (value * 1 > -10 ? (1 + value / 10) : 1) * presets.fs
        : value * 1,
    };
  }
  if (key === 'K') {
    return { kf: value };
  }
  if (key === 't') {
    const { t1, accel, tags } = value;
    const t2 = value.t2 || (presets.end - presets.start) * 1e3;
    const compiledTag = {};
    tags.forEach((t) => {
      const k = Object.keys(t)[0];
      if (~tTags.indexOf(k) && !(k === 'clip' && !t[k].dots)) {
        Object.assign(compiledTag, compileTag(t, k, presets));
      }
    });
    return { t: { t1, t2, accel, tag: compiledTag } };
  }
  return { [key]: value };
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/compiler/text.js":
/*!********************************************************!*\
  !*** ./node_modules/ass-compiler/src/compiler/text.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileText: () => (/* binding */ compileText)
/* harmony export */ });
/* harmony import */ var _drawing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawing.js */ "./node_modules/ass-compiler/src/compiler/drawing.js");
/* harmony import */ var _tag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tag.js */ "./node_modules/ass-compiler/src/compiler/tag.js");



const a2an = [
  null, 1, 2, 3,
  null, 7, 8, 9,
  null, 4, 5, 6,
];

const globalTags = ['r', 'a', 'an', 'pos', 'org', 'move', 'fade', 'fad', 'clip'];

function inheritTag(pTag) {
  return JSON.parse(JSON.stringify(Object.assign({}, pTag, {
    k: undefined,
    kf: undefined,
    ko: undefined,
    kt: undefined,
  })));
}

function compileText({ styles, style, parsed, start, end }) {
  let alignment;
  let pos;
  let org;
  let move;
  let fade;
  let clip;
  const slices = [];
  let slice = { style, fragments: [] };
  let prevTag = {};
  for (let i = 0; i < parsed.length; i++) {
    const { tags, text, drawing } = parsed[i];
    let reset;
    for (let j = 0; j < tags.length; j++) {
      const tag = tags[j];
      reset = tag.r === undefined ? reset : tag.r;
    }
    const fragment = {
      tag: reset === undefined ? inheritTag(prevTag) : {},
      text,
      drawing: drawing.length ? (0,_drawing_js__WEBPACK_IMPORTED_MODULE_0__.compileDrawing)(drawing) : null,
    };
    for (let j = 0; j < tags.length; j++) {
      const tag = tags[j];
      alignment = alignment || a2an[tag.a || 0] || tag.an;
      pos = pos || (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.compileTag)(tag, 'pos');
      org = org || (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.compileTag)(tag, 'org');
      move = move || (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.compileTag)(tag, 'move');
      fade = fade || (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.compileTag)(tag, 'fade') || (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.compileTag)(tag, 'fad');
      clip = (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.compileTag)(tag, 'clip') || clip;
      const key = Object.keys(tag)[0];
      if (key && !~globalTags.indexOf(key)) {
        const sliceTag = styles[style].tag;
        const { c1, c2, c3, c4 } = sliceTag;
        const fs = prevTag.fs || sliceTag.fs;
        const compiledTag = (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.compileTag)(tag, key, { start, end, c1, c2, c3, c4, fs });
        if (key === 't') {
          fragment.tag.t = fragment.tag.t || [];
          fragment.tag.t.push(compiledTag.t);
        } else {
          Object.assign(fragment.tag, compiledTag);
        }
      }
    }
    prevTag = fragment.tag;
    if (reset !== undefined) {
      slices.push(slice);
      slice = { style: styles[reset] ? reset : style, fragments: [] };
    }
    if (fragment.text || fragment.drawing) {
      const prev = slice.fragments[slice.fragments.length - 1] || {};
      if (prev.text && fragment.text && !Object.keys(fragment.tag).length) {
        // merge fragment to previous if its tag is empty
        prev.text += fragment.text;
      } else {
        slice.fragments.push(fragment);
      }
    }
  }
  slices.push(slice);

  return Object.assign({ alignment, slices }, pos, org, move, fade, clip);
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/parser/drawing.js":
/*!*********************************************************!*\
  !*** ./node_modules/ass-compiler/src/parser/drawing.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseDrawing: () => (/* binding */ parseDrawing)
/* harmony export */ });
function parseDrawing(text) {
  if (!text) return [];
  return text
    .toLowerCase()
    // numbers
    .replace(/([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)/g, ' $1 ')
    // commands
    .replace(/([mnlbspc])/g, ' $1 ')
    .trim()
    .replace(/\s+/g, ' ')
    .split(/\s(?=[mnlbspc])/)
    .map((cmd) => (
      cmd.split(' ')
        .filter((x, i) => !(i && Number.isNaN(x * 1)))
    ));
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/parser/effect.js":
/*!********************************************************!*\
  !*** ./node_modules/ass-compiler/src/parser/effect.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseEffect: () => (/* binding */ parseEffect)
/* harmony export */ });
function parseEffect(text) {
  const param = text
    .toLowerCase()
    .trim()
    .split(/\s*;\s*/);
  if (param[0] === 'banner') {
    return {
      name: param[0],
      delay: param[1] * 1 || 0,
      leftToRight: param[2] * 1 || 0,
      fadeAwayWidth: param[3] * 1 || 0,
    };
  }
  if (/^scroll\s/.test(param[0])) {
    return {
      name: param[0],
      y1: Math.min(param[1] * 1, param[2] * 1),
      y2: Math.max(param[1] * 1, param[2] * 1),
      delay: param[3] * 1 || 0,
      fadeAwayHeight: param[4] * 1 || 0,
    };
  }
  if (text !== '') {
    return { name: text };
  }
  return null;
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/parser/tag.js":
/*!*****************************************************!*\
  !*** ./node_modules/ass-compiler/src/parser/tag.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseTag: () => (/* binding */ parseTag)
/* harmony export */ });
/* harmony import */ var _drawing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawing.js */ "./node_modules/ass-compiler/src/parser/drawing.js");


const numTags = [
  'b', 'i', 'u', 's', 'fsp',
  'k', 'K', 'kf', 'ko', 'kt',
  'fe', 'q', 'p', 'pbo', 'a', 'an',
  'fscx', 'fscy', 'fax', 'fay', 'frx', 'fry', 'frz', 'fr',
  'be', 'blur', 'bord', 'xbord', 'ybord', 'shad', 'xshad', 'yshad',
];

const numRegexs = numTags.map((nt) => ({ name: nt, regex: new RegExp(`^${nt}-?\\d`) }));

function parseTag(text) {
  const tag = {};
  for (let i = 0; i < numRegexs.length; i++) {
    const { name, regex } = numRegexs[i];
    if (regex.test(text)) {
      tag[name] = text.slice(name.length) * 1;
      return tag;
    }
  }
  if (/^fn/.test(text)) {
    tag.fn = text.slice(2);
  } else if (/^r/.test(text)) {
    tag.r = text.slice(1);
  } else if (/^fs[\d+-]/.test(text)) {
    tag.fs = text.slice(2);
  } else if (/^\d?c&?H?[0-9a-fA-F]+|^\d?c$/.test(text)) {
    const [, num, color] = text.match(/^(\d?)c&?H?(\w*)/);
    tag[`c${num || 1}`] = color && `000000${color}`.slice(-6);
  } else if (/^\da&?H?[0-9a-fA-F]+/.test(text)) {
    const [, num, alpha] = text.match(/^(\d)a&?H?([0-9a-f]+)/i);
    tag[`a${num}`] = `00${alpha}`.slice(-2);
  } else if (/^alpha&?H?[0-9a-fA-F]+/.test(text)) {
    [, tag.alpha] = text.match(/^alpha&?H?([0-9a-f]+)/i);
    tag.alpha = `00${tag.alpha}`.slice(-2);
  } else if (/^(?:pos|org|move|fad|fade)\([^)]+/.test(text)) {
    const [, key, value] = text.match(/^(\w+)\((.*?)\)?$/);
    tag[key] = value
      .trim()
      .split(/\s*,\s*/)
      .map(Number);
  } else if (/^i?clip\([^)]+/.test(text)) {
    const p = text
      .match(/^i?clip\((.*?)\)?$/)[1]
      .trim()
      .split(/\s*,\s*/);
    tag.clip = {
      inverse: /iclip/.test(text),
      scale: 1,
      drawing: null,
      dots: null,
    };
    if (p.length === 1) {
      tag.clip.drawing = (0,_drawing_js__WEBPACK_IMPORTED_MODULE_0__.parseDrawing)(p[0]);
    }
    if (p.length === 2) {
      tag.clip.scale = p[0] * 1;
      tag.clip.drawing = (0,_drawing_js__WEBPACK_IMPORTED_MODULE_0__.parseDrawing)(p[1]);
    }
    if (p.length === 4) {
      tag.clip.dots = p.map(Number);
    }
  } else if (/^t\(/.test(text)) {
    const p = text
      .match(/^t\((.*?)\)?$/)[1]
      .trim()
      .replace(/\\.*/, (x) => x.replace(/,/g, '\n'))
      .split(/\s*,\s*/);
    if (!p[0]) return tag;
    tag.t = {
      t1: 0,
      t2: 0,
      accel: 1,
      tags: p[p.length - 1]
        .replace(/\n/g, ',')
        .split('\\')
        .slice(1)
        .map(parseTag),
    };
    if (p.length === 2) {
      tag.t.accel = p[0] * 1;
    }
    if (p.length === 3) {
      tag.t.t1 = p[0] * 1;
      tag.t.t2 = p[1] * 1;
    }
    if (p.length === 4) {
      tag.t.t1 = p[0] * 1;
      tag.t.t2 = p[1] * 1;
      tag.t.accel = p[2] * 1;
    }
  }

  return tag;
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/parser/tags.js":
/*!******************************************************!*\
  !*** ./node_modules/ass-compiler/src/parser/tags.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseTags: () => (/* binding */ parseTags)
/* harmony export */ });
/* harmony import */ var _tag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tag.js */ "./node_modules/ass-compiler/src/parser/tag.js");


function parseTags(text) {
  const tags = [];
  let depth = 0;
  let str = '';
  // `\b\c` -> `b\c\`
  // `a\b\c` -> `b\c\`
  const transText = text.split('\\').slice(1).concat('').join('\\');
  for (let i = 0; i < transText.length; i++) {
    const x = transText[i];
    if (x === '(') depth++;
    if (x === ')') depth--;
    if (depth < 0) depth = 0;
    if (!depth && x === '\\') {
      if (str) {
        tags.push(str);
      }
      str = '';
    } else {
      str += x;
    }
  }
  return tags.map(_tag_js__WEBPACK_IMPORTED_MODULE_0__.parseTag);
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/parser/text.js":
/*!******************************************************!*\
  !*** ./node_modules/ass-compiler/src/parser/text.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseText: () => (/* binding */ parseText)
/* harmony export */ });
/* harmony import */ var _drawing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawing.js */ "./node_modules/ass-compiler/src/parser/drawing.js");
/* harmony import */ var _tags_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tags.js */ "./node_modules/ass-compiler/src/parser/tags.js");



function parseText(text) {
  const pairs = text.split(/{([^{}]*?)}/);
  const parsed = [];
  if (pairs[0].length) {
    parsed.push({ tags: [], text: pairs[0], drawing: [] });
  }
  for (let i = 1; i < pairs.length; i += 2) {
    const tags = (0,_tags_js__WEBPACK_IMPORTED_MODULE_1__.parseTags)(pairs[i]);
    const isDrawing = tags.reduce((v, tag) => (tag.p === undefined ? v : !!tag.p), false);
    parsed.push({
      tags,
      text: isDrawing ? '' : pairs[i + 1],
      drawing: isDrawing ? (0,_drawing_js__WEBPACK_IMPORTED_MODULE_0__.parseDrawing)(pairs[i + 1]) : [],
    });
  }
  return {
    raw: text,
    combined: parsed.map((frag) => frag.text).join(''),
    parsed,
  };
}


/***/ }),

/***/ "./node_modules/assjs/src/internal.js":
/*!********************************************!*\
  !*** ./node_modules/assjs/src/internal.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clear: () => (/* binding */ clear),
/* harmony export */   createResize: () => (/* binding */ createResize)
/* harmony export */ });
/* unused harmony exports createSeek, createPlay, createPause */
/* harmony import */ var _renderer_renderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer/renderer.js */ "./node_modules/assjs/src/renderer/renderer.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/assjs/src/utils.js");
/* eslint-disable no-param-reassign */



function clear(store) {
  const { box } = store;
  while (box.lastChild) {
    box.lastChild.remove();
  }
  store.actives = [];
  store.space = [];
}

function framing(store) {
  const { video, dialogues, actives } = store;
  const vct = video.currentTime - store.delay;
  for (let i = actives.length - 1; i >= 0; i -= 1) {
    const dia = actives[i];
    const { end } = dia;
    if (end < vct) {
      dia.$div.remove();
      actives.splice(i, 1);
    }
  }
  while (
    store.index < dialogues.length
    && vct >= dialogues[store.index].start
  ) {
    if (vct < dialogues[store.index].end) {
      const dia = (0,_renderer_renderer_js__WEBPACK_IMPORTED_MODULE_0__.renderer)(dialogues[store.index], store);
      if (!video.paused) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.batchAnimate)(dia, 'play');
      }
      actives.push(dia);
    }
    store.index += 1;
  }
}

function createSeek(store) {
  return function seek() {
    clear(store);
    const { video, dialogues } = store;
    const vct = video.currentTime - store.delay;
    store.index = (() => {
      for (let i = 0; i < dialogues.length; i += 1) {
        if (vct < dialogues[i].end) {
          return i;
        }
      }
      return (dialogues.length || 1) - 1;
    })();
    framing(store);
  };
}

function createPlay(store) {
  return function play() {
    const frame = () => {
      framing(store);
      store.requestId = requestAnimationFrame(frame);
    };
    cancelAnimationFrame(store.requestId);
    store.requestId = requestAnimationFrame(frame);
    store.actives.forEach((dia) => {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.batchAnimate)(dia, 'play');
    });
  };
}

function createPause(store) {
  return function pause() {
    cancelAnimationFrame(store.requestId);
    store.requestId = 0;
    store.actives.forEach((dia) => {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.batchAnimate)(dia, 'pause');
    });
  };
}

function createResize(that, store) {
  const { video, box, svg, layoutRes } = store;
  return function resize() {
    const cw = video.clientWidth;
    const ch = video.clientHeight;
    const vw = layoutRes.width || video.videoWidth || cw;
    const vh = layoutRes.height || video.videoHeight || ch;
    const sw = store.scriptRes.width;
    const sh = store.scriptRes.height;
    let rw = sw;
    let rh = sh;
    const videoScale = Math.min(cw / vw, ch / vh);
    if (that.resampling === 'video_width') {
      rh = sw / vw * vh;
    }
    if (that.resampling === 'video_height') {
      rw = sh / vh * vw;
    }
    store.scale = Math.min(cw / rw, ch / rh);
    if (that.resampling === 'script_width') {
      store.scale = videoScale * (vw / rw);
    }
    if (that.resampling === 'script_height') {
      store.scale = videoScale * (vh / rh);
    }
    const bw = store.scale * rw;
    const bh = store.scale * rh;
    store.width = bw;
    store.height = bh;
    store.resampledRes = { width: rw, height: rh };

    const cssText = `width:${bw}px;height:${bh}px;top:${(ch - bh) / 2}px;left:${(cw - bw) / 2}px;`;
    box.style.cssText = cssText;
    box.style.setProperty('--ass-scale', store.scale);
    box.style.setProperty('--ass-scale-stroke', store.sbas ? store.scale : 1);
    svg.style.cssText = cssText;

    createSeek(store)();
  };
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/animation.js":
/*!******************************************************!*\
  !*** ./node_modules/assjs/src/renderer/animation.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createAnimatableVars: () => (/* binding */ createAnimatableVars),
/* harmony export */   setKeyframes: () => (/* binding */ setKeyframes)
/* harmony export */ });
/* unused harmony exports createEffectKeyframes, createFadeKeyframes */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/assjs/src/utils.js");
/* harmony import */ var _font_size_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./font-size.js */ "./node_modules/assjs/src/renderer/font-size.js");
/* harmony import */ var _stroke_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stroke.js */ "./node_modules/assjs/src/renderer/stroke.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform.js */ "./node_modules/assjs/src/renderer/transform.js");





// TODO: multi \t can't be merged directly
function mergeT(ts) {
  return ts.reduceRight((results, t) => {
    let merged = false;
    return results
      .map((r) => {
        merged = t.t1 === r.t1 && t.t2 === r.t2 && t.accel === r.accel;
        return { ...r, ...(merged ? { tag: { ...r.tag, ...t.tag } } : {}) };
      })
      .concat(merged ? [] : t);
  }, []);
}

function createEffectKeyframes({ effect, duration }) {
  // TODO: when effect and move both exist, its behavior is weird, for now only move works.
  const { name, delay, leftToRight } = effect;
  if (name === 'banner') {
    const tx = (duration / (delay || 1)) * (leftToRight ? 1 : -1);
    return [0, `calc(var(--ass-scale) * ${tx}px)`].map((x, i) => ({
      offset: i,
      transform: `translateX(${x})`,
    }));
  }
  if (name.startsWith('scroll')) {
    // speed is 1000px/s when delay=1
    const updown = /up/.test(name) ? -1 : 1;
    const y = duration / (delay || 1) * updown;
    return [
      { offset: 0, transform: 'translateY(-100%)' },
      { offset: 1, transform: `translateY(calc(var(--ass-scale) * ${y}px))` },
    ];
  }
  return [];
}

function createMoveKeyframes({ move, duration, dialogue }) {
  const { x1, y1, x2, y2, t1, t2 } = move;
  const t = [t1, t2 || duration];
  const pos = dialogue.pos || { x: 0, y: 0 };
  return [[x1, y1], [x2, y2]]
    .map(([x, y]) => [(x - pos.x), (y - pos.y)])
    .map(([x, y], index) => ({
      offset: Math.min(t[index] / duration, 1),
      transform: `translate(calc(var(--ass-scale) * ${x}px), calc(var(--ass-scale) * ${y}px))`,
    }));
}

function createFadeKeyframes(fade, duration) {
  if (fade.type === 'fad') {
    const { t1, t2 } = fade;
    const kfs = [];
    if (t1) {
      kfs.push([0, 0]);
    }
    if (t1 < duration) {
      if (t2 <= duration) {
        kfs.push([t1 / duration, 1]);
      }
      if (t1 + t2 < duration) {
        kfs.push([(duration - t2) / duration, 1]);
      }
      if (t2 > duration) {
        kfs.push([0, (t2 - duration) / t2]);
      } else if (t1 + t2 > duration) {
        kfs.push([(t1 + 0.5) / duration, 1 - (t1 + t2 - duration) / t2]);
      }
      if (t2) {
        kfs.push([1, 0]);
      }
    } else {
      kfs.push([1, duration / t1]);
    }
    return kfs.map(([offset, opacity]) => ({ offset, opacity }));
  }
  const { a1, a2, a3, t1, t2, t3, t4 } = fade;
  const opacities = [a1, a2, a3].map((a) => 1 - a / 255);
  return [0, t1, t2, t3, t4, duration]
    .map((t) => t / duration)
    .map((t, i) => ({ offset: t, opacity: opacities[i >> 1] }))
    .filter(({ offset }) => offset <= 1);
}

function createTransformKeyframes({ fromTag, tag, fragment }) {
  const toTag = { ...fromTag, ...tag };
  if (fragment.drawing) {
    // scales will be handled inside svg
    Object.assign(toTag, {
      p: 0,
      fscx: ((tag.fscx || fromTag.fscx) / fromTag.fscx) * 100,
      fscy: ((tag.fscy || fromTag.fscy) / fromTag.fscy) * 100,
    });
    Object.assign(fromTag, { fscx: 100, fscy: 100 });
  }
  return Object.fromEntries((0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.createTransform)(toTag));
}

function createAnimatableVars(tag) {
  return [
    ['real-fs', (0,_font_size_js__WEBPACK_IMPORTED_MODULE_1__.getRealFontSize)(tag.fn, tag.fs)],
    ['tag-fs', tag.fs],
    ['tag-fsp', tag.fsp],
    ['fill-color', (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.color2rgba)(tag.a1 + tag.c1)],
  ]
    .filter(([, v]) => v)
    .map(([k, v]) => [`--ass-${k}`, v]);
}

if (window.CSS.registerProperty) {
  ['real-fs', 'tag-fs', 'tag-fsp'].forEach((k) => {
    window.CSS.registerProperty({
      name: `--ass-${k}`,
      syntax: '<number>',
      inherits: true,
      initialValue: '0',
    });
  });
  window.CSS.registerProperty({
    name: '--ass-fill-color',
    syntax: '<color>',
    inherits: true,
    initialValue: 'transparent',
  });
}

// TODO: accel is not implemented yet, maybe it can be simulated by cubic-bezier?
function setKeyframes(dialogue, store) {
  const { start, end, effect, move, fade, slices } = dialogue;
  const duration = (end - start) * 1000;
  const keyframes = [
    ...(effect && !move ? createEffectKeyframes({ effect, duration }) : []),
    ...(move ? createMoveKeyframes({ move, duration, dialogue }) : []),
    ...(fade ? createFadeKeyframes(fade, duration) : []),
  ].sort((a, b) => a.offset - b.offset);
  if (keyframes.length > 0) {
    Object.assign(dialogue, { keyframes });
  }
  slices.forEach((slice) => {
    const sliceTag = store.styles[slice.style].tag;
    slice.fragments.forEach((fragment) => {
      if (!fragment.tag.t || fragment.tag.t.length === 0) {
        return;
      }
      const fromTag = { ...sliceTag, ...fragment.tag };
      const tTags = mergeT(fragment.tag.t).sort((a, b) => a.t2 - b.t2 || a.t1 - b.t1);
      if (tTags[0].t1 > 0) {
        tTags.unshift({ t1: 0, t2: tTags[0].t1, tag: fromTag });
      }
      tTags.reduce((prevTag, curr) => {
        const tag = { ...prevTag, ...curr.tag };
        tag.t = null;
        Object.assign(curr.tag, tag);
        return tag;
      }, {});
      const fDuration = Math.max(duration, ...tTags.map(({ t2 }) => t2));
      const kfs = tTags.map(({ t2, tag }) => ({
        offset: t2 / fDuration,
        ...Object.fromEntries(createAnimatableVars({
          ...tag,
          a1: tag.a1 || fromTag.a1,
          c1: tag.c1 || fromTag.c1,
        })),
        ...Object.fromEntries((0,_stroke_js__WEBPACK_IMPORTED_MODULE_2__.createCSSStroke)(
          { ...fromTag, ...tag },
          store.sbas ? store.scale : 1,
        )),
        ...createTransformKeyframes({ fromTag, tag, fragment }),
      })).sort((a, b) => a.offset - b.offset);
      if (kfs.length > 0) {
        Object.assign(fragment, { keyframes: kfs, duration: fDuration });
      }
    });
  });
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/clip.js":
/*!*************************************************!*\
  !*** ./node_modules/assjs/src/renderer/clip.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getClipPath: () => (/* binding */ getClipPath)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/assjs/src/utils.js");


function addClipPath($defs, clip, id, sw, sh) {
  if ($defs.querySelector(`#${id}`)) return;
  let d = '';
  if (clip.dots !== null) {
    let { x1, y1, x2, y2 } = clip.dots;
    x1 /= sw;
    y1 /= sh;
    x2 /= sw;
    y2 /= sh;
    d = `M${x1},${y1}L${x1},${y2},${x2},${y2},${x2},${y1}Z`;
  }
  if (clip.drawing !== null) {
    d = clip.drawing.instructions.map(({ type, points }) => (
      type + points.map(({ x, y }) => `${x / sw},${y / sh}`).join(',')
    )).join('');
  }
  const scale = 1 / (1 << (clip.scale - 1));
  if (clip.inverse) {
    d += `M0,0L0,${scale},${scale},${scale},${scale},0,0,0Z`;
  }
  const $clipPath = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('clipPath', [
    ['id', id],
    ['clipPathUnits', 'objectBoundingBox'],
  ]);
  $clipPath.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('path', [
    ['d', d],
    ['transform', `scale(${scale})`],
    ['clip-rule', 'evenodd'],
  ]));
  $defs.append($clipPath);
}

function getClipPath(dialogue, store) {
  const { id, clip } = dialogue;
  if (!clip) return {};
  const { width, height } = store.scriptRes;
  addClipPath(store.defs, clip, id, width, height);
  const $clipArea = document.createElement('div');
  store.box.insertBefore($clipArea, dialogue.$div);
  $clipArea.append(dialogue.$div);
  $clipArea.className = 'ASS-clip-area';
  $clipArea.style.clipPath = `url(#${id})`;
  return { $div: $clipArea };
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/dom.js":
/*!************************************************!*\
  !*** ./node_modules/assjs/src/renderer/dom.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDialogue: () => (/* binding */ createDialogue)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/assjs/src/utils.js");
/* harmony import */ var _drawing_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawing.js */ "./node_modules/assjs/src/renderer/drawing.js");
/* harmony import */ var _animation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./animation.js */ "./node_modules/assjs/src/renderer/animation.js");
/* harmony import */ var _stroke_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stroke.js */ "./node_modules/assjs/src/renderer/stroke.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transform.js */ "./node_modules/assjs/src/renderer/transform.js");






function encodeText(text, q) {
  return text
    .replace(/\\h/g, ' ')
    .replace(/\\N/g, '\n')
    .replace(/\\n/g, q === 2 ? '\n' : ' ');
}

function createDialogue(dialogue, store) {
  const { video, styles } = store;
  const $div = document.createElement('div');
  $div.className = 'ASS-dialogue';
  const df = document.createDocumentFragment();
  const { align, slices, start, end } = dialogue;
  [
    ['--ass-align-h', ['left', 'center', 'right'][align.h]],
    ['--ass-align-v', ['bottom', 'center', 'top'][align.v]],
  ].forEach(([k, v]) => {
    $div.style.setProperty(k, v);
  });
  const animationOptions = {
    duration: (end - start) * 1000,
    delay: Math.min(0, start - (video.currentTime - store.delay)) * 1000,
    fill: 'forwards',
  };
  const animations = [];
  slices.forEach((slice) => {
    const sliceTag = styles[slice.style].tag;
    const borderStyle = styles[slice.style].style.BorderStyle;
    slice.fragments.forEach((fragment) => {
      const { text, drawing } = fragment;
      const tag = { ...sliceTag, ...fragment.tag };
      let cssText = '';
      const cssVars = [];
      if (!drawing) {
        cssVars.push(...(0,_animation_js__WEBPACK_IMPORTED_MODULE_2__.createAnimatableVars)(tag));
        const scale = store.sbas ? store.scale : 1;
        cssVars.push(...(0,_stroke_js__WEBPACK_IMPORTED_MODULE_3__.createCSSStroke)(tag, scale));

        cssText += `font-family:"${tag.fn}";`;
        cssText += tag.b ? `font-weight:${tag.b === 1 ? 'bold' : tag.b};` : '';
        cssText += tag.i ? 'font-style:italic;' : '';
        cssText += (tag.u || tag.s) ? `text-decoration:${tag.u ? 'underline' : ''} ${tag.s ? 'line-through' : ''};` : '';
      }
      if (drawing && tag.pbo) {
        const pbo = -tag.pbo * (tag.fscy || 100) / 100;
        cssText += `vertical-align:calc(var(--ass-scale) * ${pbo}px);`;
      }

      cssVars.push(...(0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.createTransform)(tag));
      const tags = [tag, ...(tag.t || []).map((t) => t.tag)];
      const hasRotate = _transform_js__WEBPACK_IMPORTED_MODULE_4__.rotateTags.some((x) => tags.some((t) => t[x]));
      const hasScale = _transform_js__WEBPACK_IMPORTED_MODULE_4__.scaleTags.some((x) => tags.some((t) => t[x] !== undefined && t[x] !== 100));
      const hasSkew = _transform_js__WEBPACK_IMPORTED_MODULE_4__.skewTags.some((x) => tags.some((t) => t[x]));

      encodeText(text, tag.q).split('\n').forEach((content, idx) => {
        const $span = document.createElement('span');
        const $ssspan = document.createElement('span');
        $span.dataset.wrapStyle = tag.q;
        $span.dataset.borderStyle = borderStyle;
        if (hasScale || hasSkew) {
          if (hasScale) {
            $ssspan.dataset.scale = '';
          }
          if (hasSkew) {
            $ssspan.dataset.skew = '';
          }
          $ssspan.textContent = content;
        }
        if (hasRotate) {
          $span.dataset.rotate = '';
        }
        if (drawing) {
          $span.dataset.drawing = '';
          const obj = (0,_drawing_js__WEBPACK_IMPORTED_MODULE_1__.createDrawing)(fragment, sliceTag, store);
          if (!obj) return;
          $span.style.cssText = obj.cssText;
          $span.append(obj.$svg);
        } else {
          $span.dataset.text = '';
          if (idx) {
            df.append(document.createElement('br'));
          }
          if (!content) return;
          if (hasScale || hasSkew) {
            $span.append($ssspan);
          } else {
            $span.textContent = content;
          }
          const el = hasScale || hasSkew ? $ssspan : $span;
          if (tag.xbord || tag.ybord || tag.xshad || tag.yshad) {
            el.dataset.text = content;
          }
        }
        $span.style.cssText += cssText;
        cssVars.forEach(([k, v]) => {
          $span.style.setProperty(k, v);
        });
        if (fragment.keyframes) {
          const animation = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.initAnimation)(
            $span,
            fragment.keyframes,
            { ...animationOptions, duration: fragment.duration },
          );
          animations.push(animation);
        }
        df.append($span);
      });
    });
  });
  if (dialogue.keyframes) {
    animations.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.initAnimation)($div, dialogue.keyframes, animationOptions));
  }
  $div.append(df);
  return { $div, animations };
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/drawing.js":
/*!****************************************************!*\
  !*** ./node_modules/assjs/src/renderer/drawing.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDrawing: () => (/* binding */ createDrawing)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/assjs/src/utils.js");
/* harmony import */ var _stroke_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stroke.js */ "./node_modules/assjs/src/renderer/stroke.js");



function createDrawing(fragment, styleTag, store) {
  if (!fragment.drawing.d) return null;
  const tag = { ...styleTag, ...fragment.tag };
  const { minX, minY, width, height } = fragment.drawing;
  const baseScale = store.scale / (1 << (tag.p - 1));
  const scaleX = (tag.fscx ? tag.fscx / 100 : 1) * baseScale;
  const scaleY = (tag.fscy ? tag.fscy / 100 : 1) * baseScale;
  const blur = tag.blur || tag.be || 0;
  const vbx = tag.xbord + (tag.xshad < 0 ? -tag.xshad : 0) + blur;
  const vby = tag.ybord + (tag.yshad < 0 ? -tag.yshad : 0) + blur;
  const vbw = width * scaleX + 2 * tag.xbord + Math.abs(tag.xshad) + 2 * blur;
  const vbh = height * scaleY + 2 * tag.ybord + Math.abs(tag.yshad) + 2 * blur;
  const $svg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('svg', [
    ['width', vbw],
    ['height', vbh],
    ['viewBox', `${-vbx} ${-vby} ${vbw} ${vbh}`],
  ]);
  const strokeScale = store.sbas ? store.scale : 1;
  const filterId = `ASS-${(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.uuid)()}`;
  const $defs = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('defs');
  $defs.append((0,_stroke_js__WEBPACK_IMPORTED_MODULE_1__.createSVGStroke)(tag, filterId, strokeScale));
  $svg.append($defs);
  const symbolId = `ASS-${(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.uuid)()}`;
  const $symbol = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('symbol', [
    ['id', symbolId],
    ['viewBox', `${minX} ${minY} ${width} ${height}`],
  ]);
  $symbol.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('path', [['d', fragment.drawing.d]]));
  $svg.append($symbol);
  $svg.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('use', [
    ['width', width * scaleX],
    ['height', height * scaleY],
    ['xlink:href', `#${symbolId}`],
    ['filter', `url(#${filterId})`],
  ]));
  $svg.style.cssText = (
    'position:absolute;'
    + `left:${minX * scaleX - vbx}px;`
    + `top:${minY * scaleY - vby}px;`
  );
  return {
    $svg,
    cssText: `position:relative;width:${width * scaleX}px;height:${height * scaleY}px;`,
  };
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/font-size.js":
/*!******************************************************!*\
  !*** ./node_modules/assjs/src/renderer/font-size.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $fixFontSize: () => (/* binding */ $fixFontSize),
/* harmony export */   getRealFontSize: () => (/* binding */ getRealFontSize)
/* harmony export */ });
// https://github.com/weizhenye/ASS/wiki/Font-Size-in-ASS

const $fixFontSize = document.createElement('div');
$fixFontSize.className = 'ASS-fix-font-size';
const $span = document.createElement('span');
$span.textContent = '0';
$fixFontSize.append($span);

const unitsPerEm = 2048;
const lineSpacing = Object.create(null);

function getRealFontSize(fn, fs) {
  if (!lineSpacing[fn]) {
    $span.style.fontFamily = fn;
    lineSpacing[fn] = $span.clientHeight;
  }
  return fs * unitsPerEm / lineSpacing[fn];
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/position.js":
/*!*****************************************************!*\
  !*** ./node_modules/assjs/src/renderer/position.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPosition: () => (/* binding */ getPosition)
/* harmony export */ });
function allocate(dialogue, store) {
  const { video, space, scale } = store;
  const { layer, margin, width, height, alignment, end } = dialogue;
  const stageWidth = store.width - Math.trunc(scale * (margin.left + margin.right));
  const stageHeight = store.height;
  const vertical = Math.trunc(scale * margin.vertical);
  const vct = video.currentTime * 100;
  space[layer] = space[layer] || {
    left: { width: new Uint16Array(stageHeight + 1), end: new Uint32Array(stageHeight + 1) },
    center: { width: new Uint16Array(stageHeight + 1), end: new Uint32Array(stageHeight + 1) },
    right: { width: new Uint16Array(stageHeight + 1), end: new Uint32Array(stageHeight + 1) },
  };
  const channel = space[layer];
  const alignH = ['right', 'left', 'center'][alignment % 3];
  const willCollide = (y) => {
    const lw = channel.left.width[y];
    const cw = channel.center.width[y];
    const rw = channel.right.width[y];
    const le = channel.left.end[y];
    const ce = channel.center.end[y];
    const re = channel.right.end[y];
    return (
      (alignH === 'left' && (
        (le > vct && lw)
        || (ce > vct && cw && 2 * width + cw > stageWidth)
        || (re > vct && rw && width + rw > stageWidth)
      ))
      || (alignH === 'center' && (
        (le > vct && lw && 2 * lw + width > stageWidth)
        || (ce > vct && cw)
        || (re > vct && rw && 2 * rw + width > stageWidth)
      ))
      || (alignH === 'right' && (
        (le > vct && lw && lw + width > stageWidth)
        || (ce > vct && cw && 2 * width + cw > stageWidth)
        || (re > vct && rw)
      ))
    );
  };
  let count = 0;
  let result = 0;
  const find = (y) => {
    count = willCollide(y) ? 0 : count + 1;
    if (count >= height) {
      result = y;
      return true;
    }
    return false;
  };
  if (alignment <= 3) {
    result = stageHeight - vertical - 1;
    for (let i = result; i > vertical; i -= 1) {
      if (find(i)) break;
    }
  } else if (alignment >= 7) {
    result = vertical + 1;
    for (let i = result; i < stageHeight - vertical; i += 1) {
      if (find(i)) break;
    }
  } else {
    result = (stageHeight - height) >> 1;
    for (let i = result; i < stageHeight - vertical; i += 1) {
      if (find(i)) break;
    }
  }
  if (alignment > 3) {
    result -= height - 1;
  }
  for (let i = result; i < result + height; i += 1) {
    channel[alignH].width[i] = width;
    channel[alignH].end[i] = end * 100;
  }
  return result;
}

function getPosition(dialogue, store) {
  const { scale } = store;
  const { effect, move, align, width, height, margin, slices } = dialogue;
  let x = 0;
  let y = 0;
  if (effect && effect.name === 'banner') {
    x = effect.lefttoright ? -width : store.width;
    y = [
      store.height - height - margin.vertical,
      (store.height - height) / 2,
      margin.vertical,
    ][align.v];
  } else if (dialogue.pos || move) {
    const pos = dialogue.pos || { x: 0, y: 0 };
    const sx = scale * pos.x;
    const sy = scale * pos.y;
    x = [sx, sx - width / 2, sx - width][align.h];
    y = [sy - height, sy - height / 2, sy][align.v];
  } else {
    x = [
      0,
      (store.width - width) / 2,
      store.width - width - scale * margin.right,
    ][align.h];
    const hasT = slices.some((slice) => (
      slice.fragments.some(({ keyframes }) => keyframes?.length)
    ));
    y = hasT
      ? [
        store.height - height - margin.vertical,
        (store.height - height) / 2,
        margin.vertical,
      ][align.v]
      : allocate(dialogue, store);
  }
  // TODO: use % for x and y
  return { x, y };
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/renderer.js":
/*!*****************************************************!*\
  !*** ./node_modules/assjs/src/renderer/renderer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   renderer: () => (/* binding */ renderer)
/* harmony export */ });
/* harmony import */ var _clip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clip.js */ "./node_modules/assjs/src/renderer/clip.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom.js */ "./node_modules/assjs/src/renderer/dom.js");
/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./position.js */ "./node_modules/assjs/src/renderer/position.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./style.js */ "./node_modules/assjs/src/renderer/style.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transform.js */ "./node_modules/assjs/src/renderer/transform.js");
/* harmony import */ var _scroll_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scroll.js */ "./node_modules/assjs/src/renderer/scroll.js");







function renderer(dialogue, store) {
  const { $div, animations } = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createDialogue)(dialogue, store);
  Object.assign(dialogue, { $div, animations });
  store.box.append($div);
  const { width } = $div.getBoundingClientRect();
  Object.assign(dialogue, { width });
  $div.style.cssText += (0,_style_js__WEBPACK_IMPORTED_MODULE_3__.createStyle)(dialogue);
  // height may be changed after createStyle
  const { height } = $div.getBoundingClientRect();
  Object.assign(dialogue, { height });
  const { x, y } = (0,_position_js__WEBPACK_IMPORTED_MODULE_2__.getPosition)(dialogue, store);
  Object.assign(dialogue, { x, y });
  $div.style.cssText += `width:${width}px;height:${height}px;left:${x}px;top:${y}px;`;
  (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.setTransformOrigin)(dialogue, store.scale);
  Object.assign(dialogue, (0,_clip_js__WEBPACK_IMPORTED_MODULE_0__.getClipPath)(dialogue, store));
  if (dialogue.effect?.name?.startsWith('scroll')) {
    Object.assign(dialogue, (0,_scroll_js__WEBPACK_IMPORTED_MODULE_5__.getScrollEffect)(dialogue, store));
  }
  return dialogue;
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/scroll.js":
/*!***************************************************!*\
  !*** ./node_modules/assjs/src/renderer/scroll.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getScrollEffect: () => (/* binding */ getScrollEffect)
/* harmony export */ });
function getScrollEffect(dialogue, store) {
  const $scrollArea = document.createElement('div');
  $scrollArea.className = 'ASS-scroll-area';
  store.box.insertBefore($scrollArea, dialogue.$div);
  $scrollArea.append(dialogue.$div);
  const { height } = store.scriptRes;
  const { name, y1, y2 } = dialogue.effect;
  const min = Math.min(y1, y2);
  const max = Math.max(y1, y2);
  const top = min / height * 100;
  const bottom = (height - max) / height * 100;
  $scrollArea.style.cssText += `top:${top}%;bottom:${bottom}%;`;
  const up = /up/.test(name);
  // eslint-disable-next-line no-param-reassign
  dialogue.$div.style.cssText += up ? 'top:100%;' : 'top:0%;';
  return {
    $div: $scrollArea,
  };
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/stroke.js":
/*!***************************************************!*\
  !*** ./node_modules/assjs/src/renderer/stroke.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createCSSStroke: () => (/* binding */ createCSSStroke),
/* harmony export */   createSVGStroke: () => (/* binding */ createSVGStroke)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/assjs/src/utils.js");


function createSVGStroke(tag, id, scale) {
  const hasBorder = tag.xbord || tag.ybord;
  const hasShadow = tag.xshad || tag.yshad;
  const isOpaque = tag.a1 !== 'FF';
  const blur = tag.blur || tag.be || 0;
  const $filter = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('filter', [['id', id]]);
  $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feGaussianBlur', [
    ['stdDeviation', hasBorder ? 0 : blur],
    ['in', 'SourceGraphic'],
    ['result', 'sg_b'],
  ]));
  $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feFlood', [
    ['flood-color', (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.color2rgba)(tag.a1 + tag.c1)],
    ['result', 'c1'],
  ]));
  $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feComposite', [
    ['operator', 'in'],
    ['in', 'c1'],
    ['in2', 'sg_b'],
    ['result', 'main'],
  ]));
  if (hasBorder) {
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feMorphology', [
      ['radius', `${tag.xbord * scale} ${tag.ybord * scale}`],
      ['operator', 'dilate'],
      ['in', 'SourceGraphic'],
      ['result', 'dil'],
    ]));
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feGaussianBlur', [
      ['stdDeviation', blur],
      ['in', 'dil'],
      ['result', 'dil_b'],
    ]));
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feComposite', [
      ['operator', 'out'],
      ['in', 'dil_b'],
      ['in2', 'SourceGraphic'],
      ['result', 'dil_b_o'],
    ]));
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feFlood', [
      ['flood-color', (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.color2rgba)(tag.a3 + tag.c3)],
      ['result', 'c3'],
    ]));
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feComposite', [
      ['operator', 'in'],
      ['in', 'c3'],
      ['in2', 'dil_b_o'],
      ['result', 'border'],
    ]));
  }
  if (hasShadow && (hasBorder || isOpaque)) {
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feOffset', [
      ['dx', tag.xshad * scale],
      ['dy', tag.yshad * scale],
      ['in', hasBorder ? 'dil' : 'SourceGraphic'],
      ['result', 'off'],
    ]));
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feGaussianBlur', [
      ['stdDeviation', blur],
      ['in', 'off'],
      ['result', 'off_b'],
    ]));
    if (!isOpaque) {
      $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feOffset', [
        ['dx', tag.xshad * scale],
        ['dy', tag.yshad * scale],
        ['in', 'SourceGraphic'],
        ['result', 'sg_off'],
      ]));
      $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feComposite', [
        ['operator', 'out'],
        ['in', 'off_b'],
        ['in2', 'sg_off'],
        ['result', 'off_b_o'],
      ]));
    }
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feFlood', [
      ['flood-color', (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.color2rgba)(tag.a4 + tag.c4)],
      ['result', 'c4'],
    ]));
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feComposite', [
      ['operator', 'in'],
      ['in', 'c4'],
      ['in2', isOpaque ? 'off_b' : 'off_b_o'],
      ['result', 'shadow'],
    ]));
  }
  const $merge = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feMerge', []);
  if (hasShadow && (hasBorder || isOpaque)) {
    $merge.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feMergeNode', [['in', 'shadow']]));
  }
  if (hasBorder) {
    $merge.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feMergeNode', [['in', 'border']]));
  }
  $merge.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feMergeNode', [['in', 'main']]));
  $filter.append($merge);
  return $filter;
}

function get4QuadrantPoints([x, y]) {
  return [[0, 0], [0, 1], [1, 0], [1, 1]]
    .filter(([i, j]) => (i || x) && (j || y))
    .map(([i, j]) => [(i || -1) * x, (j || -1) * y]);
}

function getOffsets(x, y) {
  if (x === y) return [];
  const nx = Math.min(x, y);
  const ny = Math.max(x, y);
  // const offsets = [[nx, ny]];
  // for (let i = 0; i < nx; i++) {
  //   for (let j = Math.round(nx + 0.5); j < ny; j++) {
  //     offsets.push([i, j]);
  //   }
  // }
  // return [].concat(...offsets.map(get4QuadrantPoints));
  return Array.from({ length: Math.ceil(ny) - 1 }, (_, i) => i + 1).concat(ny)
    .map((n) => [(ny - n) / ny * nx, n])
    .map(([i, j]) => (x > y ? [j, i] : [i, j]))
    .flatMap(get4QuadrantPoints);
}

// TODO: a1 === 'ff'
function createCSSStroke(tag, scale) {
  const bc = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.color2rgba)(`00${tag.c3}`);
  const bx = tag.xbord * scale;
  const by = tag.ybord * scale;
  const sc = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.color2rgba)(`00${tag.c4}`);
  const blur = tag.blur || tag.be || 0;
  // TODO: is there any way to remove this hack?
  const deltaOffsets = getOffsets(bx, by);
  return [
    ['border-width', `${Math.min(bx, by) * 2}px`],
    ['border-color', bc],
    ['border-opacity', (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.alpha2opacity)(tag.a3)],
    ['border-delta', deltaOffsets.map(([x, y]) => `${x}px ${y}px ${bc}`).join(',')],
    ['shadow-color', sc],
    ['shadow-opacity', (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.alpha2opacity)(tag.a4)],
    ['shadow-delta', deltaOffsets.map(([x, y]) => `${x}px ${y}px ${sc}`).join(',')],
    ['tag-blur', blur],
    ['tag-xbord', tag.xbord],
    ['tag-ybord', tag.ybord],
    ['tag-xshad', tag.xshad],
    ['tag-yshad', tag.yshad],
  ].map(([k, v]) => [`--ass-${k}`, v]);
}

if (window.CSS.registerProperty) {
  window.CSS.registerProperty({
    name: '--ass-border-width',
    syntax: '<length>',
    inherits: true,
    initialValue: '0px',
  });
  ['border-color', 'shadow-color'].forEach((k) => {
    window.CSS.registerProperty({
      name: `--ass-${k}`,
      syntax: '<color>',
      inherits: true,
      initialValue: 'transparent',
    });
  });
  ['border-opacity', 'shadow-opacity'].forEach((k) => {
    window.CSS.registerProperty({
      name: `--ass-${k}`,
      syntax: '<number>',
      inherits: true,
      initialValue: '1',
    });
  });
  ['blur', 'xbord', 'ybord', 'xshad', 'yshad'].forEach((k) => {
    window.CSS.registerProperty({
      name: `--ass-tag-${k}`,
      syntax: '<number>',
      inherits: true,
      initialValue: '0',
    });
  });
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/style.js":
/*!**************************************************!*\
  !*** ./node_modules/assjs/src/renderer/style.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createStyle: () => (/* binding */ createStyle)
/* harmony export */ });
function createStyle(dialogue) {
  const { layer, align, effect, pos, margin } = dialogue;
  let cssText = '';
  if (layer) cssText += `z-index:${layer};`;
  cssText += `text-align:${['left', 'center', 'right'][align.h]};`;
  if (!effect) {
    cssText += `max-width:calc(100% - var(--ass-scale) * ${margin.left + margin.right}px);`;
    if (!pos) {
      if (align.h !== 0) {
        cssText += `margin-right:calc(var(--ass-scale) * ${margin.right}px);`;
      }
      if (align.h !== 2) {
        cssText += `margin-left:calc(var(--ass-scale) * ${margin.left}px);`;
      }
    }
  }
  return cssText;
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/transform.js":
/*!******************************************************!*\
  !*** ./node_modules/assjs/src/renderer/transform.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createTransform: () => (/* binding */ createTransform),
/* harmony export */   rotateTags: () => (/* binding */ rotateTags),
/* harmony export */   scaleTags: () => (/* binding */ scaleTags),
/* harmony export */   setTransformOrigin: () => (/* binding */ setTransformOrigin),
/* harmony export */   skewTags: () => (/* binding */ skewTags)
/* harmony export */ });
const rotateTags = ['frx', 'fry', 'frz'];
const scaleTags = ['fscx', 'fscy'];
const skewTags = ['fax', 'fay'];

if (window.CSS.registerProperty) {
  [...rotateTags, ...skewTags].forEach((tag) => {
    window.CSS.registerProperty({
      name: `--ass-tag-${tag}`,
      syntax: '<number>',
      inherits: true,
      initialValue: 0,
    });
  });
  scaleTags.forEach((tag) => {
    window.CSS.registerProperty({
      name: `--ass-tag-${tag}`,
      syntax: '<number>',
      inherits: true,
      initialValue: 1,
    });
  });
}

function createTransform(tag) {
  return [
    ...[...rotateTags, ...skewTags].map((x) => ([`--ass-tag-${x}`, `${tag[x] || 0}`])),
    ...scaleTags.map((x) => ([`--ass-tag-${x}`, tag.p ? 1 : (tag[x] || 100) / 100])),
  ];
}

function setTransformOrigin(dialogue, scale) {
  const { align, width, height, x, y, $div } = dialogue;
  const org = {};
  if (dialogue.org) {
    org.x = dialogue.org.x * scale;
    org.y = dialogue.org.y * scale;
  } else {
    org.x = [x, x + width / 2, x + width][align.h];
    org.y = [y + height, y + height / 2, y][align.v];
  }
  for (let i = $div.childNodes.length - 1; i >= 0; i -= 1) {
    const node = $div.childNodes[i];
    if (node.dataset.rotate === '') {
      // It's not extremely precise for offsets are round the value to an integer.
      const tox = org.x - x - node.offsetLeft;
      const toy = org.y - y - node.offsetTop;
      node.style.cssText += `transform-origin:${tox}px ${toy}px;`;
    }
  }
}


/***/ }),

/***/ "./node_modules/assjs/src/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/assjs/src/utils.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alpha2opacity: () => (/* binding */ alpha2opacity),
/* harmony export */   batchAnimate: () => (/* binding */ batchAnimate),
/* harmony export */   color2rgba: () => (/* binding */ color2rgba),
/* harmony export */   createSVGEl: () => (/* binding */ createSVGEl),
/* harmony export */   initAnimation: () => (/* binding */ initAnimation),
/* harmony export */   uuid: () => (/* binding */ uuid)
/* harmony export */ });
/* unused harmony export addGlobalStyle */
function alpha2opacity(a) {
  return 1 - `0x${a}` / 255;
}

function color2rgba(c) {
  const t = c.match(/(\w\w)(\w\w)(\w\w)(\w\w)/);
  const a = alpha2opacity(t[1]);
  const b = +`0x${t[2]}`;
  const g = +`0x${t[3]}`;
  const r = +`0x${t[4]}`;
  return `rgba(${r},${g},${b},${a})`;
}

function uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = Math.trunc(Math.random() * 16);
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

/**
 * @param {string} name SVG tag
 * @param {[string, string][]} attrs
 * @returns
 */
function createSVGEl(name, attrs = []) {
  const $el = document.createElementNS('http://www.w3.org/2000/svg', name);
  for (let i = 0; i < attrs.length; i += 1) {
    const attr = attrs[i];
    $el.setAttributeNS(
      attr[0] === 'xlink:href' ? 'http://www.w3.org/1999/xlink' : null,
      attr[0],
      attr[1],
    );
  }
  return $el;
}

const GLOBAL_CSS = '__GLOBAL_CSS__';
/**
 * @param {HTMLElement} container
 */
function addGlobalStyle(container) {
  const rootNode = container.getRootNode() || document;
  const styleRoot = rootNode === document ? document.head : rootNode;
  let $style = styleRoot.querySelector('#ASS-global-style');
  if (!$style) {
    $style = document.createElement('style');
    $style.type = 'text/css';
    $style.id = 'ASS-global-style';
    $style.append(document.createTextNode(GLOBAL_CSS));
    styleRoot.append($style);
  }
}

function initAnimation($el, keyframes, options) {
  const animation = $el.animate(keyframes, options);
  animation.pause();
  return animation;
}

function batchAnimate(dia, action) {
  (dia.animations || []).forEach((animation) => {
    animation[action]();
  });
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".avplayer.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "AVPlayer:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkAVPlayer"] = self["webpackChunkAVPlayer"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module factories are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./src/avplayer/AVPlayer.ts");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=avplayer.js.map
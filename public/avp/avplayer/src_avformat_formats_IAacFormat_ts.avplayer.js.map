{"version":3,"file":"src_avformat_formats_IAacFormat_ts.avplayer.js","mappings":"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","sources":["webpack://AVPlayer/./src/avformat/codecs/aac.ts","webpack://AVPlayer/./src/avformat/formats/IAacFormat.ts","webpack://AVPlayer/./src/avformat/formats/IFormat.ts"],"sourcesContent":["/*\r\n * libmedia aac util\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../AVStream'\r\nimport { AVPacketSideDataType } from 'avutil/codec'\r\nimport { NOPTS_VALUE } from 'avutil/constant'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport { Uint8ArrayInterface } from 'common/io/interface'\r\n\r\nexport const enum MPEG4AudioObjectTypes {\r\n  NULL = 0,\r\n  /**\r\n   * Main-AAC\r\n   */\r\n  AAC_MAIN,\r\n  /**\r\n   * LC-AAC\r\n   */\r\n  AAC_LC,\r\n  AAC_SSR,\r\n  AAC_LTP,\r\n  /**\r\n   * HE-AAC\r\n   */\r\n  AAC_SBR,\r\n  AAC_SCALABLE,\r\n\r\n  LAYER1 = 32,\r\n  LAYER2,\r\n  /**\r\n   * MP3\r\n   */\r\n  LAYER3\r\n}\r\n\r\nexport const AACProfile2Name: Partial<Record<MPEG4AudioObjectTypes, string>> = {\r\n  [MPEG4AudioObjectTypes.AAC_MAIN]: 'Main',\r\n  [MPEG4AudioObjectTypes.AAC_LC]: 'LC',\r\n  [MPEG4AudioObjectTypes.AAC_SSR]: 'LC',\r\n  [MPEG4AudioObjectTypes.AAC_LTP]: 'LC',\r\n  [MPEG4AudioObjectTypes.AAC_SBR]: 'HE',\r\n  [MPEG4AudioObjectTypes.AAC_SCALABLE]: 'HE'\r\n}\r\n\r\nexport const MPEG4SamplingFrequencyIndex = {\r\n  96000: 0,\r\n  88200: 1,\r\n  64000: 2,\r\n  48000: 3,\r\n  44100: 4,\r\n  32000: 5,\r\n  24000: 6,\r\n  22050: 7,\r\n  16000: 8,\r\n  12000: 9,\r\n  11025: 10,\r\n  8000: 11,\r\n  7350: 12\r\n}\r\n\r\nexport const MPEG4SamplingFrequencies = [\r\n  96000,\r\n  88200,\r\n  64000,\r\n  48000,\r\n  44100,\r\n  32000,\r\n  24000,\r\n  22050,\r\n  16000,\r\n  12000,\r\n  11025,\r\n  8000,\r\n  7350,\r\n  NOPTS_VALUE,\r\n  NOPTS_VALUE,\r\n  NOPTS_VALUE\r\n]\r\n\r\nexport const MPEG4Channels = [\r\n  NOPTS_VALUE,\r\n  1,\r\n  2,\r\n  3,\r\n  4,\r\n  5,\r\n  6,\r\n  7\r\n]\r\n\r\n/**\r\n * 解析 AAC AudioSpecificConfig\r\n *    \r\n *             frequency\r\n *              44100Hz        fill bit\r\n *               4 bit          3 bit\r\n *              -------         -----\r\n *    0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0\r\n *    ---------         -------\r\n *      5 bit            4 bit\r\n *     AAC LC           fl, fr\r\n *    profile           channel\r\n * \r\n * url: https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Audio_Specific_Config\r\n * \r\n */\r\n\r\nexport function getAVCodecParameters(extradata: Uint8ArrayInterface) {\r\n  let profile = NOPTS_VALUE\r\n  let sampleRate = NOPTS_VALUE\r\n  let channels = NOPTS_VALUE\r\n  if (extradata.length >= 2) {\r\n    profile = (extradata[0] >> 3) & 0x1f\r\n    sampleRate = MPEG4SamplingFrequencies[((extradata[0] & 0x07) << 1)\r\n      | (extradata[1] >> 7)] ?? 48000\r\n\r\n    channels = MPEG4Channels[(extradata[1] >> 3) & 0x0f] ?? 2\r\n  }\r\n\r\n  return {\r\n    profile,\r\n    sampleRate,\r\n    channels\r\n  }\r\n}\r\n\r\nexport function parseAVCodecParameters(stream: Stream, extradata?: Uint8ArrayInterface) {\r\n  if (!extradata && stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]) {\r\n    extradata = stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]\r\n  }\r\n  if (extradata) {\r\n    const { profile, sampleRate, channels } = getAVCodecParameters(extradata)\r\n    stream.codecpar.profile = profile\r\n    stream.codecpar.sampleRate = sampleRate\r\n    stream.codecpar.chLayout.nbChannels = channels\r\n  }\r\n}\r\n\r\nexport function avCodecParameters2Extradata(codecpar: AVCodecParameters) {\r\n  const samplingFreqIndex = MPEG4SamplingFrequencyIndex[codecpar.sampleRate]\r\n  const channelConfig = codecpar.chLayout.nbChannels\r\n\r\n  const extradata = new Uint8Array(2)\r\n  extradata[0] = ((codecpar.profile & 0x1f) << 3) | ((samplingFreqIndex & 0x0e) >> 1)\r\n  extradata[1] = ((samplingFreqIndex & 0x01) << 7) | ((channelConfig & 0x0f) << 3)\r\n\r\n  return extradata\r\n}\r\n","/*\r\n * libmedia aac decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVStream from '../AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVCodecID, AVMediaType } from 'avutil/codec'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\nimport IFormat from './IFormat'\r\nimport { AVFormat, AVSeekFlags } from '../avformat'\r\nimport { memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport { avMalloc } from 'avutil/util/mem'\r\nimport { addAVPacketData } from 'avutil/util/avpacket'\r\nimport { IOError } from 'common/io/error'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { AV_MILLI_TIME_BASE_Q, AV_TIME_BASE, AV_TIME_BASE_Q, NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\nimport * as array from 'common/util/array'\r\nimport { MPEG4Channels, MPEG4SamplingFrequencies, avCodecParameters2Extradata } from '../codecs/aac'\r\n\r\nconst enum FrameType {\r\n  ADIF,\r\n  ADTS\r\n}\r\n\r\nconst PACKET_SIZE = 1024\r\n\r\nexport default class IAacFormat extends IFormat {\r\n\r\n  public type: AVFormat = AVFormat.AAC\r\n\r\n  private frameType: FrameType\r\n  private fileSize: int64\r\n  private currentPts: int64\r\n\r\n  constructor() {\r\n    super()\r\n  }\r\n\r\n  public init(formatContext: AVIFormatContext): void {\r\n    this.currentPts = 0n\r\n  }\r\n\r\n  private async estimateTotalBlock(formatContext: AVIFormatContext) {\r\n    let duration = 0\r\n    const now = formatContext.ioReader.getPos()\r\n    while (true) {\r\n      try {\r\n        const nextFrame = await formatContext.ioReader.peekBuffer(7)\r\n        const aacFrameLength = ((nextFrame[3] & 0x03) << 11)\r\n          | (nextFrame[4] << 3)\r\n          | ((nextFrame[5] & 0xE0) >>> 5)\r\n        const numberOfRawDataBlocksInFrame = nextFrame[6] & 0x03\r\n        duration += (numberOfRawDataBlocksInFrame + 1)\r\n        await formatContext.ioReader.skip(aacFrameLength)\r\n      }\r\n      catch (error) {\r\n        break\r\n      }\r\n    }\r\n\r\n    await formatContext.ioReader.seek(now)\r\n\r\n    return duration\r\n  }\r\n\r\n  public async readHeader(formatContext: AVIFormatContext): Promise<number> {\r\n    const signature = await formatContext.ioReader.peekBuffer(4)\r\n\r\n    this.fileSize = await formatContext.ioReader.fileSize()\r\n\r\n    // ADIF\r\n    if (signature[0] === 65 && signature[1] === 68 && signature[2] === 73 && signature[3] === 70) {\r\n      const stream = formatContext.createStream()\r\n      stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_AAC\r\n      stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n      this.frameType = FrameType.ADIF\r\n    }\r\n    // ADTS\r\n    else if (signature[0] === 0xff && (signature[1] & 0xf0) === 0xf0) {\r\n      this.frameType = FrameType.ADTS\r\n      const stream = formatContext.createStream()\r\n      stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_AAC\r\n      stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n\r\n      const nextFrame = await formatContext.ioReader.peekBuffer(7)\r\n\r\n      const profile = (nextFrame[2] & 0xC0) >>> 6\r\n      const samplingFrequencyIndex = (nextFrame[2] & 0x3C) >>> 2\r\n      const channelConfiguration = ((nextFrame[2] & 0x01) << 2) | ((nextFrame[3] & 0xC0) >>> 6)\r\n\r\n      stream.codecpar.profile = profile + 1\r\n      stream.codecpar.sampleRate = MPEG4SamplingFrequencies[samplingFrequencyIndex]\r\n      stream.codecpar.chLayout.nbChannels = MPEG4Channels[channelConfiguration]\r\n      const extradata = avCodecParameters2Extradata(stream.codecpar)\r\n      stream.codecpar.extradata = avMalloc(extradata.length)\r\n      memcpyFromUint8Array(stream.codecpar.extradata, extradata.length, extradata)\r\n      stream.codecpar.extradataSize = extradata.length\r\n      stream.timeBase.den = stream.codecpar.sampleRate\r\n      stream.timeBase.num = 1\r\n\r\n      stream.duration = avRescaleQ(\r\n        static_cast<int64>((await this.estimateTotalBlock(formatContext)) * 1024 / stream.codecpar.sampleRate * AV_TIME_BASE),\r\n        AV_TIME_BASE_Q,\r\n        stream.timeBase\r\n      )\r\n    }\r\n    else {\r\n      return errorType.DATA_INVALID\r\n    }\r\n\r\n    return 0\r\n  }\r\n\r\n  public async readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number> {\r\n\r\n    const stream: AVStream = formatContext.streams.find((stream) => {\r\n      return stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n    })\r\n\r\n    try {\r\n      const now = formatContext.ioReader.getPos()\r\n      let nextFrame: Uint8Array\r\n\r\n      if (this.frameType === FrameType.ADIF) {\r\n        nextFrame = await formatContext.ioReader.readBuffer(Math.min(PACKET_SIZE, static_cast<int32>(this.fileSize - now)))\r\n      }\r\n      else if (this.frameType === FrameType.ADTS) {\r\n        const header = await formatContext.ioReader.readBuffer(7)\r\n\r\n        const protectionAbsent = header[1] & 0x01\r\n\r\n        const aacFrameLength = ((header[3] & 0x03) << 11)\r\n          | (header[4] << 3)\r\n          | ((header[5] & 0xE0) >>> 5)\r\n\r\n        const numberOfRawDataBlocksInFrame = header[6] & 0x03\r\n\r\n        let adtsHeaderLength = protectionAbsent === 1 ? 7 : 9\r\n        let adtsFramePayloadLength = aacFrameLength - adtsHeaderLength\r\n\r\n        if (adtsHeaderLength === 9) {\r\n          await formatContext.ioReader.skip(2)\r\n        }\r\n\r\n        const duration = avRescaleQ(\r\n          static_cast<int64>((numberOfRawDataBlocksInFrame + 1) * 1024 / stream.codecpar.sampleRate * AV_TIME_BASE),\r\n          AV_TIME_BASE_Q,\r\n          stream.timeBase\r\n        )\r\n        avpacket.duration = duration\r\n\r\n        nextFrame = await formatContext.ioReader.readBuffer(adtsFramePayloadLength)\r\n      }\r\n\r\n      const data = avMalloc(nextFrame.length)\r\n      memcpyFromUint8Array(data, nextFrame.length, nextFrame)\r\n      addAVPacketData(avpacket, data, nextFrame.length)\r\n      avpacket.dts = avpacket.pts = this.currentPts\r\n\r\n      avpacket.pos = now\r\n      avpacket.streamIndex = stream.index\r\n      avpacket.timeBase.den = stream.timeBase.den\r\n      avpacket.timeBase.num = stream.timeBase.num\r\n      this.currentPts += avpacket.duration\r\n\r\n      return 0\r\n    }\r\n    catch (error) {\r\n      if (formatContext.ioReader.error !== IOError.END) {\r\n        logger.error(error.message)\r\n      }\r\n      return formatContext.ioReader.error\r\n    }\r\n  }\r\n\r\n  @deasync\r\n  private async syncFrame(formatContext: AVIFormatContext) {\r\n    let pos: int64 = NOPTS_VALUE_BIGINT\r\n\r\n    const analyzeCount = 3\r\n\r\n    while (true) {\r\n      try {\r\n        const word = (await formatContext.ioReader.peekUint16()) >>> 4\r\n        if (word === 0xfff) {\r\n          pos = formatContext.ioReader.getPos()\r\n          const header = await formatContext.ioReader.peekBuffer(7)\r\n          const aacFrameLength = ((header[3] & 0x03) << 11)\r\n          | (header[4] << 3)\r\n          | ((header[5] & 0xE0) >>> 5)\r\n\r\n          if (aacFrameLength > 500 * 1024) {\r\n            await formatContext.ioReader.skip(1)\r\n            continue\r\n          }\r\n\r\n          await formatContext.ioReader.skip(aacFrameLength)\r\n          let count = 0\r\n\r\n          while (true) {\r\n            if (count === analyzeCount) {\r\n              break\r\n            }\r\n            const word = (await formatContext.ioReader.peekUint16()) >>> 4\r\n            if (word === 0xfff) {\r\n              count++\r\n              const header = await formatContext.ioReader.peekBuffer(7)\r\n              const aacFrameLength = ((header[3] & 0x03) << 11)\r\n                | (header[4] << 3)\r\n                | ((header[5] & 0xE0) >>> 5)\r\n              if (aacFrameLength > 500 * 1024) {\r\n                break\r\n              }\r\n              await formatContext.ioReader.skip(aacFrameLength)\r\n            }\r\n            else {\r\n              break\r\n            }\r\n          }\r\n          if (count === analyzeCount) {\r\n            break\r\n          }\r\n        }\r\n        await formatContext.ioReader.skip(1)\r\n      }\r\n      catch (error) {\r\n        break\r\n      }\r\n    }\r\n\r\n    if (pos !== NOPTS_VALUE_BIGINT) {\r\n      await formatContext.ioReader.seek(pos)\r\n    }\r\n  }\r\n\r\n  public async seek(formatContext: AVIFormatContext, stream: AVStream, timestamp: int64, flags: int32): Promise<int64> {\r\n    if (this.frameType === FrameType.ADTS) {\r\n      const now = formatContext.ioReader.getPos()\r\n      if (flags & AVSeekFlags.BYTE) {\r\n\r\n        const size = await formatContext.ioReader.fileSize()\r\n\r\n        if (size <= 0n) {\r\n          return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n        }\r\n\r\n        if (timestamp < 0n) {\r\n          timestamp = 0n\r\n        }\r\n        else if (timestamp > size) {\r\n          timestamp = size\r\n        }\r\n        await formatContext.ioReader.seek(timestamp)\r\n\r\n        if (!(flags & AVSeekFlags.ANY)) {\r\n          await this.syncFrame(formatContext)\r\n\r\n          if (stream.duration && this.fileSize) {\r\n            this.currentPts = timestamp / this.fileSize * stream.duration\r\n          }\r\n        }\r\n        return now\r\n      }\r\n      else {\r\n        if (stream && stream.sampleIndexes.length) {\r\n          let index = array.binarySearch(stream.sampleIndexes, (item) => {\r\n            if (item.pts > timestamp) {\r\n              return -1\r\n            }\r\n            return 1\r\n          })\r\n          if (index > 0 && avRescaleQ(timestamp - stream.sampleIndexes[index - 1].pts, stream.timeBase, AV_MILLI_TIME_BASE_Q) < 5000n) {\r\n            logger.debug(`seek in sampleIndexes, found index: ${index}, pts: ${stream.sampleIndexes[index - 1].pts}, pos: ${stream.sampleIndexes[index - 1].pos}`)\r\n            await formatContext.ioReader.seek(stream.sampleIndexes[index - 1].pos)\r\n            this.currentPts = timestamp\r\n            return now\r\n          }\r\n        }\r\n\r\n        logger.debug('not found any keyframe index, try to seek in bytes')\r\n\r\n        if (stream.duration) {\r\n          await formatContext.ioReader.seek(0n)\r\n          let pts = 0n\r\n          while (true) {\r\n            try {\r\n              if (pts >= timestamp) {\r\n                this.currentPts = pts\r\n                return now\r\n              }\r\n              const nextFrame = await formatContext.ioReader.peekBuffer(7)\r\n              const aacFrameLength = ((nextFrame[3] & 0x03) << 11)\r\n                | (nextFrame[4] << 3)\r\n                | ((nextFrame[5] & 0xE0) >>> 5)\r\n              const numberOfRawDataBlocksInFrame = nextFrame[6] & 0x03\r\n              const duration = avRescaleQ(\r\n                static_cast<int64>((numberOfRawDataBlocksInFrame + 1) * 1024 / stream.codecpar.sampleRate * AV_TIME_BASE),\r\n                AV_TIME_BASE_Q,\r\n                stream.timeBase\r\n              )\r\n              pts += duration\r\n              await formatContext.ioReader.skip(aacFrameLength)\r\n            }\r\n            catch (error) {\r\n              return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n            }\r\n          }\r\n        }\r\n        else {\r\n          return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n        }\r\n      }\r\n    }\r\n    return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n  }\r\n\r\n  public getAnalyzeStreamsCount(): number {\r\n    return 1\r\n  }\r\n}\r\n","/*\r\n * libmedia abstract format decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVFormat } from '../avformat'\r\n\r\nexport default abstract class IFormat {\r\n\r\n  public type: AVFormat = AVFormat.UNKNOWN\r\n\r\n  public onStreamAdd: (stream: Stream) => void\r\n  \r\n  public abstract init(formatContext: AVIFormatContext): void\r\n\r\n  public destroy(formatContext: AVIFormatContext): void {}\r\n\r\n  public abstract getAnalyzeStreamsCount(): number\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readHeader(formatContext: AVIFormatContext): Promise<number>\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number>\r\n\r\n  /**\r\n   * seek\r\n   * \r\n   * @param context \r\n   * @param stream \r\n   * @param timestamp 毫秒时间戳\r\n   * @param flags \r\n   * \r\n   * @returns 返回 seek 之前的下一个 avpacket pos（若不知道返回 0n 方便之后可以再 seek 回来）返回负数表示 seek 失败\r\n   */\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract seek(\r\n    formatContext: AVIFormatContext,\r\n    stream: Stream,\r\n    timestamp: int64,\r\n    flags: int32\r\n  ): Promise<int64>\r\n}\r\n"],"names":[],"sourceRoot":""}
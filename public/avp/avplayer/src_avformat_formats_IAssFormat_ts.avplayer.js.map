{"version":3,"file":"src_avformat_formats_IAssFormat_ts.avplayer.js","mappings":"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AACA;AACA;;;;;;;;;;;;;;ACfO;AACP;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;AC1B4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,gCAAgC,GAAG,SAAS;;AAE9E;AACP;AACA,kBAAkB,sBAAsB;AACxC,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,YAAY,SAAS,uBAAuB,MAAM;AAClD,IAAI;AACJ;AACA,YAAY,IAAI,UAAU,MAAM;AAChC,IAAI;AACJ;AACA,qBAAqB,UAAU;AAC/B,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAY;AACrC;AACA;AACA;AACA,yBAAyB,yDAAY;AACrC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AC/FoC;;AAE7B;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,kBAAkB,6CAAQ;AAC1B;;;;;;;;;;;;;;;;ACxB4C;AACN;;AAE/B;AACP,6BAA6B,KAAK,KAAK;AACvC;AACA;AACA,kBAAkB,uCAAuC;AACzD;AACA,kBAAkB,kBAAkB;AACpC,iBAAiB,mDAAS;AAC1B;AACA;AACA;AACA;AACA,2BAA2B,yDAAY;AACvC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://AVPlayer/./src/avformat/formats/IAssFormat.ts","webpack://AVPlayer/./src/avformat/formats/IFormat.ts","webpack://AVPlayer/./src/avformat/formats/ass/ass.ts","webpack://AVPlayer/./src/avformat/formats/ass/iass.ts","webpack://AVPlayer/./src/common/util/time.ts","webpack://AVPlayer/./node_modules/ass-compiler/src/parser/drawing.js","webpack://AVPlayer/./node_modules/ass-compiler/src/parser/effect.js","webpack://AVPlayer/./node_modules/ass-compiler/src/parser/tag.js","webpack://AVPlayer/./node_modules/ass-compiler/src/parser/tags.js","webpack://AVPlayer/./node_modules/ass-compiler/src/parser/text.js"],"sourcesContent":["/*\r\n * libmedia ass decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVStream from '../AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVCodecID, AVMediaType } from 'avutil/codec'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\nimport IFormat from './IFormat'\r\nimport { AVFormat, AVSeekFlags } from '../avformat'\r\nimport { memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport { avMalloc } from 'avutil/util/mem'\r\nimport { addAVPacketData } from 'avutil/util/avpacket'\r\nimport { IOError } from 'common/io/error'\r\nimport * as array from 'common/util/array'\r\nimport * as text from 'common/util/text'\r\nimport * as iass from './ass/iass'\r\nimport { AssEventsFormat } from './ass/ass'\r\n\r\nexport default class IAssFormat extends IFormat {\r\n\r\n  public type: AVFormat = AVFormat.ASS\r\n\r\n  private queue: {\r\n    startTs: int64\r\n    endTs: int64\r\n    context: string\r\n    pos: int64\r\n  }[]\r\n  private index: int32\r\n\r\n  constructor() {\r\n    super()\r\n  }\r\n\r\n  public init(formatContext: AVIFormatContext): void {\r\n    this.queue = []\r\n  }\r\n\r\n  public async readHeader(formatContext: AVIFormatContext): Promise<number> {\r\n\r\n    const line = await formatContext.ioReader.readLine()\r\n\r\n    if (line.trim() !== '[Script Info]') {\r\n      logger.error('the file format is not ass')\r\n      return errorType.DATA_INVALID\r\n    }\r\n\r\n    const stream = formatContext.createStream()\r\n    stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_ASS\r\n    stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_SUBTITLE\r\n    stream.timeBase.den = 1000\r\n    stream.timeBase.num = 1\r\n\r\n    let extradata: string = line + '\\n'\r\n    let hasEvent = false\r\n\r\n    let eventFormats: string[]\r\n    let startIndex = 0\r\n    let endIndex = 0\r\n\r\n    while (true) {\r\n      const line = await formatContext.ioReader.readLine()\r\n\r\n      if (/^;/.test(line)) {\r\n        continue\r\n      }\r\n\r\n      if (line.trim() === '[Events]') {\r\n        hasEvent = true\r\n      }\r\n      if (/^Format:/.test(line) && hasEvent) {\r\n        extradata += line\r\n        eventFormats = iass.parseEventFormat(line.trim())\r\n\r\n        for (let i = 0; i < eventFormats.length; i++) {\r\n          if (eventFormats[i] === AssEventsFormat.Start) {\r\n            startIndex = i\r\n          }\r\n          else if (eventFormats[i] === AssEventsFormat.End) {\r\n            endIndex = i\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n      extradata += line + '\\n'\r\n    }\r\n\r\n    const buffer = text.encode(extradata)\r\n\r\n    stream.codecpar.extradata = avMalloc(buffer.length)\r\n    stream.codecpar.extradataSize = buffer.length\r\n    memcpyFromUint8Array(stream.codecpar.extradata, buffer.length, buffer)\r\n\r\n    this.index = 0\r\n    \r\n    let lastStartTs = 0n\r\n\r\n    try {\r\n      while (true) {\r\n\r\n        const pos = formatContext.ioReader.getPos()\r\n        \r\n        const line = (await formatContext.ioReader.readLine()).trim()\r\n\r\n        if (/^;/.test(line) || /^Comment:/.test(line)) {\r\n          continue\r\n        }\r\n\r\n        const { start: startTs, end: endTs } = iass.getEventLineTime(eventFormats, line, startIndex, endIndex)\r\n\r\n        stream.nbFrames++\r\n        stream.duration = endTs\r\n\r\n        const cue = {\r\n          context: line,\r\n          startTs,\r\n          endTs,\r\n          pos\r\n        }\r\n\r\n        if (startTs >= lastStartTs) {\r\n          this.queue.push(cue)\r\n          lastStartTs = startTs\r\n        }\r\n        else {\r\n          array.sortInsert(\r\n            this.queue,\r\n            cue,\r\n            (a) => {\r\n              if (a.startTs < cue.startTs) {\r\n                return 1\r\n              }\r\n              else {\r\n                return -1\r\n              }\r\n            }\r\n          )\r\n        }\r\n      }\r\n    }\r\n    catch (error) {\r\n      return 0\r\n    }\r\n\r\n  }\r\n\r\n  public async readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number> {\r\n\r\n    if (!this.queue.length) {\r\n      return errorType.DATA_INVALID\r\n    }\r\n    if (this.index >= this.queue.length) {\r\n      return IOError.END\r\n    }\r\n\r\n    const stream = formatContext.streams.find((stream) => {\r\n      return stream.codecpar.codecType === AVMediaType.AVMEDIA_TYPE_SUBTITLE\r\n    })\r\n\r\n    const cue = this.queue[this.index++]\r\n\r\n    avpacket.streamIndex = stream.index\r\n    avpacket.timeBase.den = stream.timeBase.den\r\n    avpacket.timeBase.num = stream.timeBase.num\r\n\r\n    avpacket.dts = avpacket.pts = cue.startTs\r\n    avpacket.duration = cue.endTs - cue.startTs\r\n\r\n    const buffer = text.encode(cue.context)\r\n    const data = avMalloc(buffer.length)\r\n    memcpyFromUint8Array(data, buffer.length, buffer)\r\n    addAVPacketData(avpacket, data, buffer.length)\r\n\r\n    return 0\r\n  }\r\n\r\n  public async seek(formatContext: AVIFormatContext, stream: AVStream, timestamp: int64, flags: int32): Promise<int64> {\r\n    if (flags & AVSeekFlags.BYTE) {\r\n      return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n    }\r\n    if (timestamp <= 0n) {\r\n      this.index = 0\r\n      return 0n\r\n    }\r\n    const index = array.binarySearch(this.queue, (item) => {\r\n      if (item.startTs > timestamp) {\r\n        return -1\r\n      }\r\n      return 1\r\n    })\r\n    if (index >= 0) {\r\n      logger.debug(`seek in cues, found index: ${index}, pts: ${this.queue[index].startTs}, pos: ${this.queue[index].pos}`)\r\n      this.index = Math.max(index - 1, 0)\r\n      while (this.index > 0) {\r\n        if (this.queue[this.index - 1].startTs === this.queue[this.index].startTs) {\r\n          this.index--\r\n        }\r\n        else {\r\n          break\r\n        }\r\n      }\r\n      return 0n\r\n    }\r\n    return static_cast<int64>(errorType.DATA_INVALID)\r\n  }\r\n\r\n  public getAnalyzeStreamsCount(): number {\r\n    return 1\r\n  }\r\n}\r\n","/*\r\n * libmedia abstract format decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVFormat } from '../avformat'\r\n\r\nexport default abstract class IFormat {\r\n\r\n  public type: AVFormat = AVFormat.UNKNOWN\r\n\r\n  public onStreamAdd: (stream: Stream) => void\r\n  \r\n  public abstract init(formatContext: AVIFormatContext): void\r\n\r\n  public destroy(formatContext: AVIFormatContext): void {}\r\n\r\n  public abstract getAnalyzeStreamsCount(): number\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readHeader(formatContext: AVIFormatContext): Promise<number>\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number>\r\n\r\n  /**\r\n   * seek\r\n   * \r\n   * @param context \r\n   * @param stream \r\n   * @param timestamp 毫秒时间戳\r\n   * @param flags \r\n   * \r\n   * @returns 返回 seek 之前的下一个 avpacket pos（若不知道返回 0n 方便之后可以再 seek 回来）返回负数表示 seek 失败\r\n   */\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract seek(\r\n    formatContext: AVIFormatContext,\r\n    stream: Stream,\r\n    timestamp: int64,\r\n    flags: int32\r\n  ): Promise<int64>\r\n}\r\n","\r\n/*\r\n * libmedia ass defined\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nexport const enum AssStylesFormat {\r\n  Name = 'Name',\r\n  FontName = 'Fontname',\r\n  FontSize = 'Fontsize',\r\n  PrimaryColour = 'PrimaryColour',\r\n  SecondaryColour = 'SecondaryColour',\r\n  OutlineColour = 'OutlineColour',\r\n  BackColour = 'BackColour',\r\n  Bold = 'Bold',\r\n  Italic = 'Italic',\r\n  Underline = 'Underline',\r\n  StrikeOut = 'StrikeOut',\r\n  ScaleX = 'ScaleX',\r\n  ScaleY = 'ScaleY',\r\n  Spacing = 'Spacing',\r\n  Angle = 'Angle',\r\n  BorderStyle = 'BorderStyle',\r\n  Outline = 'Outline',\r\n  Shadow = 'Shadow',\r\n  Alignment = 'Alignment',\r\n  MarginL = 'MarginL',\r\n  MarginR = 'MarginR',\r\n  MarginV = 'MarginV',\r\n  Encoding = 'Encoding'\r\n}\r\n\r\nexport const enum AssEventsFormat {\r\n  ReadOrder = 'ReadOrder',\r\n  Layer = 'Layer',\r\n  Start = 'Start',\r\n  End = 'End',\r\n  Style = 'Style',\r\n  Name = 'Name',\r\n  MarginL = 'MarginL',\r\n  MarginR = 'MarginR',\r\n  MarginV = 'MarginV',\r\n  Effect = 'Effect',\r\n  Text = 'Text'\r\n}\r\n\r\nexport const AssStylesFormatList = [\r\n  AssStylesFormat.Name,\r\n  AssStylesFormat.FontName,\r\n  AssStylesFormat.FontSize,\r\n  AssStylesFormat.PrimaryColour,\r\n  AssStylesFormat.SecondaryColour,\r\n  AssStylesFormat.OutlineColour,\r\n  AssStylesFormat.BackColour,\r\n  AssStylesFormat.Bold,\r\n  AssStylesFormat.Italic,\r\n  AssStylesFormat.Underline,\r\n  AssStylesFormat.StrikeOut,\r\n  AssStylesFormat.ScaleX,\r\n  AssStylesFormat.ScaleY,\r\n  AssStylesFormat.Spacing,\r\n  AssStylesFormat.Angle,\r\n  AssStylesFormat.BorderStyle,\r\n  AssStylesFormat.Outline,\r\n  AssStylesFormat.Shadow,\r\n  AssStylesFormat.Alignment,\r\n  AssStylesFormat.MarginL,\r\n  AssStylesFormat.MarginR,\r\n  AssStylesFormat.MarginV,\r\n  AssStylesFormat.Encoding\r\n]\r\n\r\nexport const AssEventsFormatList = [\r\n  AssEventsFormat.ReadOrder,\r\n  AssEventsFormat.Layer,\r\n  AssEventsFormat.Start,\r\n  AssEventsFormat.End,\r\n  AssEventsFormat.Style,\r\n  AssEventsFormat.Name,\r\n  AssEventsFormat.MarginL,\r\n  AssEventsFormat.MarginR,\r\n  AssEventsFormat.MarginV,\r\n  AssEventsFormat.Effect,\r\n  AssEventsFormat.Text\r\n]\r\n\r\nexport const enum AssEventType {\r\n  NONE,\r\n  Dialogue,\r\n  Comment,\r\n  Picture,\r\n  Sound,\r\n  Movie,\r\n  Command\r\n}\r\n\r\nexport interface AssEffect {\r\n  name: string\r\n}\r\n\r\nexport interface AssEffectBanner extends AssEffect {\r\n  delay: number\r\n  fadeAwayWidth: number\r\n  leftToRight: number\r\n}\r\n\r\nexport interface AssEffectScroll extends AssEffect {\r\n  delay: number\r\n  fadeAwayHeight: number\r\n  y1: number\r\n  y2: number\r\n}\r\n\r\nexport interface AssEventTextParsed {\r\n  tags: AssTag[]\r\n  text: string\r\n  drawing: string[][]\r\n}\r\n\r\nexport interface AssEventText {\r\n  raw: string;\r\n  combined: string;\r\n  parsed: AssEventTextParsed[]\r\n}\r\n\r\nexport interface AssEvent {\r\n  type: AssEventType\r\n  ReadOrder: number\r\n  Layer: number\r\n  Start: int64\r\n  End: int64\r\n  Style: string\r\n  Name: string\r\n  MarginL: number\r\n  MarginR: number\r\n  MarginV: number\r\n  Effect?: AssEffect\r\n  Text: AssEventText\r\n}\r\n\r\nexport interface AssTag {\r\n  a?: 0 | 1 | 2 | 3 | 5 | 6 | 7 | 9 | 10 | 11\r\n  a1?: string\r\n  a2?: string\r\n  a3?: string\r\n  a4?: string\r\n  alpha?: string\r\n  an?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\r\n  b?: 0 | 1\r\n  be?: number\r\n  blur?: number\r\n  bord?: number\r\n  c1?: string\r\n  c2?: string\r\n  c3?: string\r\n  c4?: string\r\n  clip?: {\r\n    inverse: boolean\r\n    scale: number\r\n    drawing?: string[][]\r\n    dots?: [number, number, number, number]\r\n  }\r\n  fad?: [number, number]\r\n  fade?: [number, number, number, number, number, number]\r\n  fax?: number\r\n  fay?: number\r\n  fe?: number\r\n  fn?: string\r\n  fr?: number\r\n  frx?: number\r\n  fry?: number\r\n  frz?: number\r\n  fs?: string\r\n  fscx?: number\r\n  fscy?: number\r\n  fsp?: number\r\n  i?: 0 | 1\r\n  k?: number\r\n  kf?: number\r\n  ko?: number\r\n  kt?: number\r\n  K?: number\r\n  move?: [number, number, number, number] | [number, number, number, number, number, number]\r\n  org?: [number, number]\r\n  p?: number\r\n  pbo?: number\r\n  pos?: [number, number]\r\n  q?: 0 | 1 | 2 | 3\r\n  r?: string\r\n  s?: 0 | 1\r\n  shad?: number\r\n  t?: {\r\n    t1: number\r\n    t2: number\r\n    accel: number\r\n    tags: AssTag[]\r\n  }\r\n  u?: 0 | 1\r\n  xbord?: number\r\n  xshad?: number\r\n  ybord?: number\r\n  yshad?: number\r\n}\r\n","\r\n/*\r\n * libmedia ass input util\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport * as logger from 'common/util/logger'\r\nimport { AssEvent, AssEventsFormatList, AssEventType, AssStylesFormatList } from './ass'\r\nimport { hhColonDDColonSSDotMill2Int64 } from 'common/util/time'\r\n\r\nimport { parseEffect } from 'ass-compiler/src/parser/effect'\r\nimport { parseText } from 'ass-compiler/src/parser/text'\r\n\r\nexport function parseFormat(fields: string[], format: string) {\r\n  const items = format.match(/Format\\s*:\\s*(.*)/i)[1].split(/\\s*,\\s*/)\r\n  const result: string[] = []\r\n  for (let i = 0; i < items.length; i++) {\r\n    const field = fields.find(f => f.toLowerCase() === items[i].toLowerCase())\r\n    if (!field) {\r\n      logger.warn(`not support ass field(${items[i]})`)\r\n    }\r\n    result.push(field || items[i])\r\n  }\r\n  return result\r\n}\r\n\r\nexport function parseStyleFormat(format: string) {\r\n  return parseFormat(AssStylesFormatList, format)\r\n}\r\n\r\nexport function parseEventFormat(format: string) {\r\n  return parseFormat(AssEventsFormatList, format)\r\n}\r\n\r\nexport function parseEventLine(formats: string[], text: string) {\r\n  let fields = text.split(',')\r\n  if (fields.length > formats.length) {\r\n    const textField = fields.slice(formats.length - 1).join(',')\r\n    fields = fields.slice(0, formats.length - 1)\r\n    fields.push(textField)\r\n  }\r\n  return fields\r\n}\r\n\r\nexport function getEventLineTime(formats: string[], event: string, startIndex: number, endIndex: number) {\r\n  const [ , , value ] = event.match(/^(\\w+?)\\s*:\\s*(.*)/i)\r\n  const fields = parseEventLine(formats, value)\r\n  return {\r\n    start: hhColonDDColonSSDotMill2Int64(fields[startIndex]),\r\n    end: hhColonDDColonSSDotMill2Int64(fields[endIndex])\r\n  }\r\n}\r\n\r\nexport function parseDrawing(text: string) {\r\n  if (!text) {\r\n    return []\r\n  }\r\n  return text\r\n    .toLowerCase()\r\n    // numbers\r\n    .replace(/([+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?)/g, ' $1 ')\r\n    // commands\r\n    .replace(/([mnlbspc])/g, ' $1 ')\r\n    .trim()\r\n    .replace(/\\s+/g, ' ')\r\n    .split(/\\s(?=[mnlbspc])/)\r\n    .map((cmd) => (\r\n      cmd.split(' ').filter((x, i) => !(i && Number.isNaN(+x)))\r\n    ))\r\n}\r\n\r\nexport function parseStyle(styleFormat: string[], style: string) {\r\n  const values = style.match(/Style\\s*:\\s*(.*)/i)[1].split(/\\s*,\\s*/)\r\n  const result: Record<string, string> = {}\r\n  for (let i = 0; i < values.length; i++) {\r\n    result[styleFormat[i]] = values[i]\r\n  }\r\n  return result\r\n}\r\n\r\nexport function parseEvent(formats: string[], event: string) {\r\n  const [ , key, value ] = event.match(/^(\\w+?)\\s*:\\s*(.*)/i)\r\n  \r\n  let type: AssEventType = AssEventType.NONE\r\n\r\n  switch (key) {\r\n    case 'Comment':\r\n      type = AssEventType.Comment\r\n      break\r\n    case 'Dialogue':\r\n      type = AssEventType.Dialogue\r\n      break\r\n    case 'Command':\r\n      type = AssEventType.Command\r\n      break\r\n    case 'Movie':\r\n      type = AssEventType.Movie\r\n      break\r\n    case 'Picture':\r\n      type = AssEventType.Picture\r\n      break\r\n    case 'Sound':\r\n      type = AssEventType.Sound\r\n      break\r\n  }\r\n\r\n  const fields = parseEventLine(formats, value)\r\n\r\n  const result: Partial<AssEvent> = {\r\n    type\r\n  }\r\n  for (let i = 0; i < fields.length; i++) {\r\n    result[formats[i]] = fields[i]\r\n\r\n    const fmt = formats[i]\r\n    const fld = fields[i].trim()\r\n    switch (fmt) {\r\n      case 'Layer':\r\n      case 'MarginL':\r\n      case 'MarginR':\r\n      case 'MarginV':\r\n        result[fmt] = +fld\r\n        break;\r\n      case 'Start':\r\n      case 'End':\r\n        result[fmt] = hhColonDDColonSSDotMill2Int64(fld)\r\n        break;\r\n      case 'Effect':\r\n        result[fmt] = parseEffect(fld)\r\n        break;\r\n      case 'Text':\r\n        result[fmt] = parseText(fld)\r\n        break;\r\n      default:\r\n        result[fmt] = fld\r\n    }\r\n  }\r\n  return result as AssEvent\r\n}\r\n\r\n\r\n","\r\nexport function hhColonDDColonSSDotMill2Int64(time: string) {\r\n  time = time.trim()\r\n\r\n  if (!time) {\r\n    return -1n\r\n  }\r\n\r\n  let list = time.split(':')\r\n\r\n  let ts = 0n\r\n\r\n  if (list.length === 3) {\r\n    ts += BigInt(+(list.shift().trim())) * 3600000n\r\n  }\r\n  ts += BigInt(+(list.shift().trim())) * 60000n\r\n\r\n  list = list.shift().trim().split('.')\r\n  ts += BigInt(+(list.shift().trim())) * 1000n\r\n  ts += BigInt(+(list.shift().trim()))\r\n\r\n  return ts\r\n}\r\n\r\nexport function hhColonDDColonSSCommaMill2Int64(time: string) {\r\n  time = time.trim()\r\n\r\n  if (!time) {\r\n    return -1n\r\n  }\r\n\r\n  let list = time.split(':')\r\n\r\n  let ts = 0n\r\n\r\n  if (list.length === 3) {\r\n    ts += BigInt(+(list.shift().trim())) * 3600000n\r\n  }\r\n  ts += BigInt(+(list.shift().trim())) * 60000n\r\n\r\n  list = list.shift().trim().split(',')\r\n  ts += BigInt(+(list.shift().trim())) * 1000n\r\n  ts += BigInt(+(list.shift().trim()))\r\n\r\n  return ts\r\n}","export function parseDrawing(text) {\n  if (!text) return [];\n  return text\n    .toLowerCase()\n    // numbers\n    .replace(/([+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?)/g, ' $1 ')\n    // commands\n    .replace(/([mnlbspc])/g, ' $1 ')\n    .trim()\n    .replace(/\\s+/g, ' ')\n    .split(/\\s(?=[mnlbspc])/)\n    .map((cmd) => (\n      cmd.split(' ')\n        .filter((x, i) => !(i && Number.isNaN(x * 1)))\n    ));\n}\n","export function parseEffect(text) {\n  const param = text\n    .toLowerCase()\n    .trim()\n    .split(/\\s*;\\s*/);\n  if (param[0] === 'banner') {\n    return {\n      name: param[0],\n      delay: param[1] * 1 || 0,\n      leftToRight: param[2] * 1 || 0,\n      fadeAwayWidth: param[3] * 1 || 0,\n    };\n  }\n  if (/^scroll\\s/.test(param[0])) {\n    return {\n      name: param[0],\n      y1: Math.min(param[1] * 1, param[2] * 1),\n      y2: Math.max(param[1] * 1, param[2] * 1),\n      delay: param[3] * 1 || 0,\n      fadeAwayHeight: param[4] * 1 || 0,\n    };\n  }\n  if (text !== '') {\n    return { name: text };\n  }\n  return null;\n}\n","import { parseDrawing } from './drawing.js';\n\nconst numTags = [\n  'b', 'i', 'u', 's', 'fsp',\n  'k', 'K', 'kf', 'ko', 'kt',\n  'fe', 'q', 'p', 'pbo', 'a', 'an',\n  'fscx', 'fscy', 'fax', 'fay', 'frx', 'fry', 'frz', 'fr',\n  'be', 'blur', 'bord', 'xbord', 'ybord', 'shad', 'xshad', 'yshad',\n];\n\nconst numRegexs = numTags.map((nt) => ({ name: nt, regex: new RegExp(`^${nt}-?\\\\d`) }));\n\nexport function parseTag(text) {\n  const tag = {};\n  for (let i = 0; i < numRegexs.length; i++) {\n    const { name, regex } = numRegexs[i];\n    if (regex.test(text)) {\n      tag[name] = text.slice(name.length) * 1;\n      return tag;\n    }\n  }\n  if (/^fn/.test(text)) {\n    tag.fn = text.slice(2);\n  } else if (/^r/.test(text)) {\n    tag.r = text.slice(1);\n  } else if (/^fs[\\d+-]/.test(text)) {\n    tag.fs = text.slice(2);\n  } else if (/^\\d?c&?H?[0-9a-fA-F]+|^\\d?c$/.test(text)) {\n    const [, num, color] = text.match(/^(\\d?)c&?H?(\\w*)/);\n    tag[`c${num || 1}`] = color && `000000${color}`.slice(-6);\n  } else if (/^\\da&?H?[0-9a-fA-F]+/.test(text)) {\n    const [, num, alpha] = text.match(/^(\\d)a&?H?([0-9a-f]+)/i);\n    tag[`a${num}`] = `00${alpha}`.slice(-2);\n  } else if (/^alpha&?H?[0-9a-fA-F]+/.test(text)) {\n    [, tag.alpha] = text.match(/^alpha&?H?([0-9a-f]+)/i);\n    tag.alpha = `00${tag.alpha}`.slice(-2);\n  } else if (/^(?:pos|org|move|fad|fade)\\([^)]+/.test(text)) {\n    const [, key, value] = text.match(/^(\\w+)\\((.*?)\\)?$/);\n    tag[key] = value\n      .trim()\n      .split(/\\s*,\\s*/)\n      .map(Number);\n  } else if (/^i?clip\\([^)]+/.test(text)) {\n    const p = text\n      .match(/^i?clip\\((.*?)\\)?$/)[1]\n      .trim()\n      .split(/\\s*,\\s*/);\n    tag.clip = {\n      inverse: /iclip/.test(text),\n      scale: 1,\n      drawing: null,\n      dots: null,\n    };\n    if (p.length === 1) {\n      tag.clip.drawing = parseDrawing(p[0]);\n    }\n    if (p.length === 2) {\n      tag.clip.scale = p[0] * 1;\n      tag.clip.drawing = parseDrawing(p[1]);\n    }\n    if (p.length === 4) {\n      tag.clip.dots = p.map(Number);\n    }\n  } else if (/^t\\(/.test(text)) {\n    const p = text\n      .match(/^t\\((.*?)\\)?$/)[1]\n      .trim()\n      .replace(/\\\\.*/, (x) => x.replace(/,/g, '\\n'))\n      .split(/\\s*,\\s*/);\n    if (!p[0]) return tag;\n    tag.t = {\n      t1: 0,\n      t2: 0,\n      accel: 1,\n      tags: p[p.length - 1]\n        .replace(/\\n/g, ',')\n        .split('\\\\')\n        .slice(1)\n        .map(parseTag),\n    };\n    if (p.length === 2) {\n      tag.t.accel = p[0] * 1;\n    }\n    if (p.length === 3) {\n      tag.t.t1 = p[0] * 1;\n      tag.t.t2 = p[1] * 1;\n    }\n    if (p.length === 4) {\n      tag.t.t1 = p[0] * 1;\n      tag.t.t2 = p[1] * 1;\n      tag.t.accel = p[2] * 1;\n    }\n  }\n\n  return tag;\n}\n","import { parseTag } from './tag.js';\n\nexport function parseTags(text) {\n  const tags = [];\n  let depth = 0;\n  let str = '';\n  // `\\b\\c` -> `b\\c\\`\n  // `a\\b\\c` -> `b\\c\\`\n  const transText = text.split('\\\\').slice(1).concat('').join('\\\\');\n  for (let i = 0; i < transText.length; i++) {\n    const x = transText[i];\n    if (x === '(') depth++;\n    if (x === ')') depth--;\n    if (depth < 0) depth = 0;\n    if (!depth && x === '\\\\') {\n      if (str) {\n        tags.push(str);\n      }\n      str = '';\n    } else {\n      str += x;\n    }\n  }\n  return tags.map(parseTag);\n}\n","import { parseDrawing } from './drawing.js';\nimport { parseTags } from './tags.js';\n\nexport function parseText(text) {\n  const pairs = text.split(/{([^{}]*?)}/);\n  const parsed = [];\n  if (pairs[0].length) {\n    parsed.push({ tags: [], text: pairs[0], drawing: [] });\n  }\n  for (let i = 1; i < pairs.length; i += 2) {\n    const tags = parseTags(pairs[i]);\n    const isDrawing = tags.reduce((v, tag) => (tag.p === undefined ? v : !!tag.p), false);\n    parsed.push({\n      tags,\n      text: isDrawing ? '' : pairs[i + 1],\n      drawing: isDrawing ? parseDrawing(pairs[i + 1]) : [],\n    });\n  }\n  return {\n    raw: text,\n    combined: parsed.map((frag) => frag.text).join(''),\n    parsed,\n  };\n}\n"],"names":[],"sourceRoot":""}
{"version":3,"file":"src_avformat_formats_OOggsFormat_ts.avtranscoder.js","mappings":"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","sources":["webpack://AVTranscoder/./src/avformat/formats/OOggsFormat.ts","webpack://AVTranscoder/./src/avformat/formats/oggs/OggPage.ts"],"sourcesContent":["/*\r\n * libmedia oggs encoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOWriter from 'common/io/IOWriterSync'\r\nimport Stream from '../AVStream'\r\nimport { AVOFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport OFormat from './OFormat'\r\nimport { OggPage, PagePayload } from './oggs/OggPage'\r\nimport { AVMediaType } from 'avutil/codec'\r\nimport { AVFormat } from '../avformat'\r\nimport * as logger from 'common/util/logger'\r\nimport { getAVPacketData } from 'avutil/util/avpacket'\r\nimport { NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\n\r\nconst PAGE_MAX = 255 * 255\r\n\r\ninterface OggsStreamPrivData {\r\n  /**\r\n   * 对于音频表示已经写入的 pcm 采样数\r\n   * 对于视频表示写入的 frame count\r\n   * \r\n   */\r\n  granulePosition: bigint\r\n\r\n  /**\r\n   * page 序列号\r\n   */\r\n  pageSequenceLast: number\r\n}\r\n\r\nexport default class OOggFormat extends OFormat {\r\n\r\n  public type: AVFormat = AVFormat.OGGS\r\n\r\n  private checksumTable: number[]\r\n\r\n  public headerPagesPayload: PagePayload[]\r\n\r\n  private cacheWriter: IOWriter\r\n\r\n  private page: OggPage\r\n\r\n  constructor() {\r\n    super()\r\n    this.checksumTable = []\r\n    this.page = new OggPage()\r\n    this.headerPagesPayload = []\r\n  }\r\n\r\n  private initChecksumTab() {\r\n    for ( let i = 0; i < 256; i++ ) {\r\n      let r = i << 24\r\n      for ( let j = 0; j < 8; j++ ) {\r\n        r = ((r & 0x80000000) != 0) ? ((r << 1) ^ 0x04c11db7) : (r << 1)\r\n      }\r\n      this.checksumTable[i] = (r & 0xffffffff)\r\n    }\r\n  }\r\n\r\n  private getChecksum(data: Uint8Array) {\r\n    let checksum = 0\r\n    for (let i = 0; i < data.length; i++ ) {\r\n      checksum = (checksum << 8) ^ this.checksumTable[((checksum >>> 24) & 0xff) ^ data[i]]\r\n    }\r\n    return checksum >>> 0\r\n  }\r\n\r\n  public init(formatContext: AVOFormatContext): number {\r\n    formatContext.ioWriter.setEndian(false)\r\n\r\n    this.initChecksumTab()\r\n\r\n    this.cacheWriter = new IOWriter(PAGE_MAX, false)\r\n\r\n    if (this.headerPagesPayload) {\r\n      for (let i = 0; i < this.headerPagesPayload.length; i++) {\r\n        this.headerPagesPayload[i].setCodec(formatContext.getStreamByIndex(this.headerPagesPayload[i].streamIndex).codecpar)\r\n      }\r\n    }\r\n\r\n    if (formatContext.streams) {\r\n      formatContext.streams.forEach((stream) => {\r\n        stream.privData = {\r\n          granulePosition: 0n,\r\n          pageSequenceLast: 0\r\n        }\r\n      })\r\n    }\r\n    return 0\r\n  }\r\n\r\n  private writePage(stream: Stream, ioWriter: IOWriter, buffer: Uint8Array, headerTypeFlag: number) {\r\n    let length = buffer.length\r\n    let realLength = length\r\n    let offset = 0\r\n    while (length > 0) {\r\n      const len = Math.min(PAGE_MAX, length)\r\n      const payload = buffer.subarray(offset, offset + len)\r\n\r\n      const isLast = offset + len === realLength\r\n      const isStart = offset === 0\r\n\r\n\r\n      this.page.reset()\r\n      this.page.serialNumber = stream.index\r\n      if (!isLast) {\r\n        this.page.granulePosition = NOPTS_VALUE_BIGINT\r\n      }\r\n      else {\r\n        this.page.granulePosition = (stream.privData as OggsStreamPrivData).granulePosition\r\n      }\r\n      this.page.pageSequenceNumber = (stream.privData as OggsStreamPrivData).pageSequenceLast\r\n      this.page.crcCheckSum = 0\r\n      this.page.headerTypeFlag = headerTypeFlag || 0\r\n\r\n      if (!isStart) {\r\n        // 与前一页属于同一个 packet\r\n        this.page.headerTypeFlag != 0x01\r\n      }\r\n\r\n      this.page.payload = payload\r\n\r\n      this.cacheWriter.reset()\r\n      this.page.write(this.cacheWriter)\r\n      const crc = this.getChecksum(this.cacheWriter.getBuffer())\r\n\r\n      const pointer = this.cacheWriter.getPointer()\r\n      this.cacheWriter.seekInline(22)\r\n      this.cacheWriter.writeUint32(crc)\r\n      this.cacheWriter.seekInline(pointer)\r\n\r\n      ioWriter.writeBuffer(this.cacheWriter.getBuffer())\r\n\r\n      length -= len\r\n      offset += len\r\n    }\r\n\r\n    ++(stream.privData as OggsStreamPrivData).pageSequenceLast\r\n\r\n    if ((stream.privData as OggsStreamPrivData).pageSequenceLast > Math.pow(2, 32) - 1) {\r\n      (stream.privData as OggsStreamPrivData).pageSequenceLast = 0\r\n    }\r\n  }\r\n\r\n  public writeHeader(formatContext: AVOFormatContext): number {\r\n    if (this.headerPagesPayload) {\r\n      for (let i = 0; i < this.headerPagesPayload.length; i++) {\r\n\r\n        const stream = formatContext.getStreamByIndex(this.headerPagesPayload[i].streamIndex)\r\n\r\n        if (stream) {\r\n          this.cacheWriter.reset()\r\n          this.headerPagesPayload[i].write(this.cacheWriter)\r\n          this.writePage(stream, formatContext.ioWriter, this.cacheWriter.getBuffer().slice(), i === 0 ? 2 : 0)\r\n        }\r\n      }\r\n    }\r\n\r\n    return 0\r\n  }\r\n  public writeAVPacket(formatContext: AVOFormatContext, avpacket: pointer<AVPacket>): number {\r\n\r\n    if (!avpacket.size) {\r\n      logger.warn(`packet\\'s size is 0: ${avpacket.streamIndex}, ignore it`)\r\n      return\r\n    }\r\n\r\n    const stream = formatContext.getStreamByIndex(avpacket.streamIndex)\r\n\r\n    if (!stream) {\r\n      logger.warn(`can not found the stream width the packet\\'s streamIndex: ${avpacket.streamIndex}, ignore it`)\r\n      return\r\n    }\r\n\r\n    this.writePage(stream, formatContext.ioWriter, getAVPacketData(avpacket), 0)\r\n\r\n    if (stream.codecpar.codecType === AVMediaType.AVMEDIA_TYPE_AUDIO) {\r\n      (stream.privData as OggsStreamPrivData).granulePosition += static_cast<int64>(stream.codecpar.frameSize)\r\n    }\r\n    else if (stream.codecpar.codecType === AVMediaType.AVMEDIA_TYPE_VIDEO) {\r\n      (stream.privData as OggsStreamPrivData).granulePosition++\r\n    }\r\n\r\n    return 0\r\n  }\r\n  public writeTrailer(formatContext: AVOFormatContext): number {\r\n    formatContext.ioWriter.flush()\r\n    return 0\r\n  }\r\n\r\n  public flush(formatContext: AVOFormatContext): number {\r\n    formatContext.ioWriter.flush()\r\n    return 0\r\n  }\r\n\r\n}\r\n","/*\r\n * libmedia oggs page parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport IOWriter from 'common/io/IOWriterSync'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport IOReaderSync from 'common/io/IOReaderSync'\r\nimport { NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\n\r\nexport interface PagePayload {\r\n  signature: string\r\n  read(ioReader: IOReaderSync): void\r\n  write(ioWriter: IOWriter): void\r\n  setCodec(codecpar: AVCodecParameters): void\r\n  streamIndex: number\r\n}\r\n\r\nexport class OggPage {\r\n  /**\r\n   * 4 bytes 页标识， OggS ASCII 字符\r\n   */\r\n  public capturePattern: string\r\n\r\n  /**\r\n   * 1 bytes 版本 id, 目前为 0\r\n   */\r\n  public streamStructureVersion: number\r\n\r\n  /**\r\n   * 1 bytes 类型标识， 表示该页为逻辑流的第一页\r\n   * \r\n   * - 0x01：本页媒体编码数据与前一页属于同一个逻辑流的同一个 packet，若此位没有设，表示本页是以一个新的 packet 开始的；\r\n   * - 0x02：表示该页为逻辑流的第一页，bos 标识，如果此位未设置，那表示不是第一页；\r\n   * - 0x04：表示该页位逻辑流的最后一页，eos 标识，如果此位未设置，那表示本页不是最后一页；\r\n   */\r\n  public headerTypeFlag: number\r\n\r\n  /**\r\n   * 8 bytes 媒体编码相关的参数信息\r\n   * \r\n   * 对于音频流来说，它存储着到本页为止逻辑流在 PCM 输出中采样码的数目，可以由它来算得时间戳\r\n   * 对于视频流来说，它存储着到本页为止视频帧编码的数目\r\n   * 若此值为 -1，那表示截止到本页，逻辑流的 packet 未结束\r\n   */\r\n  public granulePosition: bigint\r\n\r\n  /**\r\n   * 4 bytes 当前页中的流的 id，它是区分本页所属逻辑流与其他逻辑流的序号，我们可以通过这个值来划分流\r\n   */\r\n  public serialNumber: number\r\n\r\n  /**\r\n   * 4 bytes 本页在逻辑流的序号\r\n   */\r\n  public pageSequenceNumber: number\r\n\r\n  /**\r\n   * 4 bytes 循环冗余效验码效验， 用来效验每页的有效性\r\n   */\r\n  public crcCheckSum: number\r\n\r\n  /**\r\n   * 1 bytes 给定本页在 segment_table 域中出现的 segment 个数\r\n   */\r\n  public numberPageSegments: number\r\n\r\n  /**\r\n   * segment 长度表\r\n   * \r\n   * 表示着每个 segment 的长度，取值范围是 0~255\r\n   * 由 segment（1 个 segment 就是 1 个字节）可以得到 packet 的值，每个 packet 的大小是以最后一个不等于 255 的 segment 结束的\r\n   */\r\n  public segmentTable: number[]\r\n\r\n  public payload: Uint8Array\r\n\r\n  constructor() {\r\n    this.reset()\r\n  }\r\n\r\n  public reset() {\r\n    this.capturePattern = 'OggS'\r\n    this.streamStructureVersion = 0\r\n    this.headerTypeFlag = 0\r\n    this.granulePosition = NOPTS_VALUE_BIGINT\r\n    this.serialNumber = 0\r\n    this.pageSequenceNumber = 0\r\n    this.crcCheckSum = 0\r\n    this.numberPageSegments = 0\r\n    this.segmentTable = []\r\n  }\r\n\r\n\r\n  @deasync\r\n  public async read(ioReader: IOReader) {\r\n    await this.readPageHeader(ioReader)\r\n\r\n    const length = this.segmentTable.reduce((prev, len) => {\r\n      return prev + len\r\n    }, 0)\r\n\r\n    if (length) {\r\n      this.payload = await ioReader.readBuffer(length)\r\n    }\r\n  }\r\n\r\n  @deasync\r\n  public async readPageHeader(ioReader: IOReader) {\r\n    this.capturePattern = await ioReader.readString(4)\r\n    this.streamStructureVersion = await ioReader.readUint8()\r\n    this.headerTypeFlag = await ioReader.readUint8()\r\n    this.granulePosition = await ioReader.readUint64()\r\n    this.serialNumber = await ioReader.readUint32()\r\n    this.pageSequenceNumber = await ioReader.readUint32()\r\n    this.crcCheckSum = await ioReader.readUint32()\r\n    this.numberPageSegments = await ioReader.readUint8()\r\n\r\n    if (this.numberPageSegments) {\r\n      for (let i = 0; i < this.numberPageSegments; i++) {\r\n        const len = await ioReader.readUint8()\r\n        this.segmentTable.push(len)\r\n      }\r\n    }\r\n  }\r\n\r\n  public write(ioWriter: IOWriter) {\r\n    ioWriter.writeString(this.capturePattern)\r\n    ioWriter.writeUint8(this.streamStructureVersion)\r\n    ioWriter.writeUint8(this.headerTypeFlag)\r\n    ioWriter.writeUint64(this.granulePosition)\r\n    ioWriter.writeUint32(this.serialNumber)\r\n    ioWriter.writeUint32(this.pageSequenceNumber)\r\n    ioWriter.writeUint32(this.crcCheckSum)\r\n\r\n    if (this.payload) {\r\n      this.numberPageSegments = Math.ceil(this.payload.length / 255)\r\n      const last = this.payload.length % 255\r\n\r\n      ioWriter.writeUint8(this.numberPageSegments)\r\n\r\n      for (let i = 0; i < this.numberPageSegments - 1; i++) {\r\n        ioWriter.writeUint8(255)\r\n      }\r\n      ioWriter.writeUint8(last)\r\n      ioWriter.writeBuffer(this.payload)\r\n    }\r\n    else {\r\n      ioWriter.writeUint8(0)\r\n    }\r\n  }\r\n}\r\n"],"names":[],"sourceRoot":""}
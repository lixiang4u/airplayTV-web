{"version":3,"file":"src_avformat_formats_IWavFormat_ts.avtranscoder.js","mappings":"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C,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAC9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,sCAA6B;IAE9C,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,0CAAiC;IAClD,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,0CAAiC;IAClD,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,0CAAiC;IAClD,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,0CAAiC;IAClD,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,0CAAiC;IAClD,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,0CAAiC;IAClD,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,0CAAiC;IAClD,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,0CAAiC;IAClD,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,0CAAiC;IAClD,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,0CAAiC;IAClD,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,0CAAiC;IAClD,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,0CAAiC;IAClD,CAAC,qEAAO,CAAC,MAAM,CAAC,CAAC,0CAAiC;IAClD,CAAC,qEAAO,CAAC,MAAM,CAAC,C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","sources":["webpack://AVTranscoder/./src/avformat/formats/IFormat.ts","webpack://AVTranscoder/./src/avformat/formats/IWavFormat.ts","webpack://AVTranscoder/./src/avformat/formats/riff/iriff.ts","webpack://AVTranscoder/./src/avformat/formats/riff/riff.ts","webpack://AVTranscoder/./src/avformat/function/mktagle.ts","webpack://AVTranscoder/./src/avutil/util/intread.ts","webpack://AVTranscoder/./src/avutil/util/pcm.ts"],"sourcesContent":["/*\r\n * libmedia abstract format decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVFormat } from '../avformat'\r\n\r\nexport default abstract class IFormat {\r\n\r\n  public type: AVFormat = AVFormat.UNKNOWN\r\n\r\n  public onStreamAdd: (stream: Stream) => void\r\n  \r\n  public abstract init(formatContext: AVIFormatContext): void\r\n\r\n  public destroy(formatContext: AVIFormatContext): void {}\r\n\r\n  public abstract getAnalyzeStreamsCount(): number\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readHeader(formatContext: AVIFormatContext): Promise<number>\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number>\r\n\r\n  /**\r\n   * seek\r\n   * \r\n   * @param context \r\n   * @param stream \r\n   * @param timestamp 毫秒时间戳\r\n   * @param flags \r\n   * \r\n   * @returns 返回 seek 之前的下一个 avpacket pos（若不知道返回 0n 方便之后可以再 seek 回来）返回负数表示 seek 失败\r\n   */\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract seek(\r\n    formatContext: AVIFormatContext,\r\n    stream: Stream,\r\n    timestamp: int64,\r\n    flags: int32\r\n  ): Promise<int64>\r\n}\r\n","/*\r\n * libmedia wav decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVStream from '../AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVMediaType } from 'avutil/codec'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\nimport IFormat from './IFormat'\r\nimport { AVFormat, AVSeekFlags } from '../avformat'\r\nimport { mapSafeUint8Array } from 'cheap/std/memory'\r\nimport { avMalloc } from 'avutil/util/mem'\r\nimport { addAVPacketData } from 'avutil/util/avpacket'\r\nimport { IOError } from 'common/io/error'\r\nimport { readFormatTag } from './riff/iriff'\r\nimport { getBitsPerSample } from 'avutil/util/pcm'\r\n\r\nconst PACKET_SAMPLE_COUNT = 1024\r\n\r\nexport default class IWavFormat extends IFormat {\r\n\r\n  public type: AVFormat = AVFormat.WAV\r\n\r\n  private dataSize: int64\r\n  private sampleCount: int64\r\n  private pcmStartPos: int64\r\n  private currentPts: int64\r\n\r\n  constructor() {\r\n    super()\r\n  }\r\n\r\n  public init(formatContext: AVIFormatContext): void {\r\n    formatContext.ioReader.setEndian(false)\r\n  }\r\n\r\n  public async readHeader(formatContext: AVIFormatContext): Promise<number> {\r\n    const signature = await formatContext.ioReader.readString(4)\r\n\r\n    switch (signature) {\r\n\r\n      case 'RIFF':\r\n      case 'RF64':\r\n      case 'BW64':\r\n        break\r\n      case 'RIFX':\r\n        formatContext.ioReader.setEndian(true)\r\n        break\r\n      default:\r\n        logger.error('the file format is not wav')\r\n        return errorType.DATA_INVALID\r\n    }\r\n\r\n    // chunk size\r\n    await formatContext.ioReader.skip(4)\r\n\r\n    const dataType = await formatContext.ioReader.readString(4)\r\n\r\n    if (dataType !== 'WAVE') {\r\n      logger.error(`invalid start code ${dataType} in RIFF header`)\r\n      return errorType.DATA_INVALID\r\n    }\r\n\r\n    if (signature === 'RF64' || signature === 'BW64') {\r\n      const tag = await formatContext.ioReader.readString(4)\r\n      if (tag !== 'ds64') {\r\n        return errorType.DATA_INVALID\r\n      }\r\n      const size = await formatContext.ioReader.readUint32()\r\n      if (size < 24) {\r\n        return errorType.DATA_INVALID\r\n      }\r\n\r\n      // riff size\r\n      await formatContext.ioReader.skip(8)\r\n      this.dataSize = await formatContext.ioReader.readUint64()\r\n      this.sampleCount = await formatContext.ioReader.readUint64()\r\n\r\n      if (this.dataSize < 0 || this.sampleCount < 0) {\r\n        logger.error('negative data_size and/or sample_count in ds64')\r\n        return errorType.DATA_INVALID\r\n      }\r\n      await formatContext.ioReader.skip(size - 24)\r\n    }\r\n\r\n    const stream = formatContext.createStream()\r\n\r\n    const fileSize = await formatContext.ioReader.fileSize()\r\n\r\n    let gotFmt = false\r\n    let gotXma2 = false\r\n\r\n    while (formatContext.ioReader.getPos() < fileSize) {\r\n      const tag = await formatContext.ioReader.readString(4)\r\n      const size = await formatContext.ioReader.readUint32()\r\n\r\n      if (tag === 'fmt ') {\r\n        if (!gotFmt) {\r\n          let ret = await readFormatTag(formatContext.ioReader, addressof(stream.codecpar), size)\r\n          if (ret < 0) {\r\n            return ret\r\n          }\r\n        }\r\n        else {\r\n          logger.warn('found more than one \\'fmt \\' tag, ignore it')\r\n        }\r\n      }\r\n      else if (tag === 'data') {\r\n        this.pcmStartPos = formatContext.ioReader.getPos()\r\n        if (!this.dataSize) {\r\n          this.dataSize = static_cast<int64>(size)\r\n        }\r\n        if (this.pcmStartPos + this.dataSize === fileSize) {\r\n          break\r\n        }\r\n        await formatContext.ioReader.seek(this.pcmStartPos + this.dataSize)\r\n      }\r\n      else {\r\n        if (this.pcmStartPos + this.dataSize === fileSize) {\r\n          break\r\n        }\r\n        await formatContext.ioReader.seek(formatContext.ioReader.getPos() + static_cast<int64>(size))\r\n      }\r\n    }\r\n\r\n    if (!this.sampleCount) {\r\n      this.sampleCount = (this.dataSize << 3n) / BigInt(stream.codecpar.chLayout.nbChannels * getBitsPerSample(stream.codecpar.codecId))\r\n    }\r\n\r\n    stream.timeBase.den = stream.codecpar.sampleRate\r\n    stream.timeBase.num = 1\r\n\r\n    if (this.sampleCount) {\r\n      stream.duration = this.sampleCount\r\n    }\r\n\r\n    this.currentPts = 0n\r\n\r\n    await formatContext.ioReader.seek(this.pcmStartPos)\r\n\r\n    return 0\r\n  }\r\n\r\n  public async readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number> {\r\n\r\n    const stream: AVStream = formatContext.streams.find((stream) => {\r\n      return stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n    })\r\n\r\n    try {\r\n\r\n      const length = (PACKET_SAMPLE_COUNT * stream.codecpar.chLayout.nbChannels * getBitsPerSample(stream.codecpar.codecId)) >>> 3\r\n\r\n      const data = avMalloc(length)\r\n      addAVPacketData(avpacket, data, length)\r\n      avpacket.dts = avpacket.pts = this.currentPts\r\n      avpacket.pos = formatContext.ioReader.getPos()\r\n      await formatContext.ioReader.readBuffer(length, mapSafeUint8Array(data, length))\r\n      avpacket.streamIndex = stream.index\r\n      avpacket.timeBase.den = stream.timeBase.den\r\n      avpacket.timeBase.num = stream.timeBase.num\r\n\r\n      this.currentPts += static_cast<int64>(PACKET_SAMPLE_COUNT)\r\n      return 0\r\n    }\r\n    catch (error) {\r\n      if (formatContext.ioReader.error !== IOError.END) {\r\n        logger.error(error.message)\r\n      }\r\n      return formatContext.ioReader.error\r\n    }\r\n  }\r\n\r\n  public async seek(formatContext: AVIFormatContext, stream: AVStream, timestamp: int64, flags: int32): Promise<int64> {\r\n    const now = formatContext.ioReader.getPos()\r\n    if (flags & AVSeekFlags.BYTE) {\r\n      const size = await formatContext.ioReader.fileSize()\r\n\r\n      if (size <= 0n) {\r\n        return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n      }\r\n\r\n      if (timestamp < 0n) {\r\n        timestamp = 0n\r\n      }\r\n      else if (timestamp > size) {\r\n        timestamp = size\r\n      }\r\n      await formatContext.ioReader.seek(timestamp)\r\n\r\n      if (!(flags & AVSeekFlags.ANY)) {\r\n        this.currentPts = ((timestamp - this.pcmStartPos) << 3n) / BigInt( stream.codecpar.chLayout.nbChannels * getBitsPerSample(stream.codecpar.codecId))\r\n      }\r\n      return now\r\n    }\r\n    else {\r\n      const pos = this.pcmStartPos + (timestamp * BigInt(stream.codecpar.chLayout.nbChannels * getBitsPerSample(stream.codecpar.codecId)) >> 3n)\r\n      await formatContext.ioReader.seek(pos)\r\n      this.currentPts = timestamp\r\n      return now\r\n    }\r\n  }\r\n\r\n  public getAnalyzeStreamsCount(): number {\r\n    return 1\r\n  }\r\n}\r\n","import AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport IOReader from 'common/io/IOReader'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\nimport { AVCodecID, AVMediaType } from 'avutil/codec'\r\nimport { WavTag2CodecId } from './riff'\r\nimport { getPcmCodecId } from 'avutil/util/pcm'\r\nimport { avMalloc } from 'avutil/util/mem'\r\nimport { mapSafeUint8Array } from 'cheap/std/memory'\r\nimport * as intread from 'avutil/util/intread'\r\nimport { AVChannelOrder } from 'avutil/audiosamplefmt'\r\n\r\nfunction getWavCodecId(tag: int32, bitsPerCodedSample: int32) {\r\n  let codecId: AVCodecID = WavTag2CodecId[tag]\r\n\r\n  if (!codecId) {\r\n    return AVCodecID.AV_CODEC_ID_NONE\r\n  }\r\n\r\n  if (codecId === AVCodecID.AV_CODEC_ID_PCM_U8) {\r\n    codecId = getPcmCodecId(bitsPerCodedSample, false, false, ~1)\r\n  }\r\n  else if (codecId === AVCodecID.AV_CODEC_ID_PCM_F32LE) {\r\n    codecId = getPcmCodecId(bitsPerCodedSample, true, false, 0)\r\n  }\r\n\r\n  if (codecId === AVCodecID.AV_CODEC_ID_ADPCM_IMA_WAV && bitsPerCodedSample === 8) {\r\n    codecId = AVCodecID.AV_CODEC_ID_ADPCM_ZORK\r\n  }\r\n\r\n  return codecId\r\n}\r\n\r\nexport async function readFormatTag(ioReader: IOReader, codecpar: pointer<AVCodecParameters>, size: int32) {\r\n  if (size < 14) {\r\n    logger.error('wav format size < 14')\r\n    return errorType.DATA_INVALID\r\n  }\r\n\r\n  codecpar.codecType = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n\r\n  const audioFormat = await ioReader.readUint16()\r\n  let channels = await ioReader.readUint16()\r\n  const sampleRate = await ioReader.readUint32()\r\n  let bitrate = await ioReader.readUint32() * 8\r\n  const blockAlgin = await ioReader.readUint16()\r\n\r\n  codecpar.sampleRate = sampleRate\r\n  codecpar.blockAlign = blockAlgin\r\n\r\n  if (size === 14) {\r\n    codecpar.bitsPerCodedSample = 8\r\n  }\r\n  else {\r\n    codecpar.bitsPerCodedSample = await ioReader.readUint16()\r\n  }\r\n\r\n  if (audioFormat === 0xfffe) {\r\n    codecpar.codecTag = 0\r\n  }\r\n  else {\r\n    codecpar.codecTag = audioFormat\r\n    codecpar.codecId = getWavCodecId(audioFormat, codecpar.bitsPerCodedSample)\r\n  }\r\n\r\n  if (size >= 18 && audioFormat !== 0x0165) {\r\n    let cbSize = await ioReader.readUint16()\r\n    size -= 18\r\n\r\n    cbSize = Math.min(size, cbSize)\r\n\r\n    if (cbSize >= 22 && audioFormat === 0xfffe) {\r\n      // TODO parse wave format ex\r\n      await ioReader.skip(22)\r\n      cbSize -= 22\r\n      size   -= 22\r\n    }\r\n\r\n    if (cbSize > 0) {\r\n      codecpar.extradata = avMalloc(cbSize)\r\n      codecpar.extradataSize = cbSize\r\n      await ioReader.readBuffer(cbSize, mapSafeUint8Array(codecpar.extradata, cbSize))\r\n\r\n      size -= cbSize\r\n    }\r\n\r\n    if (size > 0) {\r\n      await ioReader.skip(size)\r\n    }\r\n  }\r\n  else if (audioFormat === 0x0165 && size >= 32) {\r\n    size -= 4\r\n\r\n    codecpar.extradata = avMalloc(size)\r\n    codecpar.extradataSize = size\r\n    await ioReader.readBuffer(size, mapSafeUint8Array(codecpar.extradata, size))\r\n\r\n    const streams = intread.rl16(codecpar.extradata + 4)\r\n    codecpar.sampleRate = intread.rl32(codecpar.extradata + 12)\r\n\r\n    channels = 0\r\n    bitrate = 0\r\n\r\n    if (size < 8 + streams * 20) {\r\n      return errorType.DATA_INVALID\r\n    }\r\n\r\n    for (let i = 0; i < streams; i++) {\r\n      channels += codecpar.extradata[8 + i * 20 + 17]\r\n    }\r\n  }\r\n\r\n  codecpar.bitRate = BigInt(bitrate)\r\n\r\n  if (codecpar.sampleRate < 0) {\r\n    logger.error(`Invalid sample rate: ${codecpar.sampleRate}`)\r\n    return errorType.DATA_INVALID\r\n  }\r\n\r\n  if (codecpar.codecId === AVCodecID.AV_CODEC_ID_AAC_LATM) {\r\n    channels = 0\r\n    codecpar.sampleRate = 0\r\n  }\r\n\r\n  if (codecpar.codecId == AVCodecID.AV_CODEC_ID_ADPCM_G726 && codecpar.sampleRate) {\r\n    codecpar.bitsPerCodedSample = static_cast<int32>(codecpar.bitRate) / codecpar.sampleRate\r\n  }\r\n  if (channels != codecpar.chLayout.nbChannels) {\r\n    codecpar.chLayout.order = AVChannelOrder.AV_CHANNEL_ORDER_UNSPEC\r\n    codecpar.chLayout.nbChannels = channels\r\n  }\r\n  return 0\r\n}\r\n","import mktagle from 'avformat/function/mktagle'\r\nimport { AVCodecID } from 'avutil/codec'\r\n\r\nexport const WavTag2CodecId = {\r\n  0x0001: AVCodecID.AV_CODEC_ID_PCM_U8,\r\n  0x0002: AVCodecID.AV_CODEC_ID_ADPCM_MS,\r\n  0x0003: AVCodecID.AV_CODEC_ID_PCM_F32LE,\r\n  0x0006: AVCodecID.AV_CODEC_ID_PCM_ALAW,\r\n  0x0007: AVCodecID.AV_CODEC_ID_PCM_MULAW,\r\n  0x000A: AVCodecID.AV_CODEC_ID_WMAVOICE,\r\n  0x0010: AVCodecID.AV_CODEC_ID_ADPCM_IMA_OKI,\r\n  0x0011: AVCodecID.AV_CODEC_ID_ADPCM_IMA_WAV,\r\n  0x0017: AVCodecID.AV_CODEC_ID_ADPCM_IMA_OKI,\r\n  0x0020: AVCodecID.AV_CODEC_ID_ADPCM_YAMAHA,\r\n  0x0022: AVCodecID.AV_CODEC_ID_TRUESPEECH,\r\n  0x0031: AVCodecID.AV_CODEC_ID_GSM_MS,\r\n  0x0032: AVCodecID.AV_CODEC_ID_GSM_MS,\r\n  0x0038: AVCodecID.AV_CODEC_ID_AMR_NB,\r\n  0x0042: AVCodecID.AV_CODEC_ID_G723_1,\r\n  0x0045: AVCodecID.AV_CODEC_ID_ADPCM_G726,\r\n  0x0014: AVCodecID.AV_CODEC_ID_ADPCM_G726,\r\n  0x0040: AVCodecID.AV_CODEC_ID_ADPCM_G726,\r\n  0x0061: AVCodecID.AV_CODEC_ID_ADPCM_IMA_DK4,\r\n  0x0062: AVCodecID.AV_CODEC_ID_ADPCM_IMA_DK3,\r\n  0x0064: AVCodecID.AV_CODEC_ID_ADPCM_G726,\r\n  0x0069: AVCodecID.AV_CODEC_ID_ADPCM_IMA_WAV,\r\n  0x0075: AVCodecID.AV_CODEC_ID_METASOUND,\r\n  0x0083: AVCodecID.AV_CODEC_ID_G729,\r\n  0x00ff: AVCodecID.AV_CODEC_ID_AAC,\r\n  0x0111: AVCodecID.AV_CODEC_ID_G723_1,\r\n\r\n  // ADTS AAC\r\n  0x1600: AVCodecID.AV_CODEC_ID_AAC,\r\n  0x1602: AVCodecID.AV_CODEC_ID_AAC_LATM,\r\n  0x2000: AVCodecID.AV_CODEC_ID_AC3\r\n}\r\n\r\nexport const codecBmpTags: Record<int32, AVCodecID> = {\r\n  [mktagle('H264')]: AVCodecID.AV_CODEC_ID_H264,\r\n  [mktagle('h264')]: AVCodecID.AV_CODEC_ID_H264,\r\n  [mktagle('X264')]: AVCodecID.AV_CODEC_ID_H264,\r\n  [mktagle('x264')]: AVCodecID.AV_CODEC_ID_H264,\r\n  [mktagle('avc1')]: AVCodecID.AV_CODEC_ID_H264,\r\n  [mktagle('DAVC')]: AVCodecID.AV_CODEC_ID_H264,\r\n  [mktagle('SMV2')]: AVCodecID.AV_CODEC_ID_H264,\r\n  [mktagle('VSSH')]: AVCodecID.AV_CODEC_ID_H264,\r\n  [mktagle('Q264')]: AVCodecID.AV_CODEC_ID_H264,\r\n  [mktagle('V264')]: AVCodecID.AV_CODEC_ID_H264,\r\n  [mktagle('GAVC')]: AVCodecID.AV_CODEC_ID_H264,\r\n  [mktagle('UMSV')]: AVCodecID.AV_CODEC_ID_H264,\r\n  [mktagle('tshd')]: AVCodecID.AV_CODEC_ID_H264,\r\n  [mktagle('INMC')]: AVCodecID.AV_CODEC_ID_H264,\r\n\r\n  [mktagle('FMP4')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('DIVX')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('DX50')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('XVID')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('MP4S')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('M4S2')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('DIVX')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [0x04 as int32]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('ZMP4')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('DIV1')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('BLZ0')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('mp4v')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('UMP4')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('WV1F')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('SEDG')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('RMP4')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('3IV2')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('WAWV')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('FFDS')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('FVFW')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('DCOD')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('MVXM')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('PM4V')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('SMP4')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('DXGM')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('VIDM')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('M4T3')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('GEOX')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('G264')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('HDX4')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('DM4V')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('DMK2')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('DYM4')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('DIGI')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('EPHV')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('EM4A')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('M4CC')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('SN40')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('VSPX')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('ULDX')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('GEOV')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('SIPP')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('SM4V')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('XVIX')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('DreX')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('QMP4')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('PLV1')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('GLV4')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('GMP4')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('MNM4')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktagle('GTM4')]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n\r\n  [mktagle('MPG4')]: AVCodecID.AV_CODEC_ID_MSMPEG4V1,\r\n  [mktagle('MP41')]: AVCodecID.AV_CODEC_ID_MSMPEG4V1,\r\n  [mktagle('MP42')]: AVCodecID.AV_CODEC_ID_MSMPEG4V2,\r\n  [mktagle('DIV2')]: AVCodecID.AV_CODEC_ID_MSMPEG4V2,\r\n  [mktagle('MP43')]: AVCodecID.AV_CODEC_ID_MSMPEG4V3,\r\n  [mktagle('DIV3')]: AVCodecID.AV_CODEC_ID_MSMPEG4V3,\r\n  [mktagle('MPG3')]: AVCodecID.AV_CODEC_ID_MSMPEG4V3,\r\n  [mktagle('DIV5')]: AVCodecID.AV_CODEC_ID_MSMPEG4V3,\r\n  [mktagle('DIV6')]: AVCodecID.AV_CODEC_ID_MSMPEG4V3,\r\n  [mktagle('DIV4')]: AVCodecID.AV_CODEC_ID_MSMPEG4V3,\r\n  [mktagle('DVX3')]: AVCodecID.AV_CODEC_ID_MSMPEG4V3,\r\n  [mktagle('AP41')]: AVCodecID.AV_CODEC_ID_MSMPEG4V3,\r\n  [mktagle('COL1')]: AVCodecID.AV_CODEC_ID_MSMPEG4V3,\r\n  [mktagle('COL0')]: AVCodecID.AV_CODEC_ID_MSMPEG4V3,\r\n\r\n  [mktagle('VP80')]: AVCodecID.AV_CODEC_ID_VP8,\r\n  [mktagle('VP90')]: AVCodecID.AV_CODEC_ID_VP9\r\n}\r\n","/*\r\n * libmedia string tag to uint32 in litten end\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport * as logger from 'common/util/logger'\r\n\r\nexport default function mktagLe(tag: string): number {\r\n  if (tag.length !== 4) {\r\n    logger.warn(`tag length is not 4, tag: ${tag}`)\r\n  }\r\n\r\n  let value = 0\r\n  for (let i = 3; i >= 0; i--) {\r\n    value = (value << 8) | tag.charCodeAt(i)\r\n  }\r\n\r\n  return value\r\n}\r\n","/*\r\n * libmedia int read util\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nexport function r8(p: pointer<void>): uint8 {\r\n  return accessof(reinterpret_cast<pointer<uint8>>(p))\r\n}\r\n\r\nexport function rl16(p: pointer<void>): uint16 {\r\n  return (r8(reinterpret_cast<pointer<uint8>>(p + 1)) << 8) | r8(p)\r\n}\r\n\r\nexport function rb16(p: pointer<void>): uint16 {\r\n  return (r8(p) << 8) | r8(reinterpret_cast<pointer<uint8>>(p + 1))\r\n}\r\n\r\nexport function rl24(p: pointer<void>): int32 {\r\n  return (r8(reinterpret_cast<pointer<uint8>>(p + 2)) << 16) | (r8(reinterpret_cast<pointer<uint8>>(p + 1)) << 8) + r8(p)\r\n}\r\n\r\nexport function rb24(p: pointer<void>): int32 {\r\n  return (r8(p) << 16) | (r8(reinterpret_cast<pointer<uint8>>(p + 1)) << 8) | r8(reinterpret_cast<pointer<uint8>>(p + 2))\r\n}\r\n\r\nexport function rl32(p: pointer<void>): int32 {\r\n  return (rl16(reinterpret_cast<pointer<uint8>>(p + 2)) << 16) | rl16(p)\r\n}\r\n\r\nexport function rb32(p: pointer<void>): int32 {\r\n  return (rb16(p) << 16) | rb16(reinterpret_cast<pointer<uint8>>(p + 2))\r\n}\r\n\r\nexport function rl64(p: pointer<void>): int64 {\r\n  return (BigInt(rl32(reinterpret_cast<pointer<uint8>>(p + 4))) << 32n) | BigInt(rl32(p))\r\n}\r\n\r\nexport function rb64(p: pointer<void>): int64 {\r\n  return (BigInt(rb32(p)) << 32n) | BigInt(rb32(reinterpret_cast<pointer<uint8>>(p + 4)))\r\n}\r\n","/*\r\n * libmedia pcm util\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { AVCodecID } from '../codec'\r\n\r\nexport function getPcmCodecId(bps: int32, flt: boolean, be: boolean, flags: int32) {\r\n  if (bps <= 0 || bps > 64) {\r\n    return AVCodecID.AV_CODEC_ID_NONE\r\n  }\r\n\r\n  if (flt) {\r\n    switch (bps) {\r\n      case 32:\r\n        return be ? AVCodecID.AV_CODEC_ID_PCM_F32BE : AVCodecID.AV_CODEC_ID_PCM_F32LE\r\n      case 64:\r\n        return be ? AVCodecID.AV_CODEC_ID_PCM_F64BE : AVCodecID.AV_CODEC_ID_PCM_F64LE\r\n      default:\r\n        return AVCodecID.AV_CODEC_ID_NONE\r\n    }\r\n  }\r\n  else {\r\n    bps += 7\r\n    bps >>>= 3\r\n\r\n    if (flags & (1 << (bps - 1))) {\r\n      switch (bps) {\r\n        case 1:\r\n          return AVCodecID.AV_CODEC_ID_PCM_S8\r\n        case 2:\r\n          return be ? AVCodecID.AV_CODEC_ID_PCM_S16BE : AVCodecID.AV_CODEC_ID_PCM_S16LE\r\n        case 3:\r\n          return be ? AVCodecID.AV_CODEC_ID_PCM_S24BE : AVCodecID.AV_CODEC_ID_PCM_S24LE\r\n        case 4:\r\n          return be ? AVCodecID.AV_CODEC_ID_PCM_S32BE : AVCodecID.AV_CODEC_ID_PCM_S32LE\r\n        case 8:\r\n          return be ? AVCodecID.AV_CODEC_ID_PCM_S64BE : AVCodecID.AV_CODEC_ID_PCM_S64LE\r\n        default:\r\n          return AVCodecID.AV_CODEC_ID_NONE\r\n      }\r\n    }\r\n    else {\r\n      switch (bps) {\r\n        case 1:\r\n          return AVCodecID.AV_CODEC_ID_PCM_U8\r\n        case 2:\r\n          return be ? AVCodecID.AV_CODEC_ID_PCM_U16BE : AVCodecID.AV_CODEC_ID_PCM_U16LE\r\n        case 3:\r\n          return be ? AVCodecID.AV_CODEC_ID_PCM_U24BE : AVCodecID.AV_CODEC_ID_PCM_U24LE\r\n        case 4:\r\n          return be ? AVCodecID.AV_CODEC_ID_PCM_U32BE : AVCodecID.AV_CODEC_ID_PCM_U32LE\r\n        default:\r\n          return AVCodecID.AV_CODEC_ID_NONE\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function getExactBitsPerSample(codecId: AVCodecID) {\r\n  switch (codecId) {\r\n    case AVCodecID.AV_CODEC_ID_8SVX_EXP:\r\n    case AVCodecID.AV_CODEC_ID_8SVX_FIB:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_ARGO:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_CT:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_IMA_ALP:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_IMA_AMV:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_IMA_APC:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_IMA_APM:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_IMA_OKI:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_IMA_WS:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_IMA_SSI:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_G722:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_YAMAHA:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_AICA:\r\n      return 4\r\n    case AVCodecID.AV_CODEC_ID_DSD_LSBF:\r\n    case AVCodecID.AV_CODEC_ID_DSD_MSBF:\r\n    case AVCodecID.AV_CODEC_ID_DSD_LSBF_PLANAR:\r\n    case AVCodecID.AV_CODEC_ID_DSD_MSBF_PLANAR:\r\n    case AVCodecID.AV_CODEC_ID_PCM_ALAW:\r\n    case AVCodecID.AV_CODEC_ID_PCM_MULAW:\r\n    case AVCodecID.AV_CODEC_ID_PCM_VIDC:\r\n    case AVCodecID.AV_CODEC_ID_PCM_S8:\r\n    case AVCodecID.AV_CODEC_ID_PCM_S8_PLANAR:\r\n    case AVCodecID.AV_CODEC_ID_PCM_SGA:\r\n    case AVCodecID.AV_CODEC_ID_PCM_U8:\r\n    case AVCodecID.AV_CODEC_ID_SDX2_DPCM:\r\n    case AVCodecID.AV_CODEC_ID_DERF_DPCM:\r\n      return 8\r\n    case AVCodecID.AV_CODEC_ID_PCM_S16BE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_S16BE_PLANAR:\r\n    case AVCodecID.AV_CODEC_ID_PCM_S16LE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_S16LE_PLANAR:\r\n    case AVCodecID.AV_CODEC_ID_PCM_U16BE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_U16LE:\r\n      return 16\r\n    case AVCodecID.AV_CODEC_ID_PCM_S24DAUD:\r\n    case AVCodecID.AV_CODEC_ID_PCM_S24BE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_S24LE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_S24LE_PLANAR:\r\n    case AVCodecID.AV_CODEC_ID_PCM_U24BE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_U24LE:\r\n      return 24\r\n    case AVCodecID.AV_CODEC_ID_PCM_S32BE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_S32LE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_S32LE_PLANAR:\r\n    case AVCodecID.AV_CODEC_ID_PCM_U32BE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_U32LE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_F32BE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_F32LE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_F24LE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_F16LE:\r\n      return 32\r\n    case AVCodecID.AV_CODEC_ID_PCM_F64BE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_F64LE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_S64BE:\r\n    case AVCodecID.AV_CODEC_ID_PCM_S64LE:\r\n      return 64\r\n    default:\r\n      return 0\r\n  }\r\n}\r\n\r\nexport function getBitsPerSample(codecId: AVCodecID) {\r\n  switch (codecId) {\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_SBPRO_2:\r\n      return 2\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_SBPRO_3:\r\n      return 3\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_SBPRO_4:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_IMA_WAV:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_IMA_QT:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_SWF:\r\n    case AVCodecID.AV_CODEC_ID_ADPCM_MS:\r\n      return 4\r\n    default:\r\n      return getExactBitsPerSample(codecId)\r\n  }\r\n}\r\n"],"names":[],"sourceRoot":""}
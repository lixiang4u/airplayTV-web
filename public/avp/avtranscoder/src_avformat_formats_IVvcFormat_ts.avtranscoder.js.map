{"version":3,"file":"src_avformat_formats_IVvcFormat_ts.avtranscoder.js","mappings":";;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AAOY,MAAe,OAAO;IAE5B,IAAI,6BAA6B;IAEjC,WAAW,CAA0B;IAIrC,OAAO,CAAC,aAA+B,IAAS,CAAC;CA4BzD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrCwC;AACV;AAEwB;AACb;AAC0D;AAGxD;AACiB;AACzB;AACU;AACH;AACO;AACR;AAO1C,MAAM,wBAAwB,GAAsB;IAClD,SAAS,EAAE;QACT,GAAG,EAAE,EAAE;QACP,GAAG,EAAE,CAAC;KACP;CACF;AAEc,MAAM,WAAY,SAAQ,gDAAO;IAEvC,IAAI,0BAA0B;IAE7B,OAAO,CAAmB;IAE1B,UAAU,CAAO;IACjB,UAAU,CAAO;IACjB,IAAI,CAAO;IAEX,MAAM,CAAc;IACpB,OAAO,CAAO;IAEd,KAAK,CAA+C;IACpD,SAAS,CAAW;IAEpB,SAAS,CAAkB;IAC3B,QAAQ,CAAiB;IACzB,GAAG,CAAO;IAEV,OAAO,CAAO;IAEd,GAAG,CAAY;IAEf,UAAU,CAAY;IAE9B,YAAY,UAA6B,EAAE;QACzC,KAAK,EAAE;QACP,IAAI,CAAC,OAAO,GAAG,sDAAa,CAAC,EAAE,EAAE,wBAAwB,EAAE,OAAO,CAAC;IACrE,CAAC;IAEM,IAAI,CAAC,aAA+B;QAEzC,IAAI,aAAa,CAAC,QAAQ,EAAE;YAC1B,aAAa,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC;SACxC;QAED,IAAI,CAAC,MAAM,GAAG,EAAE;QAEhB,IAAI,CAAC,KAAK,GAAG,EAAE;QACf,IAAI,CAAC,SAAS,GAAG,IAAI,4DAAS,CAAC,GAAG,CAAC;QACnC,IAAI,CAAC,UAAU,GAAG,IAAI,yDAAU,EAAE;IACpC,CAAC;IAEM,OAAO,CAAC,aAA+B;QAC5C,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;YACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC1C,qEAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;aACxC;YACD,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC;SACtB;IACH,CAAC;IAEO,WAAW,CAAC,IAAgB;QAClC,MAAM,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI;QACzD,OAAO,IAAI,oCAA2B;IACxC,CAAC;IAGO,KAAK,CAAC,aAAa,CAAC,aAA+B;QAEzD,IAAI,QAAQ,GAAG,KAAK;QAEpB,MAAM,KAAK,GAAiB,IAAI,CAAC,MAAM;QACvC,IAAI,CAAC,MAAM,GAAG,EAAE;QAEhB,IAAI,KAAK,CAAC,MAAM,EAAE;YAChB,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;SACtC;QAED,OAAO,IAAI,EAAE;YACX,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC;YAC/D,IAAI,CAAC,IAAI,EAAE;gBACT,OAAO,KAAK;aACb;YAED,MAAM,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI;YAEzD,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE;gBAC1B,IAAI,QAAQ,EAAE;oBACZ,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;oBAC/C,IAAI,KAAK,EAAE;wBACT,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;wBACtB,OAAO,KAAK;qBACb;yBACI;wBACH,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;qBACjB;iBACF;qBACI;oBACH,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;oBAChB,QAAQ,GAAG,IAAI;iBAChB;aACF;iBACI,IAAI,QAAQ;mBACZ,CAAC,IAAI,sCAA6B;uBAChC,IAAI,qCAA4B;uBAChC,IAAI,sCAA6B;uBACjC,IAAI,sCAA6B;uBACjC,IAAI,sCAA6B;uBACjC,IAAI,sCAA6B;uBACjC,IAAI,sCAA6B,CACrC,EACD;gBACA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;gBACtB,OAAO,KAAK;aACb;iBACI;gBACH,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;aACjB;SACF;IACH,CAAC;IAEM,KAAK,CAAC,UAAU,CAAC,aAA+B;QACrD,MAAM,MAAM,GAAG,aAAa,CAAC,YAAY,EAAE;QAC3C,MAAM,CAAC,QAAQ,CAAC,SAAS,0CAAiC;QAC1D,MAAM,CAAC,QAAQ,CAAC,OAAO,uCAA4B;QACnD,MAAM,CAAC,QAAQ,CAAC,GAAG,GAAG,0DAAY;QAClC,MAAM,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC;QACvB,MAAM,CAAC,QAAQ,CAAC,SAAS,4BAAmB;QAC5C,IAAI,CAAC,UAAU,aAAK;QACpB,IAAI,CAAC,UAAU,aAAK;QACpB,IAAI,CAAC,OAAO,aAAK;QACjB,IAAI,CAAC,GAAG,GAAG,CAAC;QACZ,IAAI,CAAC,OAAO,GAAG,CAAC;QAChB,IAAI,CAAC,IAAI,qBAAsB,CAAC,0DAAY,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,CAAW,GAAC;QAElH,OAAO,IAAI,EAAE;YACX,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC;YAEtD,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;gBAClB,kCAAkB;aACnB;YAED,MAAM,IAAI,GAAG,2EAAe,CAAC,UAAU,EAAE,MAAM,CAAC;YAEhD,MAAM,SAAS,GAAG,2EAAe,CAAC,UAAU,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE;gBAChE,MAAM,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI;gBACnD,OAAO,IAAI,sCAA6B;uBACnC,IAAI,sCAA6B;uBACjC,IAAI,sCAA6B;YACxC,CAAC,CAAC,CAAC;YAEH,IAAI,SAAS,EAAE;gBACb,MAAM,CAAC,QAAQ,CAAC,SAAS,GAAG,yDAAQ,CAAC,SAAS,CAAC,MAAM,CAAC;gBACtD,sEAAoB,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,EAAE,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC;gBAC5E,MAAM,CAAC,QAAQ,CAAC,aAAa,GAAG,SAAS,CAAC,MAAM;gBAEhD,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE;oBAC5B,MAAM,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI;oBACnD,OAAO,IAAI,sCAA6B;gBAC1C,CAAC,CAAC;gBACF,oEAA+B,CAAC,MAAM,EAAE,GAAG,CAAC;gBAC5C,IAAI,CAAC,GAAG,GAAG,iDAAY,CAAC,GAAG,CAAC;gBAE5B,MAAM,QAAQ,GAAG,oEAAc,EAAE;gBAEjC,MAAM,KAAK,GAAG,yDAAQ,CAAC,IAAI,CAAC,MAAM,CAAC;gBACnC,sEAAoB,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;gBAC9C,qEAAe,CAAC,QAAQ,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC;gBAE7C,6EAAQ,OAAO,IAAI,CAAC,OAAO;gBAC3B,IAAI,CAAC,OAAO,sBAAuB,IAAI,CAAC,MAAM,EAAC;gBAE/C,6EAAQ,OAAO,IAAI,CAAC,UAAU;gBAC9B,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,IAAI;gBAC5B,6EAAQ,MAAO,IAAI,CAAC,UAAU;gBAC9B,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,IAAI;gBAE5B,6EAAQ,OAAe,MAAM,CAAC,KAAK;gBACnC,6EAAQ,0EAAR,QAAQ,gDAAuC;gBAC/C,6EAAQ,OAAgB,MAAM,CAAC,QAAQ,CAAC,GAAG;gBAC3C,6EAAQ,OAAgB,MAAM,CAAC,QAAQ,CAAC,GAAG;gBAC3C,6EAAQ,iCAA6B;gBAErC,aAAa,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC;gBAElD,MAAK;aACN;YAED,IAAI,CAAC,OAAO,sBAAuB,IAAI,CAAC,MAAM,EAAC;SAChD;QAED,OAAO,CAAC;IACV,CAAC;IAEO,UAAU,CAAC,QAAyB,EAAE,UAAkB,EAAE,EAAc,EAAE,WAAoB;QACpG,8BAA8B;QAC9B,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE;QACtB,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;QAEhD,IAAI,WAAW,EAAE;YACf,yCAAyC;YACzC,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE;SACxB;QACD,MAAM,uBAAuB,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE;QACvD,MAAM,mBAAmB,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE;QACnD,IAAI,eAAe,GAAG,CAAC;QACvB,IAAI,uBAAuB,EAAE;YAC3B,eAAe,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE;SAC1C;QACD,MAAM,2BAA2B,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE;QAC3D,IAAI,2BAA2B,EAAE;YAC/B,8BAA8B;YAC9B,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE;SACxB;QACD,0BAA0B;QAC1B,0DAAgB,CAAC,IAAI,CAAC,SAAS,CAAC;QAChC,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,qCAAqC,GAAG,CAAC,CAAC;QACxF,IAAI,eAAe,EAAE;YACnB,sBAAsB;YACtB,0DAAgB,CAAC,IAAI,CAAC,SAAS,CAAC;SACjC;QACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,sBAAsB,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;YAC5D,IAAI,IAAI,CAAC,GAAG,CAAC,6BAA6B,CAAC,CAAC,CAAC,EAAE;gBAC7C,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE;aACxB;SACF;QACD,IAAI,oBAAoB,GAAG,CAAC;QAC5B,IAAI,6BAA6B,GAAG,CAAC;QACrC,IAAI,IAAI,CAAC,GAAG,CAAC,sBAAsB,EAAE;YACnC,6BAA6B,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE;YACvD,IAAI,6BAA6B,EAAE;gBACjC,oBAAoB,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,4BAA4B,GAAG,CAAC,CAAC;aACvF;SACF;QAED,MAAM,WAAW,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,qCAAqC,GAAG,CAAC,CAAC;QAC7E,IAAI,OAAO,GAAG,CAAC;QACf,IAAI,QAAQ,sCAA8B;eACrC,QAAQ,wCAAgC,EAC3C;YACA,IAAI,6BAA6B,EAAE;gBACjC,OAAO,GAAG,oBAAoB,GAAG,WAAW;aAC7C;iBACI;gBACH,OAAO,GAAG,CAAC;aACZ;SACF;aACI;YACH,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO;YAC7B,MAAM,YAAY,GAAG,QAAQ,GAAG,CAAC,WAAW,GAAG,CAAC,CAAC;YACjD,MAAM,YAAY,GAAG,QAAQ,GAAG,YAAY;YAC5C,IAAI,6BAA6B,EAAE;gBACjC,OAAO,GAAG,oBAAoB,GAAG,WAAW;aAC7C;iBACI;gBACH,IAAI,CAAC,OAAO,GAAG,YAAY,CAAC;uBACvB,CAAC,CAAC,YAAY,GAAG,OAAO,CAAC,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC,EAClD;oBACA,OAAO,GAAG,YAAY,GAAG,WAAW;iBACrC;qBACI,IAAI,CAAC,OAAO,GAAG,YAAY,CAAC;uBAC5B,CAAC,CAAC,OAAO,GAAG,YAAY,CAAC,GAAG,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC,EACjD;oBACA,OAAO,GAAG,YAAY,GAAG,WAAW;iBACrC;qBACI;oBACH,OAAO,GAAG,YAAY;iBACvB;aACF;SACF;QACD,IAAI,CAAC,GAAG,GAAG,OAAO,GAAG,OAAO;QAE5B,IAAI,UAAU,IAAI,CAAC;eACd,CAAC,mBAAmB;eACpB,QAAQ,sCAA8B;eACtC,QAAQ,sCAA8B,EACzC;YACA,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,GAAG;SACxB;QACD,6BAA6B;IAC/B,CAAC;IAGO,KAAK,CAAC,aAAa,CAAC,aAA+B,EAAE,QAA2B;QAEtF,MAAM,MAAM,GAAG,aAAa,CAAC,oBAAoB,wCAAgC;QAEjF,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC;QAErD,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;YACjB,kCAAkB;SACnB;QAED,IAAI,CAAC,SAAS,wCAA8B;QAC5C,IAAI,KAAK,GAAG,KAAK;QACjB,IAAI,OAAO,GAAG,IAAI;QAElB,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;YAClB,MAAM,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACvC,MAAM,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,CAAC,GAAG,IAAI;YAClC,MAAM,UAAU,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC;YAEtC,IAAI,IAAI,sCAA6B,EAAE;gBACrC,IAAI,CAAC,GAAG,GAAG,iDAAY,CAAC,CAAC,CAAC;aAC3B;YAED,IAAI,IAAI,sCAA8B;mBACjC,IAAI,wCAAgC,EACvC;gBACA,KAAK,GAAG,IAAI;aACb;YAED,IAAI,IAAI,qCAA4B,EAAE;gBACpC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,UAAU,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;aACzE;YAED,IAAI,IAAI,oCAA2B,IAAI,OAAO,EAAE;gBAC9C,OAAO,GAAG,KAAK;gBACf,IAAI,CAAC,QAAQ,GAAG,IAAI;gBACpB,MAAM,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;gBACzC,IAAI,KAAK,EAAE;oBACT,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,UAAU,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC;iBACxE;aACF;QACH,CAAC,CAAC;QAEF,MAAM,IAAI,GAAG,2EAAe,CAAC,UAAU,EAAE,KAAK,CAAC;QAE/C,MAAM,KAAK,GAAG,yDAAQ,CAAC,IAAI,CAAC,MAAM,CAAC;QACnC,sEAAoB,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;QAC9C,qEAAe,CAAC,QAAQ,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC;QAE7C,6EAAQ,OAAO,IAAI,CAAC,OAAO;QAC3B,IAAI,CAAC,OAAO,sBAAuB,IAAI,CAAC,MAAM,EAAC;QAC/C,6EAAQ,OAAO,IAAI,CAAC,UAAU;QAC9B,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,IAAI;QAC5B,6EAAQ,OAAe,MAAM,CAAC,KAAK;QACnC,6EAAQ,OAAgB,MAAM,CAAC,QAAQ,CAAC,GAAG;QAC3C,6EAAQ,OAAgB,MAAM,CAAC,QAAQ,CAAC,GAAG;QAC3C,6EAAQ,iCAA6B;QAErC,IAAI,KAAK,EAAE;YACT,6EAAQ,0EAAR,QAAQ,gDAAuC;SAChD;QAED,OAAO,CAAC;IACV,CAAC;IAEM,KAAK,CAAC,YAAY,CAAC,aAA+B,EAAE,QAA2B;QAEpF,IAAI,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM;QAEpC,MAAM,MAAM,GAAG,GAAG,EAAE;YAElB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;gBACzB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;oBACvB,OAAO,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACnC,CAAC,CAAC;aACH;YAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC1C,yEAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,MAAO,IAAI,CAAC,UAAU;gBAC5C,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,IAAI;aAC7B;YACD,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;gBACzB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;oBACvB,OAAO,oEAAC,CAAC,QAAQ,4EAAO,CAAC,CAAC,QAAQ,MAAI,YAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtD,CAAC,CAAC;aACH;YACD,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;gBACrB,iEAAW,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;gBAC7C,qEAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;aACxC;YACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC1C,aAAa,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;aACjE;YACD,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC;QACvB,CAAC;QAED,OAAO,IAAI,EAAE;YACX,MAAM,IAAI,GAAG,oEAAc,EAAE;YAC7B,IAAI,GAAG,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,aAAa,EAAE,IAAI,CAAC;YACvD,IAAI,GAAG,GAAG,CAAC,EAAE;gBACX,qEAAe,CAAC,IAAI,CAAC;gBACrB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;oBACrB,MAAM,EAAE;oBACR,OAAO,CAAC;iBACT;qBACI;oBACH,OAAO,GAAG;iBACX;aACF;YACD,IAAI,CAAC,uEAAI,8CAAsC,CAAC;mBAC3C,IAAI,CAAC,QAAQ,qCAA6B;mBAC1C,CAAC,IAAI,CAAC,SAAS,qCAA6B;uBAC1C,IAAI,CAAC,SAAS,qCAA6B,CAC/C,EACD;gBACA,IAAI,YAAY,KAAK,CAAC;uBACjB,CAAC,IAAI,CAAC,QAAQ,qCAA6B;2BACvC,CAAC,uEAAI,8CAAsC,CAAC,CAClD;2BACI,IAAI,CAAC,KAAK,CAAC,MAAM,EACtB;oBACA,MAAM,EAAE;oBACR,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;wBACd,QAAQ,EAAE,IAAI;wBACd,GAAG,EAAE,IAAI,CAAC,GAAG;qBACd,CAAC;oBACF,OAAO,CAAC;iBACT;qBACI;oBACH,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;wBACd,QAAQ,EAAE,IAAI;wBACd,GAAG,EAAE,IAAI,CAAC,GAAG;qBACd,CAAC;oBACF,YAAY,EAAE;iBACf;aACF;iBACI;gBACH,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;oBACd,QAAQ,EAAE,IAAI;oBACd,GAAG,EAAE,IAAI,CAAC,GAAG;iBACd,CAAC;aACH;SACF;IACH,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,aAA+B,EAAE,MAAgB,EAAE,SAAgB,EAAE,KAAY;QACjG,cAA0B,4DAA4B,EAAC;IACzD,CAAC;IAEM,sBAAsB;QAC3B,OAAO,CAAC;IACV,CAAC;CAEF;;;;;;;;;;;;;;;;ACreD;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AAGqC;AACqB;AAE9C,MAAM,UAAU;IAErB,MAAM,CAAY;IAClB,GAAG,CAAO;IACV,GAAG,CAAO;IACV,KAAK,CAAS;IAEtB;QACE,IAAI,CAAC,MAAM,GAAG,IAAI,UAAU,QAAY;QACxC,IAAI,CAAC,GAAG,GAAG,CAAC;QACZ,IAAI,CAAC,GAAG,GAAG,CAAC;QACZ,IAAI,CAAC,KAAK,GAAG,KAAK;IACpB,CAAC;IAGM,KAAK,CAAC,IAAI,CAAC,QAAkB;QAClC,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,EAAE;YACtC,OAAM;SACP;QAED,MAAM,MAAM,GAAiB,EAAE;QAE/B,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,GAAG,CAAC,EAAE;YAC3B,IAAI,IAAI,GAAG,8DAAqB,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;YACjF,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE;gBACpB,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;gBAChE,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM;gBACvB,OAAO,IAAI;aACZ;iBACI;gBACH,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;gBACtD,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,GAAG,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC;gBACjD,IAAI,CAAC,GAAG,GAAG,CAAC;gBACZ,IAAI,CAAC,GAAG,GAAG,CAAC;aACb;SACF;QAED,OAAO,IAAI,EAAE;YACX,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;gBAChD,IAAI;oBACF,MAAM,GAAG,GAAG,MAAM,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;oBACtG,IAAI,CAAC,GAAG,IAAI,GAAG;iBAChB;gBACD,OAAO,KAAK,EAAE;oBACZ,IAAI,CAAC,KAAK,GAAG,IAAI;oBACjB,IAAI,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,EAAE;wBACxB,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,2EAAe,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI;qBAClE;iBACF;aACF;YAED,IAAI,IAAI,GAAG,8DAAqB,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAErG,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE;gBACpB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC;gBAChE,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM;gBACvB,OAAO,2EAAe,CAAC,UAAU,EAAE,MAAM,CAAC;aAC3C;iBACI;gBACH,IAAI,IAAI,CAAC,KAAK,EAAE;oBACd,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;oBAClD,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,GAAG,CAAC;oBACvB,OAAO,2EAAe,CAAC,UAAU,EAAE,MAAM,CAAC;iBAC3C;qBACI;oBACH,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;oBACtD,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,GAAG,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC;oBACjD,IAAI,CAAC,GAAG,GAAG,CAAC;oBACZ,IAAI,CAAC,GAAG,GAAG,CAAC;iBACb;aACF;SACF;IACH,CAAC;IAEM,KAAK;QACV,IAAI,CAAC,GAAG,GAAG,CAAC;QACZ,IAAI,CAAC,GAAG,GAAG,CAAC;QACZ,IAAI,CAAC,KAAK,GAAG,KAAK;IACpB,CAAC;CACF","sources":["webpack://AVTranscoder/./src/avformat/formats/IFormat.ts","webpack://AVTranscoder/./src/avformat/formats/IVvcFormat.ts","webpack://AVTranscoder/./src/avformat/formats/nalu/NaluReader.ts"],"sourcesContent":["/*\r\n * libmedia abstract format decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVFormat } from '../avformat'\r\n\r\nexport default abstract class IFormat {\r\n\r\n  public type: AVFormat = AVFormat.UNKNOWN\r\n\r\n  public onStreamAdd: (stream: Stream) => void\r\n\r\n  public abstract init(formatContext: AVIFormatContext): void\r\n\r\n  public destroy(formatContext: AVIFormatContext): void {}\r\n\r\n  public abstract getAnalyzeStreamsCount(): number\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readHeader(formatContext: AVIFormatContext): Promise<number>\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number>\r\n\r\n  /**\r\n   * seek\r\n   * \r\n   * @param context \r\n   * @param stream \r\n   * @param timestamp 毫秒时间戳\r\n   * @param flags \r\n   * \r\n   * @returns 返回 seek 之前的下一个 avpacket pos（若不知道返回 0n 方便之后可以再 seek 回来）返回负数表示 seek 失败\r\n   */\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract seek(\r\n    formatContext: AVIFormatContext,\r\n    stream: Stream,\r\n    timestamp: int64,\r\n    flags: int32\r\n  ): Promise<int64>\r\n}\r\n","/*\r\n * libmedia vvc decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket, { AVPacketFlags } from 'avutil/struct/avpacket'\r\nimport { AVCodecID, AVMediaType } from 'avutil/codec'\r\nimport { IOError } from 'common/io/error'\r\nimport * as errorType from 'avutil/error'\r\nimport IFormat from './IFormat'\r\nimport { AVFormat } from '../avformat'\r\nimport { memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport { avMalloc } from 'avutil/util/mem'\r\nimport { addAVPacketData, createAVPacket, destroyAVPacket, refAVPacket } from 'avutil/util/avpacket'\r\nimport AVStream from '../AVStream'\r\nimport { Rational } from 'avutil/struct/rational'\r\nimport * as object from 'common/util/object'\r\nimport concatTypeArray from 'common/function/concatTypeArray'\r\nimport * as vvc from '../codecs/vvc'\r\nimport { AV_TIME_BASE } from 'avutil/constant'\r\nimport BitReader from 'common/io/BitReader'\r\nimport * as expgolomb from 'avutil/util/expgolomb'\r\nimport NaluReader from './nalu/NaluReader'\r\nimport { BitFormat } from '../codecs/h264'\r\n\r\nexport interface IVvcFormatOptions {\r\n  framerate?: Rational\r\n}\r\n\r\nconst DefaultIVvcFormatOptions: IVvcFormatOptions = {\r\n  framerate: {\r\n    num: 30,\r\n    den: 1\r\n  }\r\n}\r\n\r\nexport default class IHevcFormat extends IFormat {\r\n\r\n  public type: AVFormat = AVFormat.HEVC\r\n\r\n  private options: IVvcFormatOptions\r\n\r\n  private currentDts: int64\r\n  private currentPts: int64\r\n  private step: int64\r\n\r\n  private slices: Uint8Array[]\r\n  private naluPos: int64\r\n\r\n  private queue: { avpacket: pointer<AVPacket>, poc: int32 }[]\r\n  private bitReader: BitReader\r\n\r\n  private sliceType: vvc.VVCSliceType\r\n  private naluType: vvc.VVCNaluType\r\n  private poc: int32\r\n\r\n  private pocTid0: int32\r\n\r\n  private sps: vvc.VvcSPS\r\n\r\n  private naluReader: NaluReader\r\n\r\n  constructor(options: IVvcFormatOptions = {}) {\r\n    super()\r\n    this.options = object.extend({}, DefaultIVvcFormatOptions, options)\r\n  }\r\n\r\n  public init(formatContext: AVIFormatContext): void {\r\n\r\n    if (formatContext.ioReader) {\r\n      formatContext.ioReader.setEndian(false)\r\n    }\r\n\r\n    this.slices = []\r\n\r\n    this.queue = []\r\n    this.bitReader = new BitReader(500)\r\n    this.naluReader = new NaluReader()\r\n  }\r\n\r\n  public destroy(formatContext: AVIFormatContext): void {\r\n    if (this.queue.length) {\r\n      for (let i = 0; i < this.queue.length; i++) {\r\n        destroyAVPacket(this.queue[i].avpacket)\r\n      }\r\n      this.queue.length = 0\r\n    }\r\n  }\r\n\r\n  private isFrameNalu(data: Uint8Array) {\r\n    const type = (data[(data[2] === 1 ? 4 : 5)] >>> 3) & 0x1f\r\n    return type < vvc.VVCNaluType.kOPI_NUT\r\n  }\r\n\r\n  @deasync\r\n  private async readNaluFrame(formatContext: AVIFormatContext) {\r\n\r\n    let hasFrame = false\r\n\r\n    const nalus: Uint8Array[] = this.slices\r\n    this.slices = []\r\n\r\n    if (nalus.length) {\r\n      hasFrame = this.isFrameNalu(nalus[0])\r\n    }\r\n\r\n    while (true) {\r\n      const next = await this.naluReader.read(formatContext.ioReader)\r\n      if (!next) {\r\n        return nalus\r\n      }\r\n\r\n      const type = (next[(next[2] === 1 ? 4 : 5)] >>> 3) & 0x1f\r\n\r\n      if (this.isFrameNalu(next)) {\r\n        if (hasFrame) {\r\n          const hasPh = next[next[2] === 1 ? 5 : 6] >>> 7\r\n          if (hasPh) {\r\n            this.slices.push(next)\r\n            return nalus\r\n          }\r\n          else {\r\n            nalus.push(next)\r\n          }\r\n        }\r\n        else {\r\n          nalus.push(next)\r\n          hasFrame = true\r\n        }\r\n      }\r\n      else if (hasFrame\r\n        && (type === vvc.VVCNaluType.kAUD_NUT\r\n          || type === vvc.VVCNaluType.kPH_NUT\r\n          || type === vvc.VVCNaluType.kSPS_NUT\r\n          || type === vvc.VVCNaluType.kVPS_NUT\r\n          || type === vvc.VVCNaluType.kPPS_NUT\r\n          || type === vvc.VVCNaluType.kOPI_NUT\r\n          || type === vvc.VVCNaluType.kDCI_NUT\r\n        )\r\n      ) {\r\n        this.slices.push(next)\r\n        return nalus\r\n      }\r\n      else {\r\n        nalus.push(next)\r\n      }\r\n    }\r\n  }\r\n\r\n  public async readHeader(formatContext: AVIFormatContext): Promise<number> {\r\n    const stream = formatContext.createStream()\r\n    stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_VIDEO\r\n    stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_VVC\r\n    stream.timeBase.den = AV_TIME_BASE\r\n    stream.timeBase.num = 1\r\n    stream.codecpar.bitFormat = BitFormat.ANNEXB\r\n    this.currentDts = 0n\r\n    this.currentPts = 0n\r\n    this.naluPos = 0n\r\n    this.poc = 0\r\n    this.pocTid0 = 0\r\n    this.step = static_cast<int64>((AV_TIME_BASE / this.options.framerate.num * this.options.framerate.den) as double)\r\n\r\n    while (true) {\r\n      const slices = await this.readNaluFrame(formatContext)\r\n\r\n      if (!slices.length) {\r\n        return IOError.END\r\n      }\r\n\r\n      const data = concatTypeArray(Uint8Array, slices)\r\n\r\n      const extradata = concatTypeArray(Uint8Array, slices.filter((n) => {\r\n        const type = (n[(n[2] === 1 ? 4 : 5)] >>> 3) & 0x1f\r\n        return type === vvc.VVCNaluType.kVPS_NUT\r\n          || type === vvc.VVCNaluType.kSPS_NUT\r\n          || type === vvc.VVCNaluType.kPPS_NUT\r\n      }))\r\n\r\n      if (extradata) {\r\n        stream.codecpar.extradata = avMalloc(extradata.length)\r\n        memcpyFromUint8Array(stream.codecpar.extradata, extradata.length, extradata)\r\n        stream.codecpar.extradataSize = extradata.length\r\n\r\n        const sps = slices.find((n) => {\r\n          const type = (n[(n[2] === 1 ? 4 : 5)] >>> 3) & 0x1f\r\n          return type === vvc.VVCNaluType.kSPS_NUT\r\n        })\r\n        vvc.parseAVCodecParametersBySps(stream, sps)\r\n        this.sps = vvc.parseSPS(sps)\r\n\r\n        const avpacket = createAVPacket()\r\n\r\n        const dataP = avMalloc(data.length)\r\n        memcpyFromUint8Array(dataP, data.length, data)\r\n        addAVPacketData(avpacket, dataP, data.length)\r\n\r\n        avpacket.pos = this.naluPos\r\n        this.naluPos += static_cast<int64>(data.length)\r\n\r\n        avpacket.dts = this.currentDts\r\n        this.currentDts += this.step\r\n        avpacket.pts = this.currentPts\r\n        this.currentPts += this.step\r\n\r\n        avpacket.streamIndex = stream.index\r\n        avpacket.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n        avpacket.timeBase.num = stream.timeBase.num\r\n        avpacket.timeBase.den = stream.timeBase.den\r\n        avpacket.bitFormat = BitFormat.ANNEXB\r\n\r\n        formatContext.interval.packetBuffer.push(avpacket)\r\n\r\n        break\r\n      }\r\n\r\n      this.naluPos += static_cast<int64>(data.length)\r\n    }\r\n\r\n    return 0\r\n  }\r\n\r\n  private computePoc(naluType: vvc.VVCNaluType, temporalId: number, ph: Uint8Array, sliceHeader: boolean) {\r\n    /* eslint-disable camelcase */\r\n    this.bitReader.reset()\r\n    this.bitReader.appendBuffer(ph.subarray(0, 500))\r\n\r\n    if (sliceHeader) {\r\n      // sh_picture_header_in_slice_header_flag\r\n      this.bitReader.readU1()\r\n    }\r\n    const ph_gdr_or_irap_pic_flag = this.bitReader.readU1()\r\n    const ph_non_ref_pic_flag = this.bitReader.readU1()\r\n    let ph_gdr_pic_flag = 0\r\n    if (ph_gdr_or_irap_pic_flag) {\r\n      ph_gdr_pic_flag = this.bitReader.readU1()\r\n    }\r\n    const ph_inter_slice_allowed_flag = this.bitReader.readU1()\r\n    if (ph_inter_slice_allowed_flag) {\r\n      // ph_intra_slice_allowed_flag\r\n      this.bitReader.readU1()\r\n    }\r\n    // ph_pic_parameter_set_id\r\n    expgolomb.readUE(this.bitReader)\r\n    const poc_lsb = this.bitReader.readU(this.sps.sps_log2_max_pic_order_cnt_lsb_minus4 + 4)\r\n    if (ph_gdr_pic_flag) {\r\n      // ph_recovery_poc_cnt\r\n      expgolomb.readUE(this.bitReader)\r\n    }\r\n    for (let i = 0; i < this.sps.sps_num_extra_ph_bytes * 8; i++) {\r\n      if (this.sps.sps_extra_ph_bit_present_flag[i]) {\r\n        this.bitReader.readU1()\r\n      }\r\n    }\r\n    let ph_poc_msb_cycle_val = 0\r\n    let ph_poc_msb_cycle_present_flag = 0\r\n    if (this.sps.sps_poc_msb_cycle_flag) {\r\n      ph_poc_msb_cycle_present_flag = this.bitReader.readU1()\r\n      if (ph_poc_msb_cycle_present_flag) {\r\n        ph_poc_msb_cycle_val = this.bitReader.readU(this.sps.sps_poc_msb_cycle_len_minus1 + 1)\r\n      }\r\n    }\r\n\r\n    const max_poc_lsb = 1 << (this.sps.sps_log2_max_pic_order_cnt_lsb_minus4 + 4)\r\n    let poc_msb = 0\r\n    if (naluType === vvc.VVCNaluType.kIDR_N_LP\r\n      || naluType === vvc.VVCNaluType.kIDR_W_RADL\r\n    ) {\r\n      if (ph_poc_msb_cycle_present_flag) {\r\n        poc_msb = ph_poc_msb_cycle_val * max_poc_lsb\r\n      }\r\n      else {\r\n        poc_msb = 0\r\n      }\r\n    }\r\n    else {\r\n      const prev_poc = this.pocTid0\r\n      const prev_poc_lsb = prev_poc & (max_poc_lsb - 1)\r\n      const prev_poc_msb = prev_poc - prev_poc_lsb\r\n      if (ph_poc_msb_cycle_present_flag) {\r\n        poc_msb = ph_poc_msb_cycle_val * max_poc_lsb\r\n      }\r\n      else {\r\n        if ((poc_lsb < prev_poc_lsb)\r\n          && ((prev_poc_lsb - poc_lsb) >= (max_poc_lsb / 2))\r\n        ) {\r\n          poc_msb = prev_poc_msb + max_poc_lsb\r\n        }\r\n        else if ((poc_lsb > prev_poc_lsb)\r\n          && ((poc_lsb - prev_poc_lsb) > (max_poc_lsb / 2))\r\n        ) {\r\n          poc_msb = prev_poc_msb - max_poc_lsb\r\n        }\r\n        else {\r\n          poc_msb = prev_poc_msb\r\n        }\r\n      }\r\n    }\r\n    this.poc = poc_msb + poc_lsb\r\n\r\n    if (temporalId == 0\r\n      && !ph_non_ref_pic_flag\r\n      && naluType !== vvc.VVCNaluType.kRADL_NUT\r\n      && naluType !== vvc.VVCNaluType.kRASL_NUT\r\n    ) {\r\n      this.pocTid0 = this.poc\r\n    }\r\n    /* eslint-enable camelcase */\r\n  }\r\n\r\n  @deasync\r\n  private async readAVPacket_(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number> {\r\n\r\n    const stream = formatContext.getStreamByMediaType(AVMediaType.AVMEDIA_TYPE_VIDEO)\r\n\r\n    const nalus = await this.readNaluFrame(formatContext)\r\n\r\n    if (!nalus.length) {\r\n      return IOError.END\r\n    }\r\n\r\n    this.sliceType = vvc.VVCSliceType.kSliceNone\r\n    let isKey = false\r\n    let isFirst = true\r\n\r\n    nalus.forEach((n) => {\r\n      const header = n[2] === 1 ? n[4] : n[5]\r\n      const type = (header >>> 3) & 0x1f\r\n      const temporalId = (header & 0x07) - 1\r\n\r\n      if (type === vvc.VVCNaluType.kSPS_NUT) {\r\n        this.sps = vvc.parseSPS(n)\r\n      }\r\n\r\n      if (type === vvc.VVCNaluType.kIDR_N_LP\r\n        || type === vvc.VVCNaluType.kIDR_W_RADL\r\n      ) {\r\n        isKey = true\r\n      }\r\n\r\n      if (type === vvc.VVCNaluType.kPH_NUT) {\r\n        this.computePoc(type, temporalId, n.subarray(n[2] === 1 ? 5 : 6), false)\r\n      }\r\n\r\n      if (type < vvc.VVCNaluType.kVPS_NUT && isFirst) {\r\n        isFirst = false\r\n        this.naluType = type\r\n        const hasPh = n[n[2] === 1 ? 5 : 6] >>> 7\r\n        if (hasPh) {\r\n          this.computePoc(type, temporalId, n.subarray(n[2] === 1 ? 5 : 6), true)\r\n        }\r\n      }\r\n    })\r\n\r\n    const data = concatTypeArray(Uint8Array, nalus)\r\n\r\n    const dataP = avMalloc(data.length)\r\n    memcpyFromUint8Array(dataP, data.length, data)\r\n    addAVPacketData(avpacket, dataP, data.length)\r\n\r\n    avpacket.pos = this.naluPos\r\n    this.naluPos += static_cast<int64>(data.length)\r\n    avpacket.dts = this.currentDts\r\n    this.currentDts += this.step\r\n    avpacket.streamIndex = stream.index\r\n    avpacket.timeBase.num = stream.timeBase.num\r\n    avpacket.timeBase.den = stream.timeBase.den\r\n    avpacket.bitFormat = BitFormat.ANNEXB\r\n\r\n    if (isKey) {\r\n      avpacket.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n    }\r\n\r\n    return 0\r\n  }\r\n\r\n  public async readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number> {\r\n\r\n    let ipFrameCount = this.queue.length\r\n\r\n    const output = () => {\r\n\r\n      if (this.queue.length > 1) {\r\n        this.queue.sort((a, b) => {\r\n          return a.poc - b.poc > 0 ? 1 : -1\r\n        })\r\n      }\r\n\r\n      for (let i = 0; i < this.queue.length; i++) {\r\n        this.queue[i].avpacket.pts = this.currentPts\r\n        this.currentPts += this.step\r\n      }\r\n      if (this.queue.length > 1) {\r\n        this.queue.sort((a, b) => {\r\n          return a.avpacket.dts - b.avpacket.dts > 0n ? 1 : -1\r\n        })\r\n      }\r\n      if (this.queue.length) {\r\n        refAVPacket(avpacket, this.queue[0].avpacket)\r\n        destroyAVPacket(this.queue[0].avpacket)\r\n      }\r\n      for (let i = 1; i < this.queue.length; i++) {\r\n        formatContext.interval.packetBuffer.push(this.queue[i].avpacket)\r\n      }\r\n      this.queue.length = 0\r\n    }\r\n\r\n    while (true) {\r\n      const next = createAVPacket()\r\n      let ret = await this.readAVPacket_(formatContext, next)\r\n      if (ret < 0) {\r\n        destroyAVPacket(next)\r\n        if (this.queue.length) {\r\n          output()\r\n          return 0\r\n        }\r\n        else {\r\n          return ret\r\n        }\r\n      }\r\n      if ((next.flags & AVPacketFlags.AV_PKT_FLAG_KEY)\r\n        || this.naluType === vvc.VVCNaluType.kCRA_NUT\r\n        || (this.sliceType === vvc.VVCSliceType.kSliceP\r\n          || this.sliceType === vvc.VVCSliceType.kSliceI\r\n        )\r\n      ) {\r\n        if (ipFrameCount === 1\r\n          || (this.naluType === vvc.VVCNaluType.kCRA_NUT\r\n              || (next.flags & AVPacketFlags.AV_PKT_FLAG_KEY)\r\n          )\r\n            && this.queue.length\r\n        ) {\r\n          output()\r\n          this.queue.push({\r\n            avpacket: next,\r\n            poc: this.poc\r\n          })\r\n          return 0\r\n        }\r\n        else {\r\n          this.queue.push({\r\n            avpacket: next,\r\n            poc: this.poc\r\n          })\r\n          ipFrameCount++\r\n        }\r\n      }\r\n      else {\r\n        this.queue.push({\r\n          avpacket: next,\r\n          poc: this.poc\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  public async seek(formatContext: AVIFormatContext, stream: AVStream, timestamp: int64, flags: int32): Promise<int64> {\r\n    return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n  }\r\n\r\n  public getAnalyzeStreamsCount(): number {\r\n    return 1\r\n  }\r\n\r\n}\r\n","/*\r\n * libmedia NaluReader\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport * as nalu from 'avutil/util/nalu'\r\nimport concatTypeArray from 'common/function/concatTypeArray'\r\n\r\nexport default class NaluReader {\r\n\r\n  private buffer: Uint8Array\r\n  private pos: int32\r\n  private end: int32\r\n  private ended: boolean\r\n\r\n  constructor() {\r\n    this.buffer = new Uint8Array(100 * 1024)\r\n    this.pos = 0\r\n    this.end = 0\r\n    this.ended = false\r\n  }\r\n\r\n  @deasync\r\n  public async read(ioReader: IOReader) {\r\n    if (this.ended && this.pos >= this.end) {\r\n      return\r\n    }\r\n\r\n    const slices: Uint8Array[] = []\r\n\r\n    if (this.pos < this.end - 4) {\r\n      let next = nalu.getNextNaluStart(this.buffer.subarray(this.pos, this.end - 4), 3)\r\n      if (next.offset > -1) {\r\n        const nalu = this.buffer.slice(this.pos, this.pos + next.offset)\r\n        this.pos += next.offset\r\n        return nalu\r\n      }\r\n      else {\r\n        slices.push(this.buffer.slice(this.pos, this.end - 4))\r\n        this.buffer.copyWithin(0, this.end - 4, this.end)\r\n        this.pos = 0\r\n        this.end = 4\r\n      }\r\n    }\r\n\r\n    while (true) {\r\n      if (!this.ended && this.end < this.buffer.length) {\r\n        try {\r\n          const len = await ioReader.readToBuffer(this.buffer.length - this.end, this.buffer.subarray(this.end))\r\n          this.end += len\r\n        }\r\n        catch (error) {\r\n          this.ended = true\r\n          if (this.pos >= this.end) {\r\n            return slices.length ? concatTypeArray(Uint8Array, slices) : null\r\n          }\r\n        }\r\n      }\r\n\r\n      let next = nalu.getNextNaluStart(this.buffer.subarray(this.pos, this.end - 4), slices.length ? 0 : 3)\r\n\r\n      if (next.offset > -1) {\r\n        slices.push(this.buffer.slice(this.pos, this.pos + next.offset))\r\n        this.pos += next.offset\r\n        return concatTypeArray(Uint8Array, slices)\r\n      }\r\n      else {\r\n        if (this.ended) {\r\n          slices.push(this.buffer.slice(this.pos, this.end))\r\n          this.pos = this.end = 0\r\n          return concatTypeArray(Uint8Array, slices)\r\n        }\r\n        else {\r\n          slices.push(this.buffer.slice(this.pos, this.end - 4))\r\n          this.buffer.copyWithin(0, this.end - 4, this.end)\r\n          this.pos = 0\r\n          this.end = 4\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public reset() {\r\n    this.pos = 0\r\n    this.end = 0\r\n    this.ended = false\r\n  }\r\n}\r\n"],"names":[],"sourceRoot":""}
{"version":3,"file":"src_avformat_formats_OIvfFormat_ts.avtranscoder.js","mappings":"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","sources":["webpack://AVTranscoder/./src/avformat/formats/OIvfFormat.ts"],"sourcesContent":["/*\r\n * libmedia lvf encoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { AVOFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport OFormat from './OFormat'\r\nimport { AVMediaType } from 'avutil/codec'\r\nimport { AVFormat } from '../avformat'\r\nimport * as logger from 'common/util/logger'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { getAVPacketData } from 'avutil/util/avpacket'\r\n\r\nexport const enum IVFCodec {\r\n  VP8 = 'VP80',\r\n  VP9 = 'VP90'\r\n}\r\n\r\nexport class IVFHeader {\r\n  // version (should be 0)\r\n  public version: number\r\n  // length of header in bytes\r\n  public length: number\r\n  // FourCC (e.g., 'VP80')\r\n  public codec: IVFCodec\r\n  // width in pixels\r\n  public width: number\r\n  // height in pixels\r\n  public height: number\r\n  // denominator\r\n  public denominator: number\r\n  // numerator\r\n  public numerator: number\r\n  // number of frames in file\r\n  public framesCount: number\r\n\r\n  constructor() {\r\n    this.version = 0\r\n    this.length = 32\r\n    this.codec = IVFCodec.VP8\r\n    this.width = 0\r\n    this.height = 0\r\n    this.framesCount = 0\r\n    this.denominator = 1\r\n    this.numerator = 0\r\n  }\r\n}\r\n\r\nexport default class OIVFFormat extends OFormat {\r\n\r\n  public type: AVFormat = AVFormat.IVF\r\n\r\n  public header: IVFHeader\r\n\r\n  constructor() {\r\n    super()\r\n\r\n    this.header = new IVFHeader()\r\n  }\r\n\r\n  public init(formatContext: AVOFormatContext): number {\r\n    formatContext.ioWriter.setEndian(false)\r\n    const stream = formatContext.getStreamByMediaType(AVMediaType.AVMEDIA_TYPE_VIDEO)\r\n    if (stream) {\r\n      this.header.width = stream.codecpar.width\r\n      this.header.height = stream.codecpar.height\r\n      this.header.numerator = stream.timeBase.num\r\n      this.header.denominator = stream.timeBase.den\r\n    }\r\n    return 0\r\n  }\r\n\r\n  public writeHeader(formatContext: AVOFormatContext): number {\r\n    // byte 0-3 signature: 'DKIF'\r\n    formatContext.ioWriter.writeString('DKIF')\r\n    // byte 4-5 version (should be 0)\r\n    formatContext.ioWriter.writeUint16(this.header.version)\r\n    // byte 6-7 length of header in bytes\r\n    formatContext.ioWriter.writeUint16(32)\r\n    // bytes 8-11 codec FourCC (e.g., 'VP80')\r\n    formatContext.ioWriter.writeString(this.header.codec)\r\n    // bytes 12-13 width in pixels\r\n    formatContext.ioWriter.writeUint16(this.header.width)\r\n    // bytes 14-15 height in pixels\r\n    formatContext.ioWriter.writeUint16(this.header.height)\r\n    // bytes 16-19 denominator\r\n    formatContext.ioWriter.writeUint32(this.header.denominator)\r\n    // bytes 19-23 numerator\r\n    formatContext.ioWriter.writeUint32(this.header.numerator)\r\n    // bytes 24-27 number of frames in file\r\n    formatContext.ioWriter.writeUint32(this.header.framesCount)\r\n    // bytes 28-31 unused\r\n    formatContext.ioWriter.writeUint32(0)\r\n\r\n    return 0\r\n  }\r\n  public writeAVPacket(formatContext: AVOFormatContext, avpacket: pointer<AVPacket>): number {\r\n    if (!avpacket.size) {\r\n      logger.warn(`packet\\'s size is 0: ${avpacket.streamIndex}, ignore it`)\r\n      return\r\n    }\r\n\r\n    const stream = formatContext.getStreamByIndex(avpacket.streamIndex)\r\n\r\n    if (!stream) {\r\n      logger.warn(`can not found the stream width the packet\\'s streamIndex: ${avpacket.streamIndex}, ignore it`)\r\n      return\r\n    }\r\n\r\n    if (stream.codecpar.codecType === AVMediaType.AVMEDIA_TYPE_VIDEO) {\r\n      const stream = formatContext.getStreamByMediaType(AVMediaType.AVMEDIA_TYPE_VIDEO)\r\n      if (stream) {\r\n        formatContext.ioWriter.writeUint32(avpacket.size)\r\n        formatContext.ioWriter.writeUint64(avRescaleQ(avpacket.pts || avpacket.dts, avpacket.timeBase, stream.timeBase))\r\n        formatContext.ioWriter.writeBuffer(getAVPacketData(avpacket))\r\n        this.header.framesCount++\r\n      }\r\n    }\r\n\r\n    return 0\r\n  }\r\n\r\n  public writeTrailer(formatContext: AVOFormatContext): number {\r\n    formatContext.ioWriter.seek(24n)\r\n    // 更新 framesCount\r\n    formatContext.ioWriter.writeUint32(this.header.framesCount)\r\n\r\n    formatContext.ioWriter.flush()\r\n\r\n    return 0\r\n  }\r\n\r\n  public flush(formatContext: AVOFormatContext): number {\r\n    formatContext.ioWriter.flush()\r\n    return 0\r\n  }\r\n\r\n}\r\n"],"names":[],"sourceRoot":""}
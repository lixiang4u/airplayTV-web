{"version":3,"file":"src_avformat_formats_ITtmlFormat_ts.avtranscoder.js","mappings":"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","sources":["webpack://AVTranscoder/./src/avformat/formats/IFormat.ts","webpack://AVTranscoder/./src/avformat/formats/ITtmlFormat.ts","webpack://AVTranscoder/./src/avformat/formats/ttml/ittml.ts","webpack://AVTranscoder/./src/common/util/time.ts","webpack://AVTranscoder/./src/common/util/xml2Json.ts"],"sourcesContent":["/*\r\n * libmedia abstract format decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVFormat } from '../avformat'\r\n\r\nexport default abstract class IFormat {\r\n\r\n  public type: AVFormat = AVFormat.UNKNOWN\r\n\r\n  public onStreamAdd: (stream: Stream) => void\r\n  \r\n  public abstract init(formatContext: AVIFormatContext): void\r\n\r\n  public destroy(formatContext: AVIFormatContext): void {}\r\n\r\n  public abstract getAnalyzeStreamsCount(): number\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readHeader(formatContext: AVIFormatContext): Promise<number>\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number>\r\n\r\n  /**\r\n   * seek\r\n   * \r\n   * @param context \r\n   * @param stream \r\n   * @param timestamp 毫秒时间戳\r\n   * @param flags \r\n   * \r\n   * @returns 返回 seek 之前的下一个 avpacket pos（若不知道返回 0n 方便之后可以再 seek 回来）返回负数表示 seek 失败\r\n   */\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract seek(\r\n    formatContext: AVIFormatContext,\r\n    stream: Stream,\r\n    timestamp: int64,\r\n    flags: int32\r\n  ): Promise<int64>\r\n}\r\n","/*\r\n * libmedia subrip decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVStream from '../AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVCodecID, AVMediaType } from 'avutil/codec'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\nimport IFormat from './IFormat'\r\nimport { AVFormat, AVSeekFlags } from '../avformat'\r\nimport { memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport { avMalloc } from 'avutil/util/mem'\r\nimport { addAVPacketData } from 'avutil/util/avpacket'\r\nimport { IOError } from 'common/io/error'\r\nimport * as array from 'common/util/array'\r\nimport * as text from 'common/util/text'\r\nimport * as ittml from './ttml/ittml'\r\nimport { IOFlags } from 'common/io/flags'\r\n\r\nexport default class ITtmlFormat extends IFormat {\r\n\r\n  public type: AVFormat = AVFormat.TTML\r\n\r\n  private queue: {\r\n    pts: int64\r\n    duration: int64\r\n    context: string\r\n    region: string\r\n  }[]\r\n  private index: int32\r\n\r\n  constructor() {\r\n    super()\r\n  }\r\n\r\n  public init(formatContext: AVIFormatContext): void {\r\n    this.queue = []\r\n  }\r\n\r\n  public async readHeader(formatContext: AVIFormatContext): Promise<number> {\r\n    const stream = formatContext.createStream()\r\n    stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_TTML\r\n    stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_SUBTITLE\r\n    stream.timeBase.den = 1000\r\n    stream.timeBase.num = 1\r\n\r\n    let xml = ''\r\n\r\n    if (formatContext.ioReader.flags & IOFlags.SEEKABLE) {\r\n      const fileSize = await formatContext.ioReader.fileSize()\r\n      xml = await formatContext.ioReader.readString(static_cast<int32>(fileSize))\r\n    }\r\n    else {\r\n      try {\r\n        xml += await formatContext.ioReader.readLine() + '\\n'\r\n      }\r\n      catch (e) {}\r\n    }\r\n\r\n    if (text) {\r\n      const result = ittml.parse(xml)\r\n      this.queue = result.queue\r\n      if (result.head) {\r\n        const header = JSON.stringify(result.head)\r\n        const data = text.encode(header)\r\n        stream.codecpar.extradata = avMalloc(data.length)\r\n        memcpyFromUint8Array(stream.codecpar.extradata, data.length, data)\r\n        stream.codecpar.extradataSize = data.length\r\n      }\r\n    }\r\n    this.index = 0\r\n    return 0\r\n  }\r\n\r\n  public async readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number> {\r\n\r\n    if (!this.queue.length) {\r\n      return errorType.DATA_INVALID\r\n    }\r\n    if (this.index >= this.queue.length) {\r\n      return IOError.END\r\n    }\r\n\r\n    const stream = formatContext.streams.find((stream) => {\r\n      return stream.codecpar.codecType === AVMediaType.AVMEDIA_TYPE_SUBTITLE\r\n    })\r\n\r\n    const cue = this.queue[this.index++]\r\n\r\n    avpacket.streamIndex = stream.index\r\n    avpacket.timeBase.den = stream.timeBase.den\r\n    avpacket.timeBase.num = stream.timeBase.num\r\n\r\n    avpacket.dts = avpacket.pts = cue.pts\r\n    avpacket.duration = cue.duration\r\n\r\n    const buffer = text.encode(cue.context)\r\n    const data = avMalloc(buffer.length)\r\n    memcpyFromUint8Array(data, buffer.length, buffer)\r\n    addAVPacketData(avpacket, data, buffer.length)\r\n\r\n    return 0\r\n  }\r\n\r\n  public async seek(formatContext: AVIFormatContext, stream: AVStream, timestamp: int64, flags: int32): Promise<int64> {\r\n    if (flags & AVSeekFlags.BYTE) {\r\n      return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n    }\r\n    if (timestamp <= 0n) {\r\n      this.index = 0\r\n      return 0n\r\n    }\r\n    const index = array.binarySearch(this.queue, (item) => {\r\n      if (item.pts > timestamp) {\r\n        return -1\r\n      }\r\n      return 1\r\n    })\r\n    if (index >= 0) {\r\n      logger.debug(`seek in cues, found index: ${index}, pts: ${this.queue[index].pts}`)\r\n      this.index = Math.max(index - 1, 0)\r\n      while (this.index > 0) {\r\n        if (this.queue[this.index - 1].pts === this.queue[this.index].pts) {\r\n          this.index--\r\n        }\r\n        else {\r\n          break\r\n        }\r\n      }\r\n      return 0n\r\n    }\r\n    return static_cast<int64>(errorType.DATA_INVALID)\r\n  }\r\n\r\n  public getAnalyzeStreamsCount(): number {\r\n    return 1\r\n  }\r\n}\r\n","\r\nimport xml2Json from 'common/util/xml2Json'\r\nimport * as is from 'common/util/is'\r\nimport * as array from 'common/util/array'\r\nimport { hhColonDDColonSSDotMill2Int64 } from 'common/util/time'\r\n\r\ninterface P {\r\n  begin: string\r\n  end?: string\r\n  dur?: string\r\n  context: string | (string | { tagName: string, context?: string } )[]\r\n  region?: string\r\n  span?: {\r\n    context: string | (string | { tagName: string, context?: string } )[]\r\n    region?: string\r\n  }\r\n}\r\n\r\nexport function parse(text: string) {\r\n  const xml = xml2Json(text, {\r\n    aloneValueName: 'context'\r\n  })\r\n\r\n  if (!xml.tt) {\r\n    return {\r\n      queue: [],\r\n      head: {}\r\n    }\r\n  }\r\n\r\n  const queue: {\r\n    pts: int64\r\n    duration: int64\r\n    context: string\r\n    region: string\r\n  }[] = []\r\n\r\n  function formatContext(list: (string | { tagName: string, context?: string } )[]) {\r\n    let context = ''\r\n    array.each(list, ((c) => {\r\n      if (is.string(c)) {\r\n        context += c\r\n      }\r\n      else {\r\n        if (c.context) {\r\n          context += `<${c.tagName}>${c.context}</${c.tagName}>`\r\n        }\r\n        else {\r\n          context += `<${c.tagName}/>`\r\n        }\r\n      }\r\n    }))\r\n    return context\r\n  }\r\n\r\n  function add(p: P, start: string, end: string) {\r\n    const pts = hhColonDDColonSSDotMill2Int64(start || p.begin)\r\n  \r\n    let context = p.context || ''\r\n    let region = p.region || 'Default'\r\n\r\n    if (is.array(context)) {\r\n      context = formatContext(context)\r\n    }\r\n    if (p.span?.context) {\r\n      if (p.span.region) {\r\n        region = p.span.region\r\n      }\r\n      if (is.string(p.span.context)) {\r\n        context += p.span.context\r\n      }\r\n      else {\r\n        context += formatContext(p.span.context)\r\n      }\r\n    }\r\n    queue.push({\r\n      context,\r\n      pts,\r\n      region: region,\r\n      duration: p.dur ? hhColonDDColonSSDotMill2Int64(p.dur) : (hhColonDDColonSSDotMill2Int64(end || p.end) - pts),\r\n    })\r\n  }\r\n\r\n  function praseP(p: P | P[], start: string, end: string) {\r\n    if (is.array(p)) {\r\n      array.each(p, (_) => {\r\n        add(_, start, end)\r\n      })\r\n    }\r\n    else {\r\n      add(p, start, end)\r\n    }\r\n  }\r\n\r\n  if (xml.tt.body) {\r\n    if (xml.tt.body.div) {\r\n      if (is.array(xml.tt.body.div)) {\r\n        array.each(xml.tt.body.div, (div: any) => {\r\n          if (div.p) {\r\n            praseP(div.p, div.begin, div.end)\r\n          }\r\n        })\r\n      }\r\n      else {\r\n        if (xml.tt.body.div.p) {\r\n          praseP(xml.tt.body.div.p, xml.tt.body.div.begin, xml.tt.body.end)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return {\r\n    queue,\r\n    head: xml.tt.head || {}\r\n  }\r\n}","\r\nexport function hhColonDDColonSSDotMill2Int64(time: string) {\r\n  time = time.trim()\r\n\r\n  if (!time) {\r\n    return -1n\r\n  }\r\n\r\n  let list = time.split(':')\r\n\r\n  let ts = 0n\r\n\r\n  if (list.length === 3) {\r\n    ts += BigInt(+(list.shift().trim())) * 3600000n\r\n  }\r\n  ts += BigInt(+(list.shift().trim())) * 60000n\r\n\r\n  list = list.shift().trim().split('.')\r\n  ts += BigInt(+(list.shift().trim())) * 1000n\r\n  ts += BigInt(+(list.shift().trim()))\r\n\r\n  return ts\r\n}\r\n\r\nexport function hhColonDDColonSSCommaMill2Int64(time: string) {\r\n  time = time.trim()\r\n\r\n  if (!time) {\r\n    return -1n\r\n  }\r\n\r\n  let list = time.split(':')\r\n\r\n  let ts = 0n\r\n\r\n  if (list.length === 3) {\r\n    ts += BigInt(+(list.shift().trim())) * 3600000n\r\n  }\r\n  ts += BigInt(+(list.shift().trim())) * 60000n\r\n\r\n  list = list.shift().trim().split(',')\r\n  ts += BigInt(+(list.shift().trim())) * 1000n\r\n  ts += BigInt(+(list.shift().trim()))\r\n\r\n  return ts\r\n}","import * as array from './array'\r\n\r\ntype Options = {\r\n  aloneValueName?: string\r\n}\r\n\r\nconst defaultOptions: Options = {\r\n  aloneValueName: '_@attribute'\r\n}\r\n\r\ninterface StackItem {\r\n  obj: Record<string, any>\r\n  tag: string\r\n  start: number\r\n}\r\n\r\nconst splitChar = [' ', '/', '\"', '\\'', '<', '>']\r\n\r\nexport default function xml2Json(xmlStr: string, options = defaultOptions) {\r\n  // remove commented lines\r\n  xmlStr = xmlStr.replace(/<!--[\\s\\S]*?-->/g, '')\r\n  // replace special characters\r\n  xmlStr = xmlStr.replace(/[\\n\\t\\r]/g, '')\r\n  // replace leading spaces and tabs between elements\r\n  xmlStr = xmlStr.replace(/>[ \\t]+</g, '><')\r\n  // delete docType tags\r\n  xmlStr = xmlStr.replace(/<\\?[^>]*\\?>/g, '')\r\n\r\n  const stack: StackItem[] = []\r\n  let pos = 0\r\n\r\n  function addData(key: string, value: any) {\r\n    const item = stack[stack.length - 1]\r\n\r\n    if (!item) {\r\n      return\r\n    }\r\n\r\n    if (key !== options.aloneValueName && item.obj[options.aloneValueName] != null) {\r\n      item.obj[options.aloneValueName] = [item.obj[options.aloneValueName], {\r\n        tagName: key,\r\n        ...value\r\n      }]\r\n      return\r\n    }\r\n    if (item.obj[key] == null) {\r\n      item.obj[key] = value\r\n    }\r\n    else if (Array.isArray(item.obj[key])) {\r\n      item.obj[key].push(value)\r\n    }\r\n    else {\r\n      item.obj[key] = [item.obj[key], value]\r\n    }\r\n  }\r\n\r\n  function gotoToken(token: string) {\r\n    while (pos < xmlStr.length) {\r\n      if (xmlStr[pos] === token) {\r\n        return true\r\n      }\r\n      pos++\r\n    }\r\n    return false\r\n  }\r\n\r\n  function readIdentity() {\r\n    skipSpace()\r\n    let key = ''\r\n    while (pos < xmlStr.length) {\r\n      if (array.has(splitChar, xmlStr[pos])) {\r\n        break\r\n      }\r\n      key += xmlStr[pos]\r\n      pos++\r\n    }\r\n    return key\r\n  }\r\n\r\n  function skipSpace() {\r\n    while (pos < xmlStr.length) {\r\n      if (!/\\s|\\r|\\n/.test(xmlStr[pos])) {\r\n        break\r\n      }\r\n      pos++\r\n    }\r\n  }\r\n\r\n  const emptyEndReg = /\\s/\r\n  const singleQuotation = /'/\r\n  const doubleQuotation = /\"/\r\n\r\n  function readAttrValue() {\r\n    if (pos >= xmlStr.length) {\r\n      return true\r\n    }\r\n    skipSpace()\r\n    // 默认属性值结束符为空格\r\n    let end = emptyEndReg\r\n    if (xmlStr[pos] === '\"' || xmlStr[pos] == '\\'') {\r\n      // 属性值是引号开始则结束符也是引号\r\n      end = xmlStr[pos] === '\"' ? doubleQuotation : singleQuotation\r\n      pos++\r\n    }\r\n    let value = ''\r\n    while (pos < xmlStr.length) {\r\n      if (end.test(xmlStr[pos])) {\r\n        pos++\r\n        break\r\n      }\r\n      value += xmlStr[pos]\r\n      pos++\r\n    }\r\n    return value\r\n  }\r\n\r\n  function readAttr() {\r\n    while (true) {\r\n      skipSpace()\r\n      // 判断标签属性结束\r\n      if (xmlStr[pos] === '>' || xmlStr[pos] === '/') {\r\n        break\r\n      }\r\n      let key = readIdentity()\r\n      if (!key) {\r\n        break\r\n      }\r\n      if (key[key.length - 1] === '=') {\r\n        key = key.substring(0, key.length - 1)\r\n      }\r\n      else {\r\n        gotoToken('=')\r\n        pos++\r\n      }\r\n      const value = readAttrValue()\r\n      addData(key, value)\r\n    }\r\n  }\r\n\r\n  // innerText 当前位置到 < 之前\r\n  function readText() {\r\n    skipSpace()\r\n    let text = ''\r\n    while (pos < xmlStr.length) {\r\n      if (xmlStr[pos] === '<') {\r\n        break\r\n      }\r\n      text += xmlStr[pos]\r\n      pos++\r\n    }\r\n    return text\r\n  }\r\n\r\n\r\n  function pop() {\r\n    // 处理 </> 跳出当前 tag\r\n    // 若是 <xx 则是子标签，进入下一次处理 \r\n    while (xmlStr[pos] === '<') {\r\n      const now = pos\r\n      pos++\r\n      skipSpace()\r\n      if (xmlStr[pos] === '/') {\r\n        pos++\r\n        const tag = readIdentity()\r\n        if (tag === stack[stack.length - 1].tag) {\r\n          if (stack.length > 1) {\r\n            const item = stack.pop()\r\n            addData(item.tag, item.obj)\r\n          }\r\n          gotoToken('>')\r\n          pos++\r\n          skipSpace()\r\n        }\r\n        else {\r\n          stack.pop()\r\n          gotoToken('>')\r\n          pos++\r\n          skipSpace()\r\n        }\r\n      }\r\n      else {\r\n        pos = now\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  function readTag() {\r\n    if (pos >= xmlStr.length) {\r\n      return\r\n    }\r\n\r\n    let start = pos\r\n    skipSpace()\r\n    // innerText 的后面部分，中间被标签分割出现这种情况，将其加入 context 中\r\n    if (xmlStr[pos] !== '<') {\r\n      pos = start\r\n      addData(options.aloneValueName, readText())\r\n      pop()\r\n      return readTag()\r\n    }\r\n\r\n    let has = gotoToken('<')\r\n    if (!has) {\r\n      return\r\n    }\r\n\r\n    start = pos\r\n    pos++\r\n\r\n    const tag = readIdentity()\r\n    stack.push({\r\n      obj: {},\r\n      tag,\r\n      start\r\n    })\r\n\r\n    readAttr()\r\n    skipSpace()\r\n    // 自闭合 tag\r\n    if (xmlStr[pos] === '/') {\r\n      pos++\r\n      if (stack.length > 1) {\r\n        const item = stack.pop()\r\n        addData(item.tag, item.obj)\r\n      }\r\n      gotoToken('>')\r\n      pos++\r\n      pop()\r\n      return readTag()\r\n    }\r\n\r\n    has = gotoToken('>')\r\n    if (!has) {\r\n      return\r\n    }\r\n    pos++\r\n\r\n    skipSpace()\r\n    // 检查有 innerText 内容\r\n    if (xmlStr[pos] !== '<') {\r\n      addData(options.aloneValueName, readText())\r\n      skipSpace()\r\n    }\r\n    pop()\r\n    readTag()\r\n  }\r\n\r\n  readTag()\r\n\r\n  return {\r\n    [stack[0].tag]: stack[0].obj\r\n  }\r\n}\r\n"],"names":[],"sourceRoot":""}
{"version":3,"file":"src_avformat_formats_IFlacFormat_ts.avtranscoder.js","mappings":"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","sources":["webpack://AVTranscoder/./src/avformat/formats/IFlacFormat.ts","webpack://AVTranscoder/./src/avformat/formats/IFormat.ts","webpack://AVTranscoder/./src/avformat/formats/flac/flac.ts","webpack://AVTranscoder/./src/avformat/formats/flac/iflac.ts","webpack://AVTranscoder/./src/avformat/function/getBytesByDuration.ts","webpack://AVTranscoder/./src/avformat/function/seekInBytes.ts","webpack://AVTranscoder/./src/common/math/crc8.ts"],"sourcesContent":["/*\r\n * libmedia flac decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVStream from '../AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVCodecID, AVMediaType } from 'avutil/codec'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\nimport IFormat from './IFormat'\r\nimport { AVFormat, AVSeekFlags } from '../avformat'\r\nimport { mapSafeUint8Array, memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport { avMalloc } from 'avutil/util/mem'\r\nimport { addAVPacketData } from 'avutil/util/avpacket'\r\nimport { IOError } from 'common/io/error'\r\nimport { MetaDataBlockType } from './flac/flac'\r\nimport { FlacContext, FrameInfo } from './flac/type'\r\nimport { decodeFrameHeader } from './flac/iflac'\r\nimport BitReader from 'common/io/BitReader'\r\nimport concatTypeArray from 'common/function/concatTypeArray'\r\nimport { AV_MILLI_TIME_BASE_Q, NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\nimport seekInBytes from '../function/seekInBytes'\r\nimport * as array from 'common/util/array'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\n\r\nconst PACKET_SIZE = 1024\r\n\r\nexport default class IFlacFormat extends IFormat {\r\n\r\n  public type: AVFormat = AVFormat.FLAC\r\n\r\n  context: FlacContext\r\n\r\n  constructor() {\r\n    super()\r\n  }\r\n\r\n  public init(formatContext: AVIFormatContext): void {\r\n    formatContext.ioReader.setEndian(true)\r\n\r\n    this.context = {\r\n      streamInfo: {\r\n        minimumBlockSize: 0,\r\n        maximumBlockSize: 0,\r\n        minimumFrameSize: 0,\r\n        maximumFrameSize: 0,\r\n        sampleRate: 0,\r\n        channels: 0,\r\n        bitPerSample: 0,\r\n        samples: 0n,\r\n        md5: ''\r\n      },\r\n      frameInfo: {\r\n        sampleRate: 0,\r\n        channels: 0,\r\n        bps: 0,\r\n        blocksize: 0,\r\n        chMode: 0,\r\n        frameOrSampleNum: 0n,\r\n        isVarSize: 0\r\n      },\r\n      seekPoints: [],\r\n      cueSheet: {\r\n        catalogNumber: '',\r\n        leadInSamples: 0n,\r\n        compactDisc: false,\r\n        tracks: []\r\n      },\r\n      picture: {\r\n        type: 0,\r\n        mimeType: '',\r\n        description: '',\r\n        width: 0,\r\n        height: 0,\r\n        colorDepth: 0,\r\n        indexedColor: 0,\r\n        data: null\r\n      },\r\n\r\n      cacheBuffer: null,\r\n      cachePos: 0n,\r\n      bitReader: new BitReader(16),\r\n      fileSize: 0n,\r\n      firstFramePos: 0n,\r\n      isVarSize: -1\r\n    }\r\n  }\r\n\r\n  public async readHeader(formatContext: AVIFormatContext): Promise<number> {\r\n\r\n    const signature = await formatContext.ioReader.readString(4)\r\n\r\n    if (signature !== 'fLaC') {\r\n      logger.error('the file format is not flac')\r\n      return errorType.DATA_INVALID\r\n    }\r\n\r\n    this.context.fileSize = await formatContext.ioReader.fileSize()\r\n\r\n    const stream = formatContext.createStream()\r\n    stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n    stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_FLAC\r\n\r\n    while (true) {\r\n      const blockHeader = await formatContext.ioReader.readUint8()\r\n      const blockLen = await formatContext.ioReader.readUint24()\r\n      const blockType = blockHeader & (~0x80)\r\n\r\n      if (blockType === MetaDataBlockType.STREAMINFO) {\r\n        stream.codecpar.extradata = avMalloc(blockLen)\r\n        stream.codecpar.extradataSize = blockLen\r\n        memcpyFromUint8Array(stream.codecpar.extradata, blockLen, await formatContext.ioReader.peekBuffer(blockLen))\r\n\r\n        this.context.streamInfo.minimumBlockSize = await formatContext.ioReader.readUint16()\r\n        this.context.streamInfo.maximumBlockSize = await formatContext.ioReader.readUint16()\r\n\r\n        this.context.streamInfo.minimumFrameSize = await formatContext.ioReader.readUint24()\r\n        this.context.streamInfo.maximumFrameSize = await formatContext.ioReader.readUint24()\r\n\r\n        const sampleRate = await formatContext.ioReader.readUint24()\r\n        stream.codecpar.sampleRate = (sampleRate >> 4)\r\n        stream.codecpar.chLayout.nbChannels = ((sampleRate & 0x0f) >>> 1) + 1\r\n\r\n        this.context.streamInfo.sampleRate = stream.codecpar.sampleRate\r\n        this.context.streamInfo.channels = stream.codecpar.chLayout.nbChannels\r\n\r\n        const bitPerSample = await formatContext.ioReader.readUint8()\r\n        stream.codecpar.bitsPerRawSample = (((sampleRate & 0x01) << 4) | ((bitPerSample & 0xf0) >>> 4)) + 1\r\n\r\n        this.context.streamInfo.bitPerSample = stream.codecpar.bitsPerRawSample\r\n\r\n        const samplesLow = await formatContext.ioReader.readUint32()\r\n\r\n        const samples = (static_cast<int64>(bitPerSample & 0x0f) << 32n) | static_cast<int64>(samplesLow)\r\n        this.context.streamInfo.samples = samples\r\n\r\n        stream.timeBase.den = stream.codecpar.sampleRate\r\n        stream.timeBase.num = 1\r\n        stream.duration = samples\r\n        stream.startTime = 0n\r\n\r\n        this.context.streamInfo.md5 = await formatContext.ioReader.readString(16)\r\n      }\r\n      else if (blockType === MetaDataBlockType.APPLICATION) {\r\n        const stream = formatContext.createStream()\r\n        stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_DATA\r\n        stream.codecpar.codecTag = await formatContext.ioReader.readUint32()\r\n        stream.codecpar.extradata = avMalloc(blockLen - 4)\r\n        stream.codecpar.extradataSize = blockLen - 4\r\n        await formatContext.ioReader.readBuffer(blockLen - 4, mapSafeUint8Array(stream.codecpar.extradata, stream.codecpar.extradataSize))\r\n      }\r\n      else if (blockType === MetaDataBlockType.SEEKTABLE) {\r\n        for (let i = 0; i < blockLen / 18; i++) {\r\n          const pts = await formatContext.ioReader.readUint64()\r\n          const pos = await formatContext.ioReader.readUint64()\r\n          const samples = await formatContext.ioReader.readUint16()\r\n          this.context.seekPoints.push({\r\n            pts,\r\n            pos,\r\n            samples\r\n          })\r\n        }\r\n      }\r\n      else if (blockType === MetaDataBlockType.VORBIS_COMMENT) {\r\n        formatContext.ioReader.setEndian(false)\r\n        const vendorStringLength = await formatContext.ioReader.readUint32()\r\n        const vendorString = await formatContext.ioReader.readString(vendorStringLength)\r\n        const userCommentListLength = await formatContext.ioReader.readUint32()\r\n        const comments = []\r\n        for (let i = 0; i < userCommentListLength; i++) {\r\n          const length = await formatContext.ioReader.readUint32()\r\n          comments.push(await formatContext.ioReader.readString(length))\r\n        }\r\n        stream.metadata['vendor'] = vendorString\r\n        stream.metadata['comments'] = comments\r\n        formatContext.ioReader.setEndian(true)\r\n      }\r\n      else if (blockType === MetaDataBlockType.CUESHEET) {\r\n        this.context.cueSheet.catalogNumber = await formatContext.ioReader.readString(128)\r\n        this.context.cueSheet.leadInSamples = await formatContext.ioReader.readUint64()\r\n        this.context.cueSheet.compactDisc = !!((await formatContext.ioReader.readUint8()) >>> 7)\r\n        await formatContext.ioReader.skip(258)\r\n\r\n        const trackCount = await formatContext.ioReader.readUint8()\r\n        for (let i = 0; i < trackCount; i++) {\r\n          const offset = await formatContext.ioReader.readUint64()\r\n          const number = await formatContext.ioReader.readUint8()\r\n          const isrc = await formatContext.ioReader.readBuffer(12)\r\n          const flags = await formatContext.ioReader.readUint8()\r\n          await formatContext.ioReader.skip(13)\r\n          const pointCount = await formatContext.ioReader.readUint8()\r\n\r\n          const points = []\r\n          for (let j = 0; j < pointCount; j++) {\r\n            points.push({\r\n              offset: await formatContext.ioReader.readUint64(),\r\n              point: await formatContext.ioReader.readUint8()\r\n            })\r\n            await formatContext.ioReader.skip(3)\r\n          }\r\n\r\n          this.context.cueSheet.tracks.push({\r\n            offset,\r\n            number,\r\n            isrc,\r\n            type: flags >>> 7,\r\n            preEmphasisFlag: (flags >>> 6) & 0x01,\r\n            points\r\n          })\r\n        }\r\n      }\r\n      else if (blockType === MetaDataBlockType.PICTURE) {\r\n        this.context.picture.type = await formatContext.ioReader.readUint32()\r\n        let len = await formatContext.ioReader.readUint32()\r\n        this.context.picture.mimeType = await formatContext.ioReader.readString(len)\r\n        len = await formatContext.ioReader.readUint32()\r\n        this.context.picture.description = await formatContext.ioReader.readString(len)\r\n        this.context.picture.width = await formatContext.ioReader.readUint32()\r\n        this.context.picture.height = await formatContext.ioReader.readUint32()\r\n        this.context.picture.colorDepth = await formatContext.ioReader.readUint32()\r\n        this.context.picture.indexedColor = await formatContext.ioReader.readUint32()\r\n        len = await formatContext.ioReader.readUint32()\r\n        this.context.picture.data = await formatContext.ioReader.readBuffer(len)\r\n      }\r\n      else {\r\n        await formatContext.ioReader.skip(blockLen)\r\n      }\r\n      if (blockHeader & 0x80) {\r\n        break\r\n      }\r\n    }\r\n\r\n    this.context.firstFramePos = formatContext.ioReader.getPos()\r\n\r\n    stream.privData = this.context\r\n\r\n    return 0\r\n  }\r\n\r\n  private async getNextFrame(formatContext: AVIFormatContext) {\r\n    const buffers: Uint8Array[] = []\r\n    while (true) {\r\n\r\n      if (formatContext.ioReader.getPos() === this.context.fileSize) {\r\n        if (this.context.cacheBuffer) {\r\n          buffers.push(this.context.cacheBuffer)\r\n          this.context.cacheBuffer = null\r\n        }\r\n        break\r\n      }\r\n\r\n      if (!this.context.cacheBuffer) {\r\n        this.context.cachePos = formatContext.ioReader.getPos()\r\n        this.context.cacheBuffer = await formatContext.ioReader.readBuffer(Math.min(PACKET_SIZE, static_cast<int32>(this.context.fileSize - formatContext.ioReader.getPos())))\r\n      }\r\n      else if (this.context.cacheBuffer.length < 17) {\r\n        this.context.cacheBuffer = concatTypeArray(\r\n          Uint8Array,\r\n          [\r\n            this.context.cacheBuffer,\r\n            await formatContext.ioReader.readBuffer(Math.min(PACKET_SIZE, static_cast<int32>(this.context.fileSize - formatContext.ioReader.getPos())))\r\n          ]\r\n        )\r\n      }\r\n\r\n      let i = buffers.length ? 0 : 2\r\n\r\n      const sync = this.context.isVarSize < 0 ? [0xf8, 0xf9] : (this.context.isVarSize ? [0xf9] : [0xf8])\r\n\r\n      for (; i < this.context.cacheBuffer.length - 2; i++) {\r\n        if (this.context.cacheBuffer[i] === 0xff && array.has(sync, this.context.cacheBuffer[i + 1])) {\r\n          if (i) {\r\n            buffers.push(this.context.cacheBuffer.subarray(0, i))\r\n            this.context.cacheBuffer = this.context.cacheBuffer.subarray(i)\r\n            this.context.cachePos += static_cast<int64>(i)\r\n          }\r\n          break\r\n        }\r\n      }\r\n\r\n      if (i === this.context.cacheBuffer.length - 2) {\r\n        if (formatContext.ioReader.getPos() === this.context.fileSize) {\r\n          buffers.push(this.context.cacheBuffer)\r\n          this.context.cachePos += static_cast<int64>(this.context.cacheBuffer.length)\r\n          this.context.cacheBuffer = null\r\n        }\r\n        else {\r\n          buffers.push(this.context.cacheBuffer.subarray(0, i))\r\n          this.context.cachePos += static_cast<int64>(i)\r\n          this.context.cacheBuffer = this.context.cacheBuffer.subarray(i)\r\n        }\r\n        continue\r\n      }\r\n\r\n      if (this.context.cacheBuffer.length < 16) {\r\n        this.context.cacheBuffer = concatTypeArray(\r\n          Uint8Array,\r\n          [\r\n            this.context.cacheBuffer,\r\n            await formatContext.ioReader.readBuffer(Math.min(PACKET_SIZE, static_cast<int32>(this.context.fileSize - formatContext.ioReader.getPos())))\r\n          ]\r\n        )\r\n      }\r\n\r\n      this.context.bitReader.reset()\r\n      this.context.bitReader.appendBuffer(this.context.cacheBuffer.subarray(0, 16))\r\n\r\n      const info: Partial<FrameInfo> = {}\r\n      // 检查下一帧的数据是否合法，不合法说明和前面的是同一帧数据\r\n      if (decodeFrameHeader(this.context.bitReader, info, true) < 0\r\n        || info.sampleRate !== this.context.frameInfo.sampleRate\r\n        || info.channels !== this.context.frameInfo.channels\r\n      ) {\r\n        buffers.push(this.context.cacheBuffer.subarray(0, 2))\r\n        this.context.cachePos += 2n\r\n        this.context.cacheBuffer = this.context.cacheBuffer.subarray(2)\r\n      }\r\n      else {\r\n        break\r\n      }\r\n    }\r\n\r\n    if (buffers.length === 1) {\r\n      return buffers[0]\r\n    }\r\n    return concatTypeArray(Uint8Array, buffers)\r\n  }\r\n\r\n  public async readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number> {\r\n\r\n    const stream: AVStream = formatContext.streams.find((stream) => {\r\n      return stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n    })\r\n\r\n    try {\r\n      let now = formatContext.ioReader.getPos()\r\n\r\n      if (now === this.context.fileSize) {\r\n        return IOError.END\r\n      }\r\n\r\n      this.context.bitReader.reset()\r\n\r\n      if (this.context.cacheBuffer) {\r\n        now = this.context.cachePos\r\n        if (this.context.cacheBuffer.length < 16) {\r\n          this.context.cacheBuffer = concatTypeArray(\r\n            Uint8Array,\r\n            [\r\n              this.context.cacheBuffer,\r\n              await formatContext.ioReader.readBuffer(Math.min(PACKET_SIZE, static_cast<int32>(this.context.fileSize - formatContext.ioReader.getPos())))\r\n            ]\r\n          )\r\n        }\r\n        this.context.bitReader.appendBuffer(this.context.cacheBuffer.subarray(0, 16))\r\n      }\r\n      else {\r\n        this.context.bitReader.appendBuffer(await formatContext.ioReader.peekBuffer(16))\r\n      }\r\n\r\n      if (decodeFrameHeader(this.context.bitReader, this.context.frameInfo) < 0) {\r\n        return errorType.DATA_INVALID\r\n      }\r\n\r\n      const nextFrame = await this.getNextFrame(formatContext)\r\n\r\n      const data = avMalloc(nextFrame.length)\r\n      memcpyFromUint8Array(data, nextFrame.length, nextFrame)\r\n      addAVPacketData(avpacket, data, nextFrame.length)\r\n\r\n      avpacket.pos = now\r\n      avpacket.streamIndex = stream.index\r\n      avpacket.timeBase.den = stream.timeBase.den\r\n      avpacket.timeBase.num = stream.timeBase.num\r\n      avpacket.dts = avpacket.pts = this.context.frameInfo.isVarSize\r\n        ? this.context.frameInfo.frameOrSampleNum\r\n        : this.context.frameInfo.frameOrSampleNum * static_cast<int64>(this.context.frameInfo.blocksize)\r\n\r\n      if (this.context.isVarSize < 0) {\r\n        this.context.isVarSize = this.context.frameInfo.isVarSize\r\n      }\r\n\r\n      return 0\r\n    }\r\n    catch (error) {\r\n      if (formatContext.ioReader.error !== IOError.END) {\r\n        logger.error(`read packet error, ${error}`)\r\n        return errorType.DATA_INVALID\r\n      }\r\n      return formatContext.ioReader.error\r\n    }\r\n  }\r\n\r\n  @deasync\r\n  private async syncFrame(formatContext: AVIFormatContext) {\r\n    let pos: int64 = NOPTS_VALUE_BIGINT\r\n    while (true) {\r\n      try {\r\n        const word = await formatContext.ioReader.peekUint16()\r\n        if (word === 0xfff9 || word === 0xfff8) {\r\n          pos = formatContext.ioReader.getPos()\r\n          this.context.bitReader.reset()\r\n          this.context.bitReader.appendBuffer(await formatContext.ioReader.peekBuffer(16))\r\n          if (!decodeFrameHeader(this.context.bitReader, {}, true)) {\r\n            break\r\n          }\r\n        }\r\n        await formatContext.ioReader.skip(1)\r\n      }\r\n      catch (error) {\r\n        break\r\n      }\r\n    }\r\n\r\n    if (pos !== NOPTS_VALUE_BIGINT) {\r\n      await formatContext.ioReader.seek(pos)\r\n    }\r\n  }\r\n\r\n  public async seek(formatContext: AVIFormatContext, stream: AVStream, timestamp: int64, flags: int32): Promise<int64> {\r\n    const now = formatContext.ioReader.getPos()\r\n\r\n    const context = stream.privData as FlacContext\r\n\r\n    if (flags & AVSeekFlags.BYTE) {\r\n\r\n      const size = await formatContext.ioReader.fileSize()\r\n\r\n      if (size <= 0n) {\r\n        return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n      }\r\n\r\n      if (timestamp < 0n) {\r\n        timestamp = 0n\r\n      }\r\n      else if (timestamp > size) {\r\n        timestamp = size\r\n      }\r\n      await formatContext.ioReader.seek(timestamp)\r\n\r\n      if (!(flags & AVSeekFlags.ANY)) {\r\n        await this.syncFrame(formatContext)\r\n      }\r\n      return now\r\n    }\r\n\r\n    if (stream && stream.sampleIndexes.length) {\r\n      let index = array.binarySearch(stream.sampleIndexes, (item) => {\r\n        if (item.pts > timestamp) {\r\n          return -1\r\n        }\r\n        return 1\r\n      })\r\n      if (index > 0 && avRescaleQ(timestamp - stream.sampleIndexes[index - 1].pts, stream.timeBase, AV_MILLI_TIME_BASE_Q) < 5000n) {\r\n        logger.debug(`seek in sampleIndexes, found index: ${index}, pts: ${stream.sampleIndexes[index - 1].pts}, pos: ${stream.sampleIndexes[index - 1].pos}`)\r\n        await formatContext.ioReader.seek(stream.sampleIndexes[index - 1].pos)\r\n        context.cacheBuffer = null\r\n        return now\r\n      }\r\n    }\r\n\r\n    if (context.seekPoints.length) {\r\n      for (let i = 0; i < context.seekPoints.length; i++) {\r\n        const cue =  context.seekPoints[i]\r\n        if (cue.pts >= timestamp) {\r\n          logger.debug(`seek in seekPoints, found index: ${i}, pts: ${cue.pts}, pos: ${cue.pos + context.firstFramePos}`)\r\n          await formatContext.ioReader.seek(cue.pos + context.firstFramePos)\r\n          context.cacheBuffer = null\r\n          return now\r\n        }\r\n      }\r\n    }\r\n\r\n    logger.debug('not found any keyframe index, try to seek in bytes')\r\n\r\n    const ret = await seekInBytes(\r\n      formatContext,\r\n      stream,\r\n      timestamp,\r\n      context.firstFramePos,\r\n      this.readAVPacket.bind(this),\r\n      this.syncFrame.bind(this)\r\n    )\r\n    if (ret > 0) {\r\n      context.cacheBuffer = null\r\n    }\r\n    return ret\r\n  }\r\n\r\n  public getAnalyzeStreamsCount(): number {\r\n    return 1\r\n  }\r\n}\r\n","/*\r\n * libmedia abstract format decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVFormat } from '../avformat'\r\n\r\nexport default abstract class IFormat {\r\n\r\n  public type: AVFormat = AVFormat.UNKNOWN\r\n\r\n  public onStreamAdd: (stream: Stream) => void\r\n\r\n  public abstract init(formatContext: AVIFormatContext): void\r\n\r\n  public destroy(formatContext: AVIFormatContext): void {}\r\n\r\n  public abstract getAnalyzeStreamsCount(): number\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readHeader(formatContext: AVIFormatContext): Promise<number>\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number>\r\n\r\n  /**\r\n   * seek\r\n   * \r\n   * @param context \r\n   * @param stream \r\n   * @param timestamp 毫秒时间戳\r\n   * @param flags \r\n   * \r\n   * @returns 返回 seek 之前的下一个 avpacket pos（若不知道返回 0n 方便之后可以再 seek 回来）返回负数表示 seek 失败\r\n   */\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract seek(\r\n    formatContext: AVIFormatContext,\r\n    stream: Stream,\r\n    timestamp: int64,\r\n    flags: int32\r\n  ): Promise<int64>\r\n}\r\n","/*\r\n * libmedia flac defined\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nexport const enum MetaDataBlockType {\r\n  STREAMINFO,\r\n  PADDING,\r\n  APPLICATION,\r\n  SEEKTABLE,\r\n  VORBIS_COMMENT,\r\n  CUESHEET,\r\n  PICTURE\r\n}\r\n\r\nexport const enum FlacCHMode {\r\n  INDEPENDENT = 0,\r\n  LEFT_SIDE = 1,\r\n  RIGHT_SIDE = 2,\r\n  MID_SIDE = 3\r\n}\r\n\r\nexport const FLAC_STREAMINFO_SIZE = 34\r\nexport const FLAC_MAX_CHANNELS = 8\r\nexport const FLAC_MIN_BLOCKSIZE = 16\r\nexport const FLAC_MAX_BLOCKSIZE = 65535\r\nexport const FLAC_MIN_FRAME_SIZE = 10\r\n\r\nexport const SampleSizeTable: number[] = [0, 8, 12, 0, 16, 20, 24, 32]\r\n\r\nexport const SampleRateTable: number[] = [\r\n  0, 88200, 176400, 192000, 8000, 16000, 22050,\r\n  24000, 32000, 44100, 48000, 96000,\r\n  0, 0, 0, 0\r\n]\r\n\r\nexport const BlockSizeTable: number[] = [\r\n  0, 192, 576 << 0, 576 << 1, 576 << 2, 576 << 3, 0, 0,\r\n  256 << 0, 256 << 1, 256 << 2, 256 << 3, 256 << 4, 256 << 5, 256 << 6, 256 << 7\r\n]\r\n","/*\r\n * libmedia flac input util\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport BitReader from 'common/io/BitReader'\r\nimport { FrameInfo } from './type'\r\nimport * as errorType from 'avutil/error'\r\nimport * as logger from 'common/util/logger'\r\nimport { BlockSizeTable, FLAC_MAX_CHANNELS, FlacCHMode, SampleRateTable, SampleSizeTable } from './flac'\r\nimport crc8 from 'common/math/crc8'\r\n\r\nexport function getUtf8(reader: BitReader) {\r\n  let value = static_cast<int64>(reader.readU(8))\r\n  let top = (value & 128n) >> 1n\r\n  if ((value & 0xc0n) === 0x80n || value >= 0xfen) {\r\n    return -1n\r\n  }\r\n  while (value & top) {\r\n    const tmp = static_cast<int64>(reader.readU(8)) - 128n\r\n    if (tmp >> 6n) {\r\n      return -1n\r\n    }\r\n    value = (value << 6n) + tmp\r\n    top <<= 5n\r\n  }\r\n  value &= (top << 1n) - 1n\r\n\r\n  return value\r\n}\r\n\r\nexport function decodeFrameHeader(bitReader: BitReader, info: Partial<FrameInfo>, check: boolean = false) {\r\n\r\n  const start = bitReader.getPointer()\r\n\r\n  if ((bitReader.readU(15) & 0x7fff) != 0x7ffc) {\r\n    !check && logger.error('invalid sync code')\r\n    return errorType.DATA_INVALID\r\n  }\r\n  info.isVarSize = bitReader.readU1()\r\n\r\n  const bsCode = bitReader.readU(4)\r\n  const srCode = bitReader.readU(4)\r\n\r\n  info.chMode = bitReader.readU(4)\r\n\r\n  if (info.chMode < FLAC_MAX_CHANNELS) {\r\n    info.channels = info.chMode + 1\r\n    info.chMode = FlacCHMode.INDEPENDENT\r\n  }\r\n  else if (info.chMode < FLAC_MAX_CHANNELS + FlacCHMode.MID_SIDE) {\r\n    info.channels = 2\r\n    info.chMode -= FLAC_MAX_CHANNELS - 1\r\n  }\r\n  else {\r\n    !check && logger.error(`invalid channel mode: ${info.chMode}`)\r\n    return errorType.DATA_INVALID\r\n  }\r\n\r\n  const bpsCode = bitReader.readU(3)\r\n  if (bpsCode === 3) {\r\n    !check && logger.error(`invalid sample size code: ${bpsCode}`)\r\n    return errorType.DATA_INVALID\r\n  }\r\n  info.bps = SampleSizeTable[bpsCode]\r\n\r\n  if (bitReader.readU1()) {\r\n    !check && logger.error('broken stream, invalid padding')\r\n    return errorType.DATA_INVALID\r\n  }\r\n\r\n  info.frameOrSampleNum = getUtf8(bitReader)\r\n\r\n  if (info.frameOrSampleNum < 0) {\r\n    !check && logger.error('sample/frame number invalid')\r\n    return errorType.DATA_INVALID\r\n  }\r\n\r\n  if (bsCode === 0) {\r\n    !check && logger.error('reserved blocksize code: 0')\r\n    return errorType.DATA_INVALID\r\n  }\r\n  else if (bsCode === 6) {\r\n    info.blocksize = bitReader.readU(8) + 1\r\n  }\r\n  else if (bsCode === 7) {\r\n    info.blocksize = bitReader.readU(16) + 1\r\n  }\r\n  else {\r\n    info.blocksize = BlockSizeTable[bsCode]\r\n  }\r\n\r\n  if (srCode < 12) {\r\n    info.sampleRate = SampleRateTable[srCode]\r\n  }\r\n  else if (srCode === 12) {\r\n    info.sampleRate = bitReader.readU(8) * 1000\r\n  }\r\n  else if (srCode === 13) {\r\n    info.sampleRate = bitReader.readU(16)\r\n  }\r\n  else if (srCode === 14) {\r\n    info.sampleRate = bitReader.readU(16) * 10\r\n  }\r\n  else {\r\n    !check && logger.error(`illegal sample rate code ${srCode}`)\r\n    return errorType.DATA_INVALID\r\n  }\r\n\r\n  const crc = crc8(bitReader.getBuffer().subarray(start, bitReader.getPointer()))\r\n\r\n  if (crc !== bitReader.readU(8)) {\r\n    !check && logger.error('header crc mismatch')\r\n    return errorType.DATA_INVALID\r\n  }\r\n\r\n  return 0\r\n}\r\n","/*\r\n * libmedia get bytes by duration\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { Rational } from 'avutil/struct/rational'\r\nimport AVStream from '../AVStream'\r\nimport * as array from 'common/util/array'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { AV_MILLI_TIME_BASE_Q } from 'avutil/constant'\r\n\r\nexport function getBytesByDuration(streams: AVStream[], duration: int64, timeBase: Rational) {\r\n  let bytes = 0n\r\n  array.each(streams, (st) => {\r\n    bytes += st.codecpar.bitrate * avRescaleQ(duration, timeBase, AV_MILLI_TIME_BASE_Q) / 8000n\r\n  })\r\n  return bytes\r\n}\r\n","/*\r\n * libmedia seek in bytes with timestamp\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVStream from '../AVStream'\r\nimport { AV_MILLI_TIME_BASE_Q, NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { getBytesByDuration } from './getBytesByDuration'\r\nimport { createAVPacket, destroyAVPacket } from 'avutil/util/avpacket'\r\nimport * as errorType from 'avutil/error'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport * as logger from 'common/util/logger'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function seekInBytes(\r\n  context: AVIFormatContext,\r\n  stream: AVStream,\r\n  timestamp: int64,\r\n  firstPacketPos: int64,\r\n  readAVPacket: (context: AVIFormatContext, avpacket: pointer<AVPacket>) => Promise<int32>,\r\n  syncAVPacket: (context: AVIFormatContext) => Promise<void>\r\n) {\r\n\r\n  const now = context.ioReader.getPos()\r\n\r\n  const fileSize = await context.ioReader.fileSize()\r\n  let pos: int64 = NOPTS_VALUE_BIGINT\r\n  let duration = timestamp\r\n  if (stream.startTime !== NOPTS_VALUE_BIGINT) {\r\n    duration -= stream.startTime\r\n  }\r\n  else {\r\n    duration -= stream.firstDTS\r\n  }\r\n\r\n  const pointPts = avRescaleQ(timestamp, stream.timeBase, AV_MILLI_TIME_BASE_Q)\r\n\r\n  // 头十秒直接回到开始位置\r\n  if (pointPts < 10000n) {\r\n    logger.debug(`seek pts is earlier then 10s, seek to first packet pos(${firstPacketPos}) directly`)\r\n    await context.ioReader.seek(firstPacketPos)\r\n    return now\r\n  }\r\n\r\n  let bytes = getBytesByDuration(context.streams, duration, stream.timeBase)\r\n  // 最大到结尾往前 10 秒\r\n  const max = fileSize - getBytesByDuration(context.streams, 10000n, AV_MILLI_TIME_BASE_Q)\r\n  const length = getBytesByDuration(context.streams, 10000n, AV_MILLI_TIME_BASE_Q)\r\n  if (bytes > max) {\r\n    bytes = max\r\n  }\r\n  if (bytes < firstPacketPos) {\r\n    await context.ioReader.seek(firstPacketPos)\r\n    return now\r\n  }\r\n  const avpacket = createAVPacket()\r\n  let seekMax = fileSize\r\n  let seekMin = 0n\r\n\r\n  while (true) {\r\n    if (seekMax - seekMin < length) {\r\n      pos = seekMin\r\n      break\r\n    }\r\n    await context.ioReader.seek(bytes)\r\n    await syncAVPacket(context)\r\n    const now = context.ioReader.getPos()\r\n\r\n    let ret = await readAVPacket(context, avpacket)\r\n\r\n    if (ret >= 0) {\r\n      const currentPts = avRescaleQ(avpacket.pts, avpacket.timeBase, AV_MILLI_TIME_BASE_Q)\r\n      const diff = currentPts - pointPts\r\n\r\n      logger.debug(`try to seek to pos: ${bytes}, got packet pts: ${avpacket.pts}(${currentPts}ms), diff: ${diff}ms`)\r\n\r\n      // seek 时间戳的前面 10 秒内\r\n      if (diff <= 0n && -diff < 10000n) {\r\n        pos = now\r\n        break\r\n      }\r\n      // seek 后面\r\n      else if (diff > 0n) {\r\n        seekMax = bytes\r\n        bytes = (seekMin + seekMax) >> 1n\r\n      }\r\n      // seek 前面 10 秒外\r\n      else {\r\n        seekMin = bytes\r\n        bytes = (seekMin + seekMax) >> 1n\r\n      }\r\n    }\r\n    else {\r\n      // 失败了重新 seek 回原来的位置\r\n      pos = NOPTS_VALUE_BIGINT\r\n      break\r\n    }\r\n  }\r\n\r\n  destroyAVPacket(avpacket)\r\n\r\n  if (pos !== NOPTS_VALUE_BIGINT) {\r\n    logger.debug(`finally seek to pos ${pos}`)\r\n\r\n    await context.ioReader.seek(pos)\r\n    await syncAVPacket(context)\r\n    return now\r\n  }\r\n  else {\r\n    await context.ioReader.seek(now)\r\n  }\r\n\r\n  return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n}\r\n","export default function crc8(data: Uint8Array, crc: number = 0x00) {\r\n  const polynomial = 0x07\r\n\r\n  for (let i = 0; i < data.length; i++) {\r\n    crc ^= data[i]\r\n\r\n    for (let j = 0; j < 8; j++) {\r\n      if (crc & 0x80) {\r\n        crc = (crc << 1) ^ polynomial\r\n      }\r\n      else {\r\n        crc <<= 1\r\n      }\r\n    }\r\n  }\r\n\r\n  return crc & 0xFF\r\n}\r\n"],"names":[],"sourceRoot":""}
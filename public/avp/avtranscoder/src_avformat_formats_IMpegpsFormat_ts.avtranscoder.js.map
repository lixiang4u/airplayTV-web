{"version":3,"file":"src_avformat_formats_IMpegpsFormat_ts.avtranscoder.js","mappings":"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","sources":["webpack://AVTranscoder/./src/avformat/bsf/AVBSFilter.ts","webpack://AVTranscoder/./src/avformat/bsf/aac/ADTS2RawFilter.ts","webpack://AVTranscoder/./src/avformat/bsf/ac3/Ac32RawFilter.ts","webpack://AVTranscoder/./src/avformat/bsf/dts/Dts2RawFilter.ts","webpack://AVTranscoder/./src/avformat/bsf/mp3/Mp32RawFilter.ts","webpack://AVTranscoder/./src/avformat/codecs/aac.ts","webpack://AVTranscoder/./src/avformat/codecs/ac3.ts","webpack://AVTranscoder/./src/avformat/codecs/dts.ts","webpack://AVTranscoder/./src/avformat/codecs/mp3.ts","webpack://AVTranscoder/./src/avformat/codecs/mpegvideo.ts","webpack://AVTranscoder/./src/avformat/codecs/opus.ts","webpack://AVTranscoder/./src/avformat/formats/IFormat.ts","webpack://AVTranscoder/./src/avformat/formats/IMpegpsFormat.ts","webpack://AVTranscoder/./src/avformat/formats/mp3/frameHeader.ts","webpack://AVTranscoder/./src/avformat/formats/mpegts/function/parsePES.ts","webpack://AVTranscoder/./src/avformat/formats/mpegts/mpegps.ts","webpack://AVTranscoder/./src/avformat/formats/mpegts/struct.ts","webpack://AVTranscoder/./src/avformat/function/getBytesByDuration.ts","webpack://AVTranscoder/./src/avformat/function/seekInBytes.ts"],"sourcesContent":["/*\r\n * libmedia AVBSFilter\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport { Rational } from 'avutil/struct/rational'\r\nimport { avMallocz } from 'avutil/util/mem'\r\nimport { copyCodecParameters, freeCodecParameters } from 'avutil/util/codecparameters'\r\n\r\nexport default abstract class AVBSFilter {\r\n\r\n  inCodecpar: pointer<AVCodecParameters>\r\n  inTimeBase: Rational\r\n\r\n  outCodecpar: pointer<AVCodecParameters>\r\n\r\n  public init(codecpar: pointer<AVCodecParameters>, timeBase: pointer<Rational>): number {\r\n    this.inCodecpar = avMallocz(sizeof(AVCodecParameters))\r\n    copyCodecParameters(this.inCodecpar, codecpar)\r\n\r\n    this.inTimeBase = {\r\n      den: timeBase.den,\r\n      num: timeBase.num\r\n    }\r\n\r\n    return 0\r\n  }\r\n\r\n  public destroy() {\r\n    if (this.inCodecpar) {\r\n      freeCodecParameters(this.inCodecpar)\r\n      this.inCodecpar = nullptr\r\n    }\r\n  }\r\n\r\n  public abstract sendAVPacket(avpacket: pointer<AVPacket>): number\r\n  public abstract receiveAVPacket(avpacket: pointer<AVPacket>): number\r\n  public abstract reset(): number\r\n}\r\n","/*\r\n * libmedia ADTS2RawFilter\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVPacket, { AVPacketFlags } from 'avutil/struct/avpacket'\r\nimport AVBSFilter from '../AVBSFilter'\r\nimport { mapUint8Array, memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\nimport { AV_TIME_BASE, AV_TIME_BASE_Q, NOPTS_VALUE } from 'avutil/constant'\r\nimport { MPEG4Channels, MPEG4SamplingFrequencies, avCodecParameters2Extradata } from '../../codecs/aac'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { avFree, avMalloc } from 'avutil/util/mem'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport { Rational } from 'avutil/struct/rational'\r\nimport { addAVPacketData, addAVPacketSideData, unrefAVPacket } from 'avutil/util/avpacket'\r\nimport { AVPacketSideDataType } from 'avutil/codec'\r\nimport * as aac from '../../codecs/aac'\r\nimport * as is from 'common/util/is'\r\n\r\nexport default class ADTS2RawFilter extends AVBSFilter {\r\n\r\n  private streamMuxConfig: {\r\n    profile: number\r\n    sampleRate: number\r\n    channels: number\r\n  }\r\n\r\n  private caches: {\r\n    duration: number\r\n    dts: bigint\r\n    buffer: Uint8Array\r\n    extradata: Uint8Array\r\n  }[]\r\n\r\n  public init(codecpar: pointer<AVCodecParameters>, timeBase: pointer<Rational>): number {\r\n    super.init(codecpar, timeBase)\r\n\r\n    this.caches = []\r\n    this.streamMuxConfig = {\r\n      profile: NOPTS_VALUE,\r\n      sampleRate: NOPTS_VALUE,\r\n      channels: NOPTS_VALUE\r\n    }\r\n\r\n    return 0\r\n  }\r\n\r\n  public sendAVPacket(avpacket: pointer<AVPacket>): number {\r\n    let i = 0\r\n\r\n    let lastDts = avpacket.dts || avpacket.pts\r\n    const buffer = mapUint8Array(avpacket.data, avpacket.size).slice()\r\n\r\n    while (i < buffer.length) {\r\n\r\n      const info = aac.parseADTSHeader(buffer.subarray(i))\r\n\r\n      if (is.number(info)) {\r\n        logger.error('AACADTSParser parse failed')\r\n        return errorType.DATA_INVALID\r\n      }\r\n\r\n      const item = {\r\n        dts: lastDts,\r\n        buffer: null,\r\n        extradata: null,\r\n        duration: NOPTS_VALUE,\r\n      }\r\n\r\n      item.buffer = buffer.subarray(i + info.headerLength, i + info.headerLength + info.framePayloadLength)\r\n\r\n      this.streamMuxConfig.profile = info.profile\r\n      this.streamMuxConfig.sampleRate = info.sampleRate\r\n      this.streamMuxConfig.channels = info.channels\r\n\r\n      const hasNewExtraData = this.inCodecpar.profile !== this.streamMuxConfig.profile\r\n        || this.inCodecpar.sampleRate !== this.streamMuxConfig.sampleRate\r\n        || this.inCodecpar.chLayout.nbChannels !== this.streamMuxConfig.channels\r\n\r\n\r\n      const duration = avRescaleQ(\r\n        static_cast<int64>((info.numberOfRawDataBlocksInFrame + 1) * 1024 / this.streamMuxConfig.sampleRate * AV_TIME_BASE),\r\n        AV_TIME_BASE_Q,\r\n        this.inTimeBase\r\n      )\r\n\r\n      item.duration = Number(duration)\r\n\r\n      if (hasNewExtraData) {\r\n        this.inCodecpar.profile = this.streamMuxConfig.profile\r\n        this.inCodecpar.sampleRate = this.streamMuxConfig.sampleRate\r\n        this.inCodecpar.chLayout.nbChannels = this.streamMuxConfig.channels\r\n\r\n        const extradata = avCodecParameters2Extradata(accessof(this.inCodecpar))\r\n\r\n        if (this.inCodecpar.extradata) {\r\n          avFree(this.inCodecpar.extradata)\r\n        }\r\n        this.inCodecpar.extradata = avMalloc(extradata.length)\r\n        memcpyFromUint8Array(this.inCodecpar.extradata, extradata.length, extradata)\r\n        this.inCodecpar.extradataSize = extradata.length\r\n        item.extradata = extradata\r\n      }\r\n\r\n      this.caches.push(item)\r\n\r\n      i += info.aacFrameLength\r\n      lastDts += duration\r\n    }\r\n    return 0\r\n  }\r\n\r\n  public receiveAVPacket(avpacket: pointer<AVPacket>): number {\r\n    if (this.caches.length) {\r\n\r\n      unrefAVPacket(avpacket)\r\n\r\n      const item = this.caches.shift()\r\n\r\n      const data = avMalloc(item.buffer.length)\r\n      memcpyFromUint8Array(data, item.buffer.length, item.buffer)\r\n      addAVPacketData(avpacket, data, item.buffer.length)\r\n\r\n      avpacket.dts = avpacket.pts = item.dts\r\n      avpacket.duration = static_cast<int64>(item.duration)\r\n      avpacket.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n      if (item.extradata) {\r\n        const extradata = avMalloc(item.extradata.length)\r\n        memcpyFromUint8Array(extradata, item.extradata.length, item.extradata)\r\n        addAVPacketSideData(avpacket, AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA, extradata, item.extradata.length)\r\n      }\r\n      return 0\r\n    }\r\n    else {\r\n      return errorType.EOF\r\n    }\r\n  }\r\n\r\n  public reset(): number {\r\n    return 0\r\n  }\r\n}\r\n","/*\r\n * libmedia Ac32RawFilter\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVPacket, { AVPacketFlags } from 'avutil/struct/avpacket'\r\nimport AVBSFilter from '../AVBSFilter'\r\nimport { mapUint8Array, memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\nimport { AV_TIME_BASE, AV_TIME_BASE_Q, NOPTS_VALUE } from 'avutil/constant'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { avMalloc } from 'avutil/util/mem'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport { Rational } from 'avutil/struct/rational'\r\nimport { addAVPacketData, unrefAVPacket } from 'avutil/util/avpacket'\r\nimport * as ac3 from '../../codecs/ac3'\r\nimport concatTypeArray from 'common/function/concatTypeArray'\r\nimport * as is from 'common/util/is'\r\n\r\nexport default class Ac32RawFilter extends AVBSFilter {\r\n\r\n  private caches: {\r\n    duration: number\r\n    dts: bigint\r\n    buffer: Uint8Array\r\n  }[]\r\n\r\n  private cache: Uint8Array\r\n  private lastDts: int64\r\n\r\n  public init(codecpar: pointer<AVCodecParameters>, timeBase: pointer<Rational>): number {\r\n    super.init(codecpar, timeBase)\r\n\r\n    this.caches = []\r\n\r\n    return 0\r\n  }\r\n\r\n  public sendAVPacket(avpacket: pointer<AVPacket>): number {\r\n    let i = 0\r\n\r\n    let lastDts = this.lastDts || (avpacket.dts || avpacket.pts)\r\n    let buffer = mapUint8Array(avpacket.data, avpacket.size).slice()\r\n    let firstGot = false\r\n    let hasCache = !!this.cache\r\n\r\n    if (hasCache) {\r\n      buffer = concatTypeArray(Uint8Array, [this.cache, buffer])\r\n      this.cache = null\r\n    }\r\n\r\n    while (i < buffer.length) {\r\n\r\n      if (i > buffer.length - 10) {\r\n        this.cache = buffer.subarray(i)\r\n        this.lastDts = lastDts\r\n        return 0\r\n      }\r\n\r\n      const info = ac3.parseHeader(buffer.subarray(i))\r\n\r\n      if (is.number(info)) {\r\n        logger.error('parse ac3 header failed')\r\n        return errorType.DATA_INVALID\r\n      }\r\n\r\n      const item = {\r\n        dts: lastDts,\r\n        buffer: null,\r\n        duration: NOPTS_VALUE,\r\n      }\r\n\r\n      let frameLength = info.frameSize\r\n\r\n      item.buffer = buffer.subarray(i, i + frameLength)\r\n\r\n      if (i + frameLength > buffer.length) {\r\n        this.cache = buffer.subarray(i)\r\n        this.lastDts = lastDts\r\n        return 0\r\n      }\r\n\r\n      const duration = avRescaleQ(\r\n        static_cast<int64>(1536 / info.sampleRate * AV_TIME_BASE),\r\n        AV_TIME_BASE_Q,\r\n        this.inTimeBase\r\n      )\r\n\r\n      item.duration = Number(duration)\r\n\r\n      this.caches.push(item)\r\n\r\n      i += frameLength\r\n      lastDts += duration\r\n\r\n      if (!firstGot && hasCache) {\r\n        firstGot = true\r\n        lastDts = avpacket.dts || avpacket.pts\r\n      }\r\n    }\r\n    this.lastDts = 0n\r\n\r\n    return 0\r\n  }\r\n\r\n  public receiveAVPacket(avpacket: pointer<AVPacket>): number {\r\n    if (this.caches.length) {\r\n\r\n      unrefAVPacket(avpacket)\r\n\r\n      const item = this.caches.shift()\r\n\r\n      const data = avMalloc(item.buffer.length)\r\n      memcpyFromUint8Array(data, item.buffer.length, item.buffer)\r\n      addAVPacketData(avpacket, data, item.buffer.length)\r\n\r\n      avpacket.dts = avpacket.pts = item.dts\r\n      avpacket.duration = static_cast<int64>(item.duration)\r\n      avpacket.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n      return 0\r\n    }\r\n    else {\r\n      return errorType.EOF\r\n    }\r\n  }\r\n\r\n  public reset(): number {\r\n    this.cache = null\r\n    this.lastDts = 0n\r\n    return 0\r\n  }\r\n}\r\n","/*\r\n * libmedia Dts2RawFilter\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVPacket, { AVPacketFlags } from 'avutil/struct/avpacket'\r\nimport AVBSFilter from '../AVBSFilter'\r\nimport { mapUint8Array, memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\nimport { AV_TIME_BASE, AV_TIME_BASE_Q, NOPTS_VALUE } from 'avutil/constant'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { avMalloc } from 'avutil/util/mem'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport { Rational } from 'avutil/struct/rational'\r\nimport { addAVPacketData, unrefAVPacket } from 'avutil/util/avpacket'\r\nimport * as dts from '../../codecs/dts'\r\nimport concatTypeArray from 'common/function/concatTypeArray'\r\nimport * as is from 'common/util/is'\r\n\r\nexport default class Dts2RawFilter extends AVBSFilter {\r\n\r\n  private caches: {\r\n    duration: number\r\n    dts: bigint\r\n    buffer: Uint8Array\r\n  }[]\r\n\r\n  private cache: Uint8Array\r\n  private lastDts: int64\r\n\r\n  public init(codecpar: pointer<AVCodecParameters>, timeBase: pointer<Rational>): number {\r\n    super.init(codecpar, timeBase)\r\n\r\n    this.caches = []\r\n\r\n    return 0\r\n  }\r\n\r\n  public sendAVPacket(avpacket: pointer<AVPacket>): number {\r\n    let i = 0\r\n\r\n    let lastDts = this.lastDts || (avpacket.dts || avpacket.pts)\r\n    let buffer = mapUint8Array(avpacket.data, avpacket.size).slice()\r\n    let firstGot = false\r\n    let hasCache = !!this.cache\r\n\r\n    if (hasCache) {\r\n      buffer = concatTypeArray(Uint8Array, [this.cache, buffer])\r\n      this.cache = null\r\n    }\r\n\r\n    while (i < buffer.length) {\r\n\r\n      if (i > buffer.length - 6) {\r\n        this.cache = buffer.subarray(i)\r\n        this.lastDts = lastDts\r\n        return 0\r\n      }\r\n\r\n      const info = dts.parseHeader(buffer.subarray(i))\r\n\r\n      if (is.number(info)) {\r\n        logger.error('parse dts header failed')\r\n        return errorType.DATA_INVALID\r\n      }\r\n\r\n      const item = {\r\n        dts: lastDts,\r\n        buffer: null,\r\n        duration: NOPTS_VALUE,\r\n      }\r\n\r\n      let frameLength = info.frameSize\r\n\r\n      item.buffer = buffer.subarray(i, i + frameLength)\r\n\r\n      if (i + frameLength > buffer.length) {\r\n        this.cache = buffer.subarray(i)\r\n        this.lastDts = lastDts\r\n        return 0\r\n      }\r\n\r\n      const duration = avRescaleQ(\r\n        static_cast<int64>(((info.sampleBlock * dts.DTS_PCMBLOCK_SAMPLES) / info.sampleRate * AV_TIME_BASE) as double),\r\n        AV_TIME_BASE_Q,\r\n        this.inTimeBase\r\n      )\r\n\r\n      item.duration = Number(duration)\r\n\r\n      this.caches.push(item)\r\n\r\n      i += frameLength\r\n      lastDts += duration\r\n\r\n      if (!firstGot && hasCache) {\r\n        firstGot = true\r\n        lastDts = avpacket.dts || avpacket.pts\r\n      }\r\n    }\r\n    this.lastDts = 0n\r\n\r\n    return 0\r\n  }\r\n\r\n  public receiveAVPacket(avpacket: pointer<AVPacket>): number {\r\n    if (this.caches.length) {\r\n\r\n      unrefAVPacket(avpacket)\r\n\r\n      const item = this.caches.shift()\r\n\r\n      const data = avMalloc(item.buffer.length)\r\n      memcpyFromUint8Array(data, item.buffer.length, item.buffer)\r\n      addAVPacketData(avpacket, data, item.buffer.length)\r\n\r\n      avpacket.dts = avpacket.pts = item.dts\r\n      avpacket.duration = static_cast<int64>(item.duration)\r\n      avpacket.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n      return 0\r\n    }\r\n    else {\r\n      return errorType.EOF\r\n    }\r\n  }\r\n\r\n  public reset(): number {\r\n    this.cache = null\r\n    this.lastDts = 0n\r\n    return 0\r\n  }\r\n}\r\n","/*\r\n * libmedia Mp32RawFilter\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVPacket, { AVPacketFlags } from 'avutil/struct/avpacket'\r\nimport AVBSFilter from '../AVBSFilter'\r\nimport { mapUint8Array, memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\nimport { AV_TIME_BASE, AV_TIME_BASE_Q, NOPTS_VALUE } from 'avutil/constant'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { avMalloc } from 'avutil/util/mem'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport { Rational } from 'avutil/struct/rational'\r\nimport { addAVPacketData, addAVPacketSideData, unrefAVPacket } from 'avutil/util/avpacket'\r\nimport { AVPacketSideDataType } from 'avutil/codec'\r\nimport * as frameHeader from '../../formats/mp3/frameHeader'\r\nimport * as mp3 from '../../codecs/mp3'\r\nimport concatTypeArray from 'common/function/concatTypeArray'\r\n\r\nexport default class Mp32RawFilter extends AVBSFilter {\r\n\r\n  private frameHeader: frameHeader.FrameHeader\r\n\r\n  private caches: {\r\n    duration: number\r\n    dts: bigint\r\n    buffer: Uint8Array\r\n    extradata: Uint8Array\r\n  }[]\r\n\r\n  private cache: Uint8Array\r\n  private lastDts: int64\r\n\r\n  public init(codecpar: pointer<AVCodecParameters>, timeBase: pointer<Rational>): number {\r\n    super.init(codecpar, timeBase)\r\n\r\n    this.caches = []\r\n    this.frameHeader = new frameHeader.FrameHeader()\r\n\r\n    return 0\r\n  }\r\n\r\n  public sendAVPacket(avpacket: pointer<AVPacket>): number {\r\n    let i = 0\r\n\r\n    let lastDts = this.lastDts || (avpacket.dts || avpacket.pts)\r\n    let buffer = mapUint8Array(avpacket.data, avpacket.size).slice()\r\n    let firstGot = false\r\n    let hasCache = !!this.cache\r\n\r\n    if (hasCache) {\r\n      buffer = concatTypeArray(Uint8Array, [this.cache, buffer])\r\n      this.cache = null\r\n    }\r\n\r\n    while (i < buffer.length) {\r\n\r\n      const syncWord = (buffer[i] << 4) | ((buffer[i + 1] >> 4) & 0x0e)\r\n\r\n      if (syncWord !== 0xFFE) {\r\n        logger.error(`found syncWord not 0xFFE, got: 0x${syncWord.toString(16)}`)\r\n        return errorType.DATA_INVALID\r\n      }\r\n\r\n      const ver = (buffer[1] >>> 3) & 0x03\r\n      // const bitrateIndex = (buffer[2] & 0xF0) >>> 4\r\n      const samplingFreqIndex = (buffer[2] & 0x0C) >>> 2\r\n\r\n      const item = {\r\n        dts: lastDts,\r\n        buffer: null,\r\n        extradata: null,\r\n        duration: NOPTS_VALUE,\r\n      }\r\n\r\n      const sampleRate = mp3.getSampleRateByVersionIndex(ver, samplingFreqIndex)\r\n\r\n      frameHeader.parse(this.frameHeader, (buffer[i] << 24) | (buffer[i + 1] << 16) | (buffer[i + 2] << 8) | buffer[i + 3])\r\n\r\n      let frameLength = frameHeader.getFrameLength(this.frameHeader, sampleRate)\r\n\r\n      item.buffer = buffer.subarray(i, i + frameLength)\r\n\r\n      if (i + frameLength > buffer.length) {\r\n        this.cache = buffer.subarray(i)\r\n        this.lastDts = lastDts\r\n        break\r\n      }\r\n\r\n      const duration = avRescaleQ(\r\n        static_cast<int64>(frameLength / sampleRate * AV_TIME_BASE),\r\n        AV_TIME_BASE_Q,\r\n        this.inTimeBase\r\n      )\r\n\r\n      item.duration = Number(duration)\r\n\r\n      this.caches.push(item)\r\n\r\n      i += frameLength\r\n      lastDts += duration\r\n\r\n      if (!firstGot && hasCache) {\r\n        firstGot = true\r\n        lastDts = avpacket.dts || avpacket.pts\r\n      }\r\n    }\r\n    this.lastDts = 0n\r\n\r\n    return 0\r\n  }\r\n\r\n  public receiveAVPacket(avpacket: pointer<AVPacket>): number {\r\n    if (this.caches.length) {\r\n\r\n      unrefAVPacket(avpacket)\r\n\r\n      const item = this.caches.shift()\r\n\r\n      const data = avMalloc(item.buffer.length)\r\n      memcpyFromUint8Array(data, item.buffer.length, item.buffer)\r\n      addAVPacketData(avpacket, data, item.buffer.length)\r\n\r\n      avpacket.dts = avpacket.pts = item.dts\r\n      avpacket.duration = static_cast<int64>(item.duration)\r\n      avpacket.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n      return 0\r\n    }\r\n    else {\r\n      return errorType.EOF\r\n    }\r\n  }\r\n\r\n  public reset(): number {\r\n    this.cache = null\r\n    this.lastDts = 0n\r\n    return 0\r\n  }\r\n}\r\n","/*\r\n * libmedia aac util\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../AVStream'\r\nimport { AVPacketSideDataType } from 'avutil/codec'\r\nimport { NOPTS_VALUE } from 'avutil/constant'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport BitReader from 'common/io/BitReader'\r\nimport { Uint8ArrayInterface } from 'common/io/interface'\r\n\r\nexport const enum MPEG4AudioObjectTypes {\r\n  NULL = 0,\r\n  /**\r\n   * Main-AAC\r\n   */\r\n  AAC_MAIN,\r\n  /**\r\n   * LC-AAC\r\n   */\r\n  AAC_LC,\r\n  AAC_SSR,\r\n  AAC_LTP,\r\n  /**\r\n   * HE-AAC\r\n   */\r\n  AAC_SBR,\r\n  AAC_SCALABLE,\r\n\r\n  LAYER1 = 32,\r\n  LAYER2,\r\n  /**\r\n   * MP3\r\n   */\r\n  LAYER3\r\n}\r\n\r\nexport const AACProfile2Name: Partial<Record<MPEG4AudioObjectTypes, string>> = {\r\n  [MPEG4AudioObjectTypes.AAC_MAIN]: 'Main',\r\n  [MPEG4AudioObjectTypes.AAC_LC]: 'LC',\r\n  [MPEG4AudioObjectTypes.AAC_SSR]: 'LC',\r\n  [MPEG4AudioObjectTypes.AAC_LTP]: 'LC',\r\n  [MPEG4AudioObjectTypes.AAC_SBR]: 'HE',\r\n  [MPEG4AudioObjectTypes.AAC_SCALABLE]: 'HE'\r\n}\r\n\r\nexport const MPEG4SamplingFrequencyIndex = {\r\n  96000: 0,\r\n  88200: 1,\r\n  64000: 2,\r\n  48000: 3,\r\n  44100: 4,\r\n  32000: 5,\r\n  24000: 6,\r\n  22050: 7,\r\n  16000: 8,\r\n  12000: 9,\r\n  11025: 10,\r\n  8000: 11,\r\n  7350: 12\r\n}\r\n\r\nexport const MPEG4SamplingFrequencies = [\r\n  96000,\r\n  88200,\r\n  64000,\r\n  48000,\r\n  44100,\r\n  32000,\r\n  24000,\r\n  22050,\r\n  16000,\r\n  12000,\r\n  11025,\r\n  8000,\r\n  7350,\r\n  NOPTS_VALUE,\r\n  NOPTS_VALUE,\r\n  NOPTS_VALUE\r\n]\r\n\r\nexport const MPEG4Channels = [\r\n  NOPTS_VALUE,\r\n  1,\r\n  2,\r\n  3,\r\n  4,\r\n  5,\r\n  6,\r\n  7\r\n]\r\n\r\n/**\r\n *  AAC AudioSpecificConfig\r\n *    \r\n *             frequency\r\n *              44100Hz        fill bit\r\n *               4 bit          3 bit\r\n *              -------         -----\r\n *    0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0\r\n *    ---------         -------\r\n *      5 bit            4 bit\r\n *     AAC LC           fl, fr\r\n *    profile           channel\r\n * \r\n * url: https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Audio_Specific_Config\r\n * \r\n */\r\n\r\nexport function getAVCodecParameters(extradata: Uint8ArrayInterface) {\r\n  let profile = NOPTS_VALUE\r\n  let sampleRate = NOPTS_VALUE\r\n  let channels = NOPTS_VALUE\r\n  if (extradata.length >= 2) {\r\n    profile = (extradata[0] >> 3) & 0x1f\r\n    sampleRate = MPEG4SamplingFrequencies[((extradata[0] & 0x07) << 1)\r\n      | (extradata[1] >> 7)] ?? 48000\r\n\r\n    channels = MPEG4Channels[(extradata[1] >> 3) & 0x0f] ?? 2\r\n  }\r\n\r\n  return {\r\n    profile,\r\n    sampleRate,\r\n    channels\r\n  }\r\n}\r\n\r\nexport function parseAVCodecParameters(stream: Stream, extradata?: Uint8ArrayInterface) {\r\n  if (!extradata && stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]) {\r\n    extradata = stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]\r\n  }\r\n  if (extradata) {\r\n    const { profile, sampleRate, channels } = getAVCodecParameters(extradata)\r\n    stream.codecpar.profile = profile\r\n    stream.codecpar.sampleRate = sampleRate\r\n    stream.codecpar.chLayout.nbChannels = channels\r\n  }\r\n}\r\n\r\nexport function avCodecParameters2Extradata(codecpar: AVCodecParameters) {\r\n  const samplingFreqIndex = MPEG4SamplingFrequencyIndex[codecpar.sampleRate]\r\n  const channelConfig = codecpar.chLayout.nbChannels\r\n\r\n  const extradata = new Uint8Array(2)\r\n  extradata[0] = ((codecpar.profile & 0x1f) << 3) | ((samplingFreqIndex & 0x0e) >> 1)\r\n  extradata[1] = ((samplingFreqIndex & 0x01) << 7) | ((channelConfig & 0x0f) << 3)\r\n\r\n  return extradata\r\n}\r\n\r\nexport interface AACADTSHeader {\r\n  syncWord: number\r\n  profile: number\r\n  sampleRate: number\r\n  channels: number\r\n  aacFrameLength: number\r\n  numberOfRawDataBlocksInFrame: number\r\n  headerLength: number\r\n  framePayloadLength: number\r\n}\r\n\r\nexport interface AACLATMHeader {\r\n  syncWord: number\r\n  profile: number\r\n  sampleRate: number\r\n  channels: number\r\n  useSameStreamMux: boolean\r\n  headerLength: number\r\n  framePayloadLength: number\r\n  muxLengthBytes: number\r\n}\r\n\r\n/**\r\n * \r\n * adts  raw\r\n * \r\n * bits    \r\n * - 12  syncword\r\n * - 1   ID (MPEG  1)\r\n * - 2   Layer (  0)\r\n * - 1   Protection Absent (  CRC 1 \r\n * - 2   Profile\r\n * - 4   Sampling Frequency Index ( \r\n * - 1   Private Bit (  0)\r\n * - 3   Channel Configuration ( \r\n * - 1   Original Copy (  0)\r\n * - 1   Home (  0)\r\n * - 1   Copyright Identification Bit 0\r\n * - 1   Copyright Identification Start 0\r\n * - 13  Frame Length (  ADTS \r\n * - 11  Buffer Fullness ( \r\n * - 2   Number of Raw Data Blocks in Frame ( \r\n * - 16  CRC (Protection Absent \r\n * - N  raw aac data\r\n * \r\n */\r\nexport function parseADTSHeader(buffer: Uint8ArrayInterface): AACADTSHeader | number {\r\n\r\n  if (buffer.length < 7) {\r\n    return -1\r\n  }\r\n\r\n  const syncWord = (buffer[0] << 4) | (buffer[0 + 1] >> 4)\r\n\r\n  if (syncWord !== 0xFFF) {\r\n    return -1\r\n  }\r\n\r\n  /*\r\n    * const id = (buffer[1] & 0x08) >>> 3\r\n    * const layer = (buffer[1] & 0x06) >>> 1\r\n    */\r\n  const protectionAbsent = buffer[1] & 0x01\r\n  const profile = (buffer[2] & 0xC0) >>> 6\r\n  const samplingFrequencyIndex = (buffer[2] & 0x3C) >>> 2\r\n  const channelConfiguration = ((buffer[2] & 0x01) << 2) | ((buffer[3] & 0xC0) >>> 6)\r\n\r\n  // adts_variable_header()\r\n  const aacFrameLength = ((buffer[3] & 0x03) << 11)\r\n    | (buffer[4] << 3)\r\n    | ((buffer[5] & 0xE0) >>> 5)\r\n\r\n  const numberOfRawDataBlocksInFrame = buffer[6] & 0x03\r\n\r\n  let headerLength = protectionAbsent === 1 ? 7 : 9\r\n  let framePayloadLength = aacFrameLength - headerLength\r\n\r\n  return {\r\n    syncWord,\r\n    profile: profile + 1,\r\n    sampleRate: MPEG4SamplingFrequencies[samplingFrequencyIndex],\r\n    channels: MPEG4Channels[channelConfiguration],\r\n    aacFrameLength,\r\n    numberOfRawDataBlocksInFrame,\r\n    headerLength,\r\n    framePayloadLength\r\n  }\r\n}\r\n\r\nexport function parseLATMHeader(buffer: Uint8ArrayInterface, bitReader?: BitReader) {\r\n  if (!bitReader) {\r\n    bitReader = new BitReader()\r\n    bitReader.appendBuffer(buffer)\r\n  }\r\n\r\n  function getLATMValue() {\r\n    const bytesForValue = bitReader.readU(2)\r\n    let value = 0\r\n\r\n    for (let i = 0; i <= bytesForValue; i++) {\r\n      value = value << 8\r\n      value = value | bitReader.readU(8)\r\n    }\r\n    return value\r\n  }\r\n\r\n  const now = bitReader.getPointer()\r\n\r\n  const info: AACLATMHeader = {\r\n    syncWord: 0,\r\n    profile: 0,\r\n    sampleRate: 0,\r\n    channels: 0,\r\n    useSameStreamMux: false,\r\n    headerLength: 0,\r\n    framePayloadLength: 0,\r\n    muxLengthBytes: 0\r\n  }\r\n\r\n  const syncWord = bitReader.readU(11)\r\n\r\n  if (syncWord !== 0x2B7) {\r\n    return -1\r\n  }\r\n\r\n  info.syncWord = syncWord\r\n\r\n  info.muxLengthBytes = bitReader.readU(13)\r\n\r\n  const useSameStreamMux = bitReader.readU1() === 0x01\r\n\r\n  info.useSameStreamMux = useSameStreamMux\r\n\r\n  if (!useSameStreamMux) {\r\n    const audioMuxVersion = bitReader.readU1() === 0x01\r\n    const audioMuxVersionA = audioMuxVersion && bitReader.readU1() === 0x01\r\n    if (audioMuxVersionA) {\r\n      return -1\r\n    }\r\n    if (audioMuxVersion) {\r\n      getLATMValue()\r\n    }\r\n    const allStreamsSameTimeFraming = bitReader.readU1() === 0x01\r\n    if (!allStreamsSameTimeFraming) {\r\n      return -1\r\n    }\r\n    const numSubFrames = bitReader.readU(6)\r\n    if (numSubFrames !== 0) {\r\n      return -1\r\n    }\r\n\r\n    const numProgram = bitReader.readU(4)\r\n    if (numProgram !== 0) {\r\n      return -1\r\n    }\r\n\r\n    const numLayer = bitReader.readU(3)\r\n    if (numLayer !== 0) {\r\n      return -1\r\n    }\r\n\r\n    let fillBits = audioMuxVersion ? getLATMValue() : 0\r\n\r\n    const audioObjectType = bitReader.readU(5)\r\n    fillBits -= 5\r\n\r\n    const samplingFreqIndex = bitReader.readU(4)\r\n    fillBits -= 4\r\n\r\n    const channelConfig = bitReader.readU(4)\r\n    fillBits -= 4\r\n\r\n    bitReader.readU(3)\r\n    fillBits -= 3\r\n\r\n    if (fillBits > 0) {\r\n      bitReader.readU(fillBits)\r\n    }\r\n\r\n    const frameLengthType = bitReader.readU(3)\r\n    if (frameLengthType === 0) {\r\n      bitReader.readU(8)\r\n    }\r\n    else {\r\n      return -1\r\n    }\r\n\r\n    const otherDataPresent = bitReader.readU1() === 0x01\r\n    if (otherDataPresent) {\r\n      if (audioMuxVersion) {\r\n        getLATMValue()\r\n      }\r\n      else {\r\n        let otherDataLenBits = 0\r\n        while (true) {\r\n          otherDataLenBits = otherDataLenBits << 8\r\n          const otherDataLenEsc = bitReader.readU1() === 0x01\r\n          const otherDataLenTmp = bitReader.readU(8)\r\n          otherDataLenBits += otherDataLenTmp\r\n          if (!otherDataLenEsc) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const crcCheckPresent = bitReader.readU1() === 0x01\r\n    if (crcCheckPresent) {\r\n      bitReader.readU(8)\r\n    }\r\n\r\n    info.profile = audioObjectType + 1\r\n    info.sampleRate = MPEG4SamplingFrequencies[samplingFreqIndex]\r\n    info.channels = MPEG4Channels[channelConfig]\r\n  }\r\n\r\n  let length = 0\r\n  while (true) {\r\n    const tmp = bitReader.readU(8)\r\n    length += tmp\r\n    if (tmp !== 0xff) {\r\n      break\r\n    }\r\n  }\r\n\r\n  info.framePayloadLength = length\r\n  info.headerLength = bitReader.getPointer() - now + (bitReader.getBitLeft() === 8 ? 0 : 1)\r\n\r\n  return info\r\n}\r\n","/*\r\n * libmedia ac3 util\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { AV_CH_LAYOUT } from 'avutil/audiosamplefmt'\r\nimport BitReader from 'common/io/BitReader'\r\nimport { Uint8ArrayInterface } from 'common/io/interface'\r\n\r\nexport const enum AC3DeltaStrategy {\r\n  DBA_REUSE = 0,\r\n  DBA_NEW,\r\n  DBA_NONE,\r\n  DBA_RESERVED\r\n}\r\n\r\nexport const enum AC3ChannelMode {\r\n  AC3_CHMODE_DUALMONO = 0,\r\n  AC3_CHMODE_MONO,\r\n  AC3_CHMODE_STEREO,\r\n  AC3_CHMODE_3F,\r\n  AC3_CHMODE_2F1R,\r\n  AC3_CHMODE_3F1R,\r\n  AC3_CHMODE_2F2R,\r\n  AC3_CHMODE_3F2R\r\n}\r\n\r\nexport const enum AC3DolbySurroundMode {\r\n  AC3_DSURMOD_NOTINDICATED = 0,\r\n  AC3_DSURMOD_OFF,\r\n  AC3_DSURMOD_ON,\r\n  AC3_DSURMOD_RESERVED\r\n}\r\n\r\nexport const enum AC3DolbySurroundEXMode {\r\n  AC3_DSUREXMOD_NOTINDICATED = 0,\r\n  AC3_DSUREXMOD_OFF,\r\n  AC3_DSUREXMOD_ON,\r\n  AC3_DSUREXMOD_PLIIZ\r\n}\r\n\r\nexport const enum AC3DolbyHeadphoneMode {\r\n  AC3_DHEADPHONMOD_NOTINDICATED = 0,\r\n  AC3_DHEADPHONMOD_OFF,\r\n  AC3_DHEADPHONMOD_ON,\r\n  AC3_DHEADPHONMOD_RESERVED\r\n}\r\n\r\nexport const enum AC3PreferredStereoDownmixMode {\r\n  AC3_DMIXMOD_NOTINDICATED = 0,\r\n  AC3_DMIXMOD_LTRT,\r\n  AC3_DMIXMOD_LORO,\r\n  // reserved value in A/52, but used by encoders to indicate DPL2\r\n  AC3_DMIXMOD_DPLII\r\n}\r\n\r\nexport const enum EAC3FrameType {\r\n  EAC3_FRAME_TYPE_INDEPENDENT = 0,\r\n  EAC3_FRAME_TYPE_DEPENDENT,\r\n  EAC3_FRAME_TYPE_AC3_CONVERT,\r\n  EAC3_FRAME_TYPE_RESERVED\r\n}\r\n\r\nexport const AC3ChannelLayout = [\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_STEREO,\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_MONO,\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_STEREO,\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_SURROUND,\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_2_1,\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_4POINT0,\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_2_2,\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_5POINT0\r\n]\r\n\r\nexport interface AC3HeaderInfo {\r\n  syncWord: uint16\r\n  crc1: uint16\r\n  srCode: uint8\r\n  bitstreamId: uint8\r\n  bitstreamMode: uint8\r\n  channelMode: uint8\r\n  lfeOn: uint8\r\n  frameType: uint8\r\n  substreamId: int32\r\n  centerMixLevel: int32\r\n  surroundMixLevel: int32\r\n  channelMap: uint16\r\n  numBlocks: int32\r\n  dolbySurroundMode: int32\r\n  srShift: uint8\r\n  sampleRate: uint16\r\n  bitrate: uint32\r\n  channels: uint8\r\n  frameSize: uint16\r\n  channelLayout: uint64\r\n  ac3BitrateCode: int8\r\n}\r\n\r\nconst AC3FrameSizeTab = [\r\n  [ 64,   69,   96   ],\r\n  [ 64,   70,   96   ],\r\n  [ 80,   87,   120  ],\r\n  [ 80,   88,   120  ],\r\n  [ 96,   104,  144  ],\r\n  [ 96,   105,  144  ],\r\n  [ 112,  121,  168  ],\r\n  [ 112,  122,  168  ],\r\n  [ 128,  139,  192  ],\r\n  [ 128,  140,  192  ],\r\n  [ 160,  174,  240  ],\r\n  [ 160,  175,  240  ],\r\n  [ 192,  208,  288  ],\r\n  [ 192,  209,  288  ],\r\n  [ 224,  243,  336  ],\r\n  [ 224,  244,  336  ],\r\n  [ 256,  278,  384  ],\r\n  [ 256,  279,  384  ],\r\n  [ 320,  348,  480  ],\r\n  [ 320,  349,  480  ],\r\n  [ 384,  417,  576  ],\r\n  [ 384,  418,  576  ],\r\n  [ 448,  487,  672  ],\r\n  [ 448,  488,  672  ],\r\n  [ 512,  557,  768  ],\r\n  [ 512,  558,  768  ],\r\n  [ 640,  696,  960  ],\r\n  [ 640,  697,  960  ],\r\n  [ 768,  835,  1152 ],\r\n  [ 768,  836,  1152 ],\r\n  [ 896,  975,  1344 ],\r\n  [ 896,  976,  1344 ],\r\n  [ 1024, 1114, 1536 ],\r\n  [ 1024, 1115, 1536 ],\r\n  [ 1152, 1253, 1728 ],\r\n  [ 1152, 1254, 1728 ],\r\n  [ 1280, 1393, 1920 ],\r\n  [ 1280, 1394, 1920 ],\r\n]\r\n\r\nconst CenterLevelsTab = [4, 5, 6, 5]\r\nconst SurroundLevelsTab = [4, 6, 7, 6]\r\nconst AC3SampleRateTab = [48000, 44100, 32000, 0]\r\nconst AC3BitrateTab = [\r\n  32, 40, 48, 56, 64, 80, 96, 112, 128,\r\n  160, 192, 224, 256, 320, 384, 448, 512, 576, 640\r\n]\r\nconst AC3ChannelsTab = [\r\n  2, 1, 2, 3, 3, 4, 4, 5\r\n]\r\n\r\nconst EAC3Blocks = [\r\n  1, 2, 3, 6\r\n]\r\n\r\nconst AC3_HEADER_SIZE = 7\r\n\r\nexport function parseHeader(buf: Uint8ArrayInterface) {\r\n  const bitReader = new BitReader(buf.length)\r\n  bitReader.appendBuffer(buf)\r\n\r\n  const info: AC3HeaderInfo = {\r\n    syncWord: 0,\r\n    crc1: 0,\r\n    srCode: 0,\r\n    bitstreamId: 0,\r\n    bitstreamMode: 0,\r\n    channelMode: 0,\r\n    lfeOn: 0,\r\n    frameType: 0,\r\n    substreamId: 0,\r\n    centerMixLevel: 0,\r\n    surroundMixLevel: 0,\r\n    channelMap: 0,\r\n    numBlocks: 0,\r\n    dolbySurroundMode: 0,\r\n    srShift: 0,\r\n    sampleRate: 0,\r\n    bitrate: 0,\r\n    channels: 0,\r\n    frameSize: 0,\r\n    channelLayout: 0n,\r\n    ac3BitrateCode: 0\r\n  }\r\n\r\n  info.syncWord = bitReader.readU(16)\r\n\r\n  if (info.syncWord !== 0x0B77) {\r\n    return -1\r\n  }\r\n\r\n  info.bitstreamId = bitReader.peekU(29) & 0x1f\r\n\r\n  if (info.bitstreamId > 16) {\r\n    return -2\r\n  }\r\n\r\n  info.numBlocks = 6\r\n  info.ac3BitrateCode = -1\r\n  info.centerMixLevel = 5\r\n  info.surroundMixLevel = 6\r\n\r\n  info.dolbySurroundMode = AC3DolbySurroundMode.AC3_DSURMOD_NOTINDICATED\r\n\r\n  if (info.bitstreamId <= 10) {\r\n    info.crc1 = bitReader.readU(16)\r\n    info.srCode = bitReader.readU(2)\r\n\r\n    if (info.srCode === 3) {\r\n      return -3\r\n    }\r\n\r\n    const frameSizeCode = bitReader.readU(6)\r\n    if (frameSizeCode > 37) {\r\n      return -4\r\n    }\r\n\r\n    info.ac3BitrateCode = (frameSizeCode >> 1)\r\n\r\n    bitReader.readU(5)\r\n\r\n    info.bitstreamMode = bitReader.readU(3)\r\n    info.channelMode = bitReader.readU(3)\r\n\r\n    if (info.channelMode == AC3ChannelMode.AC3_CHMODE_STEREO) {\r\n      info.dolbySurroundMode = bitReader.readU(2)\r\n    }\r\n    else {\r\n      if ((info.channelMode & 1) && info.channelMode != AC3ChannelMode.AC3_CHMODE_MONO) {\r\n        info.centerMixLevel = CenterLevelsTab[bitReader.readU(2)]\r\n      }\r\n      if (info.channelMode & 4) {\r\n        info.surroundMixLevel = SurroundLevelsTab[bitReader.readU(2)]\r\n      }\r\n    }\r\n    info.lfeOn = bitReader.readU(1)\r\n\r\n    info.srShift = Math.max(info.bitstreamId, 8) - 8\r\n    info.sampleRate = AC3SampleRateTab[info.srCode] >> info.srShift\r\n    info.bitrate = (AC3BitrateTab[info.ac3BitrateCode] * 1000) >> info.srShift\r\n    info.channels = AC3ChannelsTab[info.channelMode] + info.lfeOn\r\n    info.frameSize = AC3FrameSizeTab[frameSizeCode][info.srCode] * 2\r\n    info.frameType = EAC3FrameType.EAC3_FRAME_TYPE_AC3_CONVERT\r\n    info.substreamId = 0\r\n  }\r\n  else {\r\n    /* Enhanced AC-3 */\r\n    info.crc1 = 0\r\n    info.frameType = bitReader.readU(2)\r\n    if (info.frameType == EAC3FrameType.EAC3_FRAME_TYPE_RESERVED) {\r\n      return -5\r\n    }\r\n    info.substreamId = bitReader.readU(3)\r\n\r\n    info.frameSize = (bitReader.readU(11) + 1) << 1\r\n    if (info.frameSize < AC3_HEADER_SIZE) {\r\n      return -6\r\n    }\r\n\r\n    info.srCode = bitReader.readU(2)\r\n    if (info.srCode == 3) {\r\n      const srCode2 = bitReader.readU(2)\r\n      if (srCode2 == 3) {\r\n        return -7\r\n      }\r\n      info.sampleRate = AC3SampleRateTab[srCode2] / 2\r\n      info.srShift = 1\r\n    }\r\n    else {\r\n      info.numBlocks = EAC3Blocks[bitReader.readU(2)]\r\n      info.sampleRate = AC3SampleRateTab[info.srCode]\r\n      info.srShift = 0\r\n    }\r\n\r\n    info.channelMode = bitReader.readU(3)\r\n    info.lfeOn = bitReader.readU(1)\r\n\r\n    info.bitrate = 8 * info.frameSize * info.sampleRate / (info.numBlocks * 256)\r\n    info.channels = AC3ChannelsTab[info.channelMode] + info.lfeOn\r\n  }\r\n  info.channelLayout = static_cast<uint64>(AC3ChannelLayout[info.channelMode] as uint32)\r\n  if (info.lfeOn) {\r\n    info.channelLayout |= static_cast<uint64>(AV_CH_LAYOUT.AV_CH_LOW_FREQUENCY as uint32)\r\n  }\r\n\r\n  return info\r\n}\r\n","/*\r\n * libmedia dts util\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport BitReader from 'common/io/BitReader'\r\nimport { Uint8ArrayInterface } from 'common/io/interface'\r\nimport align from 'common/math/align'\r\n\r\nconst DTSChannelTab = [1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8]\r\n\r\nconst DTSSampleRateTab = [0, 8000, 16000, 32000, 0, 0, 11025, 22050, 44100, 0, 0, 12000, 24000, 48000, 96000, 192000]\r\n\r\nconst DTSBitrateTab = [32000, 56000, 64000, 96000, 112000, 128000, 192000, 224000, 256000, 320000, 384000, 448000,\r\n  512000, 576000, 640000, 768000, 960000, 1024000, 1152000, 1280000, 1344000, 1408000, 1411200, 1472000, 1536000,\r\n  1920000, 2048000, 3072000, 3840000, 0, 0, 0\r\n]\r\n\r\nexport const DTS_PCMBLOCK_SAMPLES = 32\r\n\r\nexport interface DTSHeaderInfo {\r\n  syncWord: uint32\r\n  frameType: int32\r\n  deficitSamples: int32\r\n  crcFlag: int32\r\n  sampleBlock: int32\r\n  frameSize: int32\r\n  channelIndex: int32\r\n  sampleRateIndex: int32\r\n  bitrateIndex: int32\r\n\r\n  channels: int32\r\n  sampleRate: int32\r\n  bitrate: int32\r\n}\r\n\r\nexport function parseHeader(buf: Uint8ArrayInterface) {\r\n  const bitReader = new BitReader(buf.length)\r\n  bitReader.appendBuffer(buf)\r\n\r\n  const info: DTSHeaderInfo = {\r\n    syncWord: 0,\r\n    frameType: 0,\r\n    deficitSamples: 0,\r\n    crcFlag: 0,\r\n    sampleBlock: 0,\r\n    frameSize: 0,\r\n    channelIndex: 0,\r\n    sampleRateIndex: 0,\r\n    bitrateIndex: 0,\r\n\r\n    channels: 0,\r\n    sampleRate: 0,\r\n    bitrate: 0\r\n  }\r\n\r\n  info.syncWord = bitReader.readU(32)\r\n\r\n  if (info.syncWord !== 0x7ffe8001 && info.syncWord !== 0xfe7f0180) {\r\n    return -1\r\n  }\r\n\r\n  info.frameType = bitReader.readU1()\r\n  info.deficitSamples = bitReader.readU(5) + 1\r\n  info.crcFlag = bitReader.readU1()\r\n  info.sampleBlock = bitReader.readU(7) + 1\r\n  info.frameSize = align(bitReader.readU(14) + 1, 4)\r\n  info.channelIndex = bitReader.readU(6)\r\n  info.sampleRateIndex = bitReader.readU(4)\r\n  info.bitrateIndex = bitReader.readU(5)\r\n\r\n  info.channels = DTSChannelTab[info.channelIndex]\r\n  info.sampleRate = DTSSampleRateTab[info.sampleRateIndex]\r\n  info.bitrate = DTSBitrateTab[info.bitrateIndex]\r\n\r\n  return info\r\n}\r\n","/*\r\n * libmedia mp3 util\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { Uint8ArrayInterface } from 'common/io/interface'\r\nimport AVStream from '../AVStream'\r\nimport { NOPTS_VALUE } from 'avutil/constant'\r\n\r\nconst MpegAudioV10SampleRateTable = [44100, 48000, 32000, 0]\r\n\r\nconst MpegAudioV20SampleRateTable = [22050, 24000, 16000, 0]\r\n\r\nconst MpegAudioV25SampleRateTable = [11025, 12000, 8000, 0]\r\n\r\nconst MpegAudioV10FrameSizeTable = [0, 1152, 1152, 384]\r\n\r\nconst MpegAudioV20FrameSizeTable = [0, 576, 1152, 384]\r\n\r\nconst MpegAudioV25FrameSizeTable = [0, 576, 1152, 384]\r\n\r\nconst MpegAudioV1L1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1]\r\n\r\nconst MpegAudioV1L2BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1]\r\n\r\nconst MpegAudioV1L3BitRateTable = [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1]\r\n\r\nconst MpegAudioV2L1BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, -1]\r\n\r\nconst MpegAudioV2L2L3BitRateTable = [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1]\r\n\r\nexport function getSampleRateByVersionIndex(version: number, samplingFreqIndex: number) {\r\n  switch (version) {\r\n    case 0:\r\n      // MPEG 2.5\r\n      return MpegAudioV25SampleRateTable[samplingFreqIndex]\r\n    case 2:\r\n      // MPEG 2\r\n      return MpegAudioV20SampleRateTable[samplingFreqIndex]\r\n    case 3:\r\n      // MPEG 1\r\n      return MpegAudioV10SampleRateTable[samplingFreqIndex]\r\n  }\r\n  return NOPTS_VALUE\r\n}\r\n\r\nexport function getFrameSizeByVersionLayer(version: number, layer: number) {\r\n  switch (version) {\r\n    case 0:\r\n      // MPEG 2.5\r\n      return MpegAudioV25FrameSizeTable[layer]\r\n    case 2:\r\n      // MPEG 2\r\n      return MpegAudioV20FrameSizeTable[layer]\r\n    case 3:\r\n      // MPEG 1\r\n      return MpegAudioV10FrameSizeTable[layer]\r\n  }\r\n  return NOPTS_VALUE\r\n}\r\n\r\nexport function getBitRateByVersionLayerIndex(version: number, layer: number, index: number) {\r\n\r\n  switch (layer) {\r\n    // layer3\r\n    case 1:\r\n      switch (version) {\r\n        case 0:\r\n        case 2:\r\n          return MpegAudioV2L2L3BitRateTable[index]\r\n        case 3:\r\n          return MpegAudioV1L3BitRateTable[index]\r\n      }\r\n      break\r\n    // layer2\r\n    case 2:\r\n      switch (version) {\r\n        case 0:\r\n        case 2:\r\n          return MpegAudioV2L2L3BitRateTable[index]\r\n        case 3:\r\n          return MpegAudioV1L2BitRateTable[index]\r\n      }\r\n    // layer1\r\n    case 3:\r\n      switch (version) {\r\n        case 0:\r\n        case 2:\r\n          return MpegAudioV2L1BitRateTable[index]\r\n        case 3:\r\n          return MpegAudioV1L1BitRateTable[index]\r\n      }\r\n  }\r\n  return NOPTS_VALUE\r\n}\r\n\r\nexport function getProfileByLayer(layer: number) {\r\n  switch (layer) {\r\n    case 1:\r\n      // Layer 3\r\n      return 34\r\n    case 2:\r\n      // Layer 2\r\n      return 33\r\n    case 3:\r\n      // Layer 1\r\n      return 32\r\n  }\r\n  return NOPTS_VALUE\r\n}\r\n\r\nexport const enum MP3Profile {\r\n  Layer1 = 32,\r\n  Layer2 = 33,\r\n  Layer3 = 34\r\n}\r\n\r\nexport const MP3Profile2Name: Record<MP3Profile, string> = {\r\n  [MP3Profile.Layer1]: 'Layer1',\r\n  [MP3Profile.Layer2]: 'Layer2',\r\n  [MP3Profile.Layer3]: 'Layer3'\r\n}\r\n\r\n\r\nexport function parseAVCodecParameters(stream: AVStream, buffer: Uint8ArrayInterface) {\r\n  if (buffer && buffer.length >= 4) {\r\n    const ver = (buffer[1] >>> 3) & 0x03\r\n    const layer = (buffer[1] & 0x06) >> 1\r\n    // const bitrateIndex = (buffer[2] & 0xF0) >>> 4\r\n    const samplingFreqIndex = (buffer[2] & 0x0C) >>> 2\r\n\r\n    const channelMode = (buffer[3] >>> 6) & 0x03\r\n\r\n    const channelCount = channelMode !== 3 ? 2 : 1\r\n    const profile = getProfileByLayer(layer)\r\n    const sampleRate = getSampleRateByVersionIndex(ver, samplingFreqIndex)\r\n\r\n    stream.codecpar.profile = profile\r\n    stream.codecpar.sampleRate = sampleRate\r\n    stream.codecpar.chLayout.nbChannels = channelCount\r\n  }\r\n}\r\n","/*\r\n * libmedia mpegvideo util\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { getAVPacketData } from 'avutil/util/avpacket'\r\n\r\nexport const enum MpegVideoPictureType {\r\n  I = 1,\r\n  P,\r\n  B\r\n}\r\n\r\nexport function isIDR(avpacket: pointer<AVPacket>) {\r\n  const data = getAVPacketData(avpacket)\r\n\r\n  for (let i = 0; i < data.length - 6; i++) {\r\n    if (data[i] === 0\r\n      && data[i + 1] === 0\r\n      && data[i + 2] === 1\r\n      && data[i + 3] === 0\r\n    ) {\r\n      const picType = (data[i + 5] >> 3) & 7\r\n      return picType === MpegVideoPictureType.I\r\n    }\r\n  }\r\n  return false\r\n}\r\n","/*\r\n * libmedia opus util\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { AVPacketSideDataType } from 'avutil/codec'\r\nimport AVStream from '../AVStream'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport BufferReader from 'common/io/BufferReader'\r\nimport BufferWriter from 'common/io/BufferWriter'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { Uint8ArrayInterface } from 'common/io/interface'\r\n\r\nexport const durations = [\r\n  /* Silk NB */\r\n  480, 960, 1920, 2880,\r\n  /* Silk MB */\r\n  480, 960, 1920, 2880,\r\n  /* Silk WB */\r\n  480, 960, 1920, 2880,\r\n  /* Hybrid SWB */\r\n  480, 960,\r\n  /* Hybrid FB */\r\n  480, 960,\r\n  /* CELT NB */\r\n  120, 240, 480, 960,\r\n  /* CELT NB */\r\n  120, 240, 480, 960,\r\n  /* CELT NB */\r\n  120, 240, 480, 960,\r\n  /* CELT NB */\r\n  120, 240, 480, 960\r\n]\r\n\r\n\r\nexport function getBufferSamples(buffer: Uint8Array) {\r\n  let toc = 0, frameDuration = 0, nframes = 0\r\n\r\n  if (buffer.length < 1) {\r\n    return 0\r\n  }\r\n\r\n  toc = buffer[0]\r\n\r\n  frameDuration = durations[toc >> 3]\r\n\r\n  switch (toc & 3) {\r\n    case 0:\r\n      nframes = 1\r\n      break\r\n    case 1:\r\n      nframes = 2\r\n      break\r\n    case 2:\r\n      nframes = 2\r\n      break\r\n    case 3:\r\n      if (buffer.length < 2) {\r\n        return 0\r\n      }\r\n      nframes = buffer[1] & 63\r\n      break\r\n  }\r\n  return nframes * frameDuration\r\n}\r\n\r\n/**\r\n * opus extradata\r\n * \r\n * - 8 bytes Magic Signature: OpusHead\r\n * - 1 bytes unsigned,  0x01 version\r\n * - 1 bytes unsigned, channels   packet-by-packet,  0x01\r\n * - 2 bytes unsigned, preSkip   PCM \r\n * - 4 bytes unsigned, sampleRate \r\n * - 2 bytes signed, outputGain  20 * log10 \r\n * - 1 bytes unsigned, channelMappingFamily \r\n * - channelMappingTable   Channel Mapping Family  0 \r\n *  - 1 bytes, streamCount, unsigned ogg packet  stream\r\n *  - 1 bytes, coupledStreamCount, unsigned  streamCount\r\n *  - C bytes, C  coupledStreamCount + streamCount\r\n * \r\n */\r\nexport function parseAVCodecParameters(stream: AVStream, extradata?: Uint8ArrayInterface) {\r\n  if (!extradata && stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]) {\r\n    extradata = stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]\r\n  }\r\n  if (extradata && extradata.length >= 19) {\r\n    const reader = new BufferReader(extradata, false)\r\n    reader.skip(9)\r\n    stream.codecpar.chLayout.nbChannels = reader.readUint8()\r\n    stream.codecpar.initialPadding = reader.readUint16()\r\n    stream.codecpar.sampleRate = reader.readUint32()\r\n\r\n    stream.codecpar.seekPreroll = Number(avRescaleQ(\r\n      80n,\r\n      {\r\n        den: 1000,\r\n        num: 1\r\n      },\r\n      {\r\n        den: 48000,\r\n        num: 1\r\n      }\r\n    ))\r\n  }\r\n}\r\n\r\nexport function avCodecParameters2Extradata(codecpar: AVCodecParameters) {\r\n  const extradata = new Uint8Array(19)\r\n\r\n  const writer = new BufferWriter(extradata, false)\r\n\r\n  writer.writeString('OpusHead')\r\n  writer.writeUint8(0x01)\r\n  writer.writeUint8(codecpar.chLayout.nbChannels)\r\n  writer.writeUint16(codecpar.initialPadding)\r\n  writer.writeUint32(codecpar.sampleRate)\r\n\r\n  return extradata\r\n}\r\n","/*\r\n * libmedia abstract format decoder\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVFormat } from '../avformat'\r\n\r\nexport default abstract class IFormat {\r\n\r\n  public type: AVFormat = AVFormat.UNKNOWN\r\n\r\n  public onStreamAdd: (stream: Stream) => void\r\n\r\n  public abstract init(formatContext: AVIFormatContext): void\r\n\r\n  public destroy(formatContext: AVIFormatContext): void {}\r\n\r\n  public abstract getAnalyzeStreamsCount(): number\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readHeader(formatContext: AVIFormatContext): Promise<number>\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number>\r\n\r\n  /**\r\n   * seek\r\n   * \r\n   * @param context \r\n   * @param stream \r\n   * @param timestamp \r\n   * @param flags \r\n   * \r\n   * @returns  seek  avpacket pos 0n  seek  seek \r\n   */\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract seek(\r\n    formatContext: AVIFormatContext,\r\n    stream: Stream,\r\n    timestamp: int64,\r\n    flags: int32\r\n  ): Promise<int64>\r\n}\r\n","/*\r\n * libmedia mpegps decoder\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVPacket, { AVPacketFlags } from 'avutil/struct/avpacket'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport * as logger from 'common/util/logger'\r\n\r\nimport { IOError } from 'common/io/error'\r\nimport { MpegpsContext, MpegpsSlice, MpegpsStreamContext } from './mpegts/type'\r\nimport * as mpegts from './mpegts/mpegts'\r\nimport * as errorType from 'avutil/error'\r\nimport parsePES from './mpegts/function/parsePES'\r\nimport { PES } from './mpegts/struct'\r\nimport IFormat from './IFormat'\r\nimport { AVFormat, AVSeekFlags } from '../avformat'\r\nimport { addAVPacketData, createAVPacket, deleteAVPacketSideData,\r\n  destroyAVPacket, getAVPacketData, getAVPacketSideData\r\n} from 'avutil/util/avpacket'\r\nimport { AV_MILLI_TIME_BASE_Q, NOPTS_VALUE, NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\nimport AVStream from '../AVStream'\r\nimport seekInBytes from '../function/seekInBytes'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport * as array from 'common/util/array'\r\nimport * as object from 'common/util/object'\r\nimport * as mp3 from '../codecs/mp3'\r\nimport * as h264 from '../codecs/h264'\r\nimport * as hevc from '../codecs/hevc'\r\nimport * as vvc from '../codecs/vvc'\r\nimport * as aac from '../codecs/aac'\r\nimport * as opus from '../codecs/opus'\r\nimport * as ac3 from '../codecs/ac3'\r\nimport * as dts from '../codecs/dts'\r\nimport * as mpegvideo from '../codecs/mpegvideo'\r\nimport { AVCodecID, AVMediaType, AVPacketSideDataType } from 'avutil/codec'\r\nimport { avMalloc } from 'avutil/util/mem'\r\nimport { memcpy, mapSafeUint8Array, memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport * as mpegps from './mpegts/mpegps'\r\nimport { AV_CH_LAYOUT, AVChannelOrder } from 'avutil/audiosamplefmt'\r\nimport concatTypeArray from 'common/function/concatTypeArray'\r\nimport * as nalu from 'avutil/util/nalu'\r\nimport Mp32RawFilter from '../bsf/mp3/Mp32RawFilter'\r\nimport { FrameHeader } from './mp3/frameHeader'\r\nimport * as mp3FrameHeader from '../formats/mp3/frameHeader'\r\nimport { IOFlags } from 'common/io/flags'\r\nimport * as is from 'common/util/is'\r\nimport Ac32RawFilter from '../bsf/ac3/Ac32RawFilter'\r\nimport Dts2RawFilter from '../bsf/dts/Dts2RawFilter'\r\nimport ADTS2RawFilter from '../bsf/aac/ADTS2RawFilter'\r\n\r\nexport default class IMpegpsFormat extends IFormat {\r\n\r\n  public type: AVFormat = AVFormat.MPEGPS\r\n\r\n  private context: MpegpsContext\r\n\r\n  private cacheAVPacket: pointer<AVPacket>\r\n\r\n  constructor() {\r\n    super()\r\n    this.context = {\r\n      headerState: 0xff,\r\n      psmType: new Map(),\r\n      pes: new PES(),\r\n      slices: new Map(),\r\n      lastPtsMap: new Map(),\r\n      imkhCctv: false,\r\n      sofdec: false,\r\n      ioEnded: false,\r\n      paddingPES: null\r\n    }\r\n  }\r\n\r\n  public init(formatContext: AVIFormatContext): void {\r\n    if (formatContext.ioReader) {\r\n      formatContext.ioReader.setEndian(true)\r\n    }\r\n    this.cacheAVPacket = nullptr\r\n  }\r\n\r\n  public destroy(formatContext: AVIFormatContext): void {\r\n    super.destroy(formatContext)\r\n    if (this.cacheAVPacket) {\r\n      destroyAVPacket(this.cacheAVPacket)\r\n      this.cacheAVPacket = nullptr\r\n    }\r\n    array.each(formatContext.streams, (stream) => {\r\n      const streamContext = stream.privData as MpegpsStreamContext\r\n      if (streamContext.filter) {\r\n        streamContext.filter.destroy()\r\n        streamContext.filter = null\r\n      }\r\n    })\r\n  }\r\n\r\n  @deasync\r\n  private async findNextStartCode(formatContext: AVIFormatContext) {\r\n    let code = 0xff\r\n    let n = 0\r\n    while (n < mpegps.MAX_SYNC_SIZE) {\r\n      const v = await formatContext.ioReader.readUint8()\r\n      if (code === 0x000001) {\r\n        code = ((code << 8) | v) & 0xffffff\r\n        break\r\n      }\r\n      code = ((code << 8) | v) & 0xffffff\r\n      n++\r\n    }\r\n    if (n === mpegps.MAX_SYNC_SIZE) {\r\n      code = -1\r\n    }\r\n    this.context.headerState = code\r\n    return code\r\n  }\r\n\r\n  @deasync\r\n  private async parsePSM(formatContext: AVIFormatContext) {\r\n    const psmLength = await formatContext.ioReader.readUint16()\r\n    await formatContext.ioReader.skip(2)\r\n    const psInfoLength = await formatContext.ioReader.readUint16()\r\n    await formatContext.ioReader.skip(psInfoLength)\r\n    // es_map_length\r\n    await formatContext.ioReader.readUint16()\r\n    let esMapLength = psmLength - psInfoLength - 10\r\n    while (esMapLength >= 4) {\r\n      const type = await formatContext.ioReader.readUint8()\r\n      const id = await formatContext.ioReader.readUint8()\r\n      const length = await formatContext.ioReader.readUint16()\r\n      this.context.psmType.set(id, type)\r\n      await formatContext.ioReader.skip(length)\r\n      esMapLength -= (length + 4)\r\n    }\r\n    // crc32\r\n    await formatContext.ioReader.readUint32()\r\n  }\r\n\r\n  @deasync\r\n  private async readPES(formatContext: AVIFormatContext) {\r\n    while (true) {\r\n      const startCode = await this.findNextStartCode(formatContext)\r\n      if (startCode < 0) {\r\n        return errorType.DATA_INVALID\r\n      }\r\n      if (startCode === mpegps.MpegpsStartCode.PACK_START\r\n        || startCode === mpegps.MpegpsStartCode.SYSTEM_HEADER_START\r\n      ) {\r\n        continue\r\n      }\r\n      if (startCode === mpegps.MpegpsStartCode.PADDING_STREAM\r\n        || startCode === mpegps.MpegpsStartCode.PRIVATE_STREAM_2\r\n      ) {\r\n        const len = await formatContext.ioReader.readUint16()\r\n        await formatContext.ioReader.skip(len)\r\n        continue\r\n      }\r\n      if (startCode === mpegps.MpegpsStartCode.PROGRAM_STREAM_MAP) {\r\n        await this.parsePSM(formatContext)\r\n        continue\r\n      }\r\n      if (!((startCode >= 0x1c0 && startCode <= 0x1df)\r\n        || (startCode >= 0x1e0 && startCode <= 0x1ef)\r\n        || (startCode == 0x1bd)\r\n        || (startCode == mpegps.MpegpsStartCode.PRIVATE_STREAM_2)\r\n        || (startCode == 0x1fd))\r\n      ) {\r\n        continue\r\n      }\r\n\r\n      const len = await formatContext.ioReader.readUint16()\r\n\r\n      this.context.pes.pos = formatContext.ioReader.getPos() - 6n\r\n      this.context.pes.streamId = startCode & 0xff\r\n      this.context.pes.streamType = this.context.psmType[this.context.pes.streamId]\r\n\r\n      const data = new Uint8Array(len + 6)\r\n\r\n      data[0] = 0\r\n      data[1] = 0\r\n      data[2] = 1\r\n      data[3] = this.context.pes.streamId\r\n      data[4] = len >> 8\r\n      data[5] = len & 0xff\r\n      await formatContext.ioReader.readBuffer(len, data.subarray(6))\r\n\r\n      this.context.pes.data = data\r\n\r\n      return startCode\r\n    }\r\n  }\r\n\r\n  private createStream(formatContext: AVIFormatContext, streamType: int32, streamId: int32, startCode: int32) {\r\n\r\n    let codecId: AVCodecID = AVCodecID.AV_CODEC_ID_NONE\r\n    let type: AVMediaType = AVMediaType.AVMEDIA_TYPE_UNKNOWN\r\n\r\n    switch (streamId) {\r\n      case mpegps.MpegpsStreamId.H264_ID:\r\n        type = AVMediaType.AVMEDIA_TYPE_VIDEO\r\n        codecId = AVCodecID.AV_CODEC_ID_H264\r\n        break\r\n      case mpegps.MpegpsStreamId.AC3_ID:\r\n        type = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n        codecId = AVCodecID.AV_CODEC_ID_AC3\r\n        break\r\n      case mpegps.MpegpsStreamId.DTS_ID:\r\n        type = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n        codecId = AVCodecID.AV_CODEC_ID_DTS\r\n        break\r\n      case mpegps.MpegpsStreamId.LPCM_ID:\r\n        type = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n        codecId = AVCodecID.AV_CODEC_ID_PCM_S16BE\r\n        break\r\n      case mpegps.MpegpsStreamId.SUB_ID:\r\n        type = AVMediaType.AVMEDIA_TYPE_SUBTITLE\r\n        codecId = AVCodecID.AV_CODEC_ID_DVD_SUBTITLE\r\n        break\r\n      default: {\r\n        switch (streamType) {\r\n          case mpegts.TSStreamType.VIDEO_MPEG1:\r\n          case mpegts.TSStreamType.VIDEO_MPEG2:\r\n            type = AVMediaType.AVMEDIA_TYPE_VIDEO\r\n            codecId = AVCodecID.AV_CODEC_ID_MPEG2VIDEO\r\n            break\r\n          case mpegts.TSStreamType.AUDIO_MPEG1:\r\n          case mpegts.TSStreamType.AUDIO_MPEG2:\r\n            type = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n            codecId = AVCodecID.AV_CODEC_ID_MP3\r\n            break\r\n          case mpegts.TSStreamType.AUDIO_AAC:\r\n            type = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n            codecId = AVCodecID.AV_CODEC_ID_AAC\r\n            break\r\n          case mpegts.TSStreamType.VIDEO_MPEG4:\r\n            type = AVMediaType.AVMEDIA_TYPE_VIDEO\r\n            codecId = AVCodecID.AV_CODEC_ID_MPEG4\r\n            break\r\n          case mpegts.TSStreamType.VIDEO_H264:\r\n            type = AVMediaType.AVMEDIA_TYPE_VIDEO\r\n            codecId = AVCodecID.AV_CODEC_ID_H264\r\n            break\r\n          case mpegts.TSStreamType.VIDEO_HEVC:\r\n            type = AVMediaType.AVMEDIA_TYPE_VIDEO\r\n            codecId = AVCodecID.AV_CODEC_ID_HEVC\r\n            break\r\n          case mpegts.TSStreamType.VIDEO_VVC:\r\n            type = AVMediaType.AVMEDIA_TYPE_VIDEO\r\n            codecId = AVCodecID.AV_CODEC_ID_VVC\r\n            break\r\n          case mpegts.TSStreamType.AUDIO_AC3:\r\n            type = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n            codecId = AVCodecID.AV_CODEC_ID_AC3\r\n            break\r\n          case 0x90:\r\n            type = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n            codecId = AVCodecID.AV_CODEC_ID_PCM_ALAW\r\n            break\r\n          case 0x91:\r\n            type = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n            codecId = AVCodecID.AV_CODEC_ID_PCM_MULAW\r\n            break\r\n          case mpegps.MpegpsStartCode.PRIVATE_STREAM_2:\r\n            type = AVMediaType.AVMEDIA_TYPE_DATA\r\n            codecId = AVCodecID.AV_CODEC_ID_DVD_NAV\r\n            break\r\n          default: {\r\n            if (startCode >= 0x1e0 && startCode <= 0x1ef) {\r\n              type = AVMediaType.AVMEDIA_TYPE_VIDEO\r\n              codecId = AVCodecID.AV_CODEC_ID_MPEG2VIDEO\r\n            }\r\n            else if (startCode >= 0x1c0 && startCode <= 0x1df) {\r\n              type = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n              codecId = AVCodecID.AV_CODEC_ID_MP3\r\n            }\r\n            else if (startCode >= 0x80 && startCode <= 0x87) {\r\n              type = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n              codecId = AVCodecID.AV_CODEC_ID_AC3\r\n            }\r\n            else if ((startCode >= 0x88 && startCode <= 0x8f)\r\n              || (startCode >= 0x98 && startCode <= 0x9f)\r\n            ) {\r\n              type = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n              codecId = AVCodecID.AV_CODEC_ID_DTS\r\n            }\r\n            else if (startCode >= 0xb0 && startCode <= 0xbf) {\r\n              type = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n              codecId = AVCodecID.AV_CODEC_ID_TRUEHD\r\n            }\r\n            else if (startCode >= 0xc0 && startCode <= 0xcf) {\r\n              type = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n              codecId = AVCodecID.AV_CODEC_ID_AC3\r\n            }\r\n            else if (startCode >= 0x20 && startCode <= 0x3f) {\r\n              type = AVMediaType.AVMEDIA_TYPE_SUBTITLE\r\n              codecId = AVCodecID.AV_CODEC_ID_DVD_SUBTITLE\r\n            }\r\n            else if (startCode >= 0xfd55 && startCode <= 0xfd5f) {\r\n              type = AVMediaType.AVMEDIA_TYPE_VIDEO\r\n              codecId = AVCodecID.AV_CODEC_ID_VC1\r\n            }\r\n            else {\r\n              return\r\n            }\r\n          }\r\n        }\r\n        break\r\n      }\r\n    }\r\n\r\n    const stream = formatContext.createStream()\r\n    stream.codecpar.codecType = type\r\n    stream.codecpar.codecId = codecId\r\n    stream.timeBase.den = 90000\r\n    stream.timeBase.num = 1\r\n\r\n    const context: MpegpsStreamContext = stream.privData = {\r\n      streamId,\r\n      streamType,\r\n      filter: null,\r\n      paddingPES: null\r\n    }\r\n\r\n    if (codecId === AVCodecID.AV_CODEC_ID_PCM_ALAW\r\n      || codecId === AVCodecID.AV_CODEC_ID_PCM_MULAW\r\n    ) {\r\n      stream.codecpar.chLayout.nbChannels = 1\r\n      stream.codecpar.sampleRate = 8000\r\n      stream.codecpar.chLayout.order = AVChannelOrder.AV_CHANNEL_ORDER_NATIVE\r\n      stream.codecpar.chLayout.u.mask = static_cast<uint64>(AV_CH_LAYOUT.AV_CH_LAYOUT_MONO)\r\n    }\r\n\r\n    if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_MP3) {\r\n      context.filter = new Mp32RawFilter()\r\n    }\r\n    else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_AC3) {\r\n      context.filter = new Ac32RawFilter()\r\n    }\r\n    else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_DTS) {\r\n      context.filter = new Dts2RawFilter()\r\n    }\r\n    else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_AAC) {\r\n      context.filter = new ADTS2RawFilter()\r\n    }\r\n    if (context.filter) {\r\n      context.filter.init(addressof(stream.codecpar), addressof(stream.timeBase))\r\n    }\r\n\r\n    return stream\r\n  }\r\n\r\n  public async readHeader(formatContext: AVIFormatContext): Promise<number> {\r\n\r\n    const str = await formatContext.ioReader.peekString(6)\r\n    if (str.substring(0, 4) === 'IMKH') {\r\n      this.context.imkhCctv = true\r\n      await formatContext.ioReader.skip(4)\r\n    }\r\n    else if (str === 'Sofdec') {\r\n      this.context.sofdec = true\r\n      await formatContext.ioReader.skip(6)\r\n    }\r\n\r\n    const signature = await formatContext.ioReader.peekUint32()\r\n\r\n    if (signature !== mpegps.MpegpsStartCode.PACK_START) {\r\n      logger.error('the file format is not mpegps')\r\n      return errorType.DATA_INVALID\r\n    }\r\n\r\n    if (formatContext.ioReader.flags & IOFlags.SEEKABLE) {\r\n      const now = formatContext.ioReader.getPos()\r\n      const MAX = 500n * 1000n\r\n\r\n      const fileSize = await formatContext.ioReader.fileSize()\r\n\r\n      let pos = fileSize - MAX\r\n      if (pos < now) {\r\n        pos = now\r\n      }\r\n\r\n      await formatContext.ioReader.seek(pos)\r\n\r\n      try {\r\n        this.context.pes.pts = NOPTS_VALUE_BIGINT\r\n        while (true) {\r\n          await this.readPES(formatContext)\r\n          parsePES(this.context.pes)\r\n          if (this.context.pes.pts !== NOPTS_VALUE_BIGINT) {\r\n            this.context.lastPtsMap.set(this.context.pes.streamId, this.context.pes.pts)\r\n          }\r\n        }\r\n      }\r\n      catch (error) {\r\n        await formatContext.ioReader.seek(now)\r\n      }\r\n    }\r\n\r\n    this.context.ioEnded = false\r\n\r\n    return 0\r\n  }\r\n\r\n  private checkExtradata(avpacket: pointer<AVPacket>, stream: AVStream) {\r\n    if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_MP3\r\n      && stream.codecpar.sampleRate === NOPTS_VALUE\r\n    ) {\r\n      const buffer = getAVPacketData(avpacket)\r\n\r\n      const ver = (buffer[1] >>> 3) & 0x03\r\n      const layer = (buffer[1] & 0x06) >> 1\r\n      // const bitrateIndex = (buffer[2] & 0xF0) >>> 4\r\n      const samplingFreqIndex = (buffer[2] & 0x0C) >>> 2\r\n\r\n      const channelMode = (buffer[3] >>> 6) & 0x03\r\n\r\n      const channelCount = channelMode !== 3 ? 2 : 1\r\n      const profile = mp3.getProfileByLayer(layer)\r\n      const sampleRate = mp3.getSampleRateByVersionIndex(ver, samplingFreqIndex)\r\n\r\n      stream.codecpar.profile = profile\r\n      stream.codecpar.sampleRate = sampleRate\r\n      stream.codecpar.chLayout.nbChannels = channelCount\r\n    }\r\n    else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_AC3\r\n      && stream.codecpar.sampleRate === NOPTS_VALUE\r\n    ) {\r\n      const buffer = getAVPacketData(avpacket)\r\n      const info = ac3.parseHeader(buffer)\r\n      if (!is.number(info)) {\r\n        stream.codecpar.sampleRate = reinterpret_cast<int32>(info.sampleRate)\r\n        stream.codecpar.chLayout.nbChannels = reinterpret_cast<int32>(info.channels)\r\n        stream.codecpar.bitrate = static_cast<int64>(info.bitrate)\r\n      }\r\n    }\r\n    else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_DTS\r\n      && stream.codecpar.sampleRate === NOPTS_VALUE\r\n    ) {\r\n      const buffer = getAVPacketData(avpacket)\r\n      const info = dts.parseHeader(buffer)\r\n      if (!is.number(info)) {\r\n        stream.codecpar.sampleRate = info.sampleRate\r\n        stream.codecpar.chLayout.nbChannels = info.channels\r\n        stream.codecpar.bitrate = static_cast<int64>(info.bitrate)\r\n      }\r\n    }\r\n    else if (!stream.codecpar.extradata) {\r\n      let element = getAVPacketSideData(avpacket, AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA)\r\n      if (element) {\r\n        stream.codecpar.extradata = avMalloc(element.size)\r\n        memcpy(stream.codecpar.extradata, element.data, element.size)\r\n        stream.codecpar.extradataSize = element.size\r\n        deleteAVPacketSideData(avpacket, AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA)\r\n\r\n        if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_H264) {\r\n          h264.parseAVCodecParameters(stream, mapSafeUint8Array(stream.codecpar.extradata, stream.codecpar.extradataSize))\r\n        }\r\n        else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_HEVC) {\r\n          hevc.parseAVCodecParameters(stream, mapSafeUint8Array(stream.codecpar.extradata, stream.codecpar.extradataSize))\r\n        }\r\n        else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_VVC) {\r\n          vvc.parseAVCodecParameters(stream, mapSafeUint8Array(stream.codecpar.extradata, stream.codecpar.extradataSize))\r\n        }\r\n        else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_AAC) {\r\n          aac.parseAVCodecParameters(stream, mapSafeUint8Array(stream.codecpar.extradata, stream.codecpar.extradataSize))\r\n        }\r\n        else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_OPUS) {\r\n          opus.parseAVCodecParameters(stream, mapSafeUint8Array(stream.codecpar.extradata, stream.codecpar.extradataSize))\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private parseSlice(slice: MpegpsSlice, formatContext: AVIFormatContext, avpacket: pointer<AVPacket>, stream: AVStream) {\r\n    const data = concatTypeArray(Uint8Array, slice.buffers)\r\n\r\n    const streamContext = stream.privData as MpegpsStreamContext\r\n\r\n    if (stream.codecpar.codecType === AVMediaType.AVMEDIA_TYPE_AUDIO) {\r\n      avpacket.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n    }\r\n\r\n    const codecId = stream.codecpar.codecId\r\n    if (codecId === AVCodecID.AV_CODEC_ID_H264\r\n      || codecId === AVCodecID.AV_CODEC_ID_H265\r\n      || codecId === AVCodecID.AV_CODEC_ID_VVC\r\n    ) {\r\n      avpacket.bitFormat = h264.BitFormat.ANNEXB\r\n    }\r\n\r\n    avpacket.streamIndex = stream.index\r\n\r\n    avpacket.dts = slice.dts\r\n    avpacket.pts = slice.pts\r\n    avpacket.pos = slice.pos\r\n    avpacket.timeBase.den = 90000\r\n    avpacket.timeBase.num = 1\r\n\r\n    if (stream.startTime === NOPTS_VALUE_BIGINT) {\r\n      stream.startTime = avpacket.pts || avpacket.dts\r\n      if (this.context.lastPtsMap.has(streamContext.streamId)) {\r\n        stream.duration = this.context.lastPtsMap.get(streamContext.streamId) - stream.startTime\r\n      }\r\n    }\r\n\r\n    const payload = avMalloc(data.length)\r\n    memcpyFromUint8Array(payload, data.length, data)\r\n    addAVPacketData(avpacket, payload, data.length)\r\n\r\n    if (streamContext.filter) {\r\n      let ret = 0\r\n      ret = streamContext.filter.sendAVPacket(avpacket)\r\n\r\n      if (ret < 0) {\r\n        logger.error('send avpacket to bsf failed')\r\n        return errorType.DATA_INVALID\r\n      }\r\n\r\n      ret = streamContext.filter.receiveAVPacket(avpacket)\r\n\r\n      if (ret < 0) {\r\n        return ret\r\n      }\r\n\r\n      avpacket.timeBase.den = 90000\r\n      avpacket.timeBase.num = 1\r\n      avpacket.streamIndex = stream.index\r\n\r\n      this.checkExtradata(avpacket, stream)\r\n\r\n      while (true) {\r\n        const avpacket = this.cacheAVPacket || createAVPacket()\r\n        ret = streamContext.filter.receiveAVPacket(avpacket)\r\n        if (ret === 0) {\r\n          avpacket.timeBase.den = 90000\r\n          avpacket.timeBase.num = 1\r\n          avpacket.streamIndex = stream.index\r\n          this.checkExtradata(avpacket, stream)\r\n          formatContext.interval.packetBuffer.push(avpacket)\r\n          this.cacheAVPacket = nullptr\r\n        }\r\n        else {\r\n          this.cacheAVPacket = avpacket\r\n          break\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_MPEG2VIDEO) {\r\n        if (mpegvideo.isIDR(avpacket)) {\r\n          avpacket.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n        }\r\n      }\r\n      else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_H264) {\r\n        if (!stream.codecpar.extradata) {\r\n          h264.parseAnnexbExtraData(avpacket, true)\r\n          this.checkExtradata(avpacket, stream)\r\n          stream.codecpar.bitFormat = h264.BitFormat.ANNEXB\r\n        }\r\n        if (h264.isIDR(avpacket)) {\r\n          avpacket.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n        }\r\n      }\r\n      else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_HEVC) {\r\n        if (!stream.codecpar.extradata) {\r\n          hevc.parseAnnexbExtraData(avpacket, true)\r\n          this.checkExtradata(avpacket, stream)\r\n          stream.codecpar.bitFormat = h264.BitFormat.ANNEXB\r\n        }\r\n        if (hevc.isIDR(avpacket)) {\r\n          avpacket.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n        }\r\n      }\r\n      else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_VVC) {\r\n        if (!stream.codecpar.extradata) {\r\n          vvc.parseAnnexbExtraData(avpacket, true)\r\n          this.checkExtradata(avpacket, stream)\r\n          stream.codecpar.bitFormat = h264.BitFormat.ANNEXB\r\n        }\r\n        if (vvc.isIDR(avpacket)) {\r\n          avpacket.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n        }\r\n      }\r\n    }\r\n    return 0\r\n  }\r\n\r\n  private getMpegVideoNextFrame(offset: number, payload: Uint8Array, stream: AVStream) {\r\n    while (true) {\r\n      const next = nalu.getNextNaluStart(payload, offset)\r\n      if (next.offset >= 0) {\r\n        if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_H264\r\n            && next.startCode === 4\r\n          || stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_MPEG2VIDEO\r\n            && next.startCode === 3\r\n            && (next.offset + 3 < payload.length)\r\n            && (payload[next.offset + 3] < 0x01\r\n              || payload[next.offset + 3] > 0xaf\r\n            )\r\n            && payload[next.offset + 3] !== 0xb5\r\n        ) {\r\n          return payload[next.offset + 3] === 0xb7 ? (next.offset + 4) : next.offset\r\n        }\r\n        else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_MPEG2VIDEO\r\n          && next.startCode === 4\r\n          && (next.offset + 4 < payload.length)\r\n          && (payload[next.offset + 4] < 0x01\r\n            || payload[next.offset + 4] > 0xaf\r\n          )\r\n          && payload[next.offset + 4] !== 0xb5\r\n        ) {\r\n          return payload[next.offset + 4] === 0xb7 ? (next.offset + 5) : (next.offset + 1)\r\n        }\r\n        offset = next.offset + 3\r\n      }\r\n      else {\r\n        return -1\r\n      }\r\n    }\r\n  }\r\n\r\n  private getMpegAudioNextFrame(payload: Uint8Array, stream: AVStream) {\r\n    let first = 0\r\n    let end = 2\r\n    if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_AC3) {\r\n      first = 0x0b\r\n    }\r\n    else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_MP3) {\r\n      first = 0xff\r\n    }\r\n    else {\r\n      first = 0x7f\r\n      end = 4\r\n    }\r\n    for (let i = 0; i < payload.length - end; i++) {\r\n      if (payload[i] === first ) {\r\n        const second = payload[i + 1]\r\n\r\n        const max = 2\r\n\r\n        if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_MP3 && ((second & 0xe0) === 0xe0)) {\r\n          if (i !== 0) {\r\n\r\n            let count = 0\r\n            let offset = 0\r\n\r\n            while (true) {\r\n              const header = new FrameHeader()\r\n              mp3FrameHeader.parse(\r\n                header,\r\n                (payload[i + offset] << 24)\r\n                  | (payload[i + offset + 1] << 16)\r\n                  | (payload[i + offset + 2] << 8)\r\n                  | payload[i + offset + 3]\r\n              )\r\n              const ver = (payload[i + offset + 1] >>> 3) & 0x03\r\n              const samplingFreqIndex = (payload[i + offset + 2] & 0x0C) >>> 2\r\n              const sampleRate = mp3.getSampleRateByVersionIndex(ver, samplingFreqIndex)\r\n              let frameLength = mp3FrameHeader.getFrameLength(header, sampleRate)\r\n\r\n              if (frameLength\r\n                && (i + offset + frameLength < payload.length - 2)\r\n                && payload[i + offset + frameLength] === 0xff\r\n                && (payload[i + offset + frameLength + 1] & 0xe0) === 0xe0\r\n              ) {\r\n                count++\r\n                offset += frameLength\r\n                if (count === max) {\r\n                  break\r\n                }\r\n              }\r\n              else {\r\n                break\r\n              }\r\n            }\r\n            if (count === max) {\r\n              return i\r\n            }\r\n            else {\r\n              continue\r\n            }\r\n          }\r\n          break\r\n        }\r\n        else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_AC3 && second === 0x77) {\r\n          if (i !== 0) {\r\n\r\n            let count = 0\r\n            let offset = 0\r\n\r\n            while (true) {\r\n\r\n              const info = ac3.parseHeader(payload.subarray(i + offset))\r\n\r\n              if (!is.number(info)\r\n                && (i + offset + info.frameSize < payload.length - 2)\r\n                && payload[i + offset + info.frameSize] === 0x0b\r\n                && payload[i + offset + info.frameSize + 1] === 0x77\r\n              ) {\r\n                count++\r\n                offset += info.frameSize\r\n                if (count === max) {\r\n                  break\r\n                }\r\n              }\r\n              else {\r\n                break\r\n              }\r\n            }\r\n            if (count === max) {\r\n              return i\r\n            }\r\n            else {\r\n              continue\r\n            }\r\n          }\r\n          break\r\n        }\r\n        if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_DTS\r\n          && second === 0xfe\r\n          && payload[i + 2] === 0x80\r\n          && payload[i + 3] === 0x81\r\n        ) {\r\n          if (i !== 0) {\r\n\r\n            let count = 0\r\n            let offset = 0\r\n\r\n            while (true) {\r\n\r\n              const info = dts.parseHeader(payload.subarray(i + offset))\r\n\r\n              if (!is.number(info)\r\n                && (i + offset + info.frameSize < payload.length - 4)\r\n                && payload[i + offset + info.frameSize] === 0x7f\r\n                && payload[i + offset + info.frameSize + 1] === 0xfe\r\n                && payload[i + offset + info.frameSize + 2] === 0x80\r\n                && payload[i + offset + info.frameSize + 3] === 0x81\r\n              ) {\r\n                count++\r\n                offset += info.frameSize\r\n                if (count === max) {\r\n                  break\r\n                }\r\n              }\r\n              else {\r\n                break\r\n              }\r\n            }\r\n            if (count === max) {\r\n              return i\r\n            }\r\n            else {\r\n              continue\r\n            }\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    return -1\r\n  }\r\n\r\n  @deasync\r\n  private async readAVPacket_(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number> {\r\n\r\n    const handlePES = (context: MpegpsStreamContext, stream: AVStream) => {\r\n      let slice = this.context.slices.get(context.streamId)\r\n      if (!slice) {\r\n        slice = {\r\n          pts: -1n,\r\n          dts: -1n,\r\n          pos: -1n,\r\n          buffers: []\r\n        }\r\n        this.context.slices.set(context.streamId, slice)\r\n      }\r\n\r\n      if (this.context.pes.dts === NOPTS_VALUE_BIGINT || !slice.buffers.length) {\r\n        if (this.context.pes.dts !== NOPTS_VALUE_BIGINT) {\r\n          slice.dts = this.context.pes.dts\r\n          slice.pts = this.context.pes.pts\r\n          slice.pos = this.context.pes.pos\r\n          // \r\n          if (stream.codecpar.codecType === AVMediaType.AVMEDIA_TYPE_VIDEO) {\r\n            const offset = this.getMpegVideoNextFrame(0, this.context.pes.payload, stream)\r\n\r\n            if (offset > 0) {\r\n              this.context.pes.payload = this.context.pes.payload.subarray(offset)\r\n            }\r\n            // need next pes\r\n            else if (offset < 0) {\r\n              context.paddingPES = object.extend({}, this.context.pes)\r\n              return true\r\n            }\r\n          }\r\n          else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_AC3\r\n            || stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_DTS\r\n            || stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_MP3\r\n          ) {\r\n            const offset = this.getMpegAudioNextFrame(this.context.pes.payload, stream)\r\n            if (offset > 0) {\r\n              this.context.pes.payload = this.context.pes.payload.subarray(offset)\r\n            }\r\n          }\r\n        }\r\n        slice.buffers.push(this.context.pes.payload)\r\n        return true\r\n      }\r\n      else {\r\n        let ret = 0\r\n        if (stream.codecpar.codecType === AVMediaType.AVMEDIA_TYPE_VIDEO) {\r\n          let offset = this.getMpegVideoNextFrame(0, this.context.pes.payload, stream)\r\n          if (offset > 0) {\r\n            slice.buffers.push(this.context.pes.payload.subarray(0, offset))\r\n            this.context.pes.payload = this.context.pes.payload.subarray(offset)\r\n          }\r\n          // need next pes\r\n          else if (offset < 0) {\r\n            context.paddingPES = object.extend({}, this.context.pes)\r\n            return true\r\n          }\r\n        }\r\n        // mpeg1/mpeg2 \r\n        if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_MPEG2VIDEO) {\r\n          let payload = concatTypeArray(Uint8Array, slice.buffers)\r\n          const list: Uint8Array[] = []\r\n          while (true) {\r\n            let offset = 0\r\n            let pos = 0\r\n            let hasPic = false\r\n            while (true) {\r\n              const next = this.getMpegVideoNextFrame(pos, payload, stream)\r\n              if (next >= 0) {\r\n                if (hasPic) {\r\n                  offset = next\r\n                  break\r\n                }\r\n                const type = payload[next + 3]\r\n                if (type === 0x00) {\r\n                  hasPic = true\r\n                }\r\n                pos = next + 3\r\n              }\r\n              else {\r\n                break\r\n              }\r\n            }\r\n            if (offset > 0) {\r\n              list.push(payload.subarray(0, offset))\r\n              payload = payload.subarray(offset)\r\n            }\r\n            else {\r\n              break\r\n            }\r\n          }\r\n          list.push(payload)\r\n          if (list.length > 1) {\r\n            const dtsDelta = (this.context.pes.dts - slice.dts) / static_cast<int64>(list.length)\r\n            const ptsDelta = (this.context.pes.pts - slice.pts) / static_cast<int64>(list.length)\r\n            for (let i = 0; i < list.length; i++) {\r\n              slice.buffers.length = 0\r\n              slice.buffers.push(list[i])\r\n              slice.dts += dtsDelta * static_cast<int64>(i)\r\n              slice.pts += ptsDelta * static_cast<int64>(i)\r\n              if (i === 0) {\r\n                this.parseSlice(slice, formatContext, avpacket, stream)\r\n              }\r\n              else {\r\n                const cache = createAVPacket()\r\n                this.parseSlice(slice, formatContext, cache, stream)\r\n                formatContext.interval.packetBuffer.push(cache)\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            slice.buffers = list\r\n            this.parseSlice(slice, formatContext, avpacket, stream)\r\n          }\r\n        }\r\n        else {\r\n          ret = this.parseSlice(slice, formatContext, avpacket, stream)\r\n        }\r\n\r\n        slice.buffers.length = 0\r\n\r\n        if (this.context.paddingPES) {\r\n          //  this.context.paddingPES \r\n          this.context.paddingPES.payload = this.context.pes.payload\r\n        }\r\n        else {\r\n          slice.buffers.push(this.context.pes.payload)\r\n          slice.dts = this.context.pes.dts\r\n          slice.pts = this.context.pes.pts\r\n          slice.pos = this.context.pes.pos\r\n        }\r\n        if (ret === errorType.EOF) {\r\n          return true\r\n        }\r\n        return false\r\n      }\r\n    }\r\n\r\n    while (true) {\r\n      let startCode = 0\r\n      if (this.context.paddingPES) {\r\n        this.context.pes = this.context.paddingPES\r\n        this.context.paddingPES = null\r\n      }\r\n      else {\r\n        startCode = await this.readPES(formatContext)\r\n        parsePES(this.context.pes)\r\n\r\n        if (startCode === mpegps.MpegpsStartCode.PRIVATE_STREAM_1) {\r\n          startCode = this.context.pes.payload[0]\r\n          if (startCode === 0x0b) {\r\n            if (this.context.pes.payload[1] === 0x77) {\r\n              startCode = 0x80\r\n            }\r\n            else {\r\n              this.context.pes.payload = this.context.pes.payload.subarray(1)\r\n            }\r\n          }\r\n          else {\r\n            if (startCode >= 0x80 && startCode <= 0xcf) {\r\n              this.context.pes.payload = this.context.pes.payload.subarray(4)\r\n            }\r\n            else {\r\n              this.context.pes.payload = this.context.pes.payload.subarray(1)\r\n            }\r\n          }\r\n          this.context.pes.streamId = startCode & 0xff\r\n        }\r\n      }\r\n\r\n      let stream = formatContext.streams.find(((stream) => {\r\n        const context = stream.privData as MpegpsStreamContext\r\n        return context.streamId === this.context.pes.streamId\r\n      }))\r\n\r\n      if (!stream) {\r\n        const id = startCode & 0xff\r\n        stream = this.createStream(formatContext, this.context.psmType.get(id), id, startCode)\r\n      }\r\n      if (stream) {\r\n\r\n        const context = stream.privData as MpegpsStreamContext\r\n\r\n        if (!this.context.pes.payload) {\r\n          continue\r\n        }\r\n        //  paddingPES \r\n        //  0x000001  paddingPES \r\n        if (context.paddingPES) {\r\n          context.paddingPES.payload = concatTypeArray(Uint8Array, [context.paddingPES.payload, this.context.pes.payload])\r\n          if (this.context.pes.dts === NOPTS_VALUE_BIGINT) {\r\n            this.context.pes = context.paddingPES\r\n            context.paddingPES = null\r\n          }\r\n          else {\r\n            //  this.context \r\n            this.context.paddingPES = this.context.pes\r\n            this.context.pes = context.paddingPES\r\n            context.paddingPES = null\r\n          }\r\n        }\r\n\r\n        if (handlePES(context, stream)) {\r\n          continue\r\n        }\r\n        return 0\r\n      }\r\n    }\r\n  }\r\n\r\n  public async readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number> {\r\n    try {\r\n      if (this.context.ioEnded) {\r\n        if (this.context.slices.size) {\r\n          let slice: MpegpsSlice\r\n          let stream: AVStream\r\n          this.context.slices.forEach((value, id) => {\r\n            if (value.buffers.length) {\r\n              stream = formatContext.streams.find(((stream) => {\r\n                const context = stream.privData as MpegpsStreamContext\r\n                return context.streamId === id\r\n              }))\r\n              if (stream) {\r\n                slice = value\r\n              }\r\n            }\r\n          })\r\n          if (slice) {\r\n            this.parseSlice(slice, formatContext, avpacket, stream)\r\n            slice.buffers.length = 0\r\n            slice.pts = slice.dts = slice.pos = -1n\r\n            return 0\r\n          }\r\n        }\r\n        return IOError.END\r\n      }\r\n      return await this.readAVPacket_(formatContext, avpacket)\r\n    }\r\n    catch (error) {\r\n      if (formatContext.ioReader.error !== IOError.END) {\r\n        logger.error(`read packet error, ${error}`)\r\n        return errorType.DATA_INVALID\r\n      }\r\n      else {\r\n        this.context.ioEnded = true\r\n        return this.readAVPacket(formatContext, avpacket)\r\n      }\r\n    }\r\n  }\r\n\r\n  @deasync\r\n  private async syncPSPacket(formatContext: AVIFormatContext) {\r\n    let pos: int64 = NOPTS_VALUE_BIGINT\r\n    try {\r\n      this.context.pes.pts = NOPTS_VALUE_BIGINT\r\n      while (this.context.pes.pts === NOPTS_VALUE_BIGINT) {\r\n        await this.readPES(formatContext)\r\n        parsePES(this.context.pes)\r\n        pos = this.context.pes.pos\r\n      }\r\n    }\r\n    catch (error) {\r\n      pos = NOPTS_VALUE_BIGINT\r\n    }\r\n    if (pos !== NOPTS_VALUE_BIGINT) {\r\n      await formatContext.ioReader.seek(pos)\r\n    }\r\n  }\r\n\r\n  public async seek(\r\n    formatContext: AVIFormatContext,\r\n    stream: AVStream,\r\n    timestamp: int64,\r\n    flags: int32\r\n  ): Promise<int64> {\r\n    let now = formatContext.ioReader.getPos()\r\n\r\n    this.context.slices.forEach((slice) => {\r\n      if (slice.buffers.length && slice.pos < now) {\r\n        now = slice.pos\r\n      }\r\n      slice.buffers.length = 0\r\n      slice.pts = slice.dts = slice.pos = -1n\r\n    })\r\n\r\n    formatContext.streams.forEach((stream) => {\r\n      const context = stream.privData as MpegpsStreamContext\r\n      if (context.filter) {\r\n        context.filter.reset()\r\n      }\r\n    })\r\n\r\n    if (flags & AVSeekFlags.BYTE) {\r\n\r\n      const size = await formatContext.ioReader.fileSize()\r\n\r\n      if (size <= 0n) {\r\n        return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n      }\r\n\r\n      if (timestamp < 0n) {\r\n        timestamp = 0n\r\n      }\r\n      else if (timestamp > size) {\r\n        timestamp = size\r\n      }\r\n      await formatContext.ioReader.seek(timestamp)\r\n\r\n      if (!(flags & AVSeekFlags.ANY)) {\r\n        await this.syncPSPacket(formatContext)\r\n      }\r\n\r\n      this.context.ioEnded = false\r\n\r\n      return now\r\n    }\r\n    else {\r\n      if (stream && stream.sampleIndexes.length) {\r\n        let index = array.binarySearch(stream.sampleIndexes, (item) => {\r\n          if (item.pts > timestamp) {\r\n            return -1\r\n          }\r\n          return 1\r\n        })\r\n        if (index > 0 && avRescaleQ(timestamp - stream.sampleIndexes[index - 1].pts, stream.timeBase, AV_MILLI_TIME_BASE_Q) < 10000n) {\r\n          logger.debug(`seek in sampleIndexes, found index: ${index}, pts: ${stream.sampleIndexes[index - 1].pts}, pos: ${stream.sampleIndexes[index - 1].pos}`)\r\n          await formatContext.ioReader.seek(stream.sampleIndexes[index - 1].pos)\r\n          this.context.ioEnded = false\r\n          return now\r\n        }\r\n      }\r\n\r\n      logger.debug('not found any keyframe index, try to seek in bytes')\r\n\r\n      let ret = await seekInBytes(\r\n        formatContext,\r\n        stream,\r\n        timestamp,\r\n        0n,\r\n        this.readAVPacket.bind(this),\r\n        this.syncPSPacket.bind(this)\r\n      )\r\n      if (ret >= 0) {\r\n        this.context.ioEnded = false\r\n      }\r\n      return ret\r\n    }\r\n  }\r\n\r\n  public getAnalyzeStreamsCount(): number {\r\n    return 1\r\n  }\r\n}\r\n","/*\r\n * libmedia mp3 FrameHeader utils\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport * as mp3 from '../../codecs/mp3'\r\n\r\nexport class FrameHeader {\r\n  version: uint32\r\n  layer: uint32\r\n  protection: uint32\r\n  bitrateIndex: uint32\r\n  samplingFrequency: uint32\r\n  padding: uint32\r\n  private: uint32\r\n  mode: uint32\r\n  modeExtension: uint32\r\n  copyright: uint32\r\n  original: uint32\r\n  emphasis: uint32\r\n}\r\n\r\nexport function parse(header: FrameHeader, value: uint32) {\r\n  header.version = (value >> 19) & 3\r\n  header.layer = (value >> 17) & 3\r\n  header.protection = (value >> 16) & 1\r\n  header.bitrateIndex = (value >> 12) & 0x0f\r\n  header.samplingFrequency = (value >> 10) & 3\r\n  header.padding = (value >> 9) & 1\r\n  header.mode = (value >> 6) & 3\r\n  header.modeExtension = (value >> 4) & 3\r\n  header.copyright = (value >> 3) & 1\r\n  header.original = (value >> 2) & 1\r\n  header.emphasis = value & 3\r\n}\r\n\r\nexport function getFrameLength(header: FrameHeader, sampleRate: int32) {\r\n\r\n  let frameSize = mp3.getBitRateByVersionLayerIndex(\r\n    header.version,\r\n    header.layer,\r\n    header.bitrateIndex\r\n  )\r\n\r\n  switch (header.layer) {\r\n    case 1:\r\n    default:\r\n      // Layer 3\r\n      frameSize = ((frameSize * 144000) / (sampleRate << ((header.version === 3) ? 0 : 1))) >>> 0\r\n      frameSize += header.padding\r\n      break\r\n    case 2:\r\n      // Layer 2\r\n      frameSize = ((frameSize * 144000) / sampleRate) >>> 0\r\n      frameSize += header.padding\r\n      break\r\n    case 3:\r\n      // Layer 1\r\n      frameSize = ((frameSize * 12000) / sampleRate) >>> 0\r\n      frameSize = (frameSize + header.padding) * 4\r\n      break\r\n  }\r\n\r\n  return frameSize\r\n}\r\n","/*\r\n * libmedia parse PES\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { PES } from '../struct'\r\nimport { NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\nimport * as logger from 'common/util/logger'\r\nimport { TSStreamId, TSStreamType } from '../mpegts'\r\nimport * as errorType from 'avutil/error'\r\n\r\nexport default function parsePES(pes: PES) {\r\n\r\n  const data = pes.data\r\n  const streamId = data[3]\r\n  const pesPacketLength = (data[4] << 8) | data[5]\r\n\r\n  let headerSize = 0\r\n  let offset = 0\r\n  let flags = 0\r\n\r\n  if (streamId !== TSStreamId.PROGRAM_STREAM_MAP\r\n    && streamId !== TSStreamId.PADDING_STREAM\r\n    && streamId !== TSStreamId.PRIVATE_STREAM_2\r\n    && streamId !== TSStreamId.ECM_STREAM\r\n    && streamId !== TSStreamId.EMM_STREAM\r\n    && streamId !== TSStreamId.PROGRAM_STREAM_DIRECTORY\r\n    && streamId !== TSStreamId.DSMCC_STREAM\r\n    && streamId !== TSStreamId.TYPE_E_STREAM\r\n  ) {\r\n\r\n    let pts: int64 = NOPTS_VALUE_BIGINT\r\n    let dts: int64 = NOPTS_VALUE_BIGINT\r\n\r\n    while (true) {\r\n      if (6 + offset >= data.length) {\r\n        return\r\n      }\r\n      flags = data[6 + offset]\r\n      if (flags !== 0xff) {\r\n        break\r\n      }\r\n      offset++\r\n    }\r\n\r\n    if ((flags & 0xc0) === 0x40) {\r\n      offset += 2\r\n      flags = data[6 + offset]\r\n    }\r\n    if ((flags & 0xe0) == 0x20) {\r\n\r\n      headerSize += 5\r\n\r\n      pts = pts = static_cast<int64>((data[6 + offset] & 0x0E) * 536870912\r\n        + (data[7 + offset] & 0xFF) * 4194304\r\n        + (data[8 + offset] & 0xFE) * 16384\r\n        + (data[9 + offset] & 0xFF) * 128\r\n        + (data[10 + offset] & 0xFE) / 2)\r\n\r\n      if (flags & 0x10) {\r\n        dts = static_cast<int64>((data[11 + offset] & 0x0E) * 536870912\r\n          + (data[12 + offset] & 0xFF) * 4194304\r\n          + (data[13 + offset] & 0xFE) * 16384\r\n          + (data[14 + offset] & 0xFF) * 128\r\n          + (data[15 + offset] & 0xFE) / 2)\r\n\r\n        headerSize += 5\r\n      }\r\n      else {\r\n        dts = pts\r\n      }\r\n    }\r\n    else if ((flags & 0xc0) == 0x80) {\r\n      // const pesScramblingControl = (data[6] & 0x30) >>> 4\r\n      const ptsDtsFlags = (data[7 + offset] & 0xC0) >>> 6\r\n      headerSize = 3 + data[8 + offset]\r\n\r\n      if (ptsDtsFlags === 0x02 || ptsDtsFlags === 0x03) {\r\n        pts = static_cast<int64>((data[9 + offset] & 0x0E) * 536870912\r\n          + (data[10 + offset] & 0xFF) * 4194304\r\n          + (data[11 + offset] & 0xFE) * 16384\r\n          + (data[12 + offset] & 0xFF) * 128\r\n          + (data[13 + offset] & 0xFE) / 2)\r\n\r\n        if (ptsDtsFlags === 0x03) {\r\n          dts = static_cast<int64>((data[14 + offset] & 0x0E) * 536870912\r\n            + (data[15 + offset] & 0xFF) * 4194304\r\n            + (data[16 + offset] & 0xFE) * 16384\r\n            + (data[17 + offset] & 0xFF) * 128\r\n            + (data[18 + offset] & 0xFE) / 2)\r\n        }\r\n        else {\r\n          dts = pts\r\n        }\r\n      }\r\n    }\r\n    else if (flags === 0xf) {\r\n      headerSize = 1\r\n    }\r\n    else {\r\n      logger.error('invalid data')\r\n      return errorType.DATA_INVALID\r\n    }\r\n\r\n    pes.dts = dts\r\n    pes.pts = pts\r\n\r\n    const payloadStartIndex = 6 + offset + headerSize\r\n    let payloadLength: number = 0\r\n\r\n    if (pesPacketLength !== 0) {\r\n      if (pesPacketLength < offset + headerSize) {\r\n        logger.error('Malformed PES: PES_packet_length < 3 + PES_header_data_length')\r\n        return\r\n      }\r\n      payloadLength = pesPacketLength - (offset + headerSize)\r\n    }\r\n    else {\r\n      // PES_packet_length === 0\r\n      payloadLength = data.byteLength - payloadStartIndex\r\n    }\r\n\r\n    pes.payload = data.subarray(payloadStartIndex, payloadStartIndex + payloadLength)\r\n  }\r\n  else if (streamId === TSStreamId.PROGRAM_STREAM_MAP\r\n    || streamId === TSStreamId.PRIVATE_STREAM_2\r\n    || streamId === TSStreamId.ECM_STREAM\r\n    || streamId === TSStreamId.EMM_STREAM\r\n    || streamId === TSStreamId.PROGRAM_STREAM_DIRECTORY\r\n    || streamId === TSStreamId.DSMCC_STREAM\r\n    || streamId === TSStreamId.TYPE_E_STREAM\r\n  ) {\r\n    if (pes.streamId === TSStreamType.PRIVATE_DATA) {\r\n      const payloadStartIndex = 6\r\n      let payloadLength: number = 0\r\n\r\n      if (pesPacketLength !== 0) {\r\n        payloadLength = pesPacketLength\r\n      }\r\n      else {\r\n        // PES_packet_length === 0\r\n        payloadLength = data.byteLength - payloadStartIndex\r\n      }\r\n      pes.payload = data.subarray(payloadStartIndex, payloadStartIndex + payloadLength)\r\n    }\r\n  }\r\n  return 0\r\n}\r\n","/*\r\n * libmedia mpegps identify defined\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nexport const MAX_SYNC_SIZE = 100000\r\n\r\nexport const enum MpegpsStreamId {\r\n  AUDIO_ID = 0xc0,\r\n  VIDEO_ID = 0xe0,\r\n  H264_ID = 0xe2,\r\n  AC3_ID = 0x80,\r\n  DTS_ID = 0x88,\r\n  LPCM_ID = 0xa0,\r\n  SUB_ID = 0x20\r\n}\r\n\r\nexport const enum MpegpsStartCode {\r\n  PACK_START = 0x1ba,\r\n  SYSTEM_HEADER_START = 0x1bb,\r\n  PADDING_STREAM = 0x1be,\r\n  PRIVATE_STREAM_1 = 0x1bd,\r\n  PRIVATE_STREAM_2 = 0x1bf,\r\n  PROGRAM_STREAM_MAP = 0x1bc\r\n}\r\n","/*\r\n * libmedia mpegts struct defined\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { NOPTS_VALUE, NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\nimport { TSStreamType } from './mpegts'\r\nimport { PID } from './type'\r\n\r\nexport class TSPacketAdaptationFieldInfo {\r\n  discontinuityIndicator: number = 0\r\n  randomAccessIndicator: number = 0\r\n  elementaryStreamPriorityIndicator: number = 0\r\n  pcrFlag: number = 0\r\n  opcrFlag: number = 0\r\n  splicingPointFlag: number = 0\r\n  transportPrivateDataFlag: number = 0\r\n  adaptationFieldExtensionFlag: number = 0\r\n  pcr: bigint = 0n\r\n  opcr: bigint = 0n\r\n  spliceCountDown: number = 0\r\n  transportPrivateData: Uint8Array = null\r\n  extension: Uint8Array = null\r\n}\r\n\r\nexport class TSPacket {\r\n  pos: bigint = NOPTS_VALUE_BIGINT\r\n  payloadUnitStartIndicator: number = 0\r\n  transportPriority: number = 0\r\n  pid: PID = NOPTS_VALUE\r\n  adaptationFieldControl: number = 0\r\n  continuityCounter: number = 0\r\n  transportScramblingControl: number = 0\r\n  adaptationFieldInfo: TSPacketAdaptationFieldInfo = new TSPacketAdaptationFieldInfo()\r\n  payload: Uint8Array = null\r\n}\r\n\r\nexport class TSSliceQueue {\r\n  slices: Uint8Array[] = []\r\n  totalLength: number = 0\r\n  expectedLength: number = NOPTS_VALUE\r\n  randomAccessIndicator: number = 0\r\n  pid: PID = NOPTS_VALUE\r\n  streamType: TSStreamType = TSStreamType.NONE\r\n  pos: bigint = NOPTS_VALUE_BIGINT\r\n}\r\n\r\nexport class PAT {\r\n  versionNumber: number = 0\r\n  networkPid: PID = NOPTS_VALUE\r\n  program2PmtPid: Map<number, PID> = new Map()\r\n}\r\n\r\nexport class SectionPacket extends TSPacket {\r\n}\r\n\r\nexport class ESDescriptor {\r\n  tag: number\r\n  buffer: Uint8Array\r\n}\r\n\r\nexport class PMT {\r\n  versionNumber: number = 0\r\n  programNumber: number = 0\r\n  pcrPid: PID = 0\r\n  pid2StreamType: Map<number, TSStreamType> = new Map()\r\n  pid2ESDescriptor: Map<number, ESDescriptor[]> = new Map()\r\n}\r\n\r\nexport class PES {\r\n  pid: PID = NOPTS_VALUE\r\n  streamType: TSStreamType = TSStreamType.NONE\r\n  streamId: number = NOPTS_VALUE\r\n  dts: bigint = NOPTS_VALUE_BIGINT\r\n  pts: bigint = NOPTS_VALUE_BIGINT\r\n  pos: bigint = NOPTS_VALUE_BIGINT\r\n  payload: Uint8Array = null\r\n  data: Uint8Array = null\r\n  randomAccessIndicator: number = 0\r\n}\r\n","/*\r\n * libmedia get bytes by duration\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { Rational } from 'avutil/struct/rational'\r\nimport AVStream from '../AVStream'\r\nimport * as array from 'common/util/array'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { AV_MILLI_TIME_BASE_Q } from 'avutil/constant'\r\n\r\nexport function getBytesByDuration(streams: AVStream[], duration: int64, timeBase: Rational) {\r\n  let bytes = 0n\r\n  array.each(streams, (st) => {\r\n    bytes += st.codecpar.bitrate * avRescaleQ(duration, timeBase, AV_MILLI_TIME_BASE_Q) / 8000n\r\n  })\r\n  return bytes\r\n}\r\n","/*\r\n * libmedia seek in bytes with timestamp\r\n *\r\n *  (C) 2024 \r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n *  libmedia \r\n * This file is part of libmedia.\r\n * \r\n * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1\r\n * \r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia \r\n *  libmedia  GNU Lesser General Public License \r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVStream from '../AVStream'\r\nimport { AV_MILLI_TIME_BASE_Q, NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { getBytesByDuration } from './getBytesByDuration'\r\nimport { createAVPacket, destroyAVPacket } from 'avutil/util/avpacket'\r\nimport * as errorType from 'avutil/error'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport * as logger from 'common/util/logger'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function seekInBytes(\r\n  context: AVIFormatContext,\r\n  stream: AVStream,\r\n  timestamp: int64,\r\n  firstPacketPos: int64,\r\n  readAVPacket: (context: AVIFormatContext, avpacket: pointer<AVPacket>) => Promise<int32>,\r\n  syncAVPacket: (context: AVIFormatContext) => Promise<void>\r\n) {\r\n\r\n  const now = context.ioReader.getPos()\r\n\r\n  const fileSize = await context.ioReader.fileSize()\r\n  let pos: int64 = NOPTS_VALUE_BIGINT\r\n  let duration = timestamp\r\n  if (stream.startTime !== NOPTS_VALUE_BIGINT) {\r\n    duration -= stream.startTime\r\n  }\r\n  else {\r\n    duration -= stream.firstDTS\r\n  }\r\n\r\n  const pointPts = avRescaleQ(timestamp, stream.timeBase, AV_MILLI_TIME_BASE_Q)\r\n\r\n  // \r\n  if (pointPts < 10000n) {\r\n    logger.debug(`seek pts is earlier then 10s, seek to first packet pos(${firstPacketPos}) directly`)\r\n    await context.ioReader.seek(firstPacketPos)\r\n    return now\r\n  }\r\n\r\n  let bytes = getBytesByDuration(context.streams, duration, stream.timeBase)\r\n  //  10 \r\n  const max = fileSize - getBytesByDuration(context.streams, 10000n, AV_MILLI_TIME_BASE_Q)\r\n  const length = getBytesByDuration(context.streams, 10000n, AV_MILLI_TIME_BASE_Q)\r\n  if (bytes > max) {\r\n    bytes = max\r\n  }\r\n  if (bytes < firstPacketPos) {\r\n    await context.ioReader.seek(firstPacketPos)\r\n    return now\r\n  }\r\n  const avpacket = createAVPacket()\r\n  let seekMax = fileSize\r\n  let seekMin = 0n\r\n\r\n  while (true) {\r\n    if (seekMax - seekMin < length) {\r\n      pos = seekMin\r\n      break\r\n    }\r\n    await context.ioReader.seek(bytes)\r\n    await syncAVPacket(context)\r\n    const now = context.ioReader.getPos()\r\n\r\n    let ret = await readAVPacket(context, avpacket)\r\n\r\n    if (ret >= 0) {\r\n      const currentPts = avRescaleQ(avpacket.pts, avpacket.timeBase, AV_MILLI_TIME_BASE_Q)\r\n      const diff = currentPts - pointPts\r\n\r\n      logger.debug(`try to seek to pos: ${bytes}, got packet pts: ${avpacket.pts}(${currentPts}ms), diff: ${diff}ms`)\r\n\r\n      // seek  10 \r\n      if (diff <= 0n && -diff < 10000n) {\r\n        pos = now\r\n        break\r\n      }\r\n      // seek \r\n      else if (diff > 0n) {\r\n        seekMax = bytes\r\n        bytes = (seekMin + seekMax) >> 1n\r\n      }\r\n      // seek  10 \r\n      else {\r\n        seekMin = bytes\r\n        bytes = (seekMin + seekMax) >> 1n\r\n      }\r\n    }\r\n    else {\r\n      //  seek \r\n      pos = NOPTS_VALUE_BIGINT\r\n      break\r\n    }\r\n  }\r\n\r\n  destroyAVPacket(avpacket)\r\n\r\n  if (pos !== NOPTS_VALUE_BIGINT) {\r\n    logger.debug(`finally seek to pos ${pos}`)\r\n\r\n    await context.ioReader.seek(pos)\r\n    await syncAVPacket(context)\r\n    return now\r\n  }\r\n  else {\r\n    await context.ioReader.seek(now)\r\n  }\r\n\r\n  return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n}\r\n"],"names":[],"sourceRoot":""}
{"version":3,"file":"src_avformat_formats_IAacFormat_ts.avplayer.js","mappings":"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","sources":["webpack://AVPlayer/./src/avformat/bsf/AVBSFilter.ts","webpack://AVPlayer/./src/avformat/bsf/aac/LATM2RawFilter.ts","webpack://AVPlayer/./src/avformat/codecs/aac.ts","webpack://AVPlayer/./src/avformat/formats/IAacFormat.ts","webpack://AVPlayer/./src/avformat/formats/IFormat.ts"],"sourcesContent":["/*\r\n * libmedia AVBSFilter\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport { Rational } from 'avutil/struct/rational'\r\nimport { avMallocz } from 'avutil/util/mem'\r\nimport { copyCodecParameters, freeCodecParameters } from 'avutil/util/codecparameters'\r\n\r\nexport default abstract class AVBSFilter {\r\n\r\n  inCodecpar: pointer<AVCodecParameters>\r\n  inTimeBase: Rational\r\n\r\n  outCodecpar: pointer<AVCodecParameters>\r\n\r\n  public init(codecpar: pointer<AVCodecParameters>, timeBase: pointer<Rational>): number {\r\n    this.inCodecpar = avMallocz(sizeof(AVCodecParameters))\r\n    copyCodecParameters(this.inCodecpar, codecpar)\r\n\r\n    this.inTimeBase = {\r\n      den: timeBase.den,\r\n      num: timeBase.num\r\n    }\r\n\r\n    return 0\r\n  }\r\n\r\n  public destroy() {\r\n    if (this.inCodecpar) {\r\n      freeCodecParameters(this.inCodecpar)\r\n      this.inCodecpar = nullptr\r\n    }\r\n  }\r\n\r\n  public abstract sendAVPacket(avpacket: pointer<AVPacket>): number\r\n  public abstract receiveAVPacket(avpacket: pointer<AVPacket>): number\r\n  public abstract reset(): number\r\n}\r\n","/*\r\n * libmedia LATM2RawFilter\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVPacket, { AVPacketFlags } from 'avutil/struct/avpacket'\r\nimport AVBSFilter from '../AVBSFilter'\r\nimport { mapUint8Array, memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\nimport { AV_TIME_BASE, AV_TIME_BASE_Q, NOPTS_VALUE } from 'avutil/constant'\r\nimport { avCodecParameters2Extradata } from '../../codecs/aac'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { avFree, avMalloc } from 'avutil/util/mem'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport { Rational } from 'avutil/struct/rational'\r\nimport { addAVPacketData, addAVPacketSideData, unrefAVPacket } from 'avutil/util/avpacket'\r\nimport { AVPacketSideDataType } from 'avutil/codec'\r\nimport BitReader from 'common/io/BitReader'\r\nimport * as aac from '../../codecs/aac'\r\nimport * as is from 'common/util/is'\r\n\r\n\r\nexport default class LATM2RawFilter extends AVBSFilter {\r\n\r\n  private bitReader: BitReader\r\n\r\n  private streamMuxConfig: {\r\n    profile: number\r\n    sampleRate: number\r\n    channels: number\r\n  }\r\n\r\n  private caches: {\r\n    dts: bigint\r\n    buffer: Uint8Array\r\n    extradata: Uint8Array\r\n  }[]\r\n\r\n  private refSampleDuration: bigint\r\n\r\n  public init(codecpar: pointer<AVCodecParameters>, timeBase: pointer<Rational>): number {\r\n\r\n    super.init(codecpar, timeBase)\r\n\r\n    this.caches = []\r\n    this.refSampleDuration = 0n\r\n\r\n    this.bitReader = new BitReader()\r\n    this.streamMuxConfig = {\r\n      profile: NOPTS_VALUE,\r\n      sampleRate: NOPTS_VALUE,\r\n      channels: NOPTS_VALUE\r\n    }\r\n\r\n    return 0\r\n  }\r\n\r\n  public sendAVPacket(avpacket: pointer<AVPacket>): number {\r\n\r\n    const buffer = mapUint8Array(avpacket.data, avpacket.size)\r\n\r\n    this.bitReader.appendBuffer(buffer)\r\n\r\n    let lastDts = avpacket.dts || avpacket.pts\r\n\r\n    while (this.bitReader.remainingLength() >= 20) {\r\n\r\n      const now = this.bitReader.getPointer()\r\n\r\n      const info = aac.parseLATMHeader(null, this.bitReader)\r\n\r\n      if (is.number(info)) {\r\n        logger.error('AACLATMParser parse failed')\r\n        this.bitReader.reset()\r\n        return errorType.DATA_INVALID\r\n      }\r\n\r\n      if (info.framePayloadLength >= this.bitReader.remainingLength()) {\r\n        this.bitReader.skipPadding()\r\n        this.bitReader.setPointer(now)\r\n        break\r\n      }\r\n\r\n      if (!info.useSameStreamMux) {\r\n        this.streamMuxConfig.profile = info.profile\r\n        this.streamMuxConfig.sampleRate = info.sampleRate\r\n        this.streamMuxConfig.channels = info.channels\r\n      }\r\n\r\n      const length = info.framePayloadLength\r\n\r\n      const rawData = new Uint8Array(length)\r\n      for (let i = 0; i < length; i++) {\r\n        rawData[i] = this.bitReader.readU(8)\r\n      }\r\n\r\n      const item = {\r\n        dts: lastDts,\r\n        buffer: rawData,\r\n        extradata: null\r\n      }\r\n\r\n      const hasNewExtraData = this.inCodecpar.profile !== this.streamMuxConfig.profile\r\n        || this.inCodecpar.sampleRate !== this.streamMuxConfig.sampleRate\r\n        || this.inCodecpar.chLayout.nbChannels !== this.streamMuxConfig.channels\r\n\r\n      if (hasNewExtraData) {\r\n\r\n        this.refSampleDuration = avRescaleQ(\r\n          static_cast<int64>(1024 / this.streamMuxConfig.sampleRate * AV_TIME_BASE),\r\n          AV_TIME_BASE_Q,\r\n          this.inTimeBase\r\n        )\r\n\r\n        this.inCodecpar.profile = this.streamMuxConfig.profile\r\n        this.inCodecpar.sampleRate = this.streamMuxConfig.sampleRate\r\n        this.inCodecpar.chLayout.nbChannels = this.streamMuxConfig.channels\r\n\r\n        const extradata = avCodecParameters2Extradata(accessof(this.inCodecpar))\r\n\r\n        if (this.inCodecpar.extradata) {\r\n          avFree(this.inCodecpar.extradata)\r\n        }\r\n        this.inCodecpar.extradata = avMalloc(extradata.length)\r\n        memcpyFromUint8Array(this.inCodecpar.extradata, extradata.length, extradata)\r\n        this.inCodecpar.extradataSize = extradata.length\r\n        item.extradata = extradata\r\n      }\r\n\r\n      this.caches.push(item)\r\n      lastDts += this.refSampleDuration\r\n\r\n      this.bitReader.skipPadding()\r\n    }\r\n    return 0\r\n  }\r\n\r\n  public receiveAVPacket(avpacket: pointer<AVPacket>): number {\r\n    if (this.caches.length) {\r\n\r\n      unrefAVPacket(avpacket)\r\n\r\n      const item = this.caches.shift()\r\n\r\n      const data = avMalloc(item.buffer.length)\r\n      memcpyFromUint8Array(data, item.buffer.length, item.buffer)\r\n      addAVPacketData(avpacket, data, item.buffer.length)\r\n\r\n      avpacket.dts = avpacket.pts = item.dts\r\n      avpacket.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n      avpacket.duration = this.refSampleDuration\r\n      if (item.extradata) {\r\n        const extradata = avMalloc(item.extradata.length)\r\n        memcpyFromUint8Array(extradata, item.extradata.length, item.extradata)\r\n        addAVPacketSideData(avpacket, AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA, extradata, item.extradata.length)\r\n      }\r\n      return 0\r\n    }\r\n    else {\r\n      return errorType.EOF\r\n    }\r\n  }\r\n\r\n  public reset(): number {\r\n    this.bitReader.reset()\r\n    return 0\r\n  }\r\n}\r\n","/*\r\n * libmedia aac util\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../AVStream'\r\nimport { AVPacketSideDataType } from 'avutil/codec'\r\nimport { NOPTS_VALUE } from 'avutil/constant'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport BitReader from 'common/io/BitReader'\r\nimport { Uint8ArrayInterface } from 'common/io/interface'\r\n\r\nexport const enum MPEG4AudioObjectTypes {\r\n  NULL = 0,\r\n  /**\r\n   * Main-AAC\r\n   */\r\n  AAC_MAIN,\r\n  /**\r\n   * LC-AAC\r\n   */\r\n  AAC_LC,\r\n  AAC_SSR,\r\n  AAC_LTP,\r\n  /**\r\n   * HE-AAC\r\n   */\r\n  AAC_SBR,\r\n  AAC_SCALABLE,\r\n\r\n  LAYER1 = 32,\r\n  LAYER2,\r\n  /**\r\n   * MP3\r\n   */\r\n  LAYER3\r\n}\r\n\r\nexport const AACProfile2Name: Partial<Record<MPEG4AudioObjectTypes, string>> = {\r\n  [MPEG4AudioObjectTypes.AAC_MAIN]: 'Main',\r\n  [MPEG4AudioObjectTypes.AAC_LC]: 'LC',\r\n  [MPEG4AudioObjectTypes.AAC_SSR]: 'LC',\r\n  [MPEG4AudioObjectTypes.AAC_LTP]: 'LC',\r\n  [MPEG4AudioObjectTypes.AAC_SBR]: 'HE',\r\n  [MPEG4AudioObjectTypes.AAC_SCALABLE]: 'HE'\r\n}\r\n\r\nexport const MPEG4SamplingFrequencyIndex = {\r\n  96000: 0,\r\n  88200: 1,\r\n  64000: 2,\r\n  48000: 3,\r\n  44100: 4,\r\n  32000: 5,\r\n  24000: 6,\r\n  22050: 7,\r\n  16000: 8,\r\n  12000: 9,\r\n  11025: 10,\r\n  8000: 11,\r\n  7350: 12\r\n}\r\n\r\nexport const MPEG4SamplingFrequencies = [\r\n  96000,\r\n  88200,\r\n  64000,\r\n  48000,\r\n  44100,\r\n  32000,\r\n  24000,\r\n  22050,\r\n  16000,\r\n  12000,\r\n  11025,\r\n  8000,\r\n  7350,\r\n  NOPTS_VALUE,\r\n  NOPTS_VALUE,\r\n  NOPTS_VALUE\r\n]\r\n\r\nexport const MPEG4Channels = [\r\n  NOPTS_VALUE,\r\n  1,\r\n  2,\r\n  3,\r\n  4,\r\n  5,\r\n  6,\r\n  7\r\n]\r\n\r\n/**\r\n * 解析 AAC AudioSpecificConfig\r\n *    \r\n *             frequency\r\n *              44100Hz        fill bit\r\n *               4 bit          3 bit\r\n *              -------         -----\r\n *    0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0\r\n *    ---------         -------\r\n *      5 bit            4 bit\r\n *     AAC LC           fl, fr\r\n *    profile           channel\r\n * \r\n * url: https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Audio_Specific_Config\r\n * \r\n */\r\n\r\nexport function getAVCodecParameters(extradata: Uint8ArrayInterface) {\r\n  let profile = NOPTS_VALUE\r\n  let sampleRate = NOPTS_VALUE\r\n  let channels = NOPTS_VALUE\r\n  if (extradata.length >= 2) {\r\n    profile = (extradata[0] >> 3) & 0x1f\r\n    sampleRate = MPEG4SamplingFrequencies[((extradata[0] & 0x07) << 1)\r\n      | (extradata[1] >> 7)] ?? 48000\r\n\r\n    channels = MPEG4Channels[(extradata[1] >> 3) & 0x0f] ?? 2\r\n  }\r\n\r\n  return {\r\n    profile,\r\n    sampleRate,\r\n    channels\r\n  }\r\n}\r\n\r\nexport function parseAVCodecParameters(stream: Stream, extradata?: Uint8ArrayInterface) {\r\n  if (!extradata && stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]) {\r\n    extradata = stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]\r\n  }\r\n  if (extradata) {\r\n    const { profile, sampleRate, channels } = getAVCodecParameters(extradata)\r\n    stream.codecpar.profile = profile\r\n    stream.codecpar.sampleRate = sampleRate\r\n    stream.codecpar.chLayout.nbChannels = channels\r\n  }\r\n}\r\n\r\nexport function avCodecParameters2Extradata(codecpar: AVCodecParameters) {\r\n  const samplingFreqIndex = MPEG4SamplingFrequencyIndex[codecpar.sampleRate]\r\n  const channelConfig = codecpar.chLayout.nbChannels\r\n\r\n  const extradata = new Uint8Array(2)\r\n  extradata[0] = ((codecpar.profile & 0x1f) << 3) | ((samplingFreqIndex & 0x0e) >> 1)\r\n  extradata[1] = ((samplingFreqIndex & 0x01) << 7) | ((channelConfig & 0x0f) << 3)\r\n\r\n  return extradata\r\n}\r\n\r\nexport interface AACADTSHeader {\r\n  syncWord: number\r\n  profile: number\r\n  sampleRate: number\r\n  channels: number\r\n  aacFrameLength: number\r\n  numberOfRawDataBlocksInFrame: number\r\n  headerLength: number\r\n  framePayloadLength: number\r\n}\r\n\r\nexport interface AACLATMHeader {\r\n  syncWord: number\r\n  profile: number\r\n  sampleRate: number\r\n  channels: number\r\n  useSameStreamMux: boolean\r\n  headerLength: number\r\n  framePayloadLength: number\r\n  muxLengthBytes: number\r\n}\r\n\r\n/**\r\n * \r\n * adts 封装转 raw\r\n * \r\n * bits    \r\n * - 12  syncword\r\n * - 1   ID (MPEG 标识位，固定为 1)\r\n * - 2   Layer ( 固定为 0)\r\n * - 1   Protection Absent ( 指示是否有 CRC 校验，1 表示没有校验）\r\n * - 2   Profile\r\n * - 4   Sampling Frequency Index ( 采样率的索引）\r\n * - 1   Private Bit ( 保留位，一般设置为 0)\r\n * - 3   Channel Configuration ( 音频通道数）\r\n * - 1   Original Copy ( 原始拷贝标志位，一般设置为 0)\r\n * - 1   Home ( 保留位，一般设置为 0)\r\n * - 1   Copyright Identification Bit（置 0）\r\n * - 1   Copyright Identification Start（置 0）\r\n * - 13  Frame Length ( 帧长度，包括 ADTS 头和音频帧数据的长度）\r\n * - 11  Buffer Fullness ( 缓冲区满度，可用于音频流的同步）\r\n * - 2   Number of Raw Data Blocks in Frame ( 帧中原始数据块的数量）\r\n * - 16  CRC (Protection Absent 控制）\r\n * - N  raw aac data\r\n * \r\n */\r\nexport function parseADTSHeader(buffer: Uint8ArrayInterface): AACADTSHeader | number {\r\n\r\n  if (buffer.length < 7) {\r\n    return -1\r\n  }\r\n\r\n  const syncWord = (buffer[0] << 4) | (buffer[0 + 1] >> 4)\r\n\r\n  if (syncWord !== 0xFFF) {\r\n    return -1\r\n  }\r\n\r\n  /*\r\n    * const id = (buffer[1] & 0x08) >>> 3\r\n    * const layer = (buffer[1] & 0x06) >>> 1\r\n    */\r\n  const protectionAbsent = buffer[1] & 0x01\r\n  const profile = (buffer[2] & 0xC0) >>> 6\r\n  const samplingFrequencyIndex = (buffer[2] & 0x3C) >>> 2\r\n  const channelConfiguration = ((buffer[2] & 0x01) << 2) | ((buffer[3] & 0xC0) >>> 6)\r\n\r\n  // adts_variable_header()\r\n  const aacFrameLength = ((buffer[3] & 0x03) << 11)\r\n    | (buffer[4] << 3)\r\n    | ((buffer[5] & 0xE0) >>> 5)\r\n\r\n  const numberOfRawDataBlocksInFrame = buffer[6] & 0x03\r\n\r\n  let headerLength = protectionAbsent === 1 ? 7 : 9\r\n  let framePayloadLength = aacFrameLength - headerLength\r\n\r\n  return {\r\n    syncWord,\r\n    profile: profile + 1,\r\n    sampleRate: MPEG4SamplingFrequencies[samplingFrequencyIndex],\r\n    channels: MPEG4Channels[channelConfiguration],\r\n    aacFrameLength,\r\n    numberOfRawDataBlocksInFrame,\r\n    headerLength,\r\n    framePayloadLength\r\n  }\r\n}\r\n\r\nexport function parseLATMHeader(buffer: Uint8ArrayInterface, bitReader?: BitReader) {\r\n  if (!bitReader) {\r\n    bitReader = new BitReader()\r\n    bitReader.appendBuffer(buffer)\r\n  }\r\n\r\n  function getLATMValue() {\r\n    const bytesForValue = bitReader.readU(2)\r\n    let value = 0\r\n\r\n    for (let i = 0; i <= bytesForValue; i++) {\r\n      value = value << 8\r\n      value = value | bitReader.readU(8)\r\n    }\r\n    return value\r\n  }\r\n\r\n  const now = bitReader.getPointer()\r\n\r\n  const info: AACLATMHeader = {\r\n    syncWord: 0,\r\n    profile: 0,\r\n    sampleRate: 0,\r\n    channels: 0,\r\n    useSameStreamMux: false,\r\n    headerLength: 0,\r\n    framePayloadLength: 0,\r\n    muxLengthBytes: 0\r\n  }\r\n\r\n  const syncWord = bitReader.readU(11)\r\n\r\n  if (syncWord !== 0x2B7) {\r\n    return -1\r\n  }\r\n\r\n  info.syncWord = syncWord\r\n\r\n  info.muxLengthBytes = bitReader.readU(13)\r\n\r\n  const useSameStreamMux = bitReader.readU1() === 0x01\r\n\r\n  info.useSameStreamMux = useSameStreamMux\r\n\r\n  if (!useSameStreamMux) {\r\n    const audioMuxVersion = bitReader.readU1() === 0x01\r\n    const audioMuxVersionA = audioMuxVersion && bitReader.readU1() === 0x01\r\n    if (audioMuxVersionA) {\r\n      return -1\r\n    }\r\n    if (audioMuxVersion) {\r\n      getLATMValue()\r\n    }\r\n    const allStreamsSameTimeFraming = bitReader.readU1() === 0x01\r\n    if (!allStreamsSameTimeFraming) {\r\n      return -1\r\n    }\r\n    const numSubFrames = bitReader.readU(6)\r\n    if (numSubFrames !== 0) {\r\n      return -1\r\n    }\r\n\r\n    const numProgram = bitReader.readU(4)\r\n    if (numProgram !== 0) {\r\n      return -1\r\n    }\r\n\r\n    const numLayer = bitReader.readU(3)\r\n    if (numLayer !== 0) {\r\n      return -1\r\n    }\r\n\r\n    let fillBits = audioMuxVersion ? getLATMValue() : 0\r\n\r\n    const audioObjectType = bitReader.readU(5)\r\n    fillBits -= 5\r\n\r\n    const samplingFreqIndex = bitReader.readU(4)\r\n    fillBits -= 4\r\n\r\n    const channelConfig = bitReader.readU(4)\r\n    fillBits -= 4\r\n\r\n    bitReader.readU(3)\r\n    fillBits -= 3\r\n\r\n    if (fillBits > 0) {\r\n      bitReader.readU(fillBits)\r\n    }\r\n\r\n    const frameLengthType = bitReader.readU(3)\r\n    if (frameLengthType === 0) {\r\n      bitReader.readU(8)\r\n    }\r\n    else {\r\n      return -1\r\n    }\r\n\r\n    const otherDataPresent = bitReader.readU1() === 0x01\r\n    if (otherDataPresent) {\r\n      if (audioMuxVersion) {\r\n        getLATMValue()\r\n      }\r\n      else {\r\n        let otherDataLenBits = 0\r\n        while (true) {\r\n          otherDataLenBits = otherDataLenBits << 8\r\n          const otherDataLenEsc = bitReader.readU1() === 0x01\r\n          const otherDataLenTmp = bitReader.readU(8)\r\n          otherDataLenBits += otherDataLenTmp\r\n          if (!otherDataLenEsc) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const crcCheckPresent = bitReader.readU1() === 0x01\r\n    if (crcCheckPresent) {\r\n      bitReader.readU(8)\r\n    }\r\n\r\n    info.profile = audioObjectType + 1\r\n    info.sampleRate = MPEG4SamplingFrequencies[samplingFreqIndex]\r\n    info.channels = MPEG4Channels[channelConfig]\r\n  }\r\n\r\n  let length = 0\r\n  while (true) {\r\n    const tmp = bitReader.readU(8)\r\n    length += tmp\r\n    if (tmp !== 0xff) {\r\n      break\r\n    }\r\n  }\r\n\r\n  info.framePayloadLength = length\r\n  info.headerLength = bitReader.getPointer() - now + (bitReader.getBitLeft() === 8 ? 0 : 1)\r\n\r\n  return info\r\n}\r\n","/*\r\n * libmedia aac decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVStream from '../AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVCodecID, AVMediaType } from 'avutil/codec'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\nimport IFormat from './IFormat'\r\nimport { AVFormat, AVSeekFlags } from '../avformat'\r\nimport { memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport { avMalloc } from 'avutil/util/mem'\r\nimport { addAVPacketData } from 'avutil/util/avpacket'\r\nimport { IOError } from 'common/io/error'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { AV_MILLI_TIME_BASE_Q, AV_TIME_BASE, AV_TIME_BASE_Q, NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\nimport * as array from 'common/util/array'\r\nimport { avCodecParameters2Extradata, parseLATMHeader, parseADTSHeader } from '../codecs/aac'\r\nimport * as is from 'common/util/is'\r\nimport LATM2RawFilter from '../bsf/aac/LATM2RawFilter'\r\n\r\nconst enum FrameType {\r\n  ADIF,\r\n  ADTS,\r\n  LATM\r\n}\r\n\r\nconst PACKET_SIZE = 1024\r\n\r\nexport default class IAacFormat extends IFormat {\r\n\r\n  public type: AVFormat = AVFormat.AAC\r\n\r\n  private frameType: FrameType\r\n  private fileSize: int64\r\n  private currentPts: int64\r\n\r\n  private latmFilter: LATM2RawFilter\r\n\r\n  constructor() {\r\n    super()\r\n  }\r\n\r\n  public init(formatContext: AVIFormatContext): void {\r\n    this.currentPts = 0n\r\n  }\r\n\r\n  public destroy(formatContext: AVIFormatContext): void {\r\n    if (this.latmFilter) {\r\n      this.latmFilter.destroy()\r\n      this.latmFilter = null\r\n    }\r\n  }\r\n\r\n  private async estimateTotalBlock(formatContext: AVIFormatContext) {\r\n    let duration = 0\r\n    const now = formatContext.ioReader.getPos()\r\n    while (true) {\r\n      try {\r\n        const nextFrame = await formatContext.ioReader.peekBuffer(7)\r\n        const aacFrameLength = ((nextFrame[3] & 0x03) << 11)\r\n          | (nextFrame[4] << 3)\r\n          | ((nextFrame[5] & 0xE0) >>> 5)\r\n        const numberOfRawDataBlocksInFrame = nextFrame[6] & 0x03\r\n        duration += (numberOfRawDataBlocksInFrame + 1)\r\n        await formatContext.ioReader.skip(aacFrameLength)\r\n      }\r\n      catch (error) {\r\n        break\r\n      }\r\n    }\r\n\r\n    await formatContext.ioReader.seek(now)\r\n\r\n    return duration\r\n  }\r\n\r\n  public async readHeader(formatContext: AVIFormatContext): Promise<number> {\r\n    const signature = await formatContext.ioReader.peekBuffer(4)\r\n\r\n    this.fileSize = await formatContext.ioReader.fileSize()\r\n\r\n    // ADIF\r\n    if (signature[0] === 65 && signature[1] === 68 && signature[2] === 73 && signature[3] === 70) {\r\n      const stream = formatContext.createStream()\r\n      stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_AAC\r\n      stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n      this.frameType = FrameType.ADIF\r\n\r\n      stream.duration = this.fileSize\r\n      stream.timeBase.den = PACKET_SIZE * 16\r\n      stream.timeBase.num = 1\r\n    }\r\n    // ADTS\r\n    else if (signature[0] === 0xff && (signature[1] & 0xf0) === 0xf0) {\r\n      this.frameType = FrameType.ADTS\r\n      const stream = formatContext.createStream()\r\n      stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_AAC\r\n      stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n\r\n      const info = parseADTSHeader(await formatContext.ioReader.peekBuffer(20))\r\n\r\n      if (is.number(info)) {\r\n        return errorType.DATA_INVALID\r\n      }\r\n\r\n      stream.codecpar.profile = info.profile\r\n      stream.codecpar.sampleRate = info.sampleRate\r\n      stream.codecpar.chLayout.nbChannels = info.channels\r\n      const extradata = avCodecParameters2Extradata(stream.codecpar)\r\n      stream.codecpar.extradata = avMalloc(extradata.length)\r\n      memcpyFromUint8Array(stream.codecpar.extradata, extradata.length, extradata)\r\n      stream.codecpar.extradataSize = extradata.length\r\n      stream.timeBase.den = stream.codecpar.sampleRate\r\n      stream.timeBase.num = 1\r\n\r\n      stream.duration = avRescaleQ(\r\n        static_cast<int64>((await this.estimateTotalBlock(formatContext)) * 1024 / stream.codecpar.sampleRate * AV_TIME_BASE),\r\n        AV_TIME_BASE_Q,\r\n        stream.timeBase\r\n      )\r\n    }\r\n    // LATM\r\n    else if (signature[0] === 0x56 && (signature[1] & 0xe0) === 0xe0) {\r\n      this.frameType = FrameType.LATM\r\n      const stream = formatContext.createStream()\r\n      stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_AAC\r\n      stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n\r\n      const info = parseLATMHeader(await formatContext.ioReader.peekBuffer(20))\r\n\r\n      if (is.number(info)) {\r\n        return errorType.DATA_INVALID\r\n      }\r\n\r\n      stream.codecpar.profile = info.profile\r\n      stream.codecpar.sampleRate = info.sampleRate\r\n      stream.codecpar.chLayout.nbChannels = info.channels\r\n      const extradata = avCodecParameters2Extradata(stream.codecpar)\r\n      stream.codecpar.extradata = avMalloc(extradata.length)\r\n      memcpyFromUint8Array(stream.codecpar.extradata, extradata.length, extradata)\r\n      stream.codecpar.extradataSize = extradata.length\r\n\r\n      stream.duration = this.fileSize\r\n      stream.timeBase.den = PACKET_SIZE * 16\r\n      stream.timeBase.num = 1\r\n\r\n      this.latmFilter = new LATM2RawFilter()\r\n\r\n      this.latmFilter.init(addressof(stream.codecpar), addressof(stream.timeBase))\r\n\r\n    }\r\n    else {\r\n      return errorType.DATA_INVALID\r\n    }\r\n\r\n    return 0\r\n  }\r\n\r\n  public async readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number> {\r\n\r\n    const stream: AVStream = formatContext.streams.find((stream) => {\r\n      return stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n    })\r\n\r\n    try {\r\n      const now = formatContext.ioReader.getPos()\r\n      let nextFrame: Uint8Array\r\n\r\n      if (this.frameType === FrameType.ADIF) {\r\n        nextFrame = await formatContext.ioReader.readBuffer(Math.min(PACKET_SIZE, static_cast<int32>(this.fileSize - now)))\r\n        const data = avMalloc(nextFrame.length)\r\n        memcpyFromUint8Array(data, nextFrame.length, nextFrame)\r\n        addAVPacketData(avpacket, data, nextFrame.length)\r\n        avpacket.duration = static_cast<int64>(PACKET_SIZE)\r\n        avpacket.pos = now\r\n      }\r\n      else if (this.frameType === FrameType.ADTS) {\r\n        const header = await formatContext.ioReader.readBuffer(7)\r\n\r\n        const protectionAbsent = header[1] & 0x01\r\n\r\n        const aacFrameLength = ((header[3] & 0x03) << 11)\r\n          | (header[4] << 3)\r\n          | ((header[5] & 0xE0) >>> 5)\r\n\r\n        const numberOfRawDataBlocksInFrame = header[6] & 0x03\r\n\r\n        let adtsHeaderLength = protectionAbsent === 1 ? 7 : 9\r\n        let adtsFramePayloadLength = aacFrameLength - adtsHeaderLength\r\n\r\n        if (adtsHeaderLength === 9) {\r\n          await formatContext.ioReader.skip(2)\r\n        }\r\n\r\n        const duration = avRescaleQ(\r\n          static_cast<int64>((numberOfRawDataBlocksInFrame + 1) * 1024 / stream.codecpar.sampleRate * AV_TIME_BASE),\r\n          AV_TIME_BASE_Q,\r\n          stream.timeBase\r\n        )\r\n        avpacket.duration = duration\r\n\r\n        nextFrame = await formatContext.ioReader.readBuffer(adtsFramePayloadLength)\r\n\r\n        const data = avMalloc(nextFrame.length)\r\n        memcpyFromUint8Array(data, nextFrame.length, nextFrame)\r\n        addAVPacketData(avpacket, data, nextFrame.length)\r\n        avpacket.pos = now\r\n      }\r\n      else if (this.frameType === FrameType.LATM) {\r\n        if (now === this.fileSize) {\r\n          return IOError.END\r\n        }\r\n        while (true) {\r\n          let ret = this.latmFilter.receiveAVPacket(avpacket)\r\n          if (ret === errorType.EOF) {\r\n            if (formatContext.ioReader.getPos() === this.fileSize) {\r\n              return IOError.END\r\n            }\r\n            nextFrame = await formatContext.ioReader.readBuffer(Math.min(PACKET_SIZE, static_cast<int32>(this.fileSize - now)))\r\n            const data = avMalloc(nextFrame.length)\r\n            memcpyFromUint8Array(data, nextFrame.length, nextFrame)\r\n            addAVPacketData(avpacket, data, nextFrame.length)\r\n            this.latmFilter.sendAVPacket(avpacket)\r\n            continue\r\n          }\r\n          else if (ret < 0) {\r\n            return ret\r\n          }\r\n          else {\r\n            avpacket.duration = static_cast<int64>(avpacket.size)\r\n            avpacket.pos = this.currentPts\r\n            break\r\n          }\r\n        }\r\n      }\r\n\r\n      avpacket.streamIndex = stream.index\r\n      avpacket.timeBase.den = stream.timeBase.den\r\n      avpacket.timeBase.num = stream.timeBase.num\r\n      avpacket.dts = avpacket.pts = this.currentPts\r\n      this.currentPts += avpacket.duration\r\n\r\n      return 0\r\n    }\r\n    catch (error) {\r\n      if (formatContext.ioReader.error !== IOError.END) {\r\n        logger.error(`read packet error, ${error}`)\r\n        return errorType.DATA_INVALID\r\n      }\r\n      return formatContext.ioReader.error\r\n    }\r\n  }\r\n\r\n  @deasync\r\n  private async syncFrame(formatContext: AVIFormatContext) {\r\n\r\n    if (this.frameType === FrameType.ADIF) {\r\n      return\r\n    }\r\n\r\n    let pos: int64 = NOPTS_VALUE_BIGINT\r\n\r\n    const analyzeCount = 3\r\n\r\n    const syncWord = this.frameType === FrameType.ADTS ? 0xFFF : 0x2B7\r\n    const shift = this.frameType === FrameType.ADTS ? 4 : 5\r\n\r\n    while (true) {\r\n      try {\r\n        let count = 0\r\n        pos = formatContext.ioReader.getPos()\r\n        while (true) {\r\n          if (count === analyzeCount) {\r\n            break\r\n          }\r\n          const word = (await formatContext.ioReader.peekUint16()) >>> shift\r\n          if (word === syncWord) {\r\n            const info = this.frameType === FrameType.ADTS\r\n              ? parseADTSHeader(await formatContext.ioReader.peekBuffer(9))\r\n              : parseLATMHeader(await formatContext.ioReader.peekBuffer(20))\r\n            if (!is.number(info)) {\r\n              count++\r\n              await formatContext.ioReader.skip(info.headerLength + info.framePayloadLength)\r\n              continue\r\n            }\r\n            else {\r\n              break\r\n            }\r\n          }\r\n          else {\r\n            break\r\n          }\r\n        }\r\n        if (count === analyzeCount) {\r\n          break\r\n        }\r\n        await formatContext.ioReader.skip(1)\r\n      }\r\n      catch (error) {\r\n        break\r\n      }\r\n    }\r\n\r\n    if (pos !== NOPTS_VALUE_BIGINT) {\r\n      await formatContext.ioReader.seek(pos)\r\n    }\r\n  }\r\n\r\n  public async seek(formatContext: AVIFormatContext, stream: AVStream, timestamp: int64, flags: int32): Promise<int64> {\r\n    if (this.frameType === FrameType.ADTS) {\r\n      const now = formatContext.ioReader.getPos()\r\n      if (flags & AVSeekFlags.BYTE) {\r\n\r\n        const size = await formatContext.ioReader.fileSize()\r\n\r\n        if (size <= 0n) {\r\n          return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n        }\r\n\r\n        if (timestamp < 0n) {\r\n          timestamp = 0n\r\n        }\r\n        else if (timestamp > size) {\r\n          timestamp = size\r\n        }\r\n        await formatContext.ioReader.seek(timestamp)\r\n\r\n        if (!(flags & AVSeekFlags.ANY)) {\r\n          await this.syncFrame(formatContext)\r\n\r\n          if (stream.duration && this.fileSize) {\r\n            this.currentPts = timestamp / this.fileSize * stream.duration\r\n          }\r\n        }\r\n        return now\r\n      }\r\n      else {\r\n        if (stream && stream.sampleIndexes.length) {\r\n          let index = array.binarySearch(stream.sampleIndexes, (item) => {\r\n            if (item.pts > timestamp) {\r\n              return -1\r\n            }\r\n            return 1\r\n          })\r\n          if (index > 0 && avRescaleQ(timestamp - stream.sampleIndexes[index - 1].pts, stream.timeBase, AV_MILLI_TIME_BASE_Q) < 5000n) {\r\n            logger.debug(`seek in sampleIndexes, found index: ${index}, pts: ${stream.sampleIndexes[index - 1].pts}, pos: ${stream.sampleIndexes[index - 1].pos}`)\r\n            await formatContext.ioReader.seek(stream.sampleIndexes[index - 1].pos)\r\n            this.currentPts = timestamp\r\n            return now\r\n          }\r\n        }\r\n\r\n        logger.debug('not found any keyframe index, try to seek in bytes')\r\n\r\n        if (stream.duration) {\r\n          await formatContext.ioReader.seek(0n)\r\n          let pts = 0n\r\n          while (true) {\r\n            try {\r\n              if (pts >= timestamp) {\r\n                this.currentPts = pts\r\n                return now\r\n              }\r\n              const nextFrame = await formatContext.ioReader.peekBuffer(7)\r\n              const aacFrameLength = ((nextFrame[3] & 0x03) << 11)\r\n                | (nextFrame[4] << 3)\r\n                | ((nextFrame[5] & 0xE0) >>> 5)\r\n              const numberOfRawDataBlocksInFrame = nextFrame[6] & 0x03\r\n              const duration = avRescaleQ(\r\n                static_cast<int64>((numberOfRawDataBlocksInFrame + 1) * 1024 / stream.codecpar.sampleRate * AV_TIME_BASE),\r\n                AV_TIME_BASE_Q,\r\n                stream.timeBase\r\n              )\r\n              pts += duration\r\n              await formatContext.ioReader.skip(aacFrameLength)\r\n            }\r\n            catch (error) {\r\n              return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n            }\r\n          }\r\n        }\r\n        else {\r\n          return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n        }\r\n      }\r\n    }\r\n    else if (this.frameType === FrameType.ADIF || this.frameType === FrameType.LATM) {\r\n\r\n      if (this.latmFilter) {\r\n        this.latmFilter.reset()\r\n      }\r\n\r\n      const now = formatContext.ioReader.getPos()\r\n\r\n      if (timestamp < 0n) {\r\n        timestamp = 0n\r\n      }\r\n      else if (timestamp > this.fileSize) {\r\n        timestamp = this.fileSize\r\n      }\r\n      await formatContext.ioReader.seek(timestamp)\r\n\r\n      this.currentPts = timestamp\r\n\r\n      if (this.frameType === FrameType.LATM && !(flags & AVSeekFlags.ANY)) {\r\n        await this.syncFrame(formatContext)\r\n      }\r\n      return now\r\n    }\r\n    return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n  }\r\n\r\n  public getAnalyzeStreamsCount(): number {\r\n    return 1\r\n  }\r\n}\r\n","/*\r\n * libmedia abstract format decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVFormat } from '../avformat'\r\n\r\nexport default abstract class IFormat {\r\n\r\n  public type: AVFormat = AVFormat.UNKNOWN\r\n\r\n  public onStreamAdd: (stream: Stream) => void\r\n\r\n  public abstract init(formatContext: AVIFormatContext): void\r\n\r\n  public destroy(formatContext: AVIFormatContext): void {}\r\n\r\n  public abstract getAnalyzeStreamsCount(): number\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readHeader(formatContext: AVIFormatContext): Promise<number>\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number>\r\n\r\n  /**\r\n   * seek\r\n   * \r\n   * @param context \r\n   * @param stream \r\n   * @param timestamp 毫秒时间戳\r\n   * @param flags \r\n   * \r\n   * @returns 返回 seek 之前的下一个 avpacket pos（若不知道返回 0n 方便之后可以再 seek 回来）返回负数表示 seek 失败\r\n   */\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract seek(\r\n    formatContext: AVIFormatContext,\r\n    stream: Stream,\r\n    timestamp: int64,\r\n    flags: int32\r\n  ): Promise<int64>\r\n}\r\n"],"names":[],"sourceRoot":""}
{"version":3,"file":"src_avformat_formats_IMovFormat_ts.avplayer.js","mappings":"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","sources":["webpack://AVPlayer/./src/avformat/codecs/aac.ts","webpack://AVPlayer/./src/avformat/codecs/ac3.ts","webpack://AVPlayer/./src/avformat/codecs/av1.ts","webpack://AVPlayer/./src/avformat/codecs/opus.ts","webpack://AVPlayer/./src/avformat/codecs/vp9.ts","webpack://AVPlayer/./src/avformat/formats/IFormat.ts","webpack://AVPlayer/./src/avformat/formats/IMovFormat.ts","webpack://AVPlayer/./src/avformat/formats/mov/boxType.ts","webpack://AVPlayer/./src/avformat/formats/mov/function/buildFragmentIndex.ts","webpack://AVPlayer/./src/avformat/formats/mov/function/buildIndex.ts","webpack://AVPlayer/./src/avformat/formats/mov/function/createFragmentTrack.ts","webpack://AVPlayer/./src/avformat/formats/mov/function/createMovContext.ts","webpack://AVPlayer/./src/avformat/formats/mov/function/createMovStreamContext.ts","webpack://AVPlayer/./src/avformat/formats/mov/function/getNextSample.ts","webpack://AVPlayer/./src/avformat/formats/mov/imov.ts","webpack://AVPlayer/./src/avformat/formats/mov/mov.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/av1c.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/avcc.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/co64.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/colr.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/ctts.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/dac3.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/dec3.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/dfla.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/dops.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/esds.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/hdlr.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/hvcc.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/mdhd.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/mfhd.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/mvhd.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/parsers.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/stco.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/stsc.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/stsd.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/stss.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/stsz.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/stts.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/stz2.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/tfdt.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/tfhd.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/tkhd.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/trex.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/trun.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/vpcc.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/vvcc.ts","webpack://AVPlayer/./src/avformat/formats/mov/parsing/wave.ts","webpack://AVPlayer/./src/avformat/function/mktag.ts","webpack://AVPlayer/./src/avutil/util/av1syntax.ts"],"sourcesContent":["/*\r\n * libmedia aac util\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../AVStream'\r\nimport { AVPacketSideDataType } from 'avutil/codec'\r\nimport { NOPTS_VALUE } from 'avutil/constant'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport BitReader from 'common/io/BitReader'\r\nimport { Uint8ArrayInterface } from 'common/io/interface'\r\n\r\nexport const enum MPEG4AudioObjectTypes {\r\n  NULL = 0,\r\n  /**\r\n   * Main-AAC\r\n   */\r\n  AAC_MAIN,\r\n  /**\r\n   * LC-AAC\r\n   */\r\n  AAC_LC,\r\n  AAC_SSR,\r\n  AAC_LTP,\r\n  /**\r\n   * HE-AAC\r\n   */\r\n  AAC_SBR,\r\n  AAC_SCALABLE,\r\n\r\n  LAYER1 = 32,\r\n  LAYER2,\r\n  /**\r\n   * MP3\r\n   */\r\n  LAYER3\r\n}\r\n\r\nexport const AACProfile2Name: Partial<Record<MPEG4AudioObjectTypes, string>> = {\r\n  [MPEG4AudioObjectTypes.AAC_MAIN]: 'Main',\r\n  [MPEG4AudioObjectTypes.AAC_LC]: 'LC',\r\n  [MPEG4AudioObjectTypes.AAC_SSR]: 'LC',\r\n  [MPEG4AudioObjectTypes.AAC_LTP]: 'LC',\r\n  [MPEG4AudioObjectTypes.AAC_SBR]: 'HE',\r\n  [MPEG4AudioObjectTypes.AAC_SCALABLE]: 'HE'\r\n}\r\n\r\nexport const MPEG4SamplingFrequencyIndex = {\r\n  96000: 0,\r\n  88200: 1,\r\n  64000: 2,\r\n  48000: 3,\r\n  44100: 4,\r\n  32000: 5,\r\n  24000: 6,\r\n  22050: 7,\r\n  16000: 8,\r\n  12000: 9,\r\n  11025: 10,\r\n  8000: 11,\r\n  7350: 12\r\n}\r\n\r\nexport const MPEG4SamplingFrequencies = [\r\n  96000,\r\n  88200,\r\n  64000,\r\n  48000,\r\n  44100,\r\n  32000,\r\n  24000,\r\n  22050,\r\n  16000,\r\n  12000,\r\n  11025,\r\n  8000,\r\n  7350,\r\n  NOPTS_VALUE,\r\n  NOPTS_VALUE,\r\n  NOPTS_VALUE\r\n]\r\n\r\nexport const MPEG4Channels = [\r\n  NOPTS_VALUE,\r\n  1,\r\n  2,\r\n  3,\r\n  4,\r\n  5,\r\n  6,\r\n  7\r\n]\r\n\r\n/**\r\n * 解析 AAC AudioSpecificConfig\r\n *    \r\n *             frequency\r\n *              44100Hz        fill bit\r\n *               4 bit          3 bit\r\n *              -------         -----\r\n *    0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0\r\n *    ---------         -------\r\n *      5 bit            4 bit\r\n *     AAC LC           fl, fr\r\n *    profile           channel\r\n * \r\n * url: https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Audio_Specific_Config\r\n * \r\n */\r\n\r\nexport function getAVCodecParameters(extradata: Uint8ArrayInterface) {\r\n  let profile = NOPTS_VALUE\r\n  let sampleRate = NOPTS_VALUE\r\n  let channels = NOPTS_VALUE\r\n  if (extradata.length >= 2) {\r\n    profile = (extradata[0] >> 3) & 0x1f\r\n    sampleRate = MPEG4SamplingFrequencies[((extradata[0] & 0x07) << 1)\r\n      | (extradata[1] >> 7)] ?? 48000\r\n\r\n    channels = MPEG4Channels[(extradata[1] >> 3) & 0x0f] ?? 2\r\n  }\r\n\r\n  return {\r\n    profile,\r\n    sampleRate,\r\n    channels\r\n  }\r\n}\r\n\r\nexport function parseAVCodecParameters(stream: Stream, extradata?: Uint8ArrayInterface) {\r\n  if (!extradata && stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]) {\r\n    extradata = stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]\r\n  }\r\n  if (extradata) {\r\n    const { profile, sampleRate, channels } = getAVCodecParameters(extradata)\r\n    stream.codecpar.profile = profile\r\n    stream.codecpar.sampleRate = sampleRate\r\n    stream.codecpar.chLayout.nbChannels = channels\r\n  }\r\n}\r\n\r\nexport function avCodecParameters2Extradata(codecpar: AVCodecParameters) {\r\n  const samplingFreqIndex = MPEG4SamplingFrequencyIndex[codecpar.sampleRate]\r\n  const channelConfig = codecpar.chLayout.nbChannels\r\n\r\n  const extradata = new Uint8Array(2)\r\n  extradata[0] = ((codecpar.profile & 0x1f) << 3) | ((samplingFreqIndex & 0x0e) >> 1)\r\n  extradata[1] = ((samplingFreqIndex & 0x01) << 7) | ((channelConfig & 0x0f) << 3)\r\n\r\n  return extradata\r\n}\r\n\r\nexport interface AACADTSHeader {\r\n  syncWord: number\r\n  profile: number\r\n  sampleRate: number\r\n  channels: number\r\n  aacFrameLength: number\r\n  numberOfRawDataBlocksInFrame: number\r\n  headerLength: number\r\n  framePayloadLength: number\r\n}\r\n\r\nexport interface AACLATMHeader {\r\n  syncWord: number\r\n  profile: number\r\n  sampleRate: number\r\n  channels: number\r\n  useSameStreamMux: boolean\r\n  headerLength: number\r\n  framePayloadLength: number\r\n  muxLengthBytes: number\r\n}\r\n\r\n/**\r\n * \r\n * adts 封装转 raw\r\n * \r\n * bits    \r\n * - 12  syncword\r\n * - 1   ID (MPEG 标识位，固定为 1)\r\n * - 2   Layer ( 固定为 0)\r\n * - 1   Protection Absent ( 指示是否有 CRC 校验，1 表示没有校验）\r\n * - 2   Profile\r\n * - 4   Sampling Frequency Index ( 采样率的索引）\r\n * - 1   Private Bit ( 保留位，一般设置为 0)\r\n * - 3   Channel Configuration ( 音频通道数）\r\n * - 1   Original Copy ( 原始拷贝标志位，一般设置为 0)\r\n * - 1   Home ( 保留位，一般设置为 0)\r\n * - 1   Copyright Identification Bit（置 0）\r\n * - 1   Copyright Identification Start（置 0）\r\n * - 13  Frame Length ( 帧长度，包括 ADTS 头和音频帧数据的长度）\r\n * - 11  Buffer Fullness ( 缓冲区满度，可用于音频流的同步）\r\n * - 2   Number of Raw Data Blocks in Frame ( 帧中原始数据块的数量）\r\n * - 16  CRC (Protection Absent 控制）\r\n * - N  raw aac data\r\n * \r\n */\r\nexport function parseADTSHeader(buffer: Uint8ArrayInterface): AACADTSHeader | number {\r\n\r\n  if (buffer.length < 7) {\r\n    return -1\r\n  }\r\n\r\n  const syncWord = (buffer[0] << 4) | (buffer[0 + 1] >> 4)\r\n\r\n  if (syncWord !== 0xFFF) {\r\n    return -1\r\n  }\r\n\r\n  /*\r\n    * const id = (buffer[1] & 0x08) >>> 3\r\n    * const layer = (buffer[1] & 0x06) >>> 1\r\n    */\r\n  const protectionAbsent = buffer[1] & 0x01\r\n  const profile = (buffer[2] & 0xC0) >>> 6\r\n  const samplingFrequencyIndex = (buffer[2] & 0x3C) >>> 2\r\n  const channelConfiguration = ((buffer[2] & 0x01) << 2) | ((buffer[3] & 0xC0) >>> 6)\r\n\r\n  // adts_variable_header()\r\n  const aacFrameLength = ((buffer[3] & 0x03) << 11)\r\n    | (buffer[4] << 3)\r\n    | ((buffer[5] & 0xE0) >>> 5)\r\n\r\n  const numberOfRawDataBlocksInFrame = buffer[6] & 0x03\r\n\r\n  let headerLength = protectionAbsent === 1 ? 7 : 9\r\n  let framePayloadLength = aacFrameLength - headerLength\r\n\r\n  return {\r\n    syncWord,\r\n    profile: profile + 1,\r\n    sampleRate: MPEG4SamplingFrequencies[samplingFrequencyIndex],\r\n    channels: MPEG4Channels[channelConfiguration],\r\n    aacFrameLength,\r\n    numberOfRawDataBlocksInFrame,\r\n    headerLength,\r\n    framePayloadLength\r\n  }\r\n}\r\n\r\nexport function parseLATMHeader(buffer: Uint8ArrayInterface, bitReader?: BitReader) {\r\n  if (!bitReader) {\r\n    bitReader = new BitReader()\r\n    bitReader.appendBuffer(buffer)\r\n  }\r\n\r\n  function getLATMValue() {\r\n    const bytesForValue = bitReader.readU(2)\r\n    let value = 0\r\n\r\n    for (let i = 0; i <= bytesForValue; i++) {\r\n      value = value << 8\r\n      value = value | bitReader.readU(8)\r\n    }\r\n    return value\r\n  }\r\n\r\n  const now = bitReader.getPointer()\r\n\r\n  const info: AACLATMHeader = {\r\n    syncWord: 0,\r\n    profile: 0,\r\n    sampleRate: 0,\r\n    channels: 0,\r\n    useSameStreamMux: false,\r\n    headerLength: 0,\r\n    framePayloadLength: 0,\r\n    muxLengthBytes: 0\r\n  }\r\n\r\n  const syncWord = bitReader.readU(11)\r\n\r\n  if (syncWord !== 0x2B7) {\r\n    return -1\r\n  }\r\n\r\n  info.syncWord = syncWord\r\n\r\n  info.muxLengthBytes = bitReader.readU(13)\r\n\r\n  const useSameStreamMux = bitReader.readU1() === 0x01\r\n\r\n  info.useSameStreamMux = useSameStreamMux\r\n\r\n  if (!useSameStreamMux) {\r\n    const audioMuxVersion = bitReader.readU1() === 0x01\r\n    const audioMuxVersionA = audioMuxVersion && bitReader.readU1() === 0x01\r\n    if (audioMuxVersionA) {\r\n      return -1\r\n    }\r\n    if (audioMuxVersion) {\r\n      getLATMValue()\r\n    }\r\n    const allStreamsSameTimeFraming = bitReader.readU1() === 0x01\r\n    if (!allStreamsSameTimeFraming) {\r\n      return -1\r\n    }\r\n    const numSubFrames = bitReader.readU(6)\r\n    if (numSubFrames !== 0) {\r\n      return -1\r\n    }\r\n\r\n    const numProgram = bitReader.readU(4)\r\n    if (numProgram !== 0) {\r\n      return -1\r\n    }\r\n\r\n    const numLayer = bitReader.readU(3)\r\n    if (numLayer !== 0) {\r\n      return -1\r\n    }\r\n\r\n    let fillBits = audioMuxVersion ? getLATMValue() : 0\r\n\r\n    const audioObjectType = bitReader.readU(5)\r\n    fillBits -= 5\r\n\r\n    const samplingFreqIndex = bitReader.readU(4)\r\n    fillBits -= 4\r\n\r\n    const channelConfig = bitReader.readU(4)\r\n    fillBits -= 4\r\n\r\n    bitReader.readU(3)\r\n    fillBits -= 3\r\n\r\n    if (fillBits > 0) {\r\n      bitReader.readU(fillBits)\r\n    }\r\n\r\n    const frameLengthType = bitReader.readU(3)\r\n    if (frameLengthType === 0) {\r\n      bitReader.readU(8)\r\n    }\r\n    else {\r\n      return -1\r\n    }\r\n\r\n    const otherDataPresent = bitReader.readU1() === 0x01\r\n    if (otherDataPresent) {\r\n      if (audioMuxVersion) {\r\n        getLATMValue()\r\n      }\r\n      else {\r\n        let otherDataLenBits = 0\r\n        while (true) {\r\n          otherDataLenBits = otherDataLenBits << 8\r\n          const otherDataLenEsc = bitReader.readU1() === 0x01\r\n          const otherDataLenTmp = bitReader.readU(8)\r\n          otherDataLenBits += otherDataLenTmp\r\n          if (!otherDataLenEsc) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const crcCheckPresent = bitReader.readU1() === 0x01\r\n    if (crcCheckPresent) {\r\n      bitReader.readU(8)\r\n    }\r\n\r\n    info.profile = audioObjectType + 1\r\n    info.sampleRate = MPEG4SamplingFrequencies[samplingFreqIndex]\r\n    info.channels = MPEG4Channels[channelConfig]\r\n  }\r\n\r\n  let length = 0\r\n  while (true) {\r\n    const tmp = bitReader.readU(8)\r\n    length += tmp\r\n    if (tmp !== 0xff) {\r\n      break\r\n    }\r\n  }\r\n\r\n  info.framePayloadLength = length\r\n  info.headerLength = bitReader.getPointer() - now + (bitReader.getBitLeft() === 8 ? 0 : 1)\r\n\r\n  return info\r\n}\r\n","/*\r\n * libmedia ac3 util\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { AV_CH_LAYOUT } from 'avutil/audiosamplefmt'\r\nimport BitReader from 'common/io/BitReader'\r\nimport { Uint8ArrayInterface } from 'common/io/interface'\r\n\r\nexport const enum AC3DeltaStrategy {\r\n  DBA_REUSE = 0,\r\n  DBA_NEW,\r\n  DBA_NONE,\r\n  DBA_RESERVED\r\n}\r\n\r\nexport const enum AC3ChannelMode {\r\n  AC3_CHMODE_DUALMONO = 0,\r\n  AC3_CHMODE_MONO,\r\n  AC3_CHMODE_STEREO,\r\n  AC3_CHMODE_3F,\r\n  AC3_CHMODE_2F1R,\r\n  AC3_CHMODE_3F1R,\r\n  AC3_CHMODE_2F2R,\r\n  AC3_CHMODE_3F2R\r\n}\r\n\r\nexport const enum AC3DolbySurroundMode {\r\n  AC3_DSURMOD_NOTINDICATED = 0,\r\n  AC3_DSURMOD_OFF,\r\n  AC3_DSURMOD_ON,\r\n  AC3_DSURMOD_RESERVED\r\n}\r\n\r\nexport const enum AC3DolbySurroundEXMode {\r\n  AC3_DSUREXMOD_NOTINDICATED = 0,\r\n  AC3_DSUREXMOD_OFF,\r\n  AC3_DSUREXMOD_ON,\r\n  AC3_DSUREXMOD_PLIIZ\r\n}\r\n\r\nexport const enum AC3DolbyHeadphoneMode {\r\n  AC3_DHEADPHONMOD_NOTINDICATED = 0,\r\n  AC3_DHEADPHONMOD_OFF,\r\n  AC3_DHEADPHONMOD_ON,\r\n  AC3_DHEADPHONMOD_RESERVED\r\n}\r\n\r\nexport const enum AC3PreferredStereoDownmixMode {\r\n  AC3_DMIXMOD_NOTINDICATED = 0,\r\n  AC3_DMIXMOD_LTRT,\r\n  AC3_DMIXMOD_LORO,\r\n  // reserved value in A/52, but used by encoders to indicate DPL2\r\n  AC3_DMIXMOD_DPLII\r\n}\r\n\r\nexport const enum EAC3FrameType {\r\n  EAC3_FRAME_TYPE_INDEPENDENT = 0,\r\n  EAC3_FRAME_TYPE_DEPENDENT,\r\n  EAC3_FRAME_TYPE_AC3_CONVERT,\r\n  EAC3_FRAME_TYPE_RESERVED\r\n}\r\n\r\nexport const AC3ChannelLayout = [\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_STEREO,\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_MONO,\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_STEREO,\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_SURROUND,\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_2_1,\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_4POINT0,\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_2_2,\r\n  AV_CH_LAYOUT.AV_CH_LAYOUT_5POINT0\r\n]\r\n\r\nexport interface AC3HeaderInfo {\r\n  syncWord: uint16\r\n  crc1: uint16\r\n  srCode: uint8\r\n  bitstreamId: uint8\r\n  bitstreamMode: uint8\r\n  channelMode: uint8\r\n  lfeOn: uint8\r\n  frameType: uint8\r\n  substreamId: int32\r\n  centerMixLevel: int32\r\n  surroundMixLevel: int32\r\n  channelMap: uint16\r\n  numBlocks: int32\r\n  dolbySurroundMode: int32\r\n  srShift: uint8\r\n  sampleRate: uint16\r\n  bitrate: uint32\r\n  channels: uint8\r\n  frameSize: uint16\r\n  channelLayout: uint64\r\n  ac3BitrateCode: int8\r\n}\r\n\r\nconst AC3FrameSizeTab = [\r\n  [ 64,   69,   96   ],\r\n  [ 64,   70,   96   ],\r\n  [ 80,   87,   120  ],\r\n  [ 80,   88,   120  ],\r\n  [ 96,   104,  144  ],\r\n  [ 96,   105,  144  ],\r\n  [ 112,  121,  168  ],\r\n  [ 112,  122,  168  ],\r\n  [ 128,  139,  192  ],\r\n  [ 128,  140,  192  ],\r\n  [ 160,  174,  240  ],\r\n  [ 160,  175,  240  ],\r\n  [ 192,  208,  288  ],\r\n  [ 192,  209,  288  ],\r\n  [ 224,  243,  336  ],\r\n  [ 224,  244,  336  ],\r\n  [ 256,  278,  384  ],\r\n  [ 256,  279,  384  ],\r\n  [ 320,  348,  480  ],\r\n  [ 320,  349,  480  ],\r\n  [ 384,  417,  576  ],\r\n  [ 384,  418,  576  ],\r\n  [ 448,  487,  672  ],\r\n  [ 448,  488,  672  ],\r\n  [ 512,  557,  768  ],\r\n  [ 512,  558,  768  ],\r\n  [ 640,  696,  960  ],\r\n  [ 640,  697,  960  ],\r\n  [ 768,  835,  1152 ],\r\n  [ 768,  836,  1152 ],\r\n  [ 896,  975,  1344 ],\r\n  [ 896,  976,  1344 ],\r\n  [ 1024, 1114, 1536 ],\r\n  [ 1024, 1115, 1536 ],\r\n  [ 1152, 1253, 1728 ],\r\n  [ 1152, 1254, 1728 ],\r\n  [ 1280, 1393, 1920 ],\r\n  [ 1280, 1394, 1920 ],\r\n]\r\n\r\nconst CenterLevelsTab = [4, 5, 6, 5]\r\nconst SurroundLevelsTab = [4, 6, 7, 6]\r\nconst AC3SampleRateTab = [48000, 44100, 32000, 0]\r\nconst AC3BitrateTab = [\r\n  32, 40, 48, 56, 64, 80, 96, 112, 128,\r\n  160, 192, 224, 256, 320, 384, 448, 512, 576, 640\r\n]\r\nconst AC3ChannelsTab = [\r\n  2, 1, 2, 3, 3, 4, 4, 5\r\n]\r\n\r\nconst EAC3Blocks = [\r\n  1, 2, 3, 6\r\n]\r\n\r\nconst AC3_HEADER_SIZE = 7\r\n\r\nexport function parseHeader(buf: Uint8ArrayInterface) {\r\n  const bitReader = new BitReader(buf.length)\r\n  bitReader.appendBuffer(buf)\r\n\r\n  const info: AC3HeaderInfo = {\r\n    syncWord: 0,\r\n    crc1: 0,\r\n    srCode: 0,\r\n    bitstreamId: 0,\r\n    bitstreamMode: 0,\r\n    channelMode: 0,\r\n    lfeOn: 0,\r\n    frameType: 0,\r\n    substreamId: 0,\r\n    centerMixLevel: 0,\r\n    surroundMixLevel: 0,\r\n    channelMap: 0,\r\n    numBlocks: 0,\r\n    dolbySurroundMode: 0,\r\n    srShift: 0,\r\n    sampleRate: 0,\r\n    bitrate: 0,\r\n    channels: 0,\r\n    frameSize: 0,\r\n    channelLayout: 0n,\r\n    ac3BitrateCode: 0\r\n  }\r\n\r\n  info.syncWord = bitReader.readU(16)\r\n\r\n  if (info.syncWord !== 0x0B77) {\r\n    return -1\r\n  }\r\n\r\n  info.bitstreamId = bitReader.peekU(29) & 0x1f\r\n\r\n  if (info.bitstreamId > 16) {\r\n    return -2\r\n  }\r\n\r\n  info.numBlocks = 6\r\n  info.ac3BitrateCode = -1\r\n  info.centerMixLevel = 5\r\n  info.surroundMixLevel = 6\r\n\r\n  info.dolbySurroundMode = AC3DolbySurroundMode.AC3_DSURMOD_NOTINDICATED\r\n\r\n  if (info.bitstreamId <= 10) {\r\n    info.crc1 = bitReader.readU(16)\r\n    info.srCode = bitReader.readU(2)\r\n\r\n    if (info.srCode === 3) {\r\n      return -3\r\n    }\r\n\r\n    const frameSizeCode = bitReader.readU(6)\r\n    if (frameSizeCode > 37) {\r\n      return -4\r\n    }\r\n\r\n    info.ac3BitrateCode = (frameSizeCode >> 1)\r\n\r\n    bitReader.readU(5)\r\n\r\n    info.bitstreamMode = bitReader.readU(3)\r\n    info.channelMode = bitReader.readU(3)\r\n\r\n    if (info.channelMode == AC3ChannelMode.AC3_CHMODE_STEREO) {\r\n      info.dolbySurroundMode = bitReader.readU(2)\r\n    }\r\n    else {\r\n      if ((info.channelMode & 1) && info.channelMode != AC3ChannelMode.AC3_CHMODE_MONO) {\r\n        info.centerMixLevel = CenterLevelsTab[bitReader.readU(2)]\r\n      }\r\n      if (info.channelMode & 4) {\r\n        info.surroundMixLevel = SurroundLevelsTab[bitReader.readU(2)]\r\n      }\r\n    }\r\n    info.lfeOn = bitReader.readU(1)\r\n\r\n    info.srShift = Math.max(info.bitstreamId, 8) - 8\r\n    info.sampleRate = AC3SampleRateTab[info.srCode] >> info.srShift\r\n    info.bitrate = (AC3BitrateTab[info.ac3BitrateCode] * 1000) >> info.srShift\r\n    info.channels = AC3ChannelsTab[info.channelMode] + info.lfeOn\r\n    info.frameSize = AC3FrameSizeTab[frameSizeCode][info.srCode] * 2\r\n    info.frameType = EAC3FrameType.EAC3_FRAME_TYPE_AC3_CONVERT\r\n    info.substreamId = 0\r\n  }\r\n  else {\r\n    /* Enhanced AC-3 */\r\n    info.crc1 = 0\r\n    info.frameType = bitReader.readU(2)\r\n    if (info.frameType == EAC3FrameType.EAC3_FRAME_TYPE_RESERVED) {\r\n      return -5\r\n    }\r\n    info.substreamId = bitReader.readU(3)\r\n\r\n    info.frameSize = (bitReader.readU(11) + 1) << 1\r\n    if (info.frameSize < AC3_HEADER_SIZE) {\r\n      return -6\r\n    }\r\n\r\n    info.srCode = bitReader.readU(2)\r\n    if (info.srCode == 3) {\r\n      const srCode2 = bitReader.readU(2)\r\n      if (srCode2 == 3) {\r\n        return -7\r\n      }\r\n      info.sampleRate = AC3SampleRateTab[srCode2] / 2\r\n      info.srShift = 1\r\n    }\r\n    else {\r\n      info.numBlocks = EAC3Blocks[bitReader.readU(2)]\r\n      info.sampleRate = AC3SampleRateTab[info.srCode]\r\n      info.srShift = 0\r\n    }\r\n\r\n    info.channelMode = bitReader.readU(3)\r\n    info.lfeOn = bitReader.readU(1)\r\n\r\n    info.bitrate = 8 * info.frameSize * info.sampleRate / (info.numBlocks * 256)\r\n    info.channels = AC3ChannelsTab[info.channelMode] + info.lfeOn\r\n  }\r\n  info.channelLayout = static_cast<uint64>(AC3ChannelLayout[info.channelMode] as uint32)\r\n  if (info.lfeOn) {\r\n    info.channelLayout |= static_cast<uint64>(AV_CH_LAYOUT.AV_CH_LOW_FREQUENCY as uint32)\r\n  }\r\n\r\n  return info\r\n}\r\n","/*\r\n * libmedia av1 util\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVStream from '../AVStream'\r\nimport { AVPacketSideDataType } from 'avutil/codec'\r\nimport BitReader from 'common/io/BitReader'\r\nimport * as av1syntax from 'avutil/util/av1syntax'\r\nimport { Uint8ArrayInterface } from 'common/io/interface'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport BitWriter from 'common/io/BitWriter'\r\nimport { PixelFormatDescriptorsMap } from 'avutil/pixelFormatDescriptor'\r\n\r\nexport const enum AV1Profile {\r\n  Main,\r\n  High,\r\n  Professional\r\n}\r\n\r\nexport const enum OBUType {\r\n  Reserved,\r\n  SEQUENCE_HEADER,\r\n  TEMPORAL_DELIMITER,\r\n  FRAME_HEADER,\r\n  TILE_GROUP,\r\n  METADATA,\r\n  FRAME,\r\n  REDUNDANT_FRAME_HEADER,\r\n  TILE_LIST,\r\n  PADDING = 15\r\n}\r\n\r\nexport const AV1Profile2Name: Record<AV1Profile, string> = {\r\n  [AV1Profile.Main]: 'Main',\r\n  [AV1Profile.High]: 'High',\r\n  [AV1Profile.Professional]: 'Professional'\r\n}\r\n\r\nexport const LevelCapabilities = [\r\n  { level: 20, maxResolution: 2048 * 1152 },\r\n  { level: 21, maxResolution: 2816 * 1584 },\r\n  { level: 30, maxResolution: 4352 * 2448 },\r\n  { level: 31, maxResolution: 5504 * 3096 },\r\n  { level: 40, maxResolution: 6144 * 3456 },\r\n  { level: 41, maxResolution: 6144 * 3456 },\r\n  { level: 50, maxResolution: 8192 * 4352 },\r\n  { level: 51, maxResolution: 8192 * 4352 },\r\n  { level: 52, maxResolution: 8192 * 4352 },\r\n  { level: 53, maxResolution: 8192 * 4352 },\r\n  { level: 60, maxResolution: 16384 * 8704 },\r\n  { level: 61, maxResolution: 16384 * 8704 },\r\n  { level: 62, maxResolution: 16384 * 8704 },\r\n  { level: 63, maxResolution: 16384 * 8704 }\r\n]\r\n\r\nexport const AV1LevelIdx = [20, 21, 22, 23, 30, 31, 32, 33, 40, 41, 42, 43, 50, 51, 52, 53, 60, 61, 62, 63, 70, 71, 72, 73]\r\n\r\nexport function getLevelByResolution(width: number, height: number, fps: number) {\r\n  const resolution = width * height\r\n  for (const level of LevelCapabilities) {\r\n    if (resolution <= level.maxResolution) {\r\n      return level.level\r\n    }\r\n  }\r\n}\r\n\r\nexport function parseAVCodecParameters(stream: AVStream, extradata?: Uint8ArrayInterface) {\r\n  if (!extradata && stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]) {\r\n    extradata = stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]\r\n  }\r\n  if (extradata && extradata.length >= 4) {\r\n    const params = parseExtraData(extradata)\r\n\r\n    stream.codecpar.profile = params.profile\r\n    stream.codecpar.level = params.level\r\n  }\r\n}\r\n\r\n/**\r\n * - 1 bit marker\r\n * - 7 bit version\r\n * - 3 bit profile\r\n * - 5 bit level\r\n * - 1 bit tier\r\n * - 1 bit bitdepth > 8\r\n * - 1 bit bitdepth == 12\r\n * - 1 bit monochrome\r\n * - 1 bit chroma_subsampling_x\r\n * - 1 bit chroma_subsampling_y\r\n * - 2 bit chroma_sample_position\r\n * - 8 bit padding\r\n * \r\n * @param header \r\n */\r\nexport function parseExtraData(extradata: Uint8ArrayInterface) {\r\n  const bitReader = new BitReader(extradata.length)\r\n  bitReader.appendBuffer(extradata)\r\n  // marker\r\n  bitReader.readU1()\r\n  // version\r\n  bitReader.readU(7)\r\n\r\n  const profile = bitReader.readU(3)\r\n  const level = bitReader.readU(5)\r\n  const tier = bitReader.readU1()\r\n  let bitDepth = bitReader.readU1() ? 10 : 8\r\n  if (bitReader.readU1()) {\r\n    bitDepth = 12\r\n  }\r\n  const monochrome = bitReader.readU1()\r\n  const chromaSubsamplingX = bitReader.readU1()\r\n  const chromaSubsamplingY = bitReader.readU1()\r\n  const chromaSamplePosition = bitReader.readU(2)\r\n\r\n  return {\r\n    profile,\r\n    level,\r\n    tier,\r\n    bitDepth,\r\n    monochrome,\r\n    chromaSubsamplingX,\r\n    chromaSubsamplingY,\r\n    chromaSamplePosition\r\n  }\r\n}\r\n\r\n/* eslint-disable camelcase */\r\nexport function parseSequenceHeader(header: Uint8ArrayInterface) {\r\n  const bitReader = new BitReader(header.length)\r\n  bitReader.appendBuffer(header)\r\n\r\n  bitReader.readU1()\r\n  bitReader.readU(4)\r\n  const extensionFlag = bitReader.readU1()\r\n  const hasSizeFlag = bitReader.readU1()\r\n  // obu_reserved_1bit\r\n  bitReader.readU1()\r\n  if (extensionFlag) {\r\n    bitReader.readU(8)\r\n  }\r\n  if (hasSizeFlag) {\r\n    av1syntax.leb128(bitReader)\r\n  }\r\n\r\n  const seq_profile =\tav1syntax.f(bitReader, 3)\r\n  const still_picture =\tav1syntax.f(bitReader, 1)\r\n  const reduced_still_picture_header = av1syntax.f(bitReader, 1)\r\n\r\n  let timing_info_present_flag = 0\r\n  let decoder_model_info_present_flag = 0\r\n  let initial_display_delay_present_flag = 0\r\n  let operating_points_cnt_minus_1 = 0\r\n  let operating_point_idc: number[] = [0]\r\n  let seq_level_idx: number[] = [0]\r\n  let seq_tier: number[] = [0]\r\n  let decoder_model_present_for_this_op: number[] = [0]\r\n  let initial_display_delay_present_for_this_op: number[] = [0]\r\n  let initial_display_delay_minus_1: number[] = [0]\r\n  let buffer_delay_length_minus_1 = 0\r\n  let decoder_buffer_delay: number[] = [0]\r\n  let encoder_buffer_delay: number[] = [0]\r\n  let low_delay_mode_flag: number[] = [0]\r\n\r\n  if (reduced_still_picture_header) {\r\n    seq_level_idx[0] = av1syntax.f(bitReader, 5)\r\n  }\r\n  else {\r\n    timing_info_present_flag = av1syntax.f(bitReader, 1)\r\n    if (timing_info_present_flag) {\r\n\r\n      let num_units_in_display_tick =\tav1syntax.f(bitReader, 32)\r\n      let time_scale = av1syntax.f(bitReader, 32)\r\n      let equal_picture_interval = av1syntax.f(bitReader, 1)\r\n      if (equal_picture_interval) {\r\n        let num_ticks_per_picture_minus_1 = av1syntax.uvlc(bitReader)\r\n      }\r\n\r\n      let decoder_model_info_present_flag =\tav1syntax.f(bitReader, 1)\r\n      if (decoder_model_info_present_flag) {\r\n        buffer_delay_length_minus_1 =\tav1syntax.f(bitReader, 5)\r\n        let num_units_in_decoding_tick = av1syntax.f(bitReader, 32)\r\n        let buffer_removal_time_length_minus_1 = av1syntax.f(bitReader, 5)\r\n        let frame_presentation_time_length_minus_1 = av1syntax.f(bitReader, 5)\r\n      }\r\n    }\r\n    else {\r\n      decoder_model_info_present_flag = 0\r\n    }\r\n    let initial_display_delay_present_flag = av1syntax.f(bitReader, 1)\r\n    let operating_points_cnt_minus_1 = av1syntax.f(bitReader, 5)\r\n    for (let i = 0; i <= operating_points_cnt_minus_1; i++ ) {\r\n      operating_point_idc[i] = av1syntax.f(bitReader, 12)\r\n      seq_level_idx[i] = av1syntax.f(bitReader, 5)\r\n      if (seq_level_idx[i] > 7) {\r\n        seq_tier[i] = av1syntax.f(bitReader, 1)\r\n      }\r\n      else {\r\n        seq_tier[i] = 0\r\n      }\r\n      if (decoder_model_info_present_flag) {\r\n        decoder_model_present_for_this_op[i] = av1syntax.f(bitReader, 1)\r\n        if (decoder_model_present_for_this_op[i]) {\r\n          let n = buffer_delay_length_minus_1 + 1\r\n          decoder_buffer_delay[i] =\tav1syntax.f(bitReader, n)\r\n          encoder_buffer_delay[i] =\tav1syntax.f(bitReader, n)\r\n          low_delay_mode_flag[i] = av1syntax.f(bitReader, 1)\r\n        }\r\n      }\r\n      else {\r\n        decoder_model_present_for_this_op[i] = 0\r\n      }\r\n      if (initial_display_delay_present_flag) {\r\n        initial_display_delay_present_for_this_op[i] = av1syntax.f(bitReader, 1)\r\n        if ( initial_display_delay_present_for_this_op[i] ) {\r\n          initial_display_delay_minus_1[i] = av1syntax.f(bitReader, 4)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  let frame_width_bits_minus_1 = av1syntax.f(bitReader, 4)\r\n  let frame_height_bits_minus_1 =\tav1syntax.f(bitReader, 4)\r\n  let n = frame_width_bits_minus_1 + 1\r\n  let max_frame_width_minus_1 =\tav1syntax.f(bitReader, n)\r\n  n = frame_height_bits_minus_1 + 1\r\n  let max_frame_height_minus_1 = av1syntax.f(bitReader, n)\r\n  let frame_id_numbers_present_flag = 0\r\n  let delta_frame_id_length_minus_2 = 0\r\n  let additional_frame_id_length_minus_1 = 0\r\n  if (reduced_still_picture_header ) {\r\n    frame_id_numbers_present_flag = 0\r\n  }\r\n  else {\r\n    frame_id_numbers_present_flag =\tav1syntax.f(bitReader, 1)\r\n  }\r\n  if ( frame_id_numbers_present_flag ) {\r\n    delta_frame_id_length_minus_2 =\tav1syntax.f(bitReader, 4)\r\n    additional_frame_id_length_minus_1 = av1syntax.f(bitReader, 3)\r\n  }\r\n  let use_128x128_superblock = av1syntax.f(bitReader, 1)\r\n  let enable_filter_intra =\tav1syntax.f(bitReader, 1)\r\n  let enable_intra_edge_filter = av1syntax.f(bitReader, 1)\r\n  let enable_interintra_compound = 0\r\n  let enable_masked_compound = 0\r\n  let enable_warped_motion = 0\r\n  let enable_dual_filter = 0\r\n  let enable_order_hint = 0\r\n  let enable_jnt_comp = 0\r\n  let enable_ref_frame_mvs = 0\r\n  let seq_force_screen_content_tools = 2\r\n  let seq_force_integer_mv = 2\r\n  let OrderHintBits = 0\r\n  if (!reduced_still_picture_header) {\r\n    let enable_interintra_compound = av1syntax.f(bitReader, 1)\r\n    enable_masked_compound = av1syntax.f(bitReader, 1)\r\n    enable_warped_motion = av1syntax.f(bitReader, 1)\r\n    enable_dual_filter = av1syntax.f(bitReader, 1)\r\n    enable_order_hint = av1syntax.f(bitReader, 1)\r\n    if (enable_order_hint) {\r\n      enable_jnt_comp = av1syntax.f(bitReader, 1)\r\n      enable_ref_frame_mvs = av1syntax.f(bitReader, 1)\r\n    }\r\n    else {\r\n      enable_jnt_comp = 0\r\n      enable_ref_frame_mvs = 0\r\n    }\r\n    let seq_choose_screen_content_tools =\tav1syntax.f(bitReader, 1)\r\n    if (seq_choose_screen_content_tools) {\r\n      seq_force_screen_content_tools = 2\r\n    }\r\n    else {\r\n      seq_force_screen_content_tools = av1syntax.f(bitReader, 1)\r\n    }\r\n\r\n    if (seq_force_screen_content_tools > 0) {\r\n      let seq_choose_integer_mv =\tav1syntax.f(bitReader, 1)\r\n      if (seq_choose_integer_mv) {\r\n        seq_force_integer_mv = 2\r\n      }\r\n      else {\r\n        seq_force_integer_mv = av1syntax.f(bitReader, 1)\r\n      }\r\n    }\r\n    else {\r\n      seq_force_integer_mv = 2\r\n    }\r\n    if (enable_order_hint) {\r\n      const order_hint_bits_minus_1 =\tav1syntax.f(bitReader, 3)\r\n      OrderHintBits = order_hint_bits_minus_1 + 1\r\n    }\r\n    else {\r\n      OrderHintBits = 0\r\n    }\r\n  }\r\n  let enable_superres =\tav1syntax.f(bitReader, 1)\r\n  let enable_cdef =\tav1syntax.f(bitReader, 1)\r\n  let enable_restoration = av1syntax.f(bitReader, 1)\r\n\r\n  let high_bitdepth =\tav1syntax.f(bitReader, 1)\r\n  let twelve_bit = 0\r\n  let bit_depth = 0\r\n  let mono_chrome = 0\r\n  if (seq_profile == 2 && high_bitdepth ) {\r\n    twelve_bit = av1syntax.f(bitReader, 1)\r\n    bit_depth = twelve_bit ? 12 : 10\r\n  }\r\n  else if (seq_profile <= 2) {\r\n    bit_depth = high_bitdepth ? 10 : 8\r\n  }\r\n  if ( seq_profile == 1 ) {\r\n    mono_chrome = 0\r\n  }\r\n  else {\r\n    mono_chrome = av1syntax.f(bitReader, 1)\r\n  }\r\n  const color_description_present_flag = av1syntax.f(bitReader, 1)\r\n  let color_primaries = 0\r\n  let transfer_characteristics = 0\r\n  let matrix_coefficients = 0\r\n  if (color_description_present_flag ) {\r\n    color_primaries =\tav1syntax.f(bitReader, 8)\r\n    transfer_characteristics = av1syntax.f(bitReader, 8)\r\n    matrix_coefficients = av1syntax.f(bitReader, 8)\r\n  }\r\n  else {\r\n    color_primaries = 2\r\n    transfer_characteristics = 2\r\n    matrix_coefficients = 2\r\n  }\r\n  let color_range = 0\r\n  let subsampling_x = 0\r\n  let subsampling_y = 0\r\n  let chroma_sample_position = 0\r\n  let separate_uv_delta_q = 0\r\n  if (mono_chrome) {\r\n    color_range =\tav1syntax.f(bitReader, 1)\r\n    subsampling_x = 1\r\n    subsampling_y = 1\r\n    chroma_sample_position = 0\r\n    separate_uv_delta_q = 0\r\n  }\r\n  else if (color_primaries == 1\r\n    && transfer_characteristics == 13\r\n    && matrix_coefficients == 0\r\n  ) {\r\n    color_range = 1\r\n    subsampling_x = 0\r\n    subsampling_y = 0\r\n    separate_uv_delta_q = av1syntax.f(bitReader, 1)\r\n  }\r\n  else {\r\n    color_range =\tav1syntax.f(bitReader, 1)\r\n    if (seq_profile == 0) {\r\n      subsampling_x = 1\r\n      subsampling_y = 1\r\n    }\r\n    else if ( seq_profile == 1 ) {\r\n      subsampling_x = 0\r\n      subsampling_y = 0\r\n    }\r\n    else {\r\n      if (bit_depth == 12) {\r\n        subsampling_x\t= av1syntax.f(bitReader, 1)\r\n        if (subsampling_x) {\r\n          subsampling_y =\tav1syntax.f(bitReader, 1)\r\n        }\r\n        else {\r\n          subsampling_y = 0\r\n        }\r\n      }\r\n      else {\r\n        subsampling_x = 1\r\n        subsampling_y = 0\r\n      }\r\n    }\r\n    if (subsampling_x && subsampling_y) {\r\n      chroma_sample_position = av1syntax.f(bitReader, 2)\r\n    }\r\n    separate_uv_delta_q = av1syntax.f(bitReader, 1)\r\n  }\r\n\r\n  let film_grain_params_present\t= av1syntax.f(bitReader, 1)\r\n\r\n  return {\r\n    width: max_frame_width_minus_1 + 1,\r\n    height: max_frame_height_minus_1 + 1,\r\n    profile: seq_profile,\r\n    level: AV1LevelIdx[seq_level_idx[0]],\r\n    tier: seq_tier[0],\r\n    bitDepth: bit_depth,\r\n    monoChrome: mono_chrome,\r\n    colorRange: color_range,\r\n    colorPrimaries: color_primaries,\r\n    transferCharacteristics: transfer_characteristics,\r\n    matrixCoefficients: matrix_coefficients,\r\n    subsamplingX: subsampling_x,\r\n    subsamplingY: subsampling_y,\r\n    chromaSamplePosition: chroma_sample_position\r\n  }\r\n}\r\n\r\nexport function splitOBU(buffer: Uint8ArrayInterface) {\r\n  const bitReader = new BitReader()\r\n\r\n  bitReader.appendBuffer(buffer)\r\n\r\n  const list: Uint8ArrayInterface[] = []\r\n\r\n  while (bitReader.remainingLength()) {\r\n    const now = bitReader.getPointer()\r\n    // obu_forbidden_bit\r\n    bitReader.readU1()\r\n    const type = bitReader.readU(4)\r\n    const extensionFlag = bitReader.readU1()\r\n    const hasSizeFlag = bitReader.readU1()\r\n    // obu_reserved_1bit\r\n    bitReader.readU1()\r\n\r\n    if (extensionFlag) {\r\n      bitReader.readU(8)\r\n    }\r\n\r\n    const size = hasSizeFlag ? av1syntax.leb128(bitReader) : buffer.length - 1 - extensionFlag\r\n\r\n    const headerSize = bitReader.getPointer() - now\r\n\r\n    list.push(buffer.subarray(now, now + headerSize + size))\r\n\r\n    bitReader.skip(size * 8)\r\n  }\r\n\r\n  return list\r\n}\r\n\r\nexport function generateExtradata(codecpar: pointer<AVCodecParameters>, buffer: Uint8ArrayInterface) {\r\n  const bitWriter = new BitWriter(4)\r\n  // marker\r\n  bitWriter.writeU1(1)\r\n  // version\r\n  bitWriter.writeU(7, 1)\r\n\r\n  const header = splitOBU(buffer).find((buffer) => {\r\n    return ((buffer[0] >>> 3) & 0x0f) === OBUType.SEQUENCE_HEADER\r\n  })\r\n\r\n  if (header) {\r\n    const params = parseSequenceHeader(header)\r\n    bitWriter.writeU(3, params.profile)\r\n    bitWriter.writeU(5, params.level)\r\n    bitWriter.writeU(1, params.tier)\r\n    bitWriter.writeU(1, params.bitDepth > 8 ? 1 : 0)\r\n    bitWriter.writeU(1, params.bitDepth === 12 ? 1 : 0)\r\n    bitWriter.writeU(1, params.monoChrome)\r\n    bitWriter.writeU(1, params.subsamplingX)\r\n    bitWriter.writeU(1, params.subsamplingY)\r\n    bitWriter.writeU(1, params.chromaSamplePosition)\r\n  }\r\n  else {\r\n    const desc = PixelFormatDescriptorsMap[codecpar.format]\r\n    bitWriter.writeU(3, codecpar.profile)\r\n    bitWriter.writeU(5, codecpar.level)\r\n    bitWriter.writeU(1, 0)\r\n    bitWriter.writeU(1, desc.comp[0].depth > 8 ? 1 : 0)\r\n    bitWriter.writeU(1, desc.comp[0].depth === 12 ? 1 : 0)\r\n    bitWriter.writeU(1, 0)\r\n    bitWriter.writeU(1, 1)\r\n    bitWriter.writeU(1, 1)\r\n    bitWriter.writeU(1, 0)\r\n  }\r\n  // padding\r\n  bitWriter.writeU(8, 0)\r\n  return bitWriter.getBuffer()\r\n}\r\n","/*\r\n * libmedia opus util\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { AVPacketSideDataType } from 'avutil/codec'\r\nimport AVStream from '../AVStream'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport BufferReader from 'common/io/BufferReader'\r\nimport BufferWriter from 'common/io/BufferWriter'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { Uint8ArrayInterface } from 'common/io/interface'\r\n\r\nexport const durations = [\r\n  /* Silk NB */\r\n  480, 960, 1920, 2880,\r\n  /* Silk MB */\r\n  480, 960, 1920, 2880,\r\n  /* Silk WB */\r\n  480, 960, 1920, 2880,\r\n  /* Hybrid SWB */\r\n  480, 960,\r\n  /* Hybrid FB */\r\n  480, 960,\r\n  /* CELT NB */\r\n  120, 240, 480, 960,\r\n  /* CELT NB */\r\n  120, 240, 480, 960,\r\n  /* CELT NB */\r\n  120, 240, 480, 960,\r\n  /* CELT NB */\r\n  120, 240, 480, 960\r\n]\r\n\r\n\r\nexport function getBufferSamples(buffer: Uint8Array) {\r\n  let toc = 0, frameDuration = 0, nframes = 0\r\n\r\n  if (buffer.length < 1) {\r\n    return 0\r\n  }\r\n\r\n  toc = buffer[0]\r\n\r\n  frameDuration = durations[toc >> 3]\r\n\r\n  switch (toc & 3) {\r\n    case 0:\r\n      nframes = 1\r\n      break\r\n    case 1:\r\n      nframes = 2\r\n      break\r\n    case 2:\r\n      nframes = 2\r\n      break\r\n    case 3:\r\n      if (buffer.length < 2) {\r\n        return 0\r\n      }\r\n      nframes = buffer[1] & 63\r\n      break\r\n  }\r\n  return nframes * frameDuration\r\n}\r\n\r\n/**\r\n * opus extradata\r\n * \r\n * - 8 bytes Magic Signature: OpusHead\r\n * - 1 bytes unsigned, 对应值 0x01 version\r\n * - 1 bytes unsigned, channels 它可能和编码声道数不一致， 它可能被修改成 packet-by-packet, 对应值 0x01\r\n * - 2 bytes unsigned, preSkip 这是要从开始播放时的解码器输出， 从页面的颗粒位置减去以计算其 PCM 样本位置。\r\n * - 4 bytes unsigned, sampleRate 原始输入采样率\r\n * - 2 bytes signed, outputGain 这是解码时要应用的增益， 20 * log10 缩放解码器输出以实现所需的播放音量\r\n * - 1 bytes unsigned, channelMappingFamily 指示输出渠道的顺序和语音含义。该八位位组的每个当前指定的值表示一个映射系列，它定义了一组允许的通道数，以及每个允许的通道数的通道名称的有序集合\r\n * - channelMappingTable 可选， 当 Channel Mapping Family 为 0 时被省略。\r\n *  - 1 bytes, streamCount, unsigned ogg packet 里面编码了多少路 stream\r\n *  - 1 bytes, coupledStreamCount, unsigned 标识有多少路流是双声声道，必须小于 streamCount\r\n *  - C bytes, C 为总输出声道数 coupledStreamCount + streamCount\r\n * \r\n */\r\nexport function parseAVCodecParameters(stream: AVStream, extradata?: Uint8ArrayInterface) {\r\n  if (!extradata && stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]) {\r\n    extradata = stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]\r\n  }\r\n  if (extradata && extradata.length >= 19) {\r\n    const reader = new BufferReader(extradata, false)\r\n    reader.skip(9)\r\n    stream.codecpar.chLayout.nbChannels = reader.readUint8()\r\n    stream.codecpar.initialPadding = reader.readUint16()\r\n    stream.codecpar.sampleRate = reader.readUint32()\r\n\r\n    stream.codecpar.seekPreroll = Number(avRescaleQ(\r\n      80n,\r\n      {\r\n        den: 1000,\r\n        num: 1\r\n      },\r\n      {\r\n        den: 48000,\r\n        num: 1\r\n      }\r\n    ))\r\n  }\r\n}\r\n\r\nexport function avCodecParameters2Extradata(codecpar: AVCodecParameters) {\r\n  const extradata = new Uint8Array(19)\r\n\r\n  const writer = new BufferWriter(extradata, false)\r\n\r\n  writer.writeString('OpusHead')\r\n  writer.writeUint8(0x01)\r\n  writer.writeUint8(codecpar.chLayout.nbChannels)\r\n  writer.writeUint16(codecpar.initialPadding)\r\n  writer.writeUint32(codecpar.sampleRate)\r\n\r\n  return extradata\r\n}\r\n","/*\r\n * libmedia vp9 util\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVStream from '../AVStream'\r\nimport { AVPacketSideDataType } from 'avutil/codec'\r\nimport { Uint8ArrayInterface } from 'common/io/interface'\r\nimport BitReader from 'common/io/BitReader'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport { NOPTS_VALUE } from 'avutil/constant'\r\nimport { PixelFormatDescriptorsMap } from 'avutil/pixelFormatDescriptor'\r\nimport { avQ2D } from 'avutil/util/rational'\r\nimport { AVChromaLocation, AVColorRange } from 'avutil/pixfmt'\r\nimport BufferWriter from 'common/io/BufferWriter'\r\n\r\nexport const enum VP9Profile {\r\n  Profile0,\r\n  Profile1,\r\n  Profile2,\r\n  Profile3\r\n}\r\n\r\nexport const VP9Profile2Name: Record<VP9Profile, string> = {\r\n  [VP9Profile.Profile0]: 'Profile0',\r\n  [VP9Profile.Profile1]: 'Profile1',\r\n  [VP9Profile.Profile2]: 'Profile2',\r\n  [VP9Profile.Profile3]: 'Profile3'\r\n}\r\n\r\nexport const LevelCapabilities = [\r\n  { level: 10, maxResolution: 512 * 384, maxFrameRate: 30 },\r\n  { level: 11, maxResolution: 512 * 384, maxFrameRate: 60 },\r\n  { level: 20, maxResolution: 960 * 540, maxFrameRate: 30 },\r\n  { level: 21, maxResolution: 960 * 540, maxFrameRate: 60 },\r\n  { level: 30, maxResolution: 1920 * 1080, maxFrameRate: 30 },\r\n  { level: 31, maxResolution: 1920 * 1080, maxFrameRate: 60 },\r\n  { level: 40, maxResolution: 2560 * 1440, maxFrameRate: 30 },\r\n  { level: 41, maxResolution: 2560 * 1440, maxFrameRate: 60 },\r\n  { level: 50, maxResolution: 3840 * 2160, maxFrameRate: 30 },\r\n  { level: 51, maxResolution: 3840 * 2160, maxFrameRate: 60 },\r\n  { level: 60, maxResolution: 4096 * 2160, maxFrameRate: 30 },\r\n  { level: 61, maxResolution: 4096 * 2160, maxFrameRate: 60 },\r\n  { level: 70, maxResolution: 8192 * 4320, maxFrameRate: 30 },\r\n  { level: 71, maxResolution: 8192 * 4320, maxFrameRate: 60 }\r\n]\r\n\r\nexport function getLevelByResolution(width: number, height: number, fps: number) {\r\n  const resolution = width * height\r\n  for (const level of LevelCapabilities) {\r\n    if (resolution <= level.maxResolution && fps <= level.maxFrameRate) {\r\n      return level.level\r\n    }\r\n  }\r\n}\r\n\r\nexport function parseAVCodecParameters(stream: AVStream, extradata?: Uint8ArrayInterface) {\r\n  if (!extradata && stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]) {\r\n    extradata = stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]\r\n  }\r\n  if (extradata && extradata.length >= 6) {\r\n    const params = parseExtraData(extradata)\r\n    stream.codecpar.profile = params.profile\r\n    stream.codecpar.level = params.level\r\n  }\r\n}\r\n\r\n/**\r\n * - 1 byte profile\r\n * - 1 byte level\r\n * - 4 bit bitdepth\r\n * - 3 bit chroma_subsampling\r\n * - 1 bit full_range_flag\r\n * - 1 byte color_primaries\r\n * - 1 byte color_trc\r\n * - 1 byte color_space\r\n * \r\n * @param extradata \r\n */\r\nexport function parseExtraData(extradata: Uint8ArrayInterface) {\r\n  const bitReader = new BitReader(extradata.length)\r\n  bitReader.appendBuffer(extradata)\r\n  const profile = bitReader.readU(8)\r\n  const level = bitReader.readU(8)\r\n  let bitDepth = bitReader.readU(4)\r\n  const chromaSubsampling = bitReader.readU(3)\r\n  const fullRangeFlag = bitReader.readU1()\r\n  const colorPrimaries = bitReader.readU(8)\r\n  const colorTrc = bitReader.readU(8)\r\n  const colorSpace = bitReader.readU(8)\r\n\r\n  return {\r\n    profile,\r\n    level,\r\n    bitDepth,\r\n    chromaSubsampling,\r\n    fullRangeFlag,\r\n    colorPrimaries,\r\n    colorTrc,\r\n    colorSpace\r\n  }\r\n}\r\n\r\nconst enum VPX_CHROMA_SUBSAMPLING {\r\n  VPX_SUBSAMPLING_420_VERTICAL = 0,\r\n  VPX_SUBSAMPLING_420_COLLOCATED_WITH_LUMA = 1,\r\n  VPX_SUBSAMPLING_422 = 2,\r\n  VPX_SUBSAMPLING_444 = 3\r\n}\r\n\r\nfunction getVpccFeature(codecpar: pointer<AVCodecParameters>) {\r\n  let profile = codecpar.profile\r\n  let level = codecpar.level\r\n  if (level === NOPTS_VALUE) {\r\n    level = getLevelByResolution(codecpar.width, codecpar.height, avQ2D(codecpar.framerate))\r\n  }\r\n  const desc = PixelFormatDescriptorsMap[codecpar.format]\r\n\r\n  let bitDepth = codecpar.bitsPerCodedSample\r\n  let chromaSubsampling = VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_COLLOCATED_WITH_LUMA\r\n  if (desc) {\r\n    bitDepth = desc.comp[0].depth\r\n    if (desc.log2ChromaW === 1 && desc.log2ChromaH === 1) {\r\n      if (codecpar.chromaLocation === AVChromaLocation.AVCHROMA_LOC_LEFT) {\r\n        chromaSubsampling = VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_VERTICAL\r\n      }\r\n    }\r\n    else if (desc.log2ChromaW === 1 && desc.log2ChromaH === 0) {\r\n      chromaSubsampling = VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_422\r\n    }\r\n    else if (desc.log2ChromaW === 0 && desc.log2ChromaH === 0) {\r\n      chromaSubsampling = VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_444\r\n    }\r\n  }\r\n  const fullRange = codecpar.colorRange === AVColorRange.AVCOL_RANGE_JPEG ? 1 : 0\r\n\r\n  if (profile === NOPTS_VALUE && bitDepth) {\r\n    if (chromaSubsampling == VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_VERTICAL\r\n      || chromaSubsampling == VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_COLLOCATED_WITH_LUMA\r\n    ) {\r\n      profile = (bitDepth == 8) ? VP9Profile.Profile0 : VP9Profile.Profile2\r\n    }\r\n    else {\r\n      profile = (bitDepth == 8) ? VP9Profile.Profile1 : VP9Profile.Profile3\r\n    }\r\n  }\r\n  return {\r\n    profile,\r\n    level,\r\n    bitDepth,\r\n    chromaSubsampling,\r\n    fullRange\r\n  }\r\n}\r\n\r\nexport function generateExtradata(codecpar: pointer<AVCodecParameters>) {\r\n  const ioWriter = new BufferWriter(new Uint8Array(8))\r\n  const vpcc = getVpccFeature(codecpar)\r\n  ioWriter.writeUint8(vpcc.profile)\r\n  ioWriter.writeUint8(vpcc.level)\r\n  ioWriter.writeUint8((vpcc.bitDepth << 4) | (vpcc.chromaSubsampling << 1) | vpcc.fullRange)\r\n  ioWriter.writeUint8(codecpar.colorPrimaries)\r\n  ioWriter.writeUint8(codecpar.colorTrc)\r\n  ioWriter.writeUint8(codecpar.colorSpace)\r\n  ioWriter.writeUint16(0)\r\n  return ioWriter.getWroteBuffer()\r\n}\r\n","/*\r\n * libmedia abstract format decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVFormat } from '../avformat'\r\n\r\nexport default abstract class IFormat {\r\n\r\n  public type: AVFormat = AVFormat.UNKNOWN\r\n\r\n  public onStreamAdd: (stream: Stream) => void\r\n\r\n  public abstract init(formatContext: AVIFormatContext): void\r\n\r\n  public destroy(formatContext: AVIFormatContext): void {}\r\n\r\n  public abstract getAnalyzeStreamsCount(): number\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readHeader(formatContext: AVIFormatContext): Promise<number>\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number>\r\n\r\n  /**\r\n   * seek\r\n   * \r\n   * @param context \r\n   * @param stream \r\n   * @param timestamp 毫秒时间戳\r\n   * @param flags \r\n   * \r\n   * @returns 返回 seek 之前的下一个 avpacket pos（若不知道返回 0n 方便之后可以再 seek 回来）返回负数表示 seek 失败\r\n   */\r\n  // @ts-ignore\r\n  @deasync\r\n  public abstract seek(\r\n    formatContext: AVIFormatContext,\r\n    stream: Stream,\r\n    timestamp: int64,\r\n    flags: int32\r\n  ): Promise<int64>\r\n}\r\n","/*\r\n * libmedia mov decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVPacket, { AVPacketFlags } from 'avutil/struct/avpacket'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\n\r\nimport { IOError } from 'common/io/error'\r\nimport { MOVContext, MOVStreamContext, MovFormatOptions } from './mov/type'\r\nimport mktag from '../function/mktag'\r\nimport { BoxType } from './mov/boxType'\r\nimport * as imov from './mov/imov'\r\nimport { AVCodecID, AVMediaType, AVPacketSideDataType } from 'avutil/codec'\r\nimport IFormat from './IFormat'\r\nimport { getNextSample } from './mov/function/getNextSample'\r\nimport createMovContext from './mov/function/createMovContext'\r\nimport { AVFormat, AVSeekFlags } from '../avformat'\r\nimport * as array from 'common/util/array'\r\nimport { mapSafeUint8Array, memcpy, memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport { avMalloc, avMallocz } from 'avutil/util/mem'\r\nimport { addAVPacketData, addAVPacketSideData } from 'avutil/util/avpacket'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport AVStream from '../AVStream'\r\nimport { AV_MILLI_TIME_BASE_Q, NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\nimport { IOFlags } from 'common/io/flags'\r\nimport { BitFormat } from '../codecs/h264'\r\nimport * as intread from 'avutil/util/intread'\r\n\r\nexport default class IMovFormat extends IFormat {\r\n\r\n  public type: AVFormat = AVFormat.MOV\r\n\r\n  private context: MOVContext\r\n\r\n  public options: MovFormatOptions\r\n\r\n  constructor(options: MovFormatOptions = {}) {\r\n    super()\r\n\r\n    this.options = options\r\n\r\n    this.context = createMovContext()\r\n  }\r\n\r\n  public init(formatContext: AVIFormatContext): void {\r\n    if (formatContext.ioReader) {\r\n      formatContext.ioReader.setEndian(true)\r\n    }\r\n  }\r\n\r\n  public async readHeader(formatContext: AVIFormatContext): Promise<number> {\r\n    try {\r\n\r\n      const fileSize = await formatContext.ioReader.fileSize()\r\n\r\n      let ret = 0\r\n\r\n      let size = await formatContext.ioReader.readUint32()\r\n      let type = await formatContext.ioReader.readUint32()\r\n\r\n      if (type === mktag(BoxType.FTYP)) {\r\n        await imov.readFtyp(formatContext.ioReader, this.context, {\r\n          type,\r\n          size: size - 8\r\n        })\r\n      }\r\n      else if (!fileSize || size < fileSize) {\r\n        await formatContext.ioReader.skip(size - 8)\r\n      }\r\n\r\n      let firstMdatPos = 0n\r\n\r\n      while (!this.context.foundMoov) {\r\n        const pos = formatContext.ioReader.getPos()\r\n\r\n        if (pos === fileSize) {\r\n          logger.error('the file format is not mp4')\r\n          return errorType.DATA_INVALID\r\n        }\r\n\r\n        size = await formatContext.ioReader.readUint32()\r\n        type = await formatContext.ioReader.readUint32()\r\n\r\n        if (size < 8 || fileSize && (pos + static_cast<int64>(size) > fileSize)) {\r\n          logger.error(`invalid box size ${size}`)\r\n          return errorType.DATA_INVALID\r\n        }\r\n\r\n        if (type === mktag(BoxType.MDAT)) {\r\n          if (!this.context.foundMdat) {\r\n            firstMdatPos = pos\r\n          }\r\n          this.context.foundMdat = true\r\n          await formatContext.ioReader.seek(pos + static_cast<int64>(size))\r\n        }\r\n        else if (type === mktag(BoxType.MOOV)) {\r\n          await imov.readMoov(formatContext.ioReader, formatContext, this.context, {\r\n            size: size - 8,\r\n            type\r\n          })\r\n          this.context.foundMoov = true\r\n        }\r\n        else {\r\n          await formatContext.ioReader.seek(pos + static_cast<int64>(size))\r\n        }\r\n      }\r\n\r\n      if (!this.context.fragment && !this.context.foundMdat) {\r\n        const nextType = (await formatContext.ioReader.peekUint64()) >> 32n\r\n        if (Number(nextType) === mktag(BoxType.MOOF)) {\r\n          this.context.fragment = true\r\n        }\r\n      }\r\n\r\n      if (this.context.fragment && formatContext.ioReader.flags & IOFlags.SEEKABLE) {\r\n        const now = formatContext.ioReader.getPos()\r\n        const fileSize = await formatContext.ioReader.fileSize()\r\n\r\n        if (fileSize > 16n) {\r\n          await formatContext.ioReader.seek(fileSize - 12n)\r\n          let type = await formatContext.ioReader.readUint32()\r\n          if (type === mktag(BoxType.MFRO)) {\r\n            await formatContext.ioReader.skip(4)\r\n            const mfraSize = await formatContext.ioReader.readUint32()\r\n            await formatContext.ioReader.seek(fileSize - static_cast<int64>(mfraSize))\r\n            const size = await formatContext.ioReader.readUint32()\r\n            type = await formatContext.ioReader.readUint32()\r\n            if (type === mktag(BoxType.MFRA)) {\r\n              await imov.readMfra(formatContext.ioReader, formatContext, this.context, {\r\n                size: size - 8,\r\n                type\r\n              })\r\n            }\r\n          }\r\n          await formatContext.ioReader.seek(now)\r\n        }\r\n      }\r\n\r\n      if (!this.context.fragment && this.context.foundMdat) {\r\n        await formatContext.ioReader.seek(firstMdatPos)\r\n      }\r\n\r\n      return ret\r\n    }\r\n    catch (error) {\r\n\r\n      logger.error(error.message)\r\n\r\n      if (!this.context.foundMoov) {\r\n        logger.error('moov not found')\r\n      }\r\n\r\n      return formatContext.ioReader.error\r\n    }\r\n  }\r\n\r\n  @deasync\r\n  private async readAVPacket_(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number> {\r\n\r\n    const { sample, stream } = getNextSample(formatContext, this.context)\r\n\r\n    if (sample) {\r\n      avpacket.streamIndex = stream.index\r\n      avpacket.dts = sample.dts\r\n      avpacket.pts = sample.pts\r\n      avpacket.duration = static_cast<int64>(sample.duration)\r\n      avpacket.flags |= sample.flags\r\n      avpacket.pos = sample.pos\r\n      avpacket.timeBase.den = stream.timeBase.den\r\n      avpacket.timeBase.num = stream.timeBase.num\r\n\r\n      if (stream.startTime === NOPTS_VALUE_BIGINT) {\r\n        stream.startTime = avpacket.pts || avpacket.dts\r\n      }\r\n\r\n      await formatContext.ioReader.seek(avpacket.pos)\r\n\r\n      const len = sample.size\r\n      const data = avMalloc(len)\r\n      addAVPacketData(avpacket, data, len)\r\n      await formatContext.ioReader.readBuffer(len, mapSafeUint8Array(data, len))\r\n\r\n      if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_H264\r\n        || stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_HEVC\r\n        || stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_VVC\r\n      ) {\r\n        avpacket.bitFormat = BitFormat.AVCC\r\n      }\r\n\r\n      if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_WEBVTT\r\n        && avpacket.size >= 8\r\n      ) {\r\n        const tag = static_cast<uint32>(intread.rb32(avpacket.data + 4))\r\n        const packetSize = avpacket.size\r\n        if (tag === mktag(BoxType.VTTE)) {\r\n          if (packetSize === 8) {\r\n            const newData = avMallocz(1)\r\n            addAVPacketData(avpacket, newData, 1)\r\n            avpacket.size = 1\r\n          }\r\n        }\r\n        if (packetSize > 8 && (tag === mktag(BoxType.VTTE) || tag === mktag(BoxType.VTTC))) {\r\n          let start: pointer<uint8> = (avpacket.data + 8) as pointer<uint8>\r\n          const end: pointer<uint8> = (avpacket.data + packetSize) as pointer<uint8>\r\n          while (start < end) {\r\n            const size = intread.rb32(start)\r\n            const tag = static_cast<uint32>(intread.rb32(start + 4))\r\n            if (tag === mktag(BoxType.PAYL) && size > 8) {\r\n              const newData = avMalloc(size - 8)\r\n              memcpy(newData, (start + 8) as pointer<uint8>, size - 8)\r\n              addAVPacketData(avpacket, newData, size - 8)\r\n              break\r\n            }\r\n            else {\r\n              start = reinterpret_cast<pointer<uint8>>(start + size)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]) {\r\n        const len = stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA].length\r\n        const extradata = avMalloc(len)\r\n        addAVPacketSideData(avpacket, AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA, extradata, len)\r\n        memcpyFromUint8Array(extradata, len, stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA])\r\n        delete stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]\r\n      }\r\n    }\r\n    else {\r\n      return IOError.END\r\n    }\r\n\r\n    return 0\r\n  }\r\n\r\n  public async readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number> {\r\n    try {\r\n      if (this.context.fragment && !this.context.currentFragment) {\r\n        while (!this.context.currentFragment) {\r\n          const pos = formatContext.ioReader.getPos()\r\n          const size = await formatContext.ioReader.readUint32()\r\n          const type = await formatContext.ioReader.readUint32()\r\n\r\n          if (type === mktag(BoxType.MOOF)) {\r\n            this.context.currentFragment = {\r\n              pos: pos,\r\n              size,\r\n              sequence: 0,\r\n              tracks: [],\r\n              currentTrack: null\r\n            }\r\n\r\n            if (!this.context.firstMoof) {\r\n              this.context.firstMoof = pos\r\n            }\r\n\r\n            await imov.readMoof(\r\n              formatContext.ioReader,\r\n              formatContext,\r\n              this.context,\r\n              {\r\n                type,\r\n                size: size - 8\r\n              }\r\n            )\r\n          }\r\n          else if (type === mktag(BoxType.MOOV)) {\r\n            await imov.readMoov(formatContext.ioReader, formatContext, this.context, {\r\n              size: size - 8,\r\n              type\r\n            })\r\n          }\r\n          else {\r\n            await formatContext.ioReader.skip(size - 8)\r\n          }\r\n        }\r\n      }\r\n\r\n      return await this.readAVPacket_(formatContext, avpacket)\r\n    }\r\n    catch (error) {\r\n      if (formatContext.ioReader.error !== IOError.END) {\r\n        logger.error(`read packet error, ${error}`)\r\n        return errorType.DATA_INVALID\r\n      }\r\n      return formatContext.ioReader.error\r\n    }\r\n  }\r\n\r\n\r\n  public async seek(\r\n    formatContext: AVIFormatContext,\r\n    stream: AVStream,\r\n    timestamp: int64,\r\n    flags: int32\r\n  ): Promise<int64> {\r\n\r\n    assert(stream)\r\n\r\n    const pts = timestamp\r\n\r\n    const streamContext = stream.privData as MOVStreamContext\r\n\r\n    const resetFragment = () => {\r\n      this.context.currentFragment = null\r\n      formatContext.streams.forEach((stream) => {\r\n        const movStreamContext = stream.privData as MOVStreamContext\r\n        movStreamContext.samplesIndex.length = 0\r\n      })\r\n    }\r\n\r\n    // dash 使用时间戳去 seek\r\n    if (flags & AVSeekFlags.TIMESTAMP && this.context.fragment) {\r\n      const seekTime = avRescaleQ(timestamp, stream.timeBase, AV_MILLI_TIME_BASE_Q)\r\n      await formatContext.ioReader.seek(seekTime, true)\r\n      resetFragment()\r\n      return 0n\r\n    }\r\n\r\n    if (this.context.fragment) {\r\n      if (streamContext.fragIndexes.length) {\r\n        let index = array.binarySearch(streamContext.fragIndexes, (item) => {\r\n          if (item.time > pts) {\r\n            return -1\r\n          }\r\n          else if (item.time === pts) {\r\n            return 0\r\n          }\r\n          return 1\r\n        })\r\n        if (index > -1) {\r\n          await formatContext.ioReader.seek(streamContext.fragIndexes[index].pos, true)\r\n          resetFragment()\r\n          return 0n\r\n        }\r\n      }\r\n      if (pts === 0n && this.context.firstMoof) {\r\n        await formatContext.ioReader.seek(this.context.firstMoof)\r\n        resetFragment()\r\n        return 0n\r\n      }\r\n      return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n    }\r\n\r\n    let index = array.binarySearch(streamContext.samplesIndex, (item) => {\r\n      if (item.pts > pts) {\r\n        return -1\r\n      }\r\n      else if (item.pts === pts) {\r\n        return 0\r\n      }\r\n      return 1\r\n    })\r\n\r\n    if (index > -1 && stream.codecpar.codecType === AVMediaType.AVMEDIA_TYPE_VIDEO) {\r\n      let i = index\r\n      for (; i >= 0; i--) {\r\n        if (streamContext.samplesIndex[i].flags & AVPacketFlags.AV_PKT_FLAG_KEY) {\r\n          index = i\r\n          break\r\n        }\r\n      }\r\n      if (i < 0) {\r\n        index = -1\r\n      }\r\n    }\r\n\r\n    if (index > -1) {\r\n      streamContext.currentSample = index\r\n      streamContext.sampleEnd = false\r\n      array.each(formatContext.streams, (st) => {\r\n        if (st !== stream) {\r\n          const stContext = st.privData as MOVStreamContext\r\n          let seeked = false\r\n          let timestamp = avRescaleQ(streamContext.samplesIndex[streamContext.currentSample].pts, stream.timeBase, st.timeBase)\r\n          array.each(stContext.samplesIndex, (sample, i) => {\r\n            if (sample.pts >= timestamp) {\r\n              stContext.currentSample = i\r\n              seeked = true\r\n              return false\r\n            }\r\n          })\r\n\r\n          if (!seeked) {\r\n            stContext.sampleEnd = true\r\n            stContext.currentSample = stContext.samplesIndex.length\r\n          }\r\n          else {\r\n            stContext.sampleEnd = false\r\n          }\r\n        }\r\n      })\r\n      return 0n\r\n    }\r\n    return static_cast<int64>(errorType.DATA_INVALID)\r\n  }\r\n\r\n  public getAnalyzeStreamsCount(): number {\r\n    // mov 在 readheader 时分析了 moov，不需要在进行流分析\r\n    return 0\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 box defined\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nexport const enum BoxType {\r\n  MDAT = 'mdat',\r\n  IDAT = 'idat',\r\n  FREE = 'free',\r\n  WIDE = 'wide',\r\n  SKIP = 'skip',\r\n  MECO = 'meco',\r\n  STRK = 'strk',\r\n  HMHD = 'hmhd',\r\n  NMHD = 'nmhd',\r\n  IODS = 'iods',\r\n  XML = 'xml ',\r\n  BXML = 'bxml',\r\n  IPRO = 'ipro',\r\n  MERE = 'mere',\r\n  MOOV = 'moov',\r\n  TRAK = 'trak',\r\n  EDTS = 'edts',\r\n  MDIA = 'mdia',\r\n  MINF = 'minf',\r\n  SMHD = 'smhd',\r\n  DINF = 'dinf',\r\n  DREF = 'dref',\r\n  STBL = 'stbl',\r\n  MVEX = 'mvex',\r\n  MOOF = 'moof',\r\n  TRAF = 'traf',\r\n  VTTE = 'vtte',\r\n  VTTC = 'vttc',\r\n  PAYL = 'payl',\r\n  TREF = 'tref',\r\n  IREF = 'iref',\r\n  MFRA = 'mfra',\r\n  HNTI = 'hnti',\r\n  HINF = 'hinf',\r\n  STRD = 'strd',\r\n  SINF = 'sinf',\r\n  RINF = 'rinf',\r\n  SCHI = 'schi',\r\n  TRGR = 'trgr',\r\n  UDTA = 'udta',\r\n  IPRP = 'iprp',\r\n  IPCO = 'ipco',\r\n  UUID = 'uuid',\r\n  STTS = 'stts',\r\n  CTTS = 'ctts',\r\n  STSS = 'stss',\r\n  STSZ = 'stsz',\r\n  STZ2 = 'stz2',\r\n  STSC = 'stsc',\r\n  STCO = 'stco',\r\n  CO64 = 'co64',\r\n  MVHD = 'mvhd',\r\n  TKHD = 'tkhd',\r\n  MDHD = 'mdhd',\r\n  HDLR = 'hdlr',\r\n  FTYP = 'ftyp',\r\n  STSD = 'stsd',\r\n  AVC1 = 'avc1',\r\n  AVC3 = 'avc3',\r\n  AVCC = 'avcC',\r\n  HEV1 = 'hev1',\r\n  HVC1 = 'hvc1',\r\n  HVCC = 'hvcC',\r\n  VVC1 = 'vvc1',\r\n  VVI1 = 'vvi1',\r\n  VVCC = 'vvcC',\r\n  MP4A = 'mp4a',\r\n  MP4V = 'mp4v',\r\n  VP09 = 'vp09',\r\n  VPCC = 'vpcC',\r\n  AV01 = 'av01',\r\n  AV1C = 'av1C',\r\n  OPUS = 'Opus',\r\n  FLAC = 'fLaC',\r\n  ESDS = 'esds',\r\n  WAVE = 'wave',\r\n  DFLA = 'dfLa',\r\n  DOPS = 'dOps',\r\n  TREX = 'trex',\r\n  MFHD = 'mfhd',\r\n  TFHD = 'tfhd',\r\n  TFDT = 'tfdt',\r\n  TRUN = 'trun',\r\n  COLR = 'colr',\r\n  PASP = 'pasp',\r\n  BTRT = 'btrt',\r\n  TEXT = 'text',\r\n  VMHD = 'vmhd',\r\n  ELST = 'elst',\r\n  URL = 'url ',\r\n  NONE = 'none',\r\n  STPP = 'stpp',\r\n  WVTT = 'wvtt',\r\n  TX3G = 'tx3g',\r\n  C608 = 'c608',\r\n  MFRO = 'mfro',\r\n  TFRA = 'tfra',\r\n  MINF_HDLR = 'minf_hdlr',\r\n  FRMA = 'frma',\r\n  DAC3 = 'dac3',\r\n  DEC3 = 'dec3',\r\n  EC_3 = 'ec-3',\r\n  AC_3 = 'ac-3'\r\n}\r\n\r\nexport const BasicBoxs = [\r\n  BoxType.FTYP,\r\n  BoxType.MDAT,\r\n  BoxType.IDAT,\r\n  BoxType.FREE,\r\n  BoxType.SKIP,\r\n  BoxType.MECO,\r\n  BoxType.STRK,\r\n]\r\n\r\nexport const FullBoxs = [\r\n  BoxType.HMHD,\r\n  BoxType.NMHD,\r\n  BoxType.IODS,\r\n  BoxType.XML,\r\n  BoxType.URL,\r\n  BoxType.BXML,\r\n  BoxType.IPRO,\r\n  BoxType.MERE,\r\n  BoxType.STTS,\r\n  BoxType.CTTS,\r\n  BoxType.STSS,\r\n  BoxType.STSZ,\r\n  BoxType.STZ2,\r\n  BoxType.STSC,\r\n  BoxType.STCO,\r\n  BoxType.CO64,\r\n  BoxType.STSD,\r\n  BoxType.DREF,\r\n\r\n  BoxType.MVHD,\r\n  BoxType.TKHD,\r\n  BoxType.MDHD,\r\n  BoxType.HDLR\r\n]\r\n\r\nexport const ContainerBoxs = [\r\n  BoxType.MOOV,\r\n  BoxType.TRAK,\r\n  BoxType.EDTS,\r\n  BoxType.MDIA,\r\n  BoxType.MINF,\r\n  BoxType.DINF,\r\n  BoxType.STBL,\r\n  BoxType.MVEX,\r\n  BoxType.MOOF,\r\n  BoxType.TRAF,\r\n  BoxType.VTTC,\r\n  BoxType.TREF,\r\n  BoxType.IREF,\r\n  BoxType.MFRA,\r\n  BoxType.HNTI,\r\n  BoxType.HINF,\r\n  BoxType.STRD,\r\n  BoxType.SINF,\r\n  BoxType.RINF,\r\n  BoxType.SCHI,\r\n  BoxType.TRGR,\r\n  BoxType.UDTA,\r\n  BoxType.IPRP,\r\n  BoxType.IPCO,\r\n  BoxType.STRK,\r\n  BoxType.MECO\r\n]\r\n\r\nexport const enum TFHDFlags {\r\n  BASE_DATA_OFFSET = 0x01,\r\n  SAMPLE_DESCRIPTION\t= 0x02,\r\n  SAMPLE_DURATION = 0x08,\r\n  SAMPLE_SIZE\t= 0x10,\r\n  SAMPLE_FLAGS = 0x20,\r\n  DURATION_EMPTY = 0x10000,\r\n  DEFAULT_BASE_IS_MOOF = 0x20000\r\n}\r\n\r\nexport const enum TRUNFlags {\r\n  DATA_OFFSET = 0x01,\r\n  FIRST_FLAG = 0x04,\r\n  DURATION = 0x100,\r\n  SIZE = 0x200,\r\n  FLAGS = 0x400,\r\n  CTS_OFFSET = 0x800\r\n}\r\n\r\nexport const enum SampleFlags {\r\n  DEGRADATION_PRIORITY_MASK = 0x0000ffff,\r\n  IS_NON_SYN = 0x00010000,\r\n  PADDING_MASK = 0x000e0000,\r\n  REDUNDANCY_MASK = 0x00300000,\r\n  DEPENDED_MASK = 0x00c00000,\r\n  DEPENDS_MASK = 0x03000000,\r\n  DEPENDS_NO = 0x02000000,\r\n  DEPENDS_YES = 0x01000000\r\n}\r\n\r\nexport const enum MP4Tag {\r\n  MP4_O_DESCR_TAG = 0x01,\r\n  MP4_IO_DESCR_TAG = 0x02,\r\n  MP4_ES_DESCR_TAG = 0x03,\r\n  MP4_DEC_CONFIG_DESCR_TAG = 0x04,\r\n  MP4_DEC_SPECIFIC_DESCR_TAG = 0x05,\r\n  MP4_SL_DESCR_TAG = 0x06\r\n}\r\n\r\nexport const enum TKHDFlags {\r\n  ENABLED = 0x0001,\r\n  IN_MOVIE = 0x0002,\r\n  IN_PREVIEW = 0x0004,\r\n  POSTER = 0x0008\r\n}\r\n","/*\r\n * libmedia mov fragment indexes\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../../../AVStream'\r\nimport { FragmentTrack, MOVContext, MOVStreamContext, Sample } from '../type'\r\nimport { SampleFlags } from '../boxType'\r\nimport { AVPacketFlags } from 'avutil/struct/avpacket'\r\nimport { IOFlags } from 'common/io/flags'\r\n\r\n\r\nexport function buildFragmentIndex(stream: Stream, track: FragmentTrack, movContext: MOVContext, ioFlag: int32 = 0) {\r\n  const context = stream.privData as MOVStreamContext\r\n\r\n  const trex = movContext.trexs.find((trex) => {\r\n    return trex.trackId === track.trackId\r\n  })\r\n\r\n  let currentOffset = track.baseDataOffset + static_cast<int64>(track.dataOffset)\r\n  if (track.baseIsMoof) {\r\n    currentOffset += movContext.currentFragment.pos\r\n  }\r\n  let currentDts = track.baseMediaDecodeTime\r\n\r\n  const sampleSizes = track.sampleSizes\r\n  const sampleDurations = track.sampleDurations\r\n  const sampleFlags = track.sampleFlags\r\n  const sampleCompositionTimeOffset = track.sampleCompositionTimeOffset\r\n\r\n  if (!sampleSizes.length) {\r\n    for (let i = 0; i < track.sampleCount; i++) {\r\n      sampleSizes.push(track.defaultSampleSize || trex.size)\r\n    }\r\n  }\r\n  if (!sampleDurations.length) {\r\n    for (let i = 0; i < track.sampleCount; i++) {\r\n      sampleDurations.push(track.defaultSampleDuration || trex.duration)\r\n    }\r\n  }\r\n  if (!sampleFlags.length) {\r\n    for (let i = 0; i < track.sampleCount; i++) {\r\n      sampleFlags.push(track.defaultSampleFlags || trex.flags)\r\n    }\r\n  }\r\n  if (!sampleCompositionTimeOffset.length) {\r\n    for (let i = 0; i < track.sampleCount; i++) {\r\n      sampleCompositionTimeOffset.push(0)\r\n    }\r\n  }\r\n\r\n  const samplesIndex: Sample[] = []\r\n\r\n  for (let i = 0; i < track.sampleCount; i++) {\r\n    const sample: Sample = {\r\n      dts: currentDts,\r\n      pts: currentDts + static_cast<int64>(sampleCompositionTimeOffset[i]),\r\n      pos: currentOffset,\r\n      size: sampleSizes[i],\r\n      duration: sampleDurations[i],\r\n      flags: 0\r\n    }\r\n\r\n    currentDts += static_cast<int64>(sample.duration)\r\n    currentOffset += static_cast<int64>(sample.size)\r\n\r\n    let currentFlags = sampleFlags[i]\r\n\r\n    if (i === 0 && track.firstSampleFlags) {\r\n      currentFlags = track.firstSampleFlags\r\n    }\r\n\r\n    if (!(currentFlags & (SampleFlags.IS_NON_SYN | SampleFlags.DEPENDS_YES))) {\r\n      sample.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n    }\r\n\r\n    if (i === 0 && sampleSizes.length > 1 && (ioFlag & IOFlags.SLICE)) {\r\n      // 切片的第一个帧强制为关键帧\r\n      sample.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n    }\r\n\r\n    samplesIndex.push(sample)\r\n  }\r\n\r\n  context.samplesIndex = samplesIndex\r\n}\r\n","/*\r\n * libmedia mov indexes\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../../../AVStream'\r\nimport { MOVStreamContext, Sample } from '../type'\r\nimport { AVPacketFlags } from 'avutil/struct/avpacket'\r\nimport { AVMediaType } from 'avutil/codec'\r\n\r\n\r\nexport function buildIndex(stream: Stream) {\r\n  const context = stream.privData as MOVStreamContext\r\n\r\n  const chunkOffsets = context.chunkOffsets\r\n  const sampleSizes = context.sampleSizes\r\n\r\n  const cttsSampleCounts = context.cttsSampleCounts\r\n  const cttsSampleOffsets = context.cttsSampleOffsets\r\n\r\n  const stscFirstChunk = context.stscFirstChunk\r\n  const stscSamplesPerChunk = context.stscSamplesPerChunk\r\n\r\n  const stssSampleNumbers = context.stssSampleNumbersMap\r\n\r\n  const sttsSampleCounts = context.sttsSampleCounts\r\n  const sttsSampleDeltas = context.sttsSampleDeltas\r\n\r\n  if (!chunkOffsets.length) {\r\n    return\r\n  }\r\n\r\n  let stscIndex = 0\r\n\r\n  let sttsIndex = 0\r\n  let sttsCurrentIndex = 0\r\n\r\n  let cttsIndex = 0\r\n  let cttsCurrentIndex = 0\r\n\r\n  let chunkSamples = 0\r\n  let currentOffset = 0n\r\n  let currentSample = 0\r\n  let currentDts = 0n\r\n\r\n  const samplesIndex: Sample[] = []\r\n\r\n  for (let i = 0; i < chunkOffsets.length; i++) {\r\n    currentOffset = chunkOffsets[i]\r\n    if (stscIndex < (stscFirstChunk.length - 1) && stscFirstChunk[stscIndex + 1] === i + 1) {\r\n      stscIndex++\r\n    }\r\n    chunkSamples = stscSamplesPerChunk[stscIndex]\r\n\r\n    while (chunkSamples > 0) {\r\n      const sample: Sample = {\r\n        dts: currentDts,\r\n        pts: currentDts,\r\n        pos: currentOffset,\r\n        size: sampleSizes[currentSample],\r\n        duration: 0,\r\n        flags: 0\r\n      }\r\n\r\n      if (stssSampleNumbers && stssSampleNumbers.has(currentSample + 1)\r\n                || stream.codecpar.codecType === AVMediaType.AVMEDIA_TYPE_AUDIO\r\n      ) {\r\n        sample.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n      }\r\n\r\n      if (cttsSampleOffsets) {\r\n        sample.pts = sample.dts + static_cast<int64>(cttsSampleOffsets[cttsIndex])\r\n        cttsCurrentIndex++\r\n        if (cttsCurrentIndex === cttsSampleCounts[cttsIndex]) {\r\n          cttsIndex++\r\n          cttsCurrentIndex = 0\r\n        }\r\n      }\r\n\r\n\r\n      if (currentSample) {\r\n        samplesIndex[currentSample - 1].duration = Number(sample.dts - samplesIndex[currentSample - 1].dts)\r\n      }\r\n\r\n      currentOffset += static_cast<int64>(sample.size)\r\n\r\n      currentDts += static_cast<int64>(sttsSampleDeltas[sttsIndex])\r\n      sttsCurrentIndex++\r\n      if (sttsCurrentIndex === sttsSampleCounts[sttsIndex]) {\r\n        sttsIndex++\r\n        sttsCurrentIndex = 0\r\n      }\r\n\r\n      currentSample++\r\n\r\n      samplesIndex.push(sample)\r\n\r\n      chunkSamples--\r\n    }\r\n  }\r\n\r\n  if (samplesIndex.length > 1) {\r\n    // 最后一个 sample 使用前一个的 duration\r\n    samplesIndex[currentSample - 1].duration = samplesIndex[currentSample - 2].duration\r\n  }\r\n\r\n  context.samplesIndex = samplesIndex\r\n}\r\n","/*\r\n * libmedia create fragment track\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { FragmentTrack } from '../type'\r\n\r\nexport default function createFragmentTrack(): FragmentTrack {\r\n  return {\r\n    trackId: 0,\r\n    baseDataOffset: 0n,\r\n    defaultSampleDuration: 0,\r\n    defaultSampleSize: 0,\r\n    defaultSampleFlags: 0,\r\n    baseMediaDecodeTime: 0n,\r\n    sampleCount: 0,\r\n    dataOffset: 0,\r\n    dataOffsetPos: 0n,\r\n    firstSampleFlags: 0,\r\n    sampleDurations: [],\r\n    sampleSizes: [],\r\n    sampleFlags: [],\r\n    sampleCompositionTimeOffset: [],\r\n    baseIsMoof: false,\r\n    ioWriter: null,\r\n    buffers: []\r\n  }\r\n}\r\n","/*\r\n * libmedia create mov context\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { MOVContext } from '../type'\r\nimport { NOPTS_VALUE, NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\n\r\nexport default function createMovContext(): MOVContext {\r\n  return {\r\n    isom: false,\r\n    timescale: NOPTS_VALUE,\r\n    duration: NOPTS_VALUE_BIGINT,\r\n    foundMoov: false,\r\n    foundMdat: false,\r\n    majorBrand: 0,\r\n    minorVersion: 0,\r\n    compatibleBrand: [],\r\n    creationTime: 0n,\r\n    modificationTime: 0n,\r\n    rate: NOPTS_VALUE,\r\n    volume: NOPTS_VALUE,\r\n    matrix: null,\r\n    nextTrackId: 1,\r\n    fragment: false,\r\n    trexs: [],\r\n    currentFragment: null,\r\n    boxsPositionInfo: [],\r\n    holdMoovPos: 0n,\r\n    currentChunk: null\r\n  }\r\n}\r\n","/*\r\n * libmedia create mov stream context\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { MOVStreamContext } from '../type'\r\nimport { NOPTS_VALUE } from 'avutil/constant'\r\n\r\nexport default function createMovStreamContext(): MOVStreamContext {\r\n  return {\r\n    chunkOffsets: null,\r\n    cttsSampleCounts: null,\r\n    cttsSampleOffsets: null,\r\n    stscFirstChunk: null,\r\n    stscSamplesPerChunk: null,\r\n    stscSampleDescriptionIndex: null,\r\n    stssSampleNumbersMap: null,\r\n    stssSampleNumbers: null,\r\n    sampleSizes: null,\r\n    sttsSampleCounts: null,\r\n    sttsSampleDeltas: null,\r\n\r\n    timescale: 0,\r\n    duration: 0n,\r\n    trackId: NOPTS_VALUE,\r\n    layer: 0,\r\n    alternateGroup: 0,\r\n    volume: 0,\r\n    matrix: null,\r\n    width: 0,\r\n    height: 0,\r\n\r\n    audioCid: 0,\r\n    samplesPerFrame: 0,\r\n    bytesPerFrame: 0,\r\n\r\n    currentSample: 0,\r\n    sampleEnd: false,\r\n    samplesIndex: [],\r\n    fragIndexes: [],\r\n\r\n    lastPts: 0n,\r\n    lastDts: 0n,\r\n    startDts: 0n,\r\n    startCT: 0,\r\n    lastDuration: 0,\r\n    chunkCount: 0,\r\n    firstWrote: false,\r\n    lastStscCount: 0,\r\n    perStreamGrouping: false,\r\n    index: 0,\r\n    flags: 0\r\n  }\r\n}\r\n","/*\r\n * libmedia get next sample\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../../../AVStream'\r\nimport { AVIFormatContext } from '../../../AVFormatContext'\r\nimport { MOVContext, MOVStreamContext, Sample } from '../type'\r\nimport { AV_TIME_BASE_Q } from 'avutil/constant'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { IOFlags } from 'common/io/flags'\r\n\r\nexport function getNextSample(context: AVIFormatContext, movContext: MOVContext) {\r\n  let sample: Sample\r\n  let stream: Stream\r\n\r\n  let bestDts = 0n\r\n\r\n  let posSample: Sample\r\n  let posStream: Stream\r\n\r\n  let dtsSample: Sample\r\n  let dtsStream: Stream\r\n\r\n  context.streams.forEach((s) => {\r\n    const context = s.privData as MOVStreamContext\r\n\r\n    if (!context.samplesIndex || !context.samplesIndex.length) {\r\n      context.sampleEnd = true\r\n      return true\r\n    }\r\n\r\n    if (!context.sampleEnd\r\n      && (!posSample\r\n        || (context.samplesIndex[context.currentSample].pos < posSample.pos)\r\n      )\r\n    ) {\r\n      posSample = context.samplesIndex[context.currentSample]\r\n      posStream = s\r\n    }\r\n\r\n    if (!context.sampleEnd\r\n      && (!dtsSample\r\n        || avRescaleQ(context.samplesIndex[context.currentSample].dts, s.timeBase, AV_TIME_BASE_Q)\r\n          < bestDts\r\n      )\r\n    ) {\r\n      dtsSample = context.samplesIndex[context.currentSample]\r\n      bestDts = avRescaleQ(dtsSample.dts, s.timeBase, AV_TIME_BASE_Q)\r\n      dtsStream = s\r\n    }\r\n  })\r\n\r\n  if (posSample && dtsSample) {\r\n    const posDts = avRescaleQ(posSample.dts, posStream.timeBase, AV_TIME_BASE_Q)\r\n    const dtsDts = avRescaleQ(dtsSample.dts, dtsStream.timeBase, AV_TIME_BASE_Q)\r\n    const diff = Math.abs(Number(posDts - dtsDts))\r\n    // 两者时间差值在 1s 内优先 pos，避免来回 seek\r\n    if ((diff < 1000000) || (context.ioReader.flags & IOFlags.SLICE)) {\r\n      sample = posSample\r\n      stream = posStream\r\n    }\r\n    else {\r\n      sample = dtsSample\r\n      stream = dtsStream\r\n    }\r\n  }\r\n  else if (posSample) {\r\n    sample = posSample\r\n    stream = posStream\r\n  }\r\n  else if (dtsSample) {\r\n    sample = dtsSample\r\n    stream = dtsStream\r\n  }\r\n\r\n  if (stream) {\r\n    (stream.privData as MOVStreamContext).currentSample++\r\n    if ((stream.privData as MOVStreamContext).currentSample\r\n      >= (stream.privData as MOVStreamContext).samplesIndex.length\r\n    ) {\r\n      (stream.privData as MOVStreamContext).sampleEnd = true\r\n    }\r\n\r\n  }\r\n\r\n  if (movContext.fragment) {\r\n    const hasSample = !!context.streams.find((stream) => {\r\n      return (stream.privData as MOVStreamContext).sampleEnd === false\r\n    })\r\n\r\n    if (!hasSample) {\r\n      movContext.currentFragment = null\r\n    }\r\n  }\r\n\r\n  return {\r\n    sample,\r\n    stream\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 decode util\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from '../../AVStream'\r\nimport { Atom, FragmentTrack, MOVContext, MOVStreamContext } from './type'\r\nimport IOReader from 'common/io/IOReader'\r\nimport mktag from '../../function/mktag'\r\nimport { BoxType, ContainerBoxs } from './boxType'\r\nimport { AVIFormatContext } from '../../AVFormatContext'\r\nimport parsers from './parsing/parsers'\r\nimport * as logger from 'common/util/logger'\r\nimport { buildFragmentIndex } from './function/buildFragmentIndex'\r\nimport { buildIndex } from './function/buildIndex'\r\nimport createFragmentTrack from './function/createFragmentTrack'\r\nimport createMovStreamContext from './function/createMovStreamContext'\r\nimport { AVPacketSideDataType } from 'avutil/codec'\r\nimport { avFree, avMalloc } from 'avutil/util/mem'\r\nimport { memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport { NOPTS_VALUE } from 'avutil/constant'\r\n\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport async function readFtyp(ioReader: IOReader, context: MOVContext, atom: Atom) {\r\n\r\n  const endPos = ioReader.getPos() + static_cast<int64>(atom.size)\r\n\r\n  context.majorBrand = await ioReader.readUint32()\r\n  context.minorVersion = await ioReader.readUint32()\r\n\r\n  if (context.majorBrand === mktag('qt  ')) {\r\n    context.isom = true\r\n  }\r\n\r\n  while (ioReader.getPos() < endPos) {\r\n    context.compatibleBrand.push(await ioReader.readUint32())\r\n  }\r\n}\r\n\r\n// @ts-ignore\r\n@deasync\r\nasync function parseOneBox(\r\n  ioReader: IOReader,\r\n  stream: Stream,\r\n  atom: Atom,\r\n  movContext: MOVContext\r\n) {\r\n  const endPos = ioReader.getPos() + static_cast<int64>(atom.size)\r\n  while (ioReader.getPos() < endPos) {\r\n    const size = await ioReader.readUint32()\r\n    const type = await ioReader.readUint32()\r\n\r\n    if (size < 8) {\r\n      logger.error(`invalid box size ${size}`)\r\n      return\r\n    }\r\n\r\n    if (parsers[type]) {\r\n      await parsers[type](\r\n        ioReader,\r\n        stream,\r\n        {\r\n          type,\r\n          size: size - 8\r\n        },\r\n        movContext\r\n      )\r\n    }\r\n    // 兼容 hdlr 在 minf 后面，先解析 hdlr 得到 track 类型\r\n    else if (type === mktag(BoxType.MDIA)) {\r\n      let hdlr = false\r\n      let minfPos = 0n\r\n\r\n      const endPos = ioReader.getPos() + static_cast<int64>(size - 8)\r\n\r\n      while (ioReader.getPos() < endPos) {\r\n        const size = await ioReader.readUint32()\r\n        const type = await ioReader.readUint32()\r\n\r\n        if (type === mktag(BoxType.HDLR)) {\r\n          await parsers[type](\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n          hdlr = true\r\n        }\r\n        else if (type === mktag(BoxType.MINF) && hdlr) {\r\n          await parseOneBox(\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n        }\r\n        else {\r\n          if (type === mktag(BoxType.MINF) && !hdlr) {\r\n            minfPos = ioReader.getPos() - 8n\r\n            await ioReader.skip(size - 8)\r\n          }\r\n          else if (parsers[type]) {\r\n            await parsers[type](\r\n              ioReader,\r\n              stream,\r\n              {\r\n                type,\r\n                size: size - 8\r\n              },\r\n              movContext\r\n            )\r\n          }\r\n          else if (ContainerBoxs.some((boxType) => {\r\n            return mktag(boxType) === type\r\n          })) {\r\n            await parseOneBox(\r\n              ioReader,\r\n              stream,\r\n              {\r\n                type,\r\n                size: size - 8\r\n              },\r\n              movContext\r\n            )\r\n          }\r\n          else {\r\n            await ioReader.skip(size - 8)\r\n          }\r\n        }\r\n      }\r\n      if (minfPos) {\r\n        const now = ioReader.getPos()\r\n        await ioReader.seek(minfPos)\r\n        const size = await ioReader.readUint32()\r\n        const type = await ioReader.readUint32()\r\n        await parseOneBox(\r\n          ioReader,\r\n          stream,\r\n          {\r\n            type,\r\n            size: size - 8\r\n          },\r\n          movContext\r\n        )\r\n        await ioReader.seek(now)\r\n      }\r\n    }\r\n    else if (ContainerBoxs.some((boxType) => {\r\n      return mktag(boxType) === type\r\n    })) {\r\n      await parseOneBox(\r\n        ioReader,\r\n        stream,\r\n        {\r\n          type,\r\n          size: size - 8\r\n        },\r\n        movContext\r\n      )\r\n    }\r\n    else {\r\n      await ioReader.skip(size - 8)\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport async function readMoov(\r\n  ioReader: IOReader,\r\n  formatContext: AVIFormatContext,\r\n  movContext: MOVContext,\r\n  atom: Atom\r\n) {\r\n  const endPos = ioReader.getPos() + static_cast<int64>(atom.size)\r\n  while (ioReader.getPos() < endPos) {\r\n    const size = await ioReader.readUint32()\r\n    const type = await ioReader.readUint32()\r\n\r\n    if (size < 8) {\r\n      logger.error(`invalid box, type: ${type}, size ${size}`)\r\n      return\r\n    }\r\n\r\n    if (parsers[type]) {\r\n      await parsers[type](\r\n        ioReader,\r\n        null,\r\n        {\r\n          type,\r\n          size: size - 8\r\n        },\r\n        movContext\r\n      )\r\n    }\r\n    else if (type === mktag(BoxType.TRAK)) {\r\n      if (!movContext.foundMoov || movContext.fragment) {\r\n        const stream = formatContext.createStream()\r\n        stream.privData = createMovStreamContext()\r\n        await parseOneBox(\r\n          ioReader,\r\n          stream,\r\n          {\r\n            type,\r\n            size: size - 8\r\n          },\r\n          movContext\r\n        )\r\n        if (!movContext.fragment) {\r\n          buildIndex(stream)\r\n        }\r\n        else {\r\n          const streamContext: MOVStreamContext = stream.privData\r\n          const old = formatContext.streams.find((st) => {\r\n            const context: MOVStreamContext = st.privData\r\n            if (st.index !== stream.index && context.trackId === streamContext.trackId) {\r\n              return true\r\n            }\r\n          })\r\n          if (old) {\r\n            if (stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]) {\r\n              old.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA] = stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]\r\n              if (old.codecpar.extradata) {\r\n                avFree(old.codecpar.extradata)\r\n              }\r\n              old.codecpar.extradataSize = old.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA].length\r\n              old.codecpar.extradata = avMalloc(old.codecpar.extradataSize)\r\n              memcpyFromUint8Array(old.codecpar.extradata, old.codecpar.extradataSize, old.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA])\r\n\r\n              if (stream.codecpar.width === NOPTS_VALUE && streamContext.width > 0) {\r\n                old.codecpar.width = streamContext.width\r\n              }\r\n              if (stream.codecpar.width === NOPTS_VALUE && streamContext.height > 0) {\r\n                old.codecpar.height = streamContext.height\r\n              }\r\n            }\r\n            formatContext.removeStream(stream)\r\n            formatContext.streamIndex--\r\n          }\r\n          else {\r\n            if (stream.codecpar.width === NOPTS_VALUE && streamContext.width > 0) {\r\n              stream.codecpar.width = streamContext.width\r\n            }\r\n            if (stream.codecpar.width === NOPTS_VALUE && streamContext.height > 0) {\r\n              stream.codecpar.height = streamContext.height\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        await ioReader.skip(size - 8)\r\n      }\r\n    }\r\n    else if (type === mktag(BoxType.MVEX)) {\r\n      movContext.fragment = true\r\n      await parseOneBox(\r\n        ioReader,\r\n        null,\r\n        {\r\n          type,\r\n          size: size - 8\r\n        },\r\n        movContext\r\n      )\r\n    }\r\n    else {\r\n      await ioReader.skip(size - 8)\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport async function readMoof(\r\n  ioReader: IOReader,\r\n  formatContext: AVIFormatContext,\r\n  movContext: MOVContext,\r\n  atom: Atom\r\n) {\r\n  const endPos = ioReader.getPos() + static_cast<int64>(atom.size)\r\n  while (ioReader.getPos() < endPos) {\r\n    const size = await ioReader.readUint32()\r\n    const type = await ioReader.readUint32()\r\n\r\n    if (size < 8) {\r\n      logger.error(`invalid box, type: ${type}, size ${size}`)\r\n      return\r\n    }\r\n\r\n    if (parsers[type]) {\r\n      await parsers[type](\r\n        ioReader,\r\n        null,\r\n        {\r\n          type,\r\n          size: size - 8\r\n        },\r\n        movContext\r\n      )\r\n    }\r\n    else if (type === mktag(BoxType.TRAF)) {\r\n      const track: FragmentTrack = createFragmentTrack()\r\n\r\n      movContext.currentFragment.currentTrack = track\r\n\r\n      await parseOneBox(\r\n        ioReader,\r\n        null,\r\n        {\r\n          type,\r\n          size: size - 8\r\n        },\r\n        movContext\r\n      )\r\n      movContext.currentFragment.tracks.push(track)\r\n      movContext.currentFragment.currentTrack = null\r\n\r\n      const stream = formatContext.streams.find((stream) => {\r\n        return (stream.privData as MOVStreamContext).trackId === track.trackId\r\n      })\r\n\r\n      if (stream) {\r\n        const streamContext = stream.privData as MOVStreamContext\r\n        track.streamIndex = stream.index\r\n        buildFragmentIndex(stream, track, movContext, formatContext.ioReader.flags)\r\n        streamContext.currentSample = 0\r\n        streamContext.sampleEnd = false\r\n      }\r\n    }\r\n    else {\r\n      await ioReader.skip(size - 8)\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport async function readMfra(\r\n  ioReader: IOReader,\r\n  formatContext: AVIFormatContext,\r\n  movContext: MOVContext,\r\n  atom: Atom\r\n) {\r\n  const endPos = ioReader.getPos() + static_cast<int64>(atom.size)\r\n  while (ioReader.getPos() < endPos) {\r\n    const pos = ioReader.getPos()\r\n    const size = await ioReader.readUint32()\r\n    const type = await ioReader.readUint32()\r\n\r\n    if (type === mktag(BoxType.TFRA)) {\r\n      const version = await ioReader.readUint8()\r\n      await ioReader.skip(3)\r\n      const trackId = await ioReader.readUint32()\r\n      const fieldLength = await ioReader.readUint32()\r\n      const itemCount = await ioReader.readUint32()\r\n\r\n      const stream = formatContext.streams.find((stream) => {\r\n        return (stream.privData as MOVStreamContext).trackId === trackId\r\n      })\r\n\r\n      if (stream) {\r\n\r\n        const movStreamContext = stream.privData as MOVStreamContext\r\n\r\n        let time: int64\r\n        let offset: int64\r\n        for (let i = 0; i < itemCount; i++) {\r\n          if (version === 1) {\r\n            time = await ioReader.readUint64()\r\n            offset = await ioReader.readUint64()\r\n          }\r\n          else {\r\n            time = static_cast<int64>(await ioReader.readUint32())\r\n            offset = static_cast<int64>(await ioReader.readUint32())\r\n          }\r\n\r\n          movStreamContext.fragIndexes.push({\r\n            pos: offset,\r\n            time\r\n          })\r\n\r\n          for (let j = 0; j < ((fieldLength >> 4) & 3) + 1; j++) {\r\n            await ioReader.skip(1)\r\n          }\r\n          for (let j = 0; j < ((fieldLength >> 2) & 3) + 1; j++) {\r\n            await ioReader.skip(1)\r\n          }\r\n          for (let j = 0; j < ((fieldLength >> 0) & 3) + 1; j++) {\r\n            await ioReader.skip(1)\r\n          }\r\n        }\r\n        if (movStreamContext.fragIndexes.length) {\r\n          await ioReader.seek(movStreamContext.fragIndexes[movStreamContext.fragIndexes.length - 1].pos)\r\n          const size = await ioReader.readUint32()\r\n          const type = await ioReader.readUint32()\r\n          if (type === mktag(BoxType.MOOF)) {\r\n            movContext.currentFragment = {\r\n              pos: 0n,\r\n              size,\r\n              sequence: 0,\r\n              tracks: [],\r\n              currentTrack: null\r\n            }\r\n            await readMoof(ioReader, formatContext, movContext, {\r\n              size,\r\n              type\r\n            })\r\n            if (movStreamContext.samplesIndex.length) {\r\n              const sample = movStreamContext.samplesIndex[movStreamContext.samplesIndex.length - 1]\r\n              stream.duration = sample.pts + static_cast<int64>(sample.duration)\r\n              movStreamContext.samplesIndex.length = 0\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    await ioReader.seek(pos + static_cast<int64>(size), false, false)\r\n  }\r\n  movContext.currentFragment = null\r\n}\r\n","/*\r\n * libmedia mp4 identify defined\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport mktag from '../../function/mktag'\r\nimport { AVCodecID } from 'avutil/codec'\r\nimport { AVMediaType } from 'avutil/codec'\r\nimport { BoxType } from './boxType'\r\n\r\nexport const Mp4Tag2AVCodecID = {\r\n  mp4v: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  avc1: AVCodecID.AV_CODEC_ID_H264,\r\n  avc3: AVCodecID.AV_CODEC_ID_H264,\r\n  hev1: AVCodecID.AV_CODEC_ID_HEVC,\r\n  hvc1: AVCodecID.AV_CODEC_ID_HEVC,\r\n  vvc1: AVCodecID.AV_CODEC_ID_VVC,\r\n  vvi1: AVCodecID.AV_CODEC_ID_VVC,\r\n  vp09: AVCodecID.AV_CODEC_ID_VP9,\r\n  av01: AVCodecID.AV_CODEC_ID_AV1,\r\n  mp4a: AVCodecID.AV_CODEC_ID_AAC,\r\n  opus: AVCodecID.AV_CODEC_ID_OPUS\r\n}\r\n\r\nexport const AVCodecID2Mp4a = {\r\n  [AVCodecID.AV_CODEC_ID_AAC]: 0x40,\r\n  [AVCodecID.AV_CODEC_ID_MP3]: 0x69,\r\n  [AVCodecID.AV_CODEC_ID_OPUS]: 0xAD,\r\n  [AVCodecID.AV_CODEC_ID_FLAC]: 0xC1,\r\n  [AVCodecID.AV_CODEC_ID_VORBIS]: 0xDD,\r\n\r\n  [AVCodecID.AV_CODEC_ID_MPEG4]: 0x20,\r\n  [AVCodecID.AV_CODEC_ID_H264]: 0x21,\r\n  [AVCodecID.AV_CODEC_ID_HEVC]: 0x23,\r\n  [AVCodecID.AV_CODEC_ID_VVC]: 0x33,\r\n  [AVCodecID.AV_CODEC_ID_VP9]: 0xB1,\r\n  [AVCodecID.AV_CODEC_ID_NONE]: 0\r\n}\r\n\r\nexport const Mp4aObj2AVCodecID = {\r\n  0x20: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  0x21: AVCodecID.AV_CODEC_ID_H264,\r\n  0x23: AVCodecID.AV_CODEC_ID_HEVC,\r\n  0x33: AVCodecID.AV_CODEC_ID_VVC,\r\n  0xB1: AVCodecID.AV_CODEC_ID_VP9,\r\n\r\n  0x40: AVCodecID.AV_CODEC_ID_AAC,\r\n  0x66: AVCodecID.AV_CODEC_ID_AAC,\r\n  0x67: AVCodecID.AV_CODEC_ID_AAC,\r\n  0x68: AVCodecID.AV_CODEC_ID_AAC,\r\n  0x69: AVCodecID.AV_CODEC_ID_MP3,\r\n  0x6B: AVCodecID.AV_CODEC_ID_MP3,\r\n  0xAD: AVCodecID.AV_CODEC_ID_OPUS,\r\n  0xC1: AVCodecID.AV_CODEC_ID_FLAC,\r\n  0xDD: AVCodecID.AV_CODEC_ID_VORBIS,\r\n  0: AVCodecID.AV_CODEC_ID_NONE\r\n}\r\n\r\nexport const HandlerType2MediaType = {\r\n  vide: AVMediaType.AVMEDIA_TYPE_VIDEO,\r\n  soun: AVMediaType.AVMEDIA_TYPE_AUDIO,\r\n  clcp: AVMediaType.AVMEDIA_TYPE_SUBTITLE,\r\n  sbtl: AVMediaType.AVMEDIA_TYPE_SUBTITLE,\r\n  subt: AVMediaType.AVMEDIA_TYPE_SUBTITLE,\r\n  subp: AVMediaType.AVMEDIA_TYPE_SUBTITLE,\r\n  text: AVMediaType.AVMEDIA_TYPE_SUBTITLE\r\n}\r\n\r\nexport const tag2CodecId = {\r\n  [mktag(BoxType.MP4A)]: AVCodecID.AV_CODEC_ID_AAC,\r\n  [0x6D730055]: AVCodecID.AV_CODEC_ID_MP3,\r\n  [mktag('Opus')]: AVCodecID.AV_CODEC_ID_OPUS,\r\n  [mktag('fLaC')]: AVCodecID.AV_CODEC_ID_FLAC,\r\n  [mktag('spex')]: AVCodecID.AV_CODEC_ID_SPEEX,\r\n  [mktag('SPXN')]: AVCodecID.AV_CODEC_ID_SPEEX,\r\n  [mktag('ac-3')]: AVCodecID.AV_CODEC_ID_AC3,\r\n  [mktag('sac3')]: AVCodecID.AV_CODEC_ID_AC3,\r\n\r\n  [mktag[BoxType.MP4V]]: AVCodecID.AV_CODEC_ID_MPEG4,\r\n  [mktag('av01')]: AVCodecID.AV_CODEC_ID_AV1,\r\n  [mktag('vp08')]: AVCodecID.AV_CODEC_ID_VP8,\r\n  [mktag('vp09')]: AVCodecID.AV_CODEC_ID_VP9,\r\n  [mktag('avc1')]: AVCodecID.AV_CODEC_ID_H264,\r\n  [mktag('hev1')]: AVCodecID.AV_CODEC_ID_HEVC,\r\n  [mktag('hvc1')]: AVCodecID.AV_CODEC_ID_HEVC,\r\n  [mktag('vvc1')]: AVCodecID.AV_CODEC_ID_VVC,\r\n  [mktag('vvi1')]: AVCodecID.AV_CODEC_ID_VVC,\r\n\r\n  [mktag('text')]: AVCodecID.AV_CODEC_ID_MOV_TEXT,\r\n  [mktag('tx3g')]: AVCodecID.AV_CODEC_ID_MOV_TEXT\r\n}\r\n\r\nexport const enum FragmentMode {\r\n  GOP,\r\n  FRAME\r\n}\r\n\r\nexport const enum MovMode {\r\n  MP4,\r\n  MOV\r\n}\r\n","/*\r\n * libmedia mp4 av1c box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport { AVCodecID, AVPacketSideDataType } from 'avutil/codec'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\nimport { mapSafeUint8Array } from 'cheap/std/memory'\r\nimport { avFree, avMalloc } from 'avutil/util/mem'\r\nimport * as av1 from '../../../codecs/av1'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_AV1\r\n\r\n  if (atom.size <= 0) {\r\n    return\r\n  }\r\n\r\n  const data = avMalloc(atom.size)\r\n  const extradata = await ioReader.readBuffer(atom.size, mapSafeUint8Array(data, atom.size))\r\n\r\n  if (movContext.foundMoov) {\r\n    stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA] = extradata.slice()\r\n    avFree(data)\r\n  }\r\n  else {\r\n    stream.codecpar.extradata = data\r\n    stream.codecpar.extradataSize = atom.size\r\n    stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA] = extradata.slice()\r\n  }\r\n\r\n  av1.parseAVCodecParameters(stream, stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA])\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read avcc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 avcc box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport { AVCodecID, AVPacketSideDataType } from 'avutil/codec'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport { avFree, avMalloc } from 'avutil/util/mem'\r\nimport { mapSafeUint8Array } from 'cheap/std/memory'\r\nimport * as logger from 'common/util/logger'\r\nimport * as h264 from '../../../codecs/h264'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_H264\r\n\r\n  if (atom.size <= 0) {\r\n    return\r\n  }\r\n\r\n  const data = avMalloc(atom.size)\r\n  const extradata = await ioReader.readBuffer(atom.size, mapSafeUint8Array(data, atom.size))\r\n\r\n  if (movContext.foundMoov) {\r\n    stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA] = extradata.slice()\r\n    avFree(data)\r\n  }\r\n  else {\r\n    stream.codecpar.extradata = data\r\n    stream.codecpar.extradataSize = atom.size\r\n    stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA] = extradata.slice()\r\n  }\r\n\r\n  h264.parseAVCodecParameters(stream, stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA])\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read avcc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 co64 box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext, MOVStreamContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  await ioReader.skip(3)\r\n\r\n  const chunkOffsets: bigint[] = []\r\n  const entryCount = await ioReader.readUint32()\r\n\r\n  if (version === 0) {\r\n    for (let i = 0; i < entryCount; i++) {\r\n      chunkOffsets.push(await ioReader.readUint64())\r\n    }\r\n  }\r\n\r\n  (stream.privData as MOVStreamContext).chunkOffsets = chunkOffsets\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read co64 error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 colr box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\nimport { AVPacketSideDataType } from 'avutil/codec'\r\nimport { AVColorRange, AVColorPrimaries, AVColorTransferCharacteristic, AVColorSpace } from 'avutil/pixfmt'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  let colorParameterType = await ioReader.readString(4)\r\n\r\n  if (colorParameterType === 'nclx'\r\n    || colorParameterType === 'nclc'\r\n    || colorParameterType === 'prof'\r\n  ) {\r\n    if (colorParameterType === 'prof') {\r\n      const buffer = await ioReader.readBuffer(atom.size - 4)\r\n      stream.sideData[AVPacketSideDataType.AV_PKT_DATA_ICC_PROFILE] = buffer\r\n    }\r\n    else {\r\n      let colorPrimaries = await ioReader.readUint16()\r\n      let colorTrc = await ioReader.readUint16()\r\n      let colorMatrix = await ioReader.readUint16()\r\n      if (colorParameterType === 'nclx') {\r\n        const colorRange = await ioReader.readUint8() >> 7\r\n        if (colorRange) {\r\n          stream.codecpar.colorRange = AVColorRange.AVCOL_RANGE_JPEG\r\n        }\r\n        else {\r\n          stream.codecpar.colorRange = AVColorRange.AVCOL_RANGE_MPEG\r\n        }\r\n      }\r\n\r\n      if (colorPrimaries >= AVColorPrimaries.AVCOL_PRI_NB) {\r\n        colorPrimaries = AVColorPrimaries.AVCOL_PRI_UNSPECIFIED\r\n      }\r\n      if (colorTrc >= AVColorTransferCharacteristic.AVCOL_TRC_NB) {\r\n        colorTrc = AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED\r\n      }\r\n      if (colorMatrix >= AVColorSpace.AVCOL_SPC_NB) {\r\n        colorMatrix = AVColorSpace.AVCOL_SPC_UNSPECIFIED\r\n      }\r\n\r\n      stream.codecpar.colorPrimaries = colorPrimaries\r\n      stream.codecpar.colorTrc = colorTrc\r\n      stream.codecpar.colorSpace = colorMatrix\r\n    }\r\n  }\r\n  else {\r\n    logger.warn(`unsupported color_parameter_type: ${colorParameterType}`)\r\n  }\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read vpcc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 ctts box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext, MOVStreamContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n  const now = ioReader.getPos()\r\n\r\n  const streamContext = stream.privData as MOVStreamContext\r\n\r\n  // version & flags\r\n  await ioReader.skip(4)\r\n\r\n  const sampleCounts = []\r\n  const sampleOffsets = []\r\n\r\n  const entryCount = await ioReader.readUint32()\r\n\r\n  for (let i = 0; i < entryCount; i++) {\r\n    sampleCounts.push(await ioReader.readUint32())\r\n    sampleOffsets.push(await ioReader.readInt32())\r\n  }\r\n\r\n  streamContext.cttsSampleCounts = sampleCounts\r\n  streamContext.cttsSampleOffsets = sampleOffsets\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read ctts error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 dac3 box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport { AVCodecID, AVPacketSideDataType } from 'avutil/codec'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\nimport { newSideData } from 'avutil/util/avpacket'\r\nimport { AV_CH_LAYOUT } from 'avutil/audiosamplefmt'\r\nimport { AC3ChannelLayout } from '../../../codecs/ac3'\r\nimport * as avChannel from 'avutil/util/channel'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_AC3\r\n\r\n  if (atom.size <= 0) {\r\n    return\r\n  }\r\n\r\n  const sd = newSideData(\r\n    addressof(stream.codecpar.codedSideData),\r\n    addressof(stream.codecpar.nbCodedSideData),\r\n    AVPacketSideDataType.AV_PKT_DATA_AUDIO_SERVICE_TYPE,\r\n    sizeof(int32)\r\n  )\r\n\r\n  const ast = reinterpret_cast<pointer<int32>>(sd.data)\r\n\r\n  const ac3info = await ioReader.readUint24()\r\n  const bsmod = (ac3info >> 14) & 0x7\r\n  const acmod = (ac3info >> 11) & 0x7\r\n  const lfeon = (ac3info >> 10) & 0x1\r\n\r\n  let mask = AC3ChannelLayout[acmod]\r\n  if (lfeon) {\r\n    mask |= AV_CH_LAYOUT.AV_CH_LOW_FREQUENCY\r\n  }\r\n\r\n  avChannel.unInitChannelLayout(addressof(stream.codecpar.chLayout))\r\n  avChannel.setChannelLayoutFromMask(addressof(stream.codecpar.chLayout), mask)\r\n\r\n  accessof(ast) <- reinterpret_cast<int32>(bsmod)\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read avcc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 dec3 box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport { AVCodecID, AVPacketSideDataType } from 'avutil/codec'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\nimport { newSideData } from 'avutil/util/avpacket'\r\nimport { AV_CH_LAYOUT, AVAudioServiceType } from 'avutil/audiosamplefmt'\r\nimport { AC3ChannelLayout } from '../../../codecs/ac3'\r\nimport * as avChannel from 'avutil/util/channel'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_EAC3\r\n\r\n  if (atom.size <= 0) {\r\n    return\r\n  }\r\n\r\n  const sd = newSideData(\r\n    addressof(stream.codecpar.codedSideData),\r\n    addressof(stream.codecpar.nbCodedSideData),\r\n    AVPacketSideDataType.AV_PKT_DATA_AUDIO_SERVICE_TYPE,\r\n    sizeof(int32)\r\n  )\r\n\r\n  const ast = reinterpret_cast<pointer<int32>>(sd.data)\r\n\r\n  // data_rate and num_ind_sub\r\n  await ioReader.skip(2)\r\n  const eac3info = await ioReader.readUint24()\r\n  const bsmod = (eac3info >> 12) & 0x1f\r\n  const acmod = (eac3info >>  9) & 0x7\r\n  const lfeon = (eac3info >>  8) & 0x1\r\n\r\n  let mask = AC3ChannelLayout[acmod]\r\n  if (lfeon) {\r\n    mask |= AV_CH_LAYOUT.AV_CH_LOW_FREQUENCY\r\n  }\r\n\r\n  avChannel.unInitChannelLayout(addressof(stream.codecpar.chLayout))\r\n  avChannel.setChannelLayoutFromMask(addressof(stream.codecpar.chLayout), mask)\r\n\r\n  accessof(ast) <- reinterpret_cast<int32>(bsmod)\r\n  if (stream.codecpar.chLayout.nbChannels > 1 && bsmod == 0x7) {\r\n    accessof(ast) <- reinterpret_cast<int32>(AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_KARAOKE)\r\n  }\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read avcc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 dfla box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\nimport { avFree, avMalloc } from 'avutil/util/mem'\r\nimport { mapSafeUint8Array } from 'cheap/std/memory'\r\nimport { AVCodecID, AVPacketSideDataType } from 'avutil/codec'\r\nimport { FlacMetadataType } from '../../../codecs/flac'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_FLAC\r\n\r\n  // FlacSpecificBox version\r\n  await ioReader.skip(1)\r\n  // flag\r\n  await ioReader.skip(3)\r\n\r\n  const tmp = await ioReader.readUint8()\r\n  const last = tmp & 0x80\r\n  const type = tmp & 0x7f\r\n  const size = await ioReader.readUint24()\r\n\r\n  if (type === FlacMetadataType.FLAC_METADATA_TYPE_STREAMINFO && size === 34) {\r\n    const data = avMalloc(size)\r\n    const extradata = await ioReader.readBuffer(size, mapSafeUint8Array(data, size))\r\n\r\n    if (movContext.foundMoov) {\r\n      stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA] = extradata.slice()\r\n      avFree(data)\r\n    }\r\n    else {\r\n      stream.codecpar.extradata = data\r\n      stream.codecpar.extradataSize = size\r\n    }\r\n  }\r\n  else {\r\n    logger.error('streaminfo must be first FLACMetadataBlock')\r\n  }\r\n\r\n  if (!last) {\r\n    logger.warn('non streaminfo FLACMetadataBlock(s) ignored')\r\n  }\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read vpcc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 dops box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\nimport { avFree, avMalloc } from 'avutil/util/mem'\r\nimport { mapSafeUint8Array } from 'cheap/std/memory'\r\nimport { AVCodecID, AVPacketSideDataType } from 'avutil/codec'\r\nimport * as opus from '../../../codecs/opus'\r\nimport BufferReader from 'common/io/BufferReader'\r\nimport BufferWriter from 'common/io/BufferWriter'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_OPUS\r\n\r\n  // OpusSpecificBox version\r\n  await ioReader.skip(1)\r\n\r\n  const data = avMalloc(atom.size + 8)\r\n  const extradata = mapSafeUint8Array(data, atom.size + 8)\r\n\r\n  const reader = new BufferReader(extradata)\r\n  const writer = new BufferWriter(extradata, false)\r\n\r\n  writer.writeString('OpusHead')\r\n  writer.writeUint8(1)\r\n  await ioReader.readBuffer(atom.size - 1, mapSafeUint8Array(data + 9, atom.size - 1))\r\n\r\n  reader.seek(10)\r\n  writer.seek(10)\r\n\r\n  // 大端变小端\r\n  writer.writeUint16(reader.readUint16())\r\n  writer.writeUint32(reader.readUint32())\r\n  writer.writeUint16(reader.readUint16())\r\n\r\n  if (movContext.foundMoov) {\r\n    stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA] = extradata.slice()\r\n    avFree(data)\r\n  }\r\n  else {\r\n    stream.codecpar.extradata = data\r\n    stream.codecpar.extradataSize = extradata.length\r\n    opus.parseAVCodecParameters(stream, extradata.slice())\r\n  }\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read dops error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 esds box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\nimport { MP4Tag } from '../boxType'\r\nimport { AVCodecID, AVPacketSideDataType } from 'avutil/codec'\r\nimport { Mp4aObj2AVCodecID } from '../mov'\r\nimport { avFree, avMalloc } from 'avutil/util/mem'\r\nimport { mapSafeUint8Array } from 'cheap/std/memory'\r\nimport * as aac from '../../../codecs/aac'\r\nimport * as opus from '../../../codecs/opus'\r\n\r\n// @ts-ignore\r\n@deasync\r\nasync function readDescriptorLength(ioReader: IOReader) {\r\n  let len = 0\r\n  for (let i = 0; i < 4; i++) {\r\n    const c = await ioReader.readUint8()\r\n    len = (len << 7) | (c & 0x7f)\r\n    if (!(c & 0x80)) {\r\n      break\r\n    }\r\n  }\r\n  return len\r\n}\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  // version = 0\r\n  await ioReader.skip(4)\r\n\r\n  let endPos = ioReader.getPos() + static_cast<int64>(atom.size - 4)\r\n\r\n  while (ioReader.getPos() < endPos) {\r\n    let tag = await ioReader.readUint8()\r\n    let size = await readDescriptorLength(ioReader)\r\n\r\n    if (size === 0) {\r\n      logger.warn('esds invalid descriptor size 0, skip')\r\n      await ioReader.skip(Number(endPos - ioReader.getPos()))\r\n      continue\r\n    }\r\n\r\n    // ES descriptor\r\n    if (tag === MP4Tag.MP4_ES_DESCR_TAG) {\r\n      let subEndPos = ioReader.getPos() + static_cast<int64>(size)\r\n      // track_id\r\n      await ioReader.skip(2)\r\n      // flags = 0\r\n      await ioReader.skip(1)\r\n\r\n      tag = await ioReader.readUint8()\r\n      size = await readDescriptorLength(ioReader)\r\n\r\n      if (size === 0) {\r\n        logger.warn('esds invalid ES descriptor size 0, skip')\r\n        await ioReader.skip(Number(subEndPos - ioReader.getPos()))\r\n        continue\r\n      }\r\n\r\n      // DecoderConfig descriptor\r\n      if (tag === MP4Tag.MP4_DEC_CONFIG_DESCR_TAG) {\r\n        stream.codecpar.codecId = Mp4aObj2AVCodecID[await ioReader.readUint8()]\r\n\r\n        /*\r\n         * the following fields is made of 6 bits to identify the streamtype (4 for video, 5 for audio)\r\n         * plus 1 bit to indicate upstream and 1 bit set to 1 (reserved)\r\n         */\r\n        await ioReader.skip(1)\r\n\r\n        // Buffersize DB\r\n        await ioReader.skip(3)\r\n        // maxbitrate\r\n        await ioReader.skip(4)\r\n        // avgbitrate\r\n        await ioReader.skip(4)\r\n\r\n        if (ioReader.getPos() < (subEndPos - 5n)) {\r\n          tag = await ioReader.readUint8()\r\n          size = await readDescriptorLength(ioReader)\r\n\r\n          // DecoderSpecific info descriptor\r\n          if (tag === MP4Tag.MP4_DEC_SPECIFIC_DESCR_TAG) {\r\n            const data = avMalloc(size)\r\n            const extradata = await ioReader.readBuffer(size, mapSafeUint8Array(data, size))\r\n            if (movContext.foundMoov) {\r\n              stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA] = extradata.slice()\r\n              avFree(data)\r\n            }\r\n            else {\r\n              stream.codecpar.extradata = data\r\n              stream.codecpar.extradataSize = size\r\n              if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_AAC) {\r\n                aac.parseAVCodecParameters(stream, extradata.slice())\r\n              }\r\n              else if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_OPUS) {\r\n                opus.parseAVCodecParameters(stream, extradata.slice())\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            await ioReader.skip(Number(subEndPos - ioReader.getPos()))\r\n          }\r\n        }\r\n        else {\r\n          await ioReader.skip(Number(subEndPos - ioReader.getPos()))\r\n        }\r\n      }\r\n      else {\r\n        await ioReader.skip(Math.min(size, Number(subEndPos - ioReader.getPos())))\r\n      }\r\n    }\r\n    else {\r\n      await ioReader.skip(Math.min(size, Number(endPos - ioReader.getPos())))\r\n    }\r\n  }\r\n\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read vpcc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 hdlr box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\nimport isDef from 'common/function/isDef'\r\nimport { HandlerType2MediaType } from '../mov'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  await ioReader.skip(3)\r\n\r\n  if (version === 0) {\r\n    // handler\r\n    await ioReader.skip(4)\r\n\r\n    const handlerType = await ioReader.readString(4)\r\n\r\n    const codecType = HandlerType2MediaType[handlerType]\r\n\r\n    if (isDef(codecType)) {\r\n      stream.codecpar.codecType = codecType\r\n    }\r\n\r\n    // component manufacture \r\n    await ioReader.skip(4)\r\n    // component flags \r\n    await ioReader.skip(4)\r\n    // component flags mask \r\n    await ioReader.skip(4)\r\n\r\n    const len = atom.size - 24\r\n\r\n    if (len > 0) {\r\n      const skip = !movContext.isom && (await ioReader.peekUint8()) === len - 1\r\n      if (skip) {\r\n        await ioReader.skip(1)\r\n      }\r\n      stream.metadata['handlerName'] = await ioReader.readString(len - (skip ? 1 : 0))\r\n    }\r\n  }\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read hdlr error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 hvcc box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport { AVCodecID, AVPacketSideDataType } from 'avutil/codec'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport { avFree, avMalloc } from 'avutil/util/mem'\r\nimport { mapSafeUint8Array } from 'cheap/std/memory'\r\nimport * as logger from 'common/util/logger'\r\nimport * as hevc from '../../../codecs/hevc'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_HEVC\r\n\r\n  if (atom.size <= 0) {\r\n    return\r\n  }\r\n\r\n  const data = avMalloc(atom.size)\r\n  const extradata = await ioReader.readBuffer(atom.size, mapSafeUint8Array(data, atom.size))\r\n\r\n  if (movContext.foundMoov) {\r\n    stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA] = extradata.slice()\r\n    avFree(data)\r\n  }\r\n  else {\r\n    stream.codecpar.extradata = data\r\n    stream.codecpar.extradataSize = atom.size\r\n    stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA] = extradata.slice()\r\n  }\r\n\r\n  hevc.parseAVCodecParameters(stream, stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA])\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read hevc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 mdhd box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  await ioReader.skip(3)\r\n\r\n  let creationTime: bigint = 0n\r\n  let modificationTime: bigint = 0n\r\n  let timescale = 0\r\n  let duration: bigint = 0n\r\n\r\n  if (version === 1) {\r\n    creationTime = await ioReader.readUint64()\r\n    modificationTime = await ioReader.readUint64()\r\n    timescale = await ioReader.readUint32()\r\n    duration = await ioReader.readUint64()\r\n  }\r\n  else {\r\n    creationTime = static_cast<int64>(await ioReader.readUint32())\r\n    modificationTime = static_cast<int64>(await ioReader.readUint32())\r\n    timescale = await ioReader.readUint32()\r\n    duration = static_cast<int64>(await ioReader.readUint32())\r\n  }\r\n\r\n  stream.duration = duration\r\n  stream.timeBase.den = timescale\r\n  stream.timeBase.num = 1\r\n  stream.metadata['creationTime'] = creationTime\r\n  stream.metadata['modificationTime'] = modificationTime\r\n\r\n\r\n  const language = await ioReader.readUint16()\r\n  const chars = []\r\n  chars[0] = (language >> 10) & 0x1F\r\n  chars[1] = (language >> 5) & 0x1F\r\n  chars[2] = language & 0x1F\r\n\r\n  const languageString = String.fromCharCode(chars[0] + 0x60, chars[1] + 0x60, chars[2] + 0x60)\r\n\r\n  stream.metadata['language'] = language\r\n  stream.metadata['languageString'] = languageString\r\n\r\n  await ioReader.skip(2)\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read mdhd error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 mfhd box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  await ioReader.skip(3)\r\n\r\n  movContext.currentFragment.sequence = await ioReader.readUint32()\r\n\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read vpcc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 mvhd box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  await ioReader.skip(3)\r\n\r\n  if (version === 1) {\r\n    movContext.creationTime = await ioReader.readUint64()\r\n    movContext.modificationTime = await ioReader.readUint64()\r\n    movContext.timescale = await ioReader.readUint32()\r\n    movContext.duration = await ioReader.readUint64()\r\n  }\r\n  else {\r\n    movContext.creationTime = static_cast<int64>(await ioReader.readUint32())\r\n    movContext.modificationTime = static_cast<int64>(await ioReader.readUint32())\r\n    movContext.timescale = await ioReader.readUint32()\r\n    movContext.duration = static_cast<int64>(await ioReader.readUint32())\r\n  }\r\n\r\n  movContext.rate = await ioReader.readUint32()\r\n  movContext.volume = await ioReader.readUint16() >>> 8\r\n\r\n  await ioReader.skip(10)\r\n  movContext.matrix = new Uint32Array(9)\r\n  for (let i = 0; i < 9; i++) {\r\n    movContext.matrix[i] = await ioReader.readUint32()\r\n  }\r\n\r\n  await ioReader.skip(24)\r\n  movContext.nextTrackId = await ioReader.readUint32()\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read mvhd error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 box parsers map\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { BoxType } from '../boxType'\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\n\r\nimport stts from './stts'\r\nimport ctts from './ctts'\r\nimport stss from './stss'\r\nimport stsz from './stsz'\r\nimport stz2 from './stz2'\r\nimport stsc from './stsc'\r\nimport stco from './stco'\r\nimport co64 from './co64'\r\nimport mdhd from './mdhd'\r\nimport mvhd from './mvhd'\r\nimport tkhd from './tkhd'\r\nimport hdlr from './hdlr'\r\nimport stsd from './stsd'\r\n\r\nimport trex from './trex'\r\nimport mfhd from './mfhd'\r\nimport tfhd from './tfhd'\r\nimport tfdt from './tfdt'\r\nimport trun from './trun'\r\n\r\nimport mktag from '../../../function/mktag'\r\n\r\nconst parsers: Partial<Record<\r\nnumber,\r\n(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) => Promise<void>>\r\n> = {\r\n  [mktag(BoxType.STTS)]: stts,\r\n  [mktag(BoxType.CTTS)]: ctts,\r\n  [mktag(BoxType.STSS)]: stss,\r\n  [mktag(BoxType.STSZ)]: stsz,\r\n  [mktag(BoxType.STZ2)]: stz2,\r\n  [mktag(BoxType.STSC)]: stsc,\r\n  [mktag(BoxType.STCO)]: stco,\r\n  [mktag(BoxType.CO64)]: co64,\r\n  [mktag(BoxType.MDHD)]: mdhd,\r\n  [mktag(BoxType.MVHD)]: mvhd,\r\n  [mktag(BoxType.TKHD)]: tkhd,\r\n  [mktag(BoxType.HDLR)]: hdlr,\r\n  [mktag(BoxType.STSD)]: stsd,\r\n\r\n  [mktag(BoxType.TREX)]: trex,\r\n  [mktag(BoxType.MFHD)]: mfhd,\r\n  [mktag(BoxType.TFHD)]: tfhd,\r\n  [mktag(BoxType.TFDT)]: tfdt,\r\n  [mktag(BoxType.TRUN)]: trun\r\n}\r\n\r\nexport default parsers\r\n","/*\r\n * libmedia mp4 stco box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext, MOVStreamContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  await ioReader.skip(3)\r\n\r\n  const chunkOffsets: bigint[] = []\r\n  const chunkCount = await ioReader.readUint32()\r\n\r\n  if (version === 0) {\r\n    for (let i = 0; i < chunkCount; i++) {\r\n      chunkOffsets.push(static_cast<int64>(await ioReader.readUint32()))\r\n    }\r\n  }\r\n\r\n  (stream.privData as MOVStreamContext).chunkOffsets = chunkOffsets\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read stco error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 stsc box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext, MOVStreamContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  await ioReader.skip(3)\r\n\r\n  const streamContext = stream.privData as MOVStreamContext\r\n\r\n  const firstChunk: number[] = []\r\n  const samplesPerChunk: number[] = []\r\n  const sampleDescriptionIndex: number[] = []\r\n\r\n  const entryCount = await ioReader.readUint32()\r\n\r\n  if (version === 0) {\r\n    for (let i = 0; i < entryCount; i++) {\r\n      firstChunk.push(await ioReader.readUint32())\r\n      samplesPerChunk.push(await ioReader.readUint32())\r\n      sampleDescriptionIndex.push(await ioReader.readUint32())\r\n    }\r\n  }\r\n\r\n  streamContext.stscFirstChunk = firstChunk\r\n  streamContext.stscSamplesPerChunk = samplesPerChunk\r\n  streamContext.stscSampleDescriptionIndex = sampleDescriptionIndex\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read stsc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 stsd box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext, MOVStreamContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\nimport mktag from '../../../function/mktag'\r\nimport { BoxType } from '../boxType'\r\nimport { AVCodecID, AVMediaType } from 'avutil/codec'\r\nimport { tag2CodecId } from '../mov'\r\n\r\nimport avcc from './avcc'\r\nimport hvcc from './hvcc'\r\nimport vvcc from './vvcc'\r\nimport vpcc from './vpcc'\r\nimport av1c from './av1c'\r\nimport esds from './esds'\r\nimport wave from './wave'\r\nimport dfla from './dfla'\r\nimport dops from './dops'\r\nimport colr from './colr'\r\n\r\nimport ac3 from './dac3'\r\nimport eac3 from './dec3'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n  const now = ioReader.getPos()\r\n\r\n  // version\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  await ioReader.skip(3)\r\n\r\n  const streamContext = stream.privData as MOVStreamContext\r\n\r\n  const entryCount = await ioReader.readUint32()\r\n\r\n  for (let i = 0; i < entryCount; i++) {\r\n    const size = await ioReader.readUint32()\r\n    const type = await ioReader.readUint32()\r\n    const endPos = ioReader.getPos() + static_cast<int64>(size - 8)\r\n\r\n    if (tag2CodecId[type]) {\r\n      stream.codecpar.codecId = tag2CodecId[type]\r\n    }\r\n\r\n    if (size === 0) {\r\n      logger.warn('stsd entry invalid box size 0, skip')\r\n      await ioReader.skip(Number(endPos - ioReader.getPos()))\r\n      break\r\n    }\r\n\r\n    if (size >= 16) {\r\n      // reserved\r\n      await ioReader.skip(6)\r\n\r\n      // referenceIndex uin16\r\n      await ioReader.skip(2)\r\n    }\r\n    else if (size <= 7) {\r\n      logger.fatal(`invalid size: ${size} in stsd`)\r\n    }\r\n\r\n    if (stream.codecpar.codecType === AVMediaType.AVMEDIA_TYPE_VIDEO) {\r\n      // version\r\n      await ioReader.skip(2)\r\n      // revision level\r\n      await ioReader.skip(2)\r\n      // vendor\r\n      stream.metadata['vendorId'] = await ioReader.readString(4)\r\n      // temporal quality\r\n      await ioReader.skip(4)\r\n      // spatial quality\r\n      await ioReader.skip(4)\r\n\r\n      stream.codecpar.width = await ioReader.readUint16()\r\n      stream.codecpar.height = await ioReader.readUint16()\r\n\r\n      // horizresolution uin32\r\n      await ioReader.skip(4)\r\n      // vertresolution uin32\r\n      await ioReader.skip(4)\r\n\r\n      // data size = 0 uin32\r\n      await ioReader.skip(4)\r\n\r\n      // frames per samples = 1 uin16\r\n      await ioReader.skip(2)\r\n\r\n      let len = await ioReader.readUint8()\r\n      if (len > 31) {\r\n        len = 31\r\n      }\r\n      stream.metadata['encoder'] = await ioReader.readString(len)\r\n      if (len < 31) {\r\n        await ioReader.skip(31 - len)\r\n      }\r\n\r\n      // depth uin16\r\n      await ioReader.skip(2)\r\n\r\n      // Reserved\r\n      await ioReader.skip(2)\r\n\r\n      while (ioReader.getPos() < endPos) {\r\n        const size = await ioReader.readUint32()\r\n        const type = await ioReader.readUint32()\r\n\r\n        if (size === 0) {\r\n          logger.warn('stsd video invalid box size 0, skip')\r\n          await ioReader.skip(Number(endPos - ioReader.getPos()))\r\n          continue\r\n        }\r\n\r\n        if (type === mktag(BoxType.AVCC)) {\r\n          await avcc(\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n        }\r\n        else if (type === mktag(BoxType.HVCC)) {\r\n          await hvcc(\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n        }\r\n        else if (type === mktag(BoxType.VVCC)) {\r\n          await vvcc(\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n        }\r\n        else if (type === mktag(BoxType.AV1C)) {\r\n          await av1c(\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n        }\r\n        else if (type === mktag(BoxType.VPCC)) {\r\n          await vpcc(\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n        }\r\n        else if (type === mktag(BoxType.ESDS)) {\r\n          await esds(\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n        }\r\n        else if (type === mktag(BoxType.WAVE)) {\r\n          await wave(\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n        }\r\n        else if (type === mktag(BoxType.COLR)) {\r\n          await colr(\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n        }\r\n        else {\r\n          await ioReader.skip(Math.min(size - 8, Number(endPos - ioReader.getPos())))\r\n        }\r\n      }\r\n    }\r\n    else if (stream.codecpar.codecType === AVMediaType.AVMEDIA_TYPE_AUDIO) {\r\n      // SoundDescription Version\r\n      const subVersion = await ioReader.readUint16()\r\n\r\n      // Revision level\r\n      await ioReader.skip(2)\r\n\r\n      stream.metadata['vendorId'] = await ioReader.readString(4)\r\n\r\n      stream.codecpar.chLayout.nbChannels = await ioReader.readUint16()\r\n      stream.codecpar.bitsPerCodedSample = await ioReader.readUint16()\r\n\r\n      streamContext.audioCid = await ioReader.readUint16()\r\n\r\n      // packet size = 0 \r\n      await ioReader.skip(2)\r\n\r\n      stream.codecpar.sampleRate = (await ioReader.readUint32()) >>> 16\r\n\r\n      if (!movContext.isom || (version === 0 && subVersion > 0)) {\r\n        if (subVersion === 1) {\r\n          streamContext.samplesPerFrame = await ioReader.readUint32()\r\n          // bytes per packet\r\n          await ioReader.skip(4)\r\n\r\n          streamContext.bytesPerFrame = await ioReader.readUint32()\r\n          // bytes per sample\r\n          await ioReader.skip(4)\r\n        }\r\n        else if (subVersion === 2) {\r\n          // sizeof struct only\r\n          await ioReader.skip(4)\r\n          stream.codecpar.sampleRate = Number(await ioReader.readUint64())\r\n          stream.codecpar.chLayout.nbChannels = await ioReader.readUint32()\r\n          // always 0x7F000000\r\n          await ioReader.skip(4)\r\n          stream.codecpar.bitsPerCodedSample = await ioReader.readUint32()\r\n          // lpcm format specific flag\r\n          await ioReader.skip(4)\r\n          streamContext.bytesPerFrame = await ioReader.readUint32()\r\n          streamContext.samplesPerFrame = await ioReader.readUint32()\r\n        }\r\n      }\r\n\r\n      while (ioReader.getPos() < endPos) {\r\n        const size = await ioReader.readUint32()\r\n        const type = await ioReader.readUint32()\r\n\r\n        if (size === 0) {\r\n          logger.warn('stsd audio invalid box size 0, skip')\r\n          await ioReader.skip(Number(endPos - ioReader.getPos()))\r\n          continue\r\n        }\r\n\r\n        if (type === mktag(BoxType.ESDS)) {\r\n          await esds(\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n        }\r\n        else if (type === mktag(BoxType.DFLA)) {\r\n          await dfla(\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n        }\r\n        else if (type === mktag(BoxType.DOPS)) {\r\n          await dops(\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n        }\r\n        else if (type === mktag(BoxType.WAVE)) {\r\n          await wave(\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n        }\r\n        else if (type === mktag(BoxType.DAC3)) {\r\n          await ac3(\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n        }\r\n        else if (type === mktag(BoxType.DEC3)) {\r\n          await eac3(\r\n            ioReader,\r\n            stream,\r\n            {\r\n              type,\r\n              size: size - 8\r\n            },\r\n            movContext\r\n          )\r\n        }\r\n        else {\r\n          await ioReader.skip(Math.min(size - 8, Number(endPos - ioReader.getPos())))\r\n        }\r\n      }\r\n    }\r\n    else if (stream.codecpar.codecType === AVMediaType.AVMEDIA_TYPE_SUBTITLE) {\r\n      if (type === mktag(BoxType.STPP)) {\r\n        stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_TTML\r\n      }\r\n      else if (type === mktag(BoxType.WVTT)) {\r\n        stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_WEBVTT\r\n      }\r\n      else if (type === mktag(BoxType.TX3G) || type === mktag(BoxType.TEXT)) {\r\n        stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_MOV_TEXT\r\n      }\r\n      else if (type === mktag(BoxType.C608)) {\r\n        stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_EIA_608\r\n      }\r\n      await ioReader.skip(Math.min(size - 8, Number(endPos - ioReader.getPos())))\r\n    }\r\n    else {\r\n      await ioReader.skip(Math.min(size - 8, Number(endPos - ioReader.getPos())))\r\n    }\r\n  }\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read stsd error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 stss box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext, MOVStreamContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  await ioReader.skip(3)\r\n\r\n  const sampleNumbers: Map<number, true> = new Map()\r\n\r\n  const entryCount = await ioReader.readUint32()\r\n\r\n  if (version === 0) {\r\n    for (let i = 0; i < entryCount; i++) {\r\n      sampleNumbers.set(await ioReader.readUint32(), true)\r\n    }\r\n  }\r\n\r\n  (stream.privData as MOVStreamContext).stssSampleNumbersMap = sampleNumbers\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read stss error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 stsz box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext, MOVStreamContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  await ioReader.skip(3)\r\n\r\n  const sampleSizes: number[] = []\r\n  let sampleSize = 0\r\n  let sampleCount = 0\r\n\r\n  if (version === 0) {\r\n    sampleSize = await ioReader.readUint32()\r\n    sampleCount = await ioReader.readUint32()\r\n\r\n    for (let i = 0; i < sampleCount; i++) {\r\n      if (sampleSize === 0) {\r\n        sampleSizes.push(await ioReader.readUint32())\r\n      }\r\n      else {\r\n        sampleSizes[i] = sampleSize\r\n      }\r\n    }\r\n  }\r\n\r\n  (stream.privData as MOVStreamContext).sampleSizes = sampleSizes\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read stsz error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 stts box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext, MOVStreamContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  await ioReader.skip(3)\r\n\r\n  const streamContext = stream.privData as MOVStreamContext\r\n\r\n  const sampleCounts: number[] = []\r\n  const sampleDeltas: number[] = []\r\n\r\n  const entryCount = await ioReader.readUint32()\r\n  let delta = 1\r\n\r\n  if (version === 0) {\r\n    for (let i = 0; i < entryCount; i++) {\r\n      sampleCounts.push(await ioReader.readUint32())\r\n      delta = await ioReader.readInt32()\r\n      if (delta < 0) {\r\n        logger.warn('File uses negative stts sample delta, using value 1 instead, sync may be lost!')\r\n      }\r\n      sampleDeltas.push(delta)\r\n    }\r\n  }\r\n\r\n  streamContext.sttsSampleCounts = sampleCounts\r\n  streamContext.sttsSampleDeltas = sampleDeltas\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read stts error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 stz2 box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext, MOVStreamContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  await ioReader.skip(3)\r\n\r\n  const sampleSizes: number[] = []\r\n  let sampleCount = 0\r\n  let fieldSize = 0\r\n\r\n  if (version === 0) {\r\n    await ioReader.skip(3)\r\n    fieldSize = await ioReader.readUint8()\r\n    sampleCount = await ioReader.readUint32()\r\n\r\n    if (fieldSize === 4) {\r\n      for (let i = 0; i < sampleCount; i += 2) {\r\n        const tmp = await ioReader.readUint8()\r\n        sampleSizes[i] = (tmp >> 4) & 0xF\r\n        sampleSizes[i + 1] = tmp & 0xF\r\n      }\r\n    }\r\n    else if (fieldSize === 8) {\r\n      for (let i = 0; i < sampleCount; i++) {\r\n        sampleSizes[i] = await ioReader.readUint8()\r\n      }\r\n    }\r\n    else if (fieldSize === 16) {\r\n      for (let i = 0; i < sampleCount; i++) {\r\n        sampleSizes[i] = await ioReader.readUint16()\r\n      }\r\n    }\r\n    else {\r\n      logger.error('Error in length field in stz2 box')\r\n    }\r\n  }\r\n\r\n  (stream.privData as MOVStreamContext).sampleSizes = sampleSizes\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read stz2 error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 tfdt box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n\r\n  await ioReader.skip(3)\r\n\r\n  const track = movContext.currentFragment.currentTrack\r\n\r\n  if (track) {\r\n    if (version === 1) {\r\n      track.baseMediaDecodeTime = await ioReader.readUint64()\r\n    }\r\n    else {\r\n      track.baseMediaDecodeTime = static_cast<int64>(await ioReader.readUint32())\r\n    }\r\n  }\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read vpcc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 tfhd box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\nimport { TFHDFlags } from '../boxType'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n\r\n  const flags = await ioReader.readUint24()\r\n\r\n  const trackId = await ioReader.readUint32()\r\n\r\n  const track = movContext.currentFragment.currentTrack\r\n  track.trackId = trackId\r\n\r\n  if (track) {\r\n    if (flags & TFHDFlags.BASE_DATA_OFFSET) {\r\n      track.baseDataOffset = await ioReader.readUint64()\r\n    }\r\n    if (flags & TFHDFlags.SAMPLE_DESCRIPTION) {\r\n      await ioReader.skip(4)\r\n    }\r\n    if (flags & TFHDFlags.SAMPLE_DURATION) {\r\n      track.defaultSampleDuration = await ioReader.readUint32()\r\n    }\r\n    if (flags & TFHDFlags.SAMPLE_SIZE) {\r\n      track.defaultSampleSize = await ioReader.readUint32()\r\n    }\r\n    if (flags & TFHDFlags.SAMPLE_FLAGS) {\r\n      track.defaultSampleFlags = await ioReader.readUint32()\r\n    }\r\n\r\n    if (flags & TFHDFlags.DEFAULT_BASE_IS_MOOF) {\r\n      track.baseIsMoof = true\r\n    }\r\n  }\r\n\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read vpcc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 tkhd box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream, { AVDisposition } from '../../../AVStream'\r\nimport { Atom, MOVContext, MOVStreamContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\nimport { TKHDFlags } from '../boxType'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n  const streamContext = stream.privData as MOVStreamContext\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  streamContext.flags = await ioReader.readUint24()\r\n\r\n  if (streamContext.flags & TKHDFlags.ENABLED) {\r\n    stream.disposition |= AVDisposition.DEFAULT\r\n  }\r\n\r\n  if (version === 1) {\r\n    stream.metadata['creationTime'] = await ioReader.readUint64()\r\n    stream.metadata['modificationTime'] = await ioReader.readUint64()\r\n    streamContext.trackId = await ioReader.readUint32()\r\n    await ioReader.skip(4)\r\n    streamContext.duration = await ioReader.readUint64()\r\n  }\r\n  else {\r\n    stream.metadata['creationTime'] = static_cast<int64>(await ioReader.readUint32())\r\n    stream.metadata['modificationTime'] = static_cast<int64>(await ioReader.readUint32())\r\n    streamContext.trackId = await ioReader.readUint32()\r\n    await ioReader.skip(4)\r\n    streamContext.duration = static_cast<int64>(await ioReader.readUint32())\r\n  }\r\n\r\n  await ioReader.skip(4 * 2)\r\n\r\n  streamContext.layer = await ioReader.readInt16()\r\n  streamContext.alternateGroup = await ioReader.readInt16()\r\n  streamContext.volume = await ioReader.readInt16() >> 8\r\n\r\n  await ioReader.skip(2)\r\n\r\n  streamContext.matrix = new Uint32Array(9)\r\n  for (let i = 0; i < 9; i++) {\r\n    streamContext.matrix[i] = await ioReader.readUint32()\r\n  }\r\n  streamContext.width = (await ioReader.readUint32()) >> 16\r\n  streamContext.height = (await ioReader.readUint32()) >> 16\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read tkhd error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 trex box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  await ioReader.skip(3)\r\n\r\n  const trackId = await ioReader.readUint32()\r\n  // default_sample_description_index\r\n  await ioReader.skip(4)\r\n  const duration = await ioReader.readUint32()\r\n  const size = await ioReader.readUint32()\r\n  const flags = await ioReader.readUint32()\r\n\r\n  movContext.trexs.push({\r\n    trackId,\r\n    duration,\r\n    size,\r\n    flags\r\n  })\r\n\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read trex error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 trun box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\nimport { TRUNFlags } from '../boxType'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n\r\n  const flags = await ioReader.readUint24()\r\n\r\n  const track = movContext.currentFragment.currentTrack\r\n\r\n  if (track) {\r\n    track.sampleCount = await ioReader.readUint32()\r\n    if (flags & TRUNFlags.DATA_OFFSET) {\r\n      track.dataOffset = await ioReader.readInt32()\r\n    }\r\n    if (flags & TRUNFlags.FIRST_FLAG) {\r\n      track.firstSampleFlags = await ioReader.readUint32()\r\n    }\r\n    for (let i = 0; i < track.sampleCount; i++) {\r\n      if (flags & TRUNFlags.DURATION) {\r\n        track.sampleDurations.push(await ioReader.readUint32())\r\n      }\r\n      if (flags & TRUNFlags.SIZE) {\r\n        track.sampleSizes.push(await ioReader.readUint32())\r\n      }\r\n      if (flags & TRUNFlags.FLAGS) {\r\n        track.sampleFlags.push(await ioReader.readUint32())\r\n      }\r\n      if (flags & TRUNFlags.CTS_OFFSET) {\r\n        if (version === 0) {\r\n          track.sampleCompositionTimeOffset.push(await ioReader.readUint32())\r\n        }\r\n        else {\r\n          track.sampleCompositionTimeOffset.push(await ioReader.readInt32())\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read vpcc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 vpcc box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport { AVCodecID, AVPacketSideDataType } from 'avutil/codec'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport { avFree, avMalloc } from 'avutil/util/mem'\r\nimport { mapSafeUint8Array } from 'cheap/std/memory'\r\nimport * as logger from 'common/util/logger'\r\nimport * as vp9 from '../../../codecs/vp9'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  await ioReader.skip(3)\r\n\r\n  stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_VP9\r\n\r\n  if ((atom.size - 4) <= 0) {\r\n    return\r\n  }\r\n\r\n  const data = avMalloc(atom.size - 4)\r\n  const extradata = await ioReader.readBuffer(atom.size - 4, mapSafeUint8Array(data, atom.size - 4))\r\n\r\n  if (movContext.foundMoov) {\r\n    stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA] = extradata.slice()\r\n    avFree(data)\r\n  }\r\n  else {\r\n    stream.codecpar.extradata = data\r\n    stream.codecpar.extradataSize = atom.size - 4\r\n    stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA] = extradata.slice()\r\n  }\r\n\r\n  vp9.parseAVCodecParameters(stream, stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA])\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read vpcc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia mp4 hvcc box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport { AVCodecID, AVPacketSideDataType } from 'avutil/codec'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport { avFree, avMalloc } from 'avutil/util/mem'\r\nimport { mapSafeUint8Array } from 'cheap/std/memory'\r\nimport * as logger from 'common/util/logger'\r\nimport * as vvc from '../../../codecs/vvc'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  const version = await ioReader.readUint8()\r\n  // flags\r\n  await ioReader.skip(3)\r\n\r\n  stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_VVC\r\n\r\n  if ((atom.size - 4) <= 0) {\r\n    return\r\n  }\r\n\r\n  const data = avMalloc(atom.size - 4)\r\n  const extradata = await ioReader.readBuffer(atom.size - 4, mapSafeUint8Array(data, atom.size - 4))\r\n\r\n  if (movContext.foundMoov) {\r\n    stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA] = extradata.slice()\r\n    avFree(data)\r\n  }\r\n  else {\r\n    stream.codecpar.extradata = data\r\n    stream.codecpar.extradataSize = atom.size - 4\r\n    stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA] = extradata.slice()\r\n  }\r\n\r\n  vvc.parseAVCodecParameters(stream, stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA])\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read vvcc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia wave av1c box parser\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport IOReader from 'common/io/IOReader'\r\nimport Stream from '../../../AVStream'\r\nimport { Atom, MOVContext } from '../type'\r\nimport * as logger from 'common/util/logger'\r\nimport mktag from '../../../function/mktag'\r\nimport { BoxType } from '../boxType'\r\nimport esds from './esds'\r\n\r\n// @ts-ignore\r\n@deasync\r\nexport default async function read(ioReader: IOReader, stream: Stream, atom: Atom, movContext: MOVContext) {\r\n\r\n  const now = ioReader.getPos()\r\n\r\n  const endPos = now + static_cast<int64>(atom.size)\r\n\r\n  while (ioReader.getPos() < endPos) {\r\n    const size = await ioReader.readUint32()\r\n    const type = await ioReader.readUint32()\r\n\r\n    if (size === 0) {\r\n      logger.warn('wave invalid box size 0, skip')\r\n      await ioReader.skip(Number(endPos - ioReader.getPos()))\r\n      continue\r\n    }\r\n\r\n    if (type === mktag(BoxType.ESDS)) {\r\n      await esds(\r\n        ioReader,\r\n        stream,\r\n        {\r\n          type,\r\n          size: size - 8\r\n        },\r\n        movContext\r\n      )\r\n    }\r\n    else {\r\n      await ioReader.skip(Math.min(size - 8, Number(endPos - ioReader.getPos())))\r\n    }\r\n  }\r\n\r\n  const remainingLength = atom.size - Number(ioReader.getPos() - now)\r\n  if (remainingLength > 0) {\r\n    await ioReader.skip(remainingLength)\r\n  }\r\n  else if (remainingLength < 0) {\r\n    logger.error(`read vpcc error, size: ${atom.size}, read: ${atom.size - remainingLength}`)\r\n  }\r\n}\r\n","/*\r\n * libmedia string tag to uint32 in big end\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport * as logger from 'common/util/logger'\r\n\r\nexport default function mktag(tag: string): number {\r\n  if (tag.length !== 4) {\r\n    logger.warn(`tag length is not 4, tag: ${tag}`)\r\n  }\r\n\r\n  let value = 0\r\n  for (let i = 0; i < 4; i++) {\r\n    value = (value << 8) | tag.charCodeAt(i)\r\n  }\r\n\r\n  return value\r\n}\r\n","/*\r\n * libmedia av1 syntax util\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport BitReader from 'common/io/BitReader'\r\n\r\nexport function f(bitReader: BitReader, n: number) {\r\n  let x = 0\r\n  for (let i = 0; i < n; i++ ) {\r\n    x = 2 * x + bitReader.readU1()\r\n  }\r\n  return x\r\n}\r\n\r\nexport function uvlc(bitReader: BitReader) {\r\n  let leadingZeros = 0\r\n  while (true) {\r\n    let done = f(bitReader, 1)\r\n    if (done) {\r\n      break\r\n    }\r\n    leadingZeros++\r\n  }\r\n  if (leadingZeros >= 32) {\r\n    return (1 << 32) - 1\r\n  }\r\n  const value =\tf(bitReader, leadingZeros)\r\n  return value + (1 << leadingZeros) - 1\r\n}\r\n\r\nexport function le(bitReader: BitReader, n: number) {\r\n  let t = 0\r\n  for (let i = 0; i < n; i++) {\r\n    let byte = f(bitReader, 8)\r\n    t += (byte << (i * 8))\r\n  }\r\n  return t\r\n}\r\n\r\nexport function leb128(bitReader: BitReader) {\r\n  let value = 0\r\n  let Leb128Bytes = 0\r\n  for (let i = 0; i < 8; i++ ) {\r\n    let leb128Byte_ = f(bitReader, 8)\r\n    value |= ((leb128Byte_ & 0x7f) << (i * 7))\r\n    Leb128Bytes += 1\r\n    if (!(leb128Byte_ & 0x80)) {\r\n      break\r\n    }\r\n  }\r\n  return value\r\n}\r\n\r\nexport function su(bitReader: BitReader, n: number) {\r\n  let value = f(bitReader, n)\r\n  let signMask = 1 << (n - 1)\r\n  if (value & signMask) {\r\n    value = value - 2 * signMask\r\n  }\r\n  return value\r\n}\r\n\r\nexport function ns(bitReader: BitReader, n: number) {\r\n  let w = Math.floor(Math.log2(n)) + 1\r\n  let m = (1 << w) - n\r\n  let v =\tf(bitReader, w - 1)\r\n  if (v < m) {\r\n    return v\r\n  }\r\n  let extraBit =\tf(bitReader, 1)\r\n  return (v << 1) - m + extraBit\r\n}\r\n\r\nexport function L(bitReader: BitReader, n: number) {\r\n  let x = 0\r\n  for (let i = 0 ; i < n; i++ ) {\r\n    x = 2 * x + bitReader.readU1()\r\n  }\r\n  return x\r\n}\r\n\r\nexport function NS(bitReader: BitReader, n: number) {\r\n  let w = Math.floor(Math.log2(n)) + 1\r\n  let m = (1 << w) - n\r\n  let v =\tL(bitReader, w - 1)\r\n  if (v < m) {\r\n    return v\r\n  }\r\n  let extraBit = L(bitReader, 1)\r\n  return (v << 1) - m + extraBit\r\n}\r\n"],"names":[],"sourceRoot":""}
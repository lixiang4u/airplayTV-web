(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["AVPlayer"] = factory();
	else
		root["AVPlayer"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ui/avplayer/AVPlayer.hbs":
/*!**************************************!*\
  !*** ./src/ui/avplayer/AVPlayer.hbs ***!
  \**************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    "class": "avplayer-ui-player"
  }, var6 = var3, var7 = {
    "class": "avplayer-ui-title"
  }, var8 = {
    d: "M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"
  }, var9 = {
    viewBox: "64 64 896 896"
  }, var10 = {
    href: "https://github.com/zhaohappy/libmedia",
    target: "_blank"
  }, var11 = {
    "class": "avplayer-ui-header"
  }, var12 = {
    "class": "avplayer-ui-progress-container"
  }, var13 = {
    "class": "avplayer-ui-control-item"
  }, var14 = {
    "class": "avplayer-ui-footer-left"
  }, var15 = {
    "class": "avplayer-ui-footer-right"
  }, var16 = {
    "class": "avplayer-ui-control"
  }, var17 = {
    "class": "avplayer-ui-footer"
  }, var18 = {
    d: "m10 17 5-5-5-5v10z"
  }, var19 = {
    viewBox: "0 0 24 24"
  }, var20 = {
    "class": "avplayer-ui-pcm-visualization-container"
  }, var21 = {
    height: "min(80vh, 80vw)",
    width: "min(80vh, 80vw)"
  }, var22 = {
    "class": "avplayer-ui-pcm-visualization-mask"
  }, var23 = {
    "class": "avplayer-ui-mask"
  }, var24 = {
    "class": "avplayer-ui-mask info"
  }, var25 = {
    "class": "avplayer-ui-mask showSettings"
  }, var26 = {
    "class": "avplayer-ui-menu-item"
  }, var27 = {
    "class": "avplayer-ui-menu"
  }, var28 = {
    type: "text/css"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              context: instance,
              events: {
                click: renderEventMethod(
                  "click",
                  "playClick(true)",
                  "click",
                  "",
                  "playClick",
                  {
                    execute: function ($event, $data) {
                      return [
                        var6
                      ]
                    }
                  }
                )
              },
              nativeAttrs: var5,
              operator: elementVNodeOperator,
              ref: "playerContainer",
              tag: "div",
              type: 3
            }
          );
          lookupProp(
            stack,
            stack.length - 1,
            "hasHeader"
          ).value ? children.push(
            {
              children: function () {
                var children = [];
                children.push(
                  {
                    context: instance,
                    nativeAttrs: var7,
                    operator: elementVNodeOperator,
                    tag: "span",
                    text: toString(
                      lookupProp(
                        stack,
                        stack.length - 1,
                        "title"
                      ).value
                    ),
                    type: 3
                  }
                );
                children.push(
                  {
                    children: [
                      {
                        children: [
                          {
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            nativeAttrs: var8,
                            operator: elementVNodeOperator,
                            tag: "path",
                            type: 3
                          }
                        ],
                        context: instance,
                        isPure: var3,
                        isStatic: var3,
                        isSvg: var3,
                        nativeAttrs: var9,
                        operator: elementVNodeOperator,
                        tag: "svg",
                        type: 3
                      }
                    ],
                    context: instance,
                    isPure: var3,
                    isStatic: var3,
                    nativeAttrs: var10,
                    operator: elementVNodeOperator,
                    tag: "a",
                    type: 3
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var11,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          ) : children.push(
            {
              isPure: var3,
              operator: commentVNodeOperator,
              text: "",
              type: 2
            }
          );
          children.push(
            {
              children: function () {
                var children = [];
                !lookupProp(
                  stack,
                  stack.length - 1,
                  "isLive"
                ).value ? children.push(
                  {
                    children: function () {
                      var children = [];
                      children.push(
                        {
                          context: instance,
                          operator: componentVNodeOperator,
                          props: {
                            indicatorUrl: lookupProp(
                              stack,
                              stack.length - 1,
                              "indicatorUrl"
                            ).value,
                            player: lookupProp(
                              stack,
                              stack.length - 1,
                              "player"
                            ).value
                          },
                          tag: "Progress",
                          type: 4
                        }
                      );
                      return children.length ? children : var1
                    }(),
                    context: instance,
                    nativeAttrs: var12,
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                ) : children.push(
                  {
                    isPure: var3,
                    operator: commentVNodeOperator,
                    text: "",
                    type: 2
                  }
                );
                children.push(
                  {
                    children: function () {
                      var children = [];
                      children.push(
                        {
                          children: function () {
                            var children = [];
                            children.push(
                              {
                                children: function () {
                                  var children = [];
                                  children.push(
                                    {
                                      context: instance,
                                      model: renderModel(
                                        lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "played"
                                        )
                                      ),
                                      operator: componentVNodeOperator,
                                      props: {
                                        language: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "language"
                                        ).value,
                                        player: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "player"
                                        ).value
                                      },
                                      ref: "play",
                                      tag: "Play",
                                      type: 4
                                    }
                                  );
                                  return children.length ? children : var1
                                }(),
                                context: instance,
                                nativeAttrs: var13,
                                operator: elementVNodeOperator,
                                tag: "div",
                                type: 3
                              }
                            );
                            children.push(
                              {
                                children: function () {
                                  var children = [];
                                  children.push(
                                    {
                                      context: instance,
                                      operator: componentVNodeOperator,
                                      props: {
                                        language: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "language"
                                        ).value,
                                        player: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "player"
                                        ).value
                                      },
                                      tag: "Volume",
                                      type: 4
                                    }
                                  );
                                  return children.length ? children : var1
                                }(),
                                context: instance,
                                nativeAttrs: var13,
                                operator: elementVNodeOperator,
                                tag: "div",
                                type: 3
                              }
                            );
                            !lookupProp(
                              stack,
                              stack.length - 1,
                              "isLive"
                            ).value ? children.push(
                              {
                                children: function () {
                                  var children = [];
                                  children.push(
                                    {
                                      context: instance,
                                      operator: componentVNodeOperator,
                                      props: {
                                        language: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "language"
                                        ).value,
                                        player: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "player"
                                        ).value
                                      },
                                      tag: "Loop",
                                      type: 4
                                    }
                                  );
                                  return children.length ? children : var1
                                }(),
                                context: instance,
                                nativeAttrs: var13,
                                operator: elementVNodeOperator,
                                tag: "div",
                                type: 3
                              }
                            ) : children.push(
                              {
                                isPure: var3,
                                operator: commentVNodeOperator,
                                text: "",
                                type: 2
                              }
                            );
                            !lookupProp(
                              stack,
                              stack.length - 1,
                              "isLive"
                            ).value ? children.push(
                              {
                                children: function () {
                                  var children = [];
                                  children.push(
                                    {
                                      context: instance,
                                      operator: componentVNodeOperator,
                                      props: {
                                        language: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "language"
                                        ).value,
                                        player: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "player"
                                        ).value
                                      },
                                      tag: "Timer",
                                      type: 4
                                    }
                                  );
                                  return children.length ? children : var1
                                }(),
                                context: instance,
                                nativeAttrs: var13,
                                operator: elementVNodeOperator,
                                tag: "div",
                                type: 3
                              }
                            ) : children.push(
                              {
                                isPure: var3,
                                operator: commentVNodeOperator,
                                text: "",
                                type: 2
                              }
                            );
                            return children.length ? children : var1
                          }(),
                          context: instance,
                          nativeAttrs: var14,
                          operator: elementVNodeOperator,
                          tag: "div",
                          type: 3
                        }
                      );
                      children.push(
                        {
                          children: function () {
                            var children = [];
                            lookupProp(
                              stack,
                              stack.length - 1,
                              "hasVideoTrack"
                            ).value ? children.push(
                              {
                                children: function () {
                                  var children = [];
                                  children.push(
                                    {
                                      context: instance,
                                      operator: componentVNodeOperator,
                                      props: {
                                        language: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "language"
                                        ).value,
                                        player: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "player"
                                        ).value
                                      },
                                      tag: "VideoTrack",
                                      type: 4
                                    }
                                  );
                                  return children.length ? children : var1
                                }(),
                                context: instance,
                                nativeAttrs: var13,
                                operator: elementVNodeOperator,
                                tag: "div",
                                type: 3
                              }
                            ) : children.push(
                              {
                                isPure: var3,
                                operator: commentVNodeOperator,
                                text: "",
                                type: 2
                              }
                            );
                            lookupProp(
                              stack,
                              stack.length - 1,
                              "hasAudioTrack"
                            ).value ? children.push(
                              {
                                children: function () {
                                  var children = [];
                                  children.push(
                                    {
                                      context: instance,
                                      operator: componentVNodeOperator,
                                      props: {
                                        language: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "language"
                                        ).value,
                                        player: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "player"
                                        ).value
                                      },
                                      tag: "AudioTrack",
                                      type: 4
                                    }
                                  );
                                  return children.length ? children : var1
                                }(),
                                context: instance,
                                nativeAttrs: var13,
                                operator: elementVNodeOperator,
                                tag: "div",
                                type: 3
                              }
                            ) : children.push(
                              {
                                isPure: var3,
                                operator: commentVNodeOperator,
                                text: "",
                                type: 2
                              }
                            );
                            lookupProp(
                              stack,
                              stack.length - 1,
                              "hasSubtitleTrack"
                            ).value ? children.push(
                              {
                                children: function () {
                                  var children = [];
                                  children.push(
                                    {
                                      context: instance,
                                      operator: componentVNodeOperator,
                                      props: {
                                        language: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "language"
                                        ).value,
                                        player: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "player"
                                        ).value
                                      },
                                      tag: "SubtitleTrack",
                                      type: 4
                                    }
                                  );
                                  return children.length ? children : var1
                                }(),
                                context: instance,
                                nativeAttrs: var13,
                                operator: elementVNodeOperator,
                                tag: "div",
                                type: 3
                              }
                            ) : children.push(
                              {
                                isPure: var3,
                                operator: commentVNodeOperator,
                                text: "",
                                type: 2
                              }
                            );
                            children.push(
                              {
                                children: function () {
                                  var children = [];
                                  children.push(
                                    {
                                      context: instance,
                                      operator: componentVNodeOperator,
                                      props: {
                                        language: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "language"
                                        ).value,
                                        player: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "player"
                                        ).value
                                      },
                                      tag: "Playrate",
                                      type: 4
                                    }
                                  );
                                  return children.length ? children : var1
                                }(),
                                context: instance,
                                nativeAttrs: var13,
                                operator: elementVNodeOperator,
                                tag: "div",
                                type: 3
                              }
                            );
                            children.push(
                              {
                                children: function () {
                                  var children = [];
                                  children.push(
                                    {
                                      context: instance,
                                      operator: componentVNodeOperator,
                                      props: {
                                        language: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "language"
                                        ).value,
                                        player: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "player"
                                        ).value
                                      },
                                      tag: "Setting",
                                      type: 4
                                    }
                                  );
                                  return children.length ? children : var1
                                }(),
                                context: instance,
                                nativeAttrs: var13,
                                operator: elementVNodeOperator,
                                tag: "div",
                                type: 3
                              }
                            );
                            lookupProp(
                              stack,
                              stack.length - 1,
                              "hasPip"
                            ).value ? children.push(
                              {
                                children: function () {
                                  var children = [];
                                  children.push(
                                    {
                                      context: instance,
                                      operator: componentVNodeOperator,
                                      props: {
                                        language: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "language"
                                        ).value,
                                        player: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "player"
                                        ).value
                                      },
                                      tag: "Pip",
                                      type: 4
                                    }
                                  );
                                  return children.length ? children : var1
                                }(),
                                context: instance,
                                nativeAttrs: var13,
                                operator: elementVNodeOperator,
                                tag: "div",
                                type: 3
                              }
                            ) : children.push(
                              {
                                isPure: var3,
                                operator: commentVNodeOperator,
                                text: "",
                                type: 2
                              }
                            );
                            children.push(
                              {
                                children: function () {
                                  var children = [];
                                  children.push(
                                    {
                                      context: instance,
                                      operator: componentVNodeOperator,
                                      props: {
                                        dom: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "fullscreenDom"
                                        ).value,
                                        language: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "language"
                                        ).value,
                                        player: lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "player"
                                        ).value
                                      },
                                      tag: "Fullscreen",
                                      type: 4
                                    }
                                  );
                                  return children.length ? children : var1
                                }(),
                                context: instance,
                                nativeAttrs: var13,
                                operator: elementVNodeOperator,
                                tag: "div",
                                type: 3
                              }
                            );
                            return children.length ? children : var1
                          }(),
                          context: instance,
                          nativeAttrs: var15,
                          operator: elementVNodeOperator,
                          tag: "div",
                          type: 3
                        }
                      );
                      return children.length ? children : var1
                    }(),
                    context: instance,
                    nativeAttrs: var16,
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var17,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          lookupProp(
            stack,
            stack.length - 1,
            "hasFolder"
          ).value ? children.push(
            {
              children: function () {
                var children = [];
                children.push(
                  {
                    children: [
                      {
                        children: [
                          {
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            nativeAttrs: var18,
                            operator: elementVNodeOperator,
                            tag: "path",
                            type: 3
                          }
                        ],
                        context: instance,
                        isPure: var3,
                        isStatic: var3,
                        isSvg: var3,
                        nativeAttrs: var19,
                        operator: elementVNodeOperator,
                        tag: "svg",
                        type: 3
                      }
                    ],
                    context: instance,
                    events: {
                      click: renderEventMethod(
                        "click",
                        "toggleFold()",
                        "click",
                        "",
                        "toggleFold"
                      )
                    },
                    nativeAttrs: {
                      "class": "avplayer-ui-folder-toggle hint--right",
                      "data-hint": lookupProp(
                        stack,
                        stack.length - 1,
                        "folded"
                      ).value ? lookupKeypath(
                        stack,
                        stack.length - 1,
                        "language.TIP_UNFOLD",
                        [
                          "language",
                          "TIP_UNFOLD"
                        ],
                        var3
                      ).value : lookupKeypath(
                        stack,
                        stack.length - 1,
                        "language.TIP_FOLD",
                        [
                          "language",
                          "TIP_FOLD"
                        ],
                        var3
                      ).value
                    },
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                );
                children.push(
                  {
                    context: instance,
                    operator: componentVNodeOperator,
                    props: {
                      language: lookupProp(
                        stack,
                        stack.length - 1,
                        "language"
                      ).value,
                      player: lookupProp(
                        stack,
                        stack.length - 1,
                        "player"
                      ).value
                    },
                    tag: "Folder",
                    type: 4
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: {
                "class": "avplayer-ui-folder-container",
                "data-fold": lookupProp(
                  stack,
                  stack.length - 1,
                  "folded"
                ).value ? 1 : 0
              },
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          ) : children.push(
            {
              isPure: var3,
              operator: commentVNodeOperator,
              text: "",
              type: 2
            }
          );
          children.push(
            {
              context: instance,
              operator: componentVNodeOperator,
              props: {
                error: lookupProp(
                  stack,
                  stack.length - 1,
                  "error"
                ).value,
                language: lookupProp(
                  stack,
                  stack.length - 1,
                  "language"
                ).value,
                player: lookupProp(
                  stack,
                  stack.length - 1,
                  "player"
                ).value
              },
              tag: "LoadingTip",
              type: 4
            }
          );
          lookupProp(
            stack,
            stack.length - 1,
            "hasPcmVisualization"
          ).value && !lookupProp(
            stack,
            stack.length - 1,
            "loading"
          ).value ? children.push(
            {
              children: function () {
                var children = [];
                children.push(
                  {
                    children: function () {
                      var children = [];
                      children.push(
                        {
                          context: instance,
                          operator: componentVNodeOperator,
                          props: {
                            language: lookupProp(
                              stack,
                              stack.length - 1,
                              "language"
                            ).value,
                            player: lookupProp(
                              stack,
                              stack.length - 1,
                              "player"
                            ).value
                          },
                          tag: "PcmVisualization",
                          type: 4
                        }
                      );
                      return children.length ? children : var1
                    }(),
                    context: instance,
                    nativeAttrs: var20,
                    nativeStyles: var21,
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var22,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          ) : children.push(
            {
              isPure: var3,
              operator: commentVNodeOperator,
              text: "",
              type: 2
            }
          );
          children.push(
            {
              children: function () {
                var children = [];
                children.push(
                  {
                    children: function () {
                      var children = [];
                      lookupProp(
                        stack,
                        stack.length - 1,
                        "error"
                      ).value ? children.push(
                        {
                          context: instance,
                          nativeAttrs: {
                            src: lookupProp(
                              stack,
                              stack.length - 1,
                              "errorStateUrl"
                            ).value
                          },
                          operator: elementVNodeOperator,
                          tag: "img",
                          type: 3
                        }
                      ) : !lookupProp(
                        stack,
                        stack.length - 1,
                        "played"
                      ).value ? children.push(
                        {
                          context: instance,
                          events: {
                            click: renderEventMethod(
                              "click",
                              "playClick()",
                              "click",
                              "",
                              "playClick"
                            )
                          },
                          nativeAttrs: {
                            src: lookupProp(
                              stack,
                              stack.length - 1,
                              "pauseStateUrl"
                            ).value
                          },
                          operator: elementVNodeOperator,
                          tag: "img",
                          type: 3
                        }
                      ) : children.push(
                        {
                          isPure: var3,
                          operator: commentVNodeOperator,
                          text: "",
                          type: 2
                        }
                      );
                      return children.length ? children : var1
                    }(),
                    context: instance,
                    nativeAttrs: {
                      "class": "avplayer-ui-state",
                      "data-show": lookupProp(
                        stack,
                        stack.length - 1,
                        "title"
                      ).value && !lookupProp(
                        stack,
                        stack.length - 1,
                        "played"
                      ).value && !lookupProp(
                        stack,
                        stack.length - 1,
                        "loading"
                      ).value || lookupProp(
                        stack,
                        stack.length - 1,
                        "error"
                      ).value ? 1 : 0
                    },
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var23,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          lookupProp(
            stack,
            stack.length - 1,
            "showInfo"
          ).value ? children.push(
            {
              children: function () {
                var children = [];
                children.push(
                  {
                    context: instance,
                    operator: componentVNodeOperator,
                    props: {
                      language: lookupProp(
                        stack,
                        stack.length - 1,
                        "language"
                      ).value,
                      player: lookupProp(
                        stack,
                        stack.length - 1,
                        "player"
                      ).value
                    },
                    tag: "Info",
                    type: 4
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var24,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          ) : children.push(
            {
              isPure: var3,
              operator: commentVNodeOperator,
              text: "",
              type: 2
            }
          );
          lookupProp(
            stack,
            stack.length - 1,
            "showSettings"
          ).value ? children.push(
            {
              children: function () {
                var children = [];
                children.push(
                  {
                    context: instance,
                    operator: componentVNodeOperator,
                    props: {
                      language: lookupProp(
                        stack,
                        stack.length - 1,
                        "language"
                      ).value,
                      player: lookupProp(
                        stack,
                        stack.length - 1,
                        "player"
                      ).value
                    },
                    tag: "Settings",
                    type: 4
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var25,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          ) : children.push(
            {
              isPure: var3,
              operator: commentVNodeOperator,
              text: "",
              type: 2
            }
          );
          lookupProp(
            stack,
            stack.length - 1,
            "showMenu"
          ).value ? children.push(
            {
              children: function () {
                var children = [];
                renderEach(
                  lookupProp(
                    stack,
                    stack.length - 1,
                    "menu"
                  ),
                  function (stack, $scope, $keypath, $length) {
                    children.push(
                      {
                        context: instance,
                        events: {
                          click: renderEventMethod(
                            "click",
                            "menuAction(action)",
                            "click",
                            "",
                            "menuAction",
                            {
                              execute: function ($event, $data) {
                                return [
                                  lookupProp(
                                    stack,
                                    stack.length - 1,
                                    "action"
                                  ).value
                                ]
                              }
                            }
                          )
                        },
                        key: lookupProp(
                          stack,
                          stack.length - 1,
                          "action"
                        ).value,
                        nativeAttrs: var26,
                        operator: elementVNodeOperator,
                        tag: "div",
                        text: toString(
                          lookupProp(
                            stack,
                            stack.length - 1,
                            "name"
                          ).value
                        ),
                        type: 3
                      }
                    )
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              events: {
                outside: renderEventMethod(
                  "outside",
                  "menuOutside()",
                  "outside",
                  "",
                  "menuOutside"
                )
              },
              nativeAttrs: var27,
              nativeStyles: renderStyleStyle(
                "top: " + toString(
                  lookupProp(
                    stack,
                    stack.length - 1,
                    "menuTop"
                  ).value
                ) + "px; left: " + toString(
                  lookupProp(
                    stack,
                    stack.length - 1,
                    "menuLeft"
                  ).value
                ) + "px;"
              ),
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          ) : children.push(
            {
              isPure: var3,
              operator: commentVNodeOperator,
              text: "",
              type: 2
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var28,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        events: {
          mousemove: renderEventMethod(
            "mousemove",
            "mousemove()",
            "mousemove",
            "",
            "mousemove"
          )
        },
        nativeAttrs: {
          "class": "avplayer-ui-container",
          "data-bar-show": lookupProp(
            stack,
            stack.length - 1,
            "showBar"
          ).value ? 1 : 0,
          id: "avplayer-ui-container"
        },
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/control/audioTrack/AudioTrack.hbs":
/*!**********************************************************************!*\
  !*** ./src/ui/avplayer/components/control/audioTrack/AudioTrack.hbs ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    "class": "avplayer-ui-control-audio-track-value"
  }, var6 = {
    "class": "libmedia-ui-selector"
  }, var7 = {
    type: "text/css"
  }, var8 = {
    "class": "avplayer-ui-control-audio-track"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              context: instance,
              nativeAttrs: var5,
              operator: elementVNodeOperator,
              tag: "div",
              text: toString(
                lookupKeypath(
                  stack,
                  stack.length - 1,
                  "language.CONTROL_AUDIO_TRACK",
                  [
                    "language",
                    "CONTROL_AUDIO_TRACK"
                  ],
                  var3
                ).value
              ),
              type: 3
            }
          );
          children.push(
            {
              children: function () {
                var children = [];
                renderEach(
                  lookupProp(
                    stack,
                    stack.length - 1,
                    "list"
                  ),
                  function (stack, $scope, $keypath, $length, i) {
                    children.push(
                      {
                        context: instance,
                        events: {
                          click: renderEventMethod(
                            "click",
                            "change(i)",
                            "click",
                            "",
                            "change",
                            {
                              execute: function ($event, $data) {
                                return [
                                  i
                                ]
                              }
                            }
                          )
                        },
                        key: lookupProp(
                          stack,
                          stack.length - 1,
                          "id"
                        ).value,
                        nativeAttrs: {
                          "class": "libmedia-ui-selector-item " + (lookupProp(
                            stack,
                            stack.length - 1,
                            "selectIndex"
                          ).value === i ? "active" : "")
                        },
                        operator: elementVNodeOperator,
                        tag: "div",
                        text: toString(
                          lookupProp(
                            stack,
                            stack.length - 1,
                            "name"
                          ).value
                        ),
                        type: 3
                      }
                    )
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var6,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var7,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        nativeAttrs: var8,
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/control/fullscreen/Fullscreen.hbs":
/*!**********************************************************************!*\
  !*** ./src/ui/avplayer/components/control/fullscreen/Fullscreen.hbs ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    d: "M768 298.666667h170.666667v85.333333h-256V128h85.333333v170.666667zM341.333333 384H85.333333V298.666667h170.666667V128h85.333333v256z m426.666667 341.333333v170.666667h-85.333333v-256h256v85.333333h-170.666667zM341.333333 640v256H256v-170.666667H85.333333v-85.333333h256z",
    fill: "#ffffff"
  }, var6 = {
    "class": "icon",
    version: "1.1",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
  }, var7 = {
    d: "M625.777778 256h142.222222V398.222222h113.777778V142.222222H625.777778v113.777778zM256 398.222222V256H398.222222v-113.777778H142.222222V398.222222h113.777778zM768 625.777778v142.222222H625.777778v113.777778h256V625.777778h-113.777778zM398.222222 768H256V625.777778h-113.777778v256H398.222222v-113.777778z",
    fill: "#ffffff"
  }, var8 = {
    type: "text/css"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          lookupProp(
            stack,
            stack.length - 1,
            "fullscreen"
          ).value ? children.push(
            {
              children: [
                {
                  context: instance,
                  isPure: var3,
                  isStatic: var3,
                  isSvg: var3,
                  nativeAttrs: var5,
                  operator: elementVNodeOperator,
                  tag: "path",
                  type: 3
                }
              ],
              context: instance,
              isPure: var3,
              isStatic: var3,
              isSvg: var3,
              nativeAttrs: var6,
              operator: elementVNodeOperator,
              tag: "svg",
              type: 3
            }
          ) : children.push(
            {
              children: [
                {
                  context: instance,
                  isPure: var3,
                  isStatic: var3,
                  isSvg: var3,
                  nativeAttrs: var7,
                  operator: elementVNodeOperator,
                  tag: "path",
                  type: 3
                }
              ],
              context: instance,
              isPure: var3,
              isStatic: var3,
              isSvg: var3,
              nativeAttrs: var6,
              operator: elementVNodeOperator,
              tag: "svg",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var8,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        events: {
          click: renderEventMethod(
            "click",
            "fullscreenClick()",
            "click",
            "",
            "fullscreenClick"
          )
        },
        nativeAttrs: {
          "class": "avplayer-ui-control-fullscreen hint--top",
          "data-hint": lookupKeypath(
            stack,
            stack.length - 1,
            "language.TIP_FULLSCREEN",
            [
              "language",
              "TIP_FULLSCREEN"
            ],
            var3
          ).value
        },
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/control/loop/Loop.hbs":
/*!**********************************************************!*\
  !*** ./src/ui/avplayer/components/control/loop/Loop.hbs ***!
  \**********************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    d: "M9 8.877a3 3 0 0 0-2.995 2.824L6 11.877v4a3 3 0 0 0 2.824 2.995l.176.005a1 1 0 1 1 0 2 5 5 0 0 1-4.995-4.783L4 15.877v-4a5 5 0 0 1 4.783-4.995L9 6.877h3V5.5a.5.5 0 0 1 .834-.372L17 8.878H9Zm11 10a3 3 0 0 0 2.995-2.823l.005-.177v-4a3 3 0 0 0-2.824-2.995L20 8.877a1 1 0 0 1 0-2 5 5 0 0 1 4.995 4.783l.005.217v4a5 5 0 0 1-4.783 4.996l-.217.004h-3v1.378a.5.5 0 0 1-.834.371L12 18.877h8Z",
    "fill-rule": "nonzero"
  }, var6 = {
    "fill-rule": "evenodd"
  }, var7 = {
    viewBox: "0 0 28 28",
    xmlns: "http://www.w3.org/2000/svg"
  }, var8 = {
    d: "M16.859 14.22c2.738 0 4.958 2.164 4.958 4.834 0 2.67-2.22 4.834-4.958 4.834-2.739 0-4.959-2.164-4.959-4.834 0-2.67 2.22-4.835 4.959-4.835Zm0 .966c-2.19 0-3.967 1.732-3.967 3.868s1.776 3.867 3.967 3.867c2.19 0 3.967-1.731 3.967-3.867s-1.776-3.868-3.967-3.868Zm-1.206 2.02.069.056 2.975 2.9a.475.475 0 0 1 0 .684.506.506 0 0 1-.633.056l-.068-.056-2.975-2.9a.475.475 0 0 1 0-.684.506.506 0 0 1 .632-.056ZM12.591 4.9a.69.69 0 0 1 .456.171l3.812 3.346H11.9v-.001H8.925c-1.584 0-2.88 1.208-2.97 2.731l-.005.17v3.868c0 1.545 1.239 2.808 2.8 2.896l.175.005.992-.001v1.934h-.992c-2.664 0-4.838-2.048-4.953-4.619l-.005-.215v-3.868c0-2.597 2.101-4.717 4.737-4.83l.221-.004H11.9v-.892c0-.382.31-.691.691-.691Zm7.243 1.68c2.19.433 3.856 2.274 3.961 4.512l.006.225v3.868c0 .432-.058.85-.167 1.248l-1.817-2.215v-2.9c0-1.263-.827-2.338-1.982-2.736V6.581Z",
    "fill-rule": "nonzero"
  }, var9 = {
    type: "text/css"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          lookupProp(
            stack,
            stack.length - 1,
            "loop"
          ).value ? children.push(
            {
              children: [
                {
                  children: [
                    {
                      context: instance,
                      isPure: var3,
                      isStatic: var3,
                      isSvg: var3,
                      nativeAttrs: var5,
                      operator: elementVNodeOperator,
                      tag: "path",
                      type: 3
                    }
                  ],
                  context: instance,
                  isPure: var3,
                  isStatic: var3,
                  isSvg: var3,
                  nativeAttrs: var6,
                  operator: elementVNodeOperator,
                  tag: "g",
                  type: 3
                }
              ],
              context: instance,
              isPure: var3,
              isStatic: var3,
              isSvg: var3,
              nativeAttrs: var7,
              operator: elementVNodeOperator,
              tag: "svg",
              type: 3
            }
          ) : children.push(
            {
              children: [
                {
                  children: [
                    {
                      context: instance,
                      isPure: var3,
                      isStatic: var3,
                      isSvg: var3,
                      nativeAttrs: var8,
                      operator: elementVNodeOperator,
                      tag: "path",
                      type: 3
                    }
                  ],
                  context: instance,
                  isPure: var3,
                  isStatic: var3,
                  isSvg: var3,
                  nativeAttrs: var6,
                  operator: elementVNodeOperator,
                  tag: "g",
                  type: 3
                }
              ],
              context: instance,
              isPure: var3,
              isStatic: var3,
              isSvg: var3,
              nativeAttrs: var7,
              operator: elementVNodeOperator,
              tag: "svg",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var9,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        events: {
          click: renderEventMethod(
            "click",
            "change()",
            "click",
            "",
            "change"
          )
        },
        nativeAttrs: {
          "class": "avplayer-ui-control-loop hint--top",
          "data-hint": lookupProp(
            stack,
            stack.length - 1,
            "loop"
          ).value ? lookupKeypath(
            stack,
            stack.length - 1,
            "language.TIP_LOOP_STOP",
            [
              "language",
              "TIP_LOOP_STOP"
            ],
            var3
          ).value : lookupKeypath(
            stack,
            stack.length - 1,
            "language.TIP_LOOP_START",
            [
              "language",
              "TIP_LOOP_START"
            ],
            var3
          ).value
        },
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/control/pip/Pip.hbs":
/*!********************************************************!*\
  !*** ./src/ui/avplayer/components/control/pip/Pip.hbs ***!
  \********************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    d: "M23.625 15.75c.966 0 1.75.784 1.75 1.75v4.375a1.75 1.75 0 0 1-1.75 1.75H17.5a1.75 1.75 0 0 1-1.75-1.75V17.5c0-.966.784-1.75 1.75-1.75h6.125ZM21 5.25a2.625 2.625 0 0 1 2.62 2.47l.005.155v5.25a.875.875 0 0 1-1.744.102l-.006-.102v-5.25a.875.875 0 0 0-.773-.87L21 7H7a.875.875 0 0 0-.87.773l-.005.102V19.25c0 .449.338.819.773.87l.102.005h6.125a.875.875 0 0 1 .102 1.744l-.102.006H7a2.625 2.625 0 0 1-2.62-2.47l-.005-.155V7.875a2.625 2.625 0 0 1 2.47-2.62L7 5.25h14Z",
    "fill-rule": "evenodd",
    "stroke-width": ".5"
  }, var6 = {
    viewBox: "0 0 28 28",
    xmlns: "http://www.w3.org/2000/svg"
  }, var7 = {
    type: "text/css"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              children: [
                {
                  children: [
                    {
                      context: instance,
                      isPure: var3,
                      isStatic: var3,
                      isSvg: var3,
                      nativeAttrs: var5,
                      operator: elementVNodeOperator,
                      tag: "path",
                      type: 3
                    }
                  ],
                  context: instance,
                  isPure: var3,
                  isStatic: var3,
                  isSvg: var3,
                  operator: elementVNodeOperator,
                  tag: "g",
                  type: 3
                }
              ],
              context: instance,
              isPure: var3,
              isStatic: var3,
              isSvg: var3,
              nativeAttrs: var6,
              operator: elementVNodeOperator,
              tag: "svg",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var7,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        events: {
          click: renderEventMethod(
            "click",
            "pipClick()",
            "click",
            "",
            "pipClick"
          )
        },
        nativeAttrs: {
          "class": "avplayer-ui-control-pip hint--top",
          "data-hint": lookupProp(
            stack,
            stack.length - 1,
            "pip"
          ).value ? lookupKeypath(
            stack,
            stack.length - 1,
            "language.TIP_PIP_STOP",
            [
              "language",
              "TIP_PIP_STOP"
            ],
            var3
          ).value : lookupKeypath(
            stack,
            stack.length - 1,
            "language.TIP_PIP_START",
            [
              "language",
              "TIP_PIP_START"
            ],
            var3
          ).value
        },
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/control/play/Play.hbs":
/*!**********************************************************!*\
  !*** ./src/ui/avplayer/components/control/play/Play.hbs ***!
  \**********************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    d: "M7 3a2 2 0 0 0-2 2v12a2 2 0 1 0 4 0V5a2 2 0 0 0-2-2zM15 3a2 2 0 0 0-2 2v12a2 2 0 1 0 4 0V5a2 2 0 0 0-2-2z"
  }, var6 = {
    viewBox: "0 0 22 22",
    xmlns: "http://www.w3.org/2000/svg"
  }, var7 = {
    d: "M17.982 9.275L8.06 3.27A2.013 2.013 0 0 0 5 4.994v12.011a2.017 2.017 0 0 0 3.06 1.725l9.922-6.005a2.017 2.017 0 0 0 0-3.45z"
  }, var8 = {
    type: "text/css"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          lookupProp(
            stack,
            stack.length - 1,
            "played"
          ).value ? children.push(
            {
              children: [
                {
                  context: instance,
                  isPure: var3,
                  isStatic: var3,
                  isSvg: var3,
                  nativeAttrs: var5,
                  operator: elementVNodeOperator,
                  tag: "path",
                  type: 3
                }
              ],
              context: instance,
              isPure: var3,
              isStatic: var3,
              isSvg: var3,
              nativeAttrs: var6,
              operator: elementVNodeOperator,
              tag: "svg",
              type: 3
            }
          ) : children.push(
            {
              children: [
                {
                  context: instance,
                  isPure: var3,
                  isStatic: var3,
                  isSvg: var3,
                  nativeAttrs: var7,
                  operator: elementVNodeOperator,
                  tag: "path",
                  type: 3
                }
              ],
              context: instance,
              isPure: var3,
              isStatic: var3,
              isSvg: var3,
              nativeAttrs: var6,
              operator: elementVNodeOperator,
              tag: "svg",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var8,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        events: {
          click: renderEventMethod(
            "click",
            "playClick()",
            "click",
            "",
            "playClick"
          )
        },
        nativeAttrs: {
          "class": "avplayer-ui-control-play hint--top",
          "data-hint": lookupProp(
            stack,
            stack.length - 1,
            "played"
          ).value ? lookupKeypath(
            stack,
            stack.length - 1,
            "language.TIP_PAUSE",
            [
              "language",
              "TIP_PAUSE"
            ],
            var3
          ).value : lookupKeypath(
            stack,
            stack.length - 1,
            "language.TIP_PLAY",
            [
              "language",
              "TIP_PLAY"
            ],
            var3
          ).value
        },
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/control/playrate/Playrate.hbs":
/*!******************************************************************!*\
  !*** ./src/ui/avplayer/components/control/playrate/Playrate.hbs ***!
  \******************************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    "class": "avplayer-ui-control-play-rate-value"
  }, var6 = {
    "class": "libmedia-ui-selector"
  }, var7 = {
    type: "text/css"
  }, var8 = {
    "class": "avplayer-ui-control-play-rate"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              context: instance,
              nativeAttrs: var5,
              operator: elementVNodeOperator,
              tag: "div",
              text: toString(
                lookupKeypath(
                  stack,
                  stack.length - 1,
                  "language.CONTROL_PLAYRATE",
                  [
                    "language",
                    "CONTROL_PLAYRATE"
                  ],
                  var3
                ).value
              ),
              type: 3
            }
          );
          children.push(
            {
              children: function () {
                var children = [];
                renderEach(
                  lookupProp(
                    stack,
                    stack.length - 1,
                    "list"
                  ),
                  function (stack, $scope, $keypath, $length, i) {
                    children.push(
                      {
                        children: function () {
                          var children = [];
                          children.push(
                            {
                              isPure: var3,
                              operator: textVNodeOperator,
                              text: toString(
                                (
                                  var0 = stack[ stack.length - 1 ],
                                  setValueHolder(
                                    var0.getScope(),
                                    var0.keypath
                                  )
                                ).value
                              ) + "x",
                              type: 1
                            }
                          );
                          return children.length ? children : var1
                        }(),
                        context: instance,
                        events: {
                          click: renderEventMethod(
                            "click",
                            "change(i)",
                            "click",
                            "",
                            "change",
                            {
                              execute: function ($event, $data) {
                                return [
                                  i
                                ]
                              }
                            }
                          )
                        },
                        key: (
                          var0 = stack[ stack.length - 1 ],
                          setValueHolder(
                            var0.getScope(),
                            var0.keypath
                          )
                        ).value,
                        nativeAttrs: {
                          "class": "libmedia-ui-selector-item " + (lookupProp(
                            stack,
                            stack.length - 1,
                            "index"
                          ).value === i ? "active" : "")
                        },
                        operator: elementVNodeOperator,
                        tag: "div",
                        type: 3
                      }
                    )
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var6,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var7,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        nativeAttrs: var8,
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/control/setting/Setting.hbs":
/*!****************************************************************!*\
  !*** ./src/ui/avplayer/components/control/setting/Setting.hbs ***!
  \****************************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    cx: "11",
    cy: "11",
    r: "2"
  }, var6 = {
    d: "M19.164 8.861L17.6 8.6a6.978 6.978 0 0 0-1.186-2.099l.574-1.533a1 1 0 0 0-.436-1.217l-1.997-1.153a1.001 1.001 0 0 0-1.272.23l-1.008 1.225a7.04 7.04 0 0 0-2.55.001L8.716 2.829a1 1 0 0 0-1.272-.23L5.447 3.751a1 1 0 0 0-.436 1.217l.574 1.533A6.997 6.997 0 0 0 4.4 8.6l-1.564.261A.999.999 0 0 0 2 9.847v2.306c0 .489.353.906.836.986l1.613.269a7 7 0 0 0 1.228 2.075l-.558 1.487a1 1 0 0 0 .436 1.217l1.997 1.153c.423.244.961.147 1.272-.23l1.04-1.263a7.089 7.089 0 0 0 2.272 0l1.04 1.263a1 1 0 0 0 1.272.23l1.997-1.153a1 1 0 0 0 .436-1.217l-.557-1.487c.521-.61.94-1.31 1.228-2.075l1.613-.269a.999.999 0 0 0 .835-.986V9.847a.999.999 0 0 0-.836-.986zM11 15a4 4 0 1 1 0-8 4 4 0 0 1 0 8z"
  }, var7 = {
    viewBox: "0 0 22 22",
    xmlns: "http://www.w3.org/2000/svg"
  }, var8 = {
    type: "text/css"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              children: [
                {
                  context: instance,
                  isPure: var3,
                  isStatic: var3,
                  isSvg: var3,
                  nativeAttrs: var5,
                  operator: elementVNodeOperator,
                  tag: "circle",
                  type: 3
                },
                {
                  context: instance,
                  isPure: var3,
                  isStatic: var3,
                  isSvg: var3,
                  nativeAttrs: var6,
                  operator: elementVNodeOperator,
                  tag: "path",
                  type: 3
                }
              ],
              context: instance,
              isPure: var3,
              isStatic: var3,
              isSvg: var3,
              nativeAttrs: var7,
              operator: elementVNodeOperator,
              tag: "svg",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var8,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        events: {
          click: renderEventMethod(
            "click",
            "click()",
            "click",
            "",
            "click"
          )
        },
        nativeAttrs: {
          "class": "avplayer-ui-control-settings hint--top",
          "data-hint": lookupKeypath(
            stack,
            stack.length - 1,
            "language.TIP_SETTING",
            [
              "language",
              "TIP_SETTING"
            ],
            var3
          ).value
        },
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/control/subtitleTrack/SubtitleTrack.hbs":
/*!****************************************************************************!*\
  !*** ./src/ui/avplayer/components/control/subtitleTrack/SubtitleTrack.hbs ***!
  \****************************************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    "class": "avplayer-ui-control-subtitle-track-value"
  }, var6 = {
    display: "none"
  }, var7 = {
    "class": "libmedia-ui-selector"
  }, var8 = {
    type: "text/css"
  }, var9 = {
    "class": "avplayer-ui-control-subtitle-track"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              context: instance,
              nativeAttrs: var5,
              operator: elementVNodeOperator,
              tag: "div",
              text: toString(
                lookupKeypath(
                  stack,
                  stack.length - 1,
                  "language.CONTROL_SUBTITLE_TRACK",
                  [
                    "language",
                    "CONTROL_SUBTITLE_TRACK"
                  ],
                  var3
                ).value
              ),
              type: 3
            }
          );
          children.push(
            {
              children: function () {
                var children = [];
                renderEach(
                  lookupProp(
                    stack,
                    stack.length - 1,
                    "list"
                  ),
                  function (stack, $scope, $keypath, $length, i) {
                    children.push(
                      {
                        context: instance,
                        events: {
                          click: renderEventMethod(
                            "click",
                            "change(i)",
                            "click",
                            "",
                            "change",
                            {
                              execute: function ($event, $data) {
                                return [
                                  i
                                ]
                              }
                            }
                          )
                        },
                        key: lookupProp(
                          stack,
                          stack.length - 1,
                          "id"
                        ).value,
                        nativeAttrs: {
                          "class": "libmedia-ui-selector-item " + (lookupProp(
                            stack,
                            stack.length - 1,
                            "selectIndex"
                          ).value === i ? "active" : "")
                        },
                        operator: elementVNodeOperator,
                        tag: "div",
                        text: toString(
                          lookupProp(
                            stack,
                            stack.length - 1,
                            "name"
                          ).value
                        ),
                        type: 3
                      }
                    )
                  }
                );
                children.push(
                  function (vnode) {
                    lookupProp(
                      stack,
                      stack.length - 1,
                      "canUseFilePicker"
                    ).value ? appendVNodeProperty(
                      vnode,
                      "events",
                      "click",
                      renderEventMethod(
                        "click",
                        "openFile()",
                        "click",
                        "",
                        "openFile"
                      )
                    ) : appendVNodeProperty(
                      vnode,
                      "nativeAttrs",
                      "for",
                      "avplayer-file-open-subtitle"
                    );
                    return vnode
                  }(
                    {
                      children: function () {
                        var children = [];
                        children.push(
                          {
                            isPure: var3,
                            operator: textVNodeOperator,
                            text: toString(
                              lookupKeypath(
                                stack,
                                stack.length - 1,
                                "language.CONTROL_SUBTITLE_TRACK_ADD",
                                [
                                  "language",
                                  "CONTROL_SUBTITLE_TRACK_ADD"
                                ],
                                var3
                              ).value
                            ),
                            type: 1
                          }
                        );
                        !lookupProp(
                          stack,
                          stack.length - 1,
                          "canUseFilePicker"
                        ).value ? children.push(
                          {
                            context: instance,
                            events: {
                              change: renderEventMethod(
                                "change",
                                "fileChange()",
                                "change",
                                "",
                                "fileChange"
                              )
                            },
                            nativeAttrs: {
                              accept: lookupProp(
                                stack,
                                stack.length - 1,
                                "accept"
                              ).value,
                              id: "avplayer-file-open-subtitle",
                              type: "file"
                            },
                            nativeStyles: var6,
                            operator: elementVNodeOperator,
                            tag: "input",
                            type: 3
                          }
                        ) : children.push(
                          {
                            isPure: var3,
                            operator: commentVNodeOperator,
                            text: "",
                            type: 2
                          }
                        );
                        return children.length ? children : var1
                      }(),
                      context: instance,
                      nativeAttrs: {
                        "class": "libmedia-ui-selector-item"
                      },
                      operator: elementVNodeOperator,
                      tag: "label",
                      type: 3
                    }
                  )
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var7,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var8,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        nativeAttrs: var9,
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/control/timer/Timer.hbs":
/*!************************************************************!*\
  !*** ./src/ui/avplayer/components/control/timer/Timer.hbs ***!
  \************************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    "class": "avplayer-ui-time-label"
  }, var6 = {
    "class": "avplayer-ui-time-div"
  }, var7 = {
    type: "text/css"
  }, var8 = {
    "class": "avplayer-ui-control-timer"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              context: instance,
              nativeAttrs: var5,
              operator: elementVNodeOperator,
              tag: "span",
              text: toString(
                setValueHolder(
                  (
                    var0 = lookupProp(
                      stack,
                      stack.length - 1,
                      "formatTime",
                      filters && filters.formatTime || globalFilters.formatTime
                    ).value,
                    typeof var0 === "function" ? var0(
                      lookupProp(
                        stack,
                        stack.length - 1,
                        "currentTime"
                      ).value
                    ) : logger.fatal(
                      "[formatTime(currentTime)] is not a function."
                    )
                  )
                ).value
              ),
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: "&nbsp;/&nbsp;",
              isPure: var3,
              isStatic: var3,
              nativeAttrs: var6,
              operator: elementVNodeOperator,
              tag: "span",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              nativeAttrs: var5,
              operator: elementVNodeOperator,
              tag: "span",
              text: toString(
                setValueHolder(
                  (
                    var0 = lookupProp(
                      stack,
                      stack.length - 1,
                      "formatTime",
                      filters && filters.formatTime || globalFilters.formatTime
                    ).value,
                    typeof var0 === "function" ? var0(
                      lookupProp(
                        stack,
                        stack.length - 1,
                        "totalTime"
                      ).value
                    ) : logger.fatal(
                      "[formatTime(totalTime)] is not a function."
                    )
                  )
                ).value
              ),
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var7,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        nativeAttrs: var8,
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/control/videoTrack/VideoTrack.hbs":
/*!**********************************************************************!*\
  !*** ./src/ui/avplayer/components/control/videoTrack/VideoTrack.hbs ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    "class": "avplayer-ui-control-video-track-value"
  }, var6 = {
    "class": "libmedia-ui-selector"
  }, var7 = {
    type: "text/css"
  }, var8 = {
    "class": "avplayer-ui-control-video-track"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              context: instance,
              nativeAttrs: var5,
              operator: elementVNodeOperator,
              tag: "div",
              text: toString(
                lookupKeypath(
                  stack,
                  stack.length - 1,
                  "language.CONTROL_VIDEO_TRACK",
                  [
                    "language",
                    "CONTROL_VIDEO_TRACK"
                  ],
                  var3
                ).value
              ),
              type: 3
            }
          );
          children.push(
            {
              children: function () {
                var children = [];
                renderEach(
                  lookupProp(
                    stack,
                    stack.length - 1,
                    "list"
                  ),
                  function (stack, $scope, $keypath, $length, i) {
                    children.push(
                      {
                        context: instance,
                        events: {
                          click: renderEventMethod(
                            "click",
                            "change(i)",
                            "click",
                            "",
                            "change",
                            {
                              execute: function ($event, $data) {
                                return [
                                  i
                                ]
                              }
                            }
                          )
                        },
                        key: lookupProp(
                          stack,
                          stack.length - 1,
                          "id"
                        ).value,
                        nativeAttrs: {
                          "class": "libmedia-ui-selector-item " + (lookupProp(
                            stack,
                            stack.length - 1,
                            "selectIndex"
                          ).value === i ? "active" : "")
                        },
                        operator: elementVNodeOperator,
                        tag: "div",
                        text: toString(
                          lookupProp(
                            stack,
                            stack.length - 1,
                            "name"
                          ).value
                        ),
                        type: 3
                      }
                    )
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var6,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var7,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        nativeAttrs: var8,
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/control/volume/Volume.hbs":
/*!**************************************************************!*\
  !*** ./src/ui/avplayer/components/control/volume/Volume.hbs ***!
  \**************************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    d: "M10.188 4.65L6 8H5a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h1l4.188 3.35a.5.5 0 0 0 .812-.39V5.04a.498.498 0 0 0-.812-.39zM14.446 3.778a1 1 0 0 0-.862 1.804 6.002 6.002 0 0 1-.007 10.838 1 1 0 0 0 .86 1.806A8.001 8.001 0 0 0 19 11a8.001 8.001 0 0 0-4.554-7.222z"
  }, var6 = {
    d: "M15 11a3.998 3.998 0 0 0-2-3.465v6.93A3.998 3.998 0 0 0 15 11z"
  }, var7 = {
    viewBox: "0 0 22 22",
    xmlns: "http://www.w3.org/2000/svg"
  }, var8 = {
    d: "M15 11a3.998 3.998 0 0 0-2-3.465v2.636l1.865 1.865A4.02 4.02 0 0 0 15 11z"
  }, var9 = {
    d: "M13.583 5.583A5.998 5.998 0 0 1 17 11a6 6 0 0 1-.585 2.587l1.477 1.477a8.001 8.001 0 0 0-3.446-11.286 1 1 0 0 0-.863 1.805zM18.778 18.778l-2.121-2.121-1.414-1.414-1.415-1.415L13 13l-2-2-3.889-3.889-3.889-3.889a.999.999 0 1 0-1.414 1.414L5.172 8H5a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h1l4.188 3.35a.5.5 0 0 0 .812-.39v-3.131l2.587 2.587-.01.005a1 1 0 0 0 .86 1.806c.215-.102.424-.214.627-.333l2.3 2.3a1.001 1.001 0 0 0 1.414-1.416zM11 5.04a.5.5 0 0 0-.813-.39L8.682 5.854 11 8.172V5.04z"
  }, var10 = {
    "class": "avplayer-ui-volume-icon"
  }, var11 = {
    "class": "avplayer-ui-volume-value"
  }, var12 = {
    "class": "avplayer-ui-volume-inner"
  }, var13 = {
    "class": "avplayer-ui-volume-panel"
  }, var14 = {
    type: "text/css"
  }, var15 = {
    "class": "avplayer-ui-control-volume"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              children: function () {
                var children = [];
                lookupProp(
                  stack,
                  stack.length - 1,
                  "volume"
                ).value ? children.push(
                  {
                    children: [
                      {
                        context: instance,
                        isPure: var3,
                        isStatic: var3,
                        isSvg: var3,
                        nativeAttrs: var5,
                        operator: elementVNodeOperator,
                        tag: "path",
                        type: 3
                      },
                      {
                        context: instance,
                        isPure: var3,
                        isStatic: var3,
                        isSvg: var3,
                        nativeAttrs: var6,
                        operator: elementVNodeOperator,
                        tag: "path",
                        type: 3
                      }
                    ],
                    context: instance,
                    isPure: var3,
                    isStatic: var3,
                    isSvg: var3,
                    nativeAttrs: var7,
                    operator: elementVNodeOperator,
                    tag: "svg",
                    type: 3
                  }
                ) : children.push(
                  {
                    children: [
                      {
                        context: instance,
                        isPure: var3,
                        isStatic: var3,
                        isSvg: var3,
                        nativeAttrs: var8,
                        operator: elementVNodeOperator,
                        tag: "path",
                        type: 3
                      },
                      {
                        context: instance,
                        isPure: var3,
                        isStatic: var3,
                        isSvg: var3,
                        nativeAttrs: var9,
                        operator: elementVNodeOperator,
                        tag: "path",
                        type: 3
                      }
                    ],
                    context: instance,
                    isPure: var3,
                    isStatic: var3,
                    isSvg: var3,
                    nativeAttrs: var7,
                    operator: elementVNodeOperator,
                    tag: "svg",
                    type: 3
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              events: {
                click: renderEventMethod(
                  "click",
                  "volumeClick()",
                  "click",
                  "",
                  "volumeClick"
                )
              },
              nativeAttrs: var10,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              children: function () {
                var children = [];
                children.push(
                  {
                    children: function () {
                      var children = [];
                      children.push(
                        {
                          context: instance,
                          nativeAttrs: var11,
                          operator: elementVNodeOperator,
                          tag: "div",
                          text: toString(
                            lookupProp(
                              stack,
                              stack.length - 1,
                              "volume"
                            ).value
                          ),
                          type: 3
                        }
                      );
                      children.push(
                        {
                          context: instance,
                          model: renderModel(
                            lookupProp(
                              stack,
                              stack.length - 1,
                              "volume"
                            )
                          ),
                          operator: componentVNodeOperator,
                          tag: "Slider",
                          type: 4
                        }
                      );
                      return children.length ? children : var1
                    }(),
                    context: instance,
                    nativeAttrs: var12,
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var13,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var14,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        nativeAttrs: var15,
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/folder/Folder.hbs":
/*!******************************************************!*\
  !*** ./src/ui/avplayer/components/folder/Folder.hbs ***!
  \******************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    d: "M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"
  }, var6 = {
    viewBox: "0 0 24 24"
  }, var7 = {
    "class": "avplayer-ui-folder-icon dir"
  }, var8 = {
    "class": "avplayer-ui-folder-open-name"
  }, var9 = {
    "class": "avplayer-ui-folder-open-dir item"
  }, var10 = {
    "stroke-width": "0"
  }, var11 = {
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, var12 = {
    d: "M21 11V15.8C21 16.9201 21 17.4802 20.782 17.908C20.5903 18.2843 20.2843 18.5903 19.908 18.782C19.4802 19 18.9201 19 17.8 19H6.2C5.0799 19 4.51984 19 4.09202 18.782C3.71569 18.5903 3.40973 18.2843 3.21799 17.908C3 17.4802 3 16.9201 3 15.8V8.2C3 7.0799 3 6.51984 3.21799 6.09202C3.40973 5.71569 3.71569 5.40973 4.09202 5.21799C4.51984 5 5.0799 5 6.2 5H15M21 11L15 5M21 11H16.6C16.0399 11 15.7599 11 15.546 10.891C15.3578 10.7951 15.2049 10.6422 15.109 10.454C15 10.2401 15 9.96005 15 9.4V5",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2"
  }, var13 = {
    fill: "none",
    transform: "rotate(270)",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, var14 = {
    "class": "avplayer-ui-folder-icon file"
  }, var15 = {
    display: "none"
  }, var16 = {
    "class": "avplayer-ui-folder-open"
  }, var17 = {
    type: "checkbox"
  }, var18 = {
    "class": "avplayer-ui-url-open-live"
  }, var19 = {
    "clip-rule": "evenodd",
    d: "M10 1C9.73478 1 9.48043 1.10536 9.29289 1.29289L3.29289 7.29289C3.10536 7.48043 3 7.73478 3 8V20C3 21.6569 4.34315 23 6 23H7C7.55228 23 8 22.5523 8 22C8 21.4477 7.55228 21 7 21H6C5.44772 21 5 20.5523 5 20V9H10C10.5523 9 11 8.55228 11 8V3H18C18.5523 3 19 3.44772 19 4V7C19 7.55228 19.4477 8 20 8C20.5523 8 21 7.55228 21 7V4C21 2.34315 19.6569 1 18 1H10ZM9 7H6.41421L9 4.41421V7ZM12.5 24",
    "fill-rule": "evenodd"
  }, var20 = {
    stroke: "none"
  }, var21 = {
    d: "M17 15V18M17 21V18M17 18H14M17 18H20",
    stroke: "",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2"
  }, var22 = {
    fill: "none",
    height: "120%",
    viewBox: "00 0 24 24",
    width: "120%",
    x: "-4",
    xmlns: "http://www.w3.org/2000/svg",
    y: "-4"
  }, var23 = {
    fill: "none",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, var24 = {
    "class": "avplayer-ui-url-open"
  }, var25 = {
    "class": "avplayer-ui-folder-list",
    role: "list"
  }, var26 = {
    "class": "avplayer-ui-folder-list-container"
  }, var27 = {
    type: "text/css"
  }, var28 = {
    "class": "avplayer-ui-folder"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              children: function () {
                var children = [];
                lookupProp(
                  stack,
                  stack.length - 1,
                  "canOpenFolder"
                ).value ? children.push(
                  {
                    children: function () {
                      var children = [];
                      children.push(
                        {
                          children: [
                            {
                              children: [
                                {
                                  context: instance,
                                  isPure: var3,
                                  isStatic: var3,
                                  isSvg: var3,
                                  nativeAttrs: var5,
                                  operator: elementVNodeOperator,
                                  tag: "path",
                                  type: 3
                                }
                              ],
                              context: instance,
                              isPure: var3,
                              isStatic: var3,
                              isSvg: var3,
                              nativeAttrs: var6,
                              operator: elementVNodeOperator,
                              tag: "svg",
                              type: 3
                            }
                          ],
                          context: instance,
                          isPure: var3,
                          isStatic: var3,
                          nativeAttrs: var7,
                          operator: elementVNodeOperator,
                          tag: "div",
                          type: 3
                        }
                      );
                      children.push(
                        {
                          context: instance,
                          nativeAttrs: var8,
                          operator: elementVNodeOperator,
                          tag: "div",
                          text: toString(
                            lookupKeypath(
                              stack,
                              stack.length - 1,
                              "language.FOLDER_OPEN_DIR",
                              [
                                "language",
                                "FOLDER_OPEN_DIR"
                              ],
                              var3
                            ).value
                          ),
                          type: 3
                        }
                      );
                      return children.length ? children : var1
                    }(),
                    context: instance,
                    events: {
                      click: renderEventMethod(
                        "click",
                        "openDir()",
                        "click",
                        "",
                        "openDir"
                      )
                    },
                    nativeAttrs: var9,
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                ) : children.push(
                  {
                    isPure: var3,
                    operator: commentVNodeOperator,
                    text: "",
                    type: 2
                  }
                );
                children.push(
                  function (vnode) {
                    lookupProp(
                      stack,
                      stack.length - 1,
                      "canUseFilePicker"
                    ).value ? appendVNodeProperty(
                      vnode,
                      "events",
                      "click",
                      renderEventMethod(
                        "click",
                        "openFile()",
                        "click",
                        "",
                        "openFile"
                      )
                    ) : appendVNodeProperty(
                      vnode,
                      "nativeAttrs",
                      "for",
                      "avplayer-file-open-input"
                    );
                    return vnode
                  }(
                    {
                      children: function () {
                        var children = [];
                        children.push(
                          {
                            children: [
                              {
                                children: [
                                  {
                                    context: instance,
                                    isPure: var3,
                                    isStatic: var3,
                                    isSvg: var3,
                                    nativeAttrs: var10,
                                    operator: elementVNodeOperator,
                                    tag: "g",
                                    type: 3
                                  },
                                  {
                                    context: instance,
                                    isPure: var3,
                                    isStatic: var3,
                                    isSvg: var3,
                                    nativeAttrs: var11,
                                    operator: elementVNodeOperator,
                                    tag: "g",
                                    type: 3
                                  },
                                  {
                                    children: [
                                      {
                                        isPure: var3,
                                        operator: textVNodeOperator,
                                        text: " ",
                                        type: 1
                                      },
                                      {
                                        context: instance,
                                        isPure: var3,
                                        isStatic: var3,
                                        isSvg: var3,
                                        nativeAttrs: var12,
                                        operator: elementVNodeOperator,
                                        tag: "path",
                                        type: 3
                                      },
                                      {
                                        isPure: var3,
                                        operator: textVNodeOperator,
                                        text: " ",
                                        type: 1
                                      }
                                    ],
                                    context: instance,
                                    isPure: var3,
                                    isStatic: var3,
                                    isSvg: var3,
                                    operator: elementVNodeOperator,
                                    tag: "g",
                                    type: 3
                                  }
                                ],
                                context: instance,
                                isPure: var3,
                                isStatic: var3,
                                isSvg: var3,
                                nativeAttrs: var13,
                                operator: elementVNodeOperator,
                                tag: "svg",
                                type: 3
                              }
                            ],
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            nativeAttrs: var14,
                            operator: elementVNodeOperator,
                            tag: "div",
                            type: 3
                          }
                        );
                        children.push(
                          {
                            context: instance,
                            nativeAttrs: var8,
                            operator: elementVNodeOperator,
                            tag: "div",
                            text: toString(
                              lookupKeypath(
                                stack,
                                stack.length - 1,
                                "language.FOLDER_OPEN_FILE",
                                [
                                  "language",
                                  "FOLDER_OPEN_FILE"
                                ],
                                var3
                              ).value
                            ),
                            type: 3
                          }
                        );
                        !lookupProp(
                          stack,
                          stack.length - 1,
                          "canUseFilePicker"
                        ).value ? children.push(
                          {
                            context: instance,
                            events: {
                              change: renderEventMethod(
                                "change",
                                "fileChange()",
                                "change",
                                "",
                                "fileChange"
                              )
                            },
                            nativeAttrs: {
                              accept: lookupProp(
                                stack,
                                stack.length - 1,
                                "accept"
                              ).value,
                              id: "avplayer-file-open-input",
                              type: "file"
                            },
                            nativeStyles: var15,
                            operator: elementVNodeOperator,
                            tag: "input",
                            type: 3
                          }
                        ) : children.push(
                          {
                            isPure: var3,
                            operator: commentVNodeOperator,
                            text: "",
                            type: 2
                          }
                        );
                        return children.length ? children : var1
                      }(),
                      context: instance,
                      nativeAttrs: {
                        "class": "avplayer-ui-folder-open-file item"
                      },
                      operator: elementVNodeOperator,
                      tag: "label",
                      type: 3
                    }
                  )
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var16,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              children: function () {
                var children = [];
                children.push(
                  {
                    context: instance,
                    nativeAttrs: {
                      "class": "avplayer-ui-url-open-input",
                      placeholder: lookupKeypath(
                        stack,
                        stack.length - 1,
                        "language.FOLDER_OPEN_URL_PLACEHOLDER",
                        [
                          "language",
                          "FOLDER_OPEN_URL_PLACEHOLDER"
                        ],
                        var3
                      ).value,
                      type: "text"
                    },
                    operator: elementVNodeOperator,
                    ref: "url",
                    tag: "input",
                    type: 3
                  }
                );
                children.push(
                  {
                    children: function () {
                      var children = [];
                      children.push(
                        {
                          context: instance,
                          nativeAttrs: var17,
                          operator: elementVNodeOperator,
                          ref: "live",
                          tag: "input",
                          type: 3
                        }
                      );
                      children.push(
                        {
                          context: instance,
                          operator: elementVNodeOperator,
                          tag: "span",
                          text: toString(
                            lookupKeypath(
                              stack,
                              stack.length - 1,
                              "language.CHECKBOX_LIVE",
                              [
                                "language",
                                "CHECKBOX_LIVE"
                              ],
                              var3
                            ).value
                          ),
                          type: 3
                        }
                      );
                      return children.length ? children : var1
                    }(),
                    context: instance,
                    nativeAttrs: var18,
                    operator: elementVNodeOperator,
                    tag: "label",
                    type: 3
                  }
                );
                children.push(
                  {
                    children: [
                      {
                        children: [
                          {
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            nativeAttrs: var10,
                            operator: elementVNodeOperator,
                            tag: "g",
                            type: 3
                          },
                          {
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            nativeAttrs: var11,
                            operator: elementVNodeOperator,
                            tag: "g",
                            type: 3
                          },
                          {
                            children: [
                              {
                                isPure: var3,
                                operator: textVNodeOperator,
                                text: " ",
                                type: 1
                              },
                              {
                                context: instance,
                                isPure: var3,
                                isStatic: var3,
                                isSvg: var3,
                                nativeAttrs: var19,
                                nativeStyles: var20,
                                operator: elementVNodeOperator,
                                tag: "path",
                                type: 3
                              },
                              {
                                isPure: var3,
                                operator: textVNodeOperator,
                                text: " ",
                                type: 1
                              }
                            ],
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            operator: elementVNodeOperator,
                            tag: "g",
                            type: 3
                          },
                          {
                            children: [
                              {
                                children: [
                                  {
                                    context: instance,
                                    isPure: var3,
                                    isStatic: var3,
                                    isSvg: var3,
                                    nativeAttrs: var21,
                                    operator: elementVNodeOperator,
                                    tag: "path",
                                    type: 3
                                  }
                                ],
                                context: instance,
                                isPure: var3,
                                isStatic: var3,
                                isSvg: var3,
                                operator: elementVNodeOperator,
                                tag: "g",
                                type: 3
                              }
                            ],
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            nativeAttrs: var22,
                            operator: elementVNodeOperator,
                            tag: "svg",
                            type: 3
                          }
                        ],
                        context: instance,
                        isPure: var3,
                        isStatic: var3,
                        isSvg: var3,
                        nativeAttrs: var23,
                        operator: elementVNodeOperator,
                        tag: "svg",
                        type: 3
                      }
                    ],
                    context: instance,
                    events: {
                      click: renderEventMethod(
                        "click",
                        "openUrl()",
                        "click",
                        "",
                        "openUrl"
                      )
                    },
                    nativeAttrs: {
                      "class": "avplayer-ui-folder-icon add hint--top",
                      "data-hint": lookupKeypath(
                        stack,
                        stack.length - 1,
                        "language.BUTTON_ADD",
                        [
                          "language",
                          "BUTTON_ADD"
                        ],
                        var3
                      ).value
                    },
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var24,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              children: function () {
                var children = [];
                children.push(
                  {
                    children: function () {
                      var children = [];
                      renderEach(
                        lookupProp(
                          stack,
                          stack.length - 1,
                          "root"
                        ),
                        function (stack, $scope, $keypath, $length) {
                          children.push(
                            {
                              context: instance,
                              key: setValueHolder(
                                $scope.name,
                                stack[ stack.length - 1 ].getKeypath(
                                  "name"
                                )
                              ).value,
                              operator: componentVNodeOperator,
                              props: {
                                language: lookupProp(
                                  stack,
                                  stack.length - 1,
                                  "language"
                                ).value,
                                node: (
                                  var0 = stack[ stack.length - 1 ],
                                  setValueHolder(
                                    var0.getScope(),
                                    var0.keypath
                                  )
                                ).value
                              },
                              ref: setValueHolder(
                                $scope.id,
                                stack[ stack.length - 1 ].getKeypath(
                                  "id"
                                )
                              ).value,
                              tag: "FolderNode",
                              type: 4
                            }
                          )
                        }
                      );
                      return children.length ? children : var1
                    }(),
                    context: instance,
                    nativeAttrs: var25,
                    operator: elementVNodeOperator,
                    tag: "ul",
                    type: 3
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              events: {
                keydown: renderEventMethod(
                  "keydown",
                  "preventDefault()",
                  "keydown",
                  "",
                  "preventDefault"
                ),
                keyup: renderEventMethod(
                  "keyup",
                  "preventDefault()",
                  "keyup",
                  "",
                  "preventDefault"
                )
              },
              nativeAttrs: var26,
              operator: elementVNodeOperator,
              ref: "scroll",
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              nativeAttrs: {
                "class": "avplayer-ui-folder-tip",
                "data-show": lookupProp(
                  stack,
                  stack.length - 1,
                  "tipShow"
                ).value ? 1 : 0
              },
              nativeStyles: renderStyleStyle(
                "top: " + toString(
                  lookupProp(
                    stack,
                    stack.length - 1,
                    "tipTop"
                  ).value
                ) + "px"
              ),
              operator: elementVNodeOperator,
              tag: "div",
              text: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "tip"
                ).value
              ),
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var27,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        nativeAttrs: var28,
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/folder/Node.hbs":
/*!****************************************************!*\
  !*** ./src/ui/avplayer/components/folder/Node.hbs ***!
  \****************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    d: "m10 17 5-5-5-5v10z"
  }, var6 = {
    viewBox: "0 0 24 24"
  }, var7 = {
    d: "M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"
  }, var8 = {
    "class": "avplayer-ui-folder-icon dir"
  }, var9 = {
    "stroke-width": "0"
  }, var10 = {
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, var11 = {
    "clip-rule": "evenodd",
    d: "M10 1C9.73478 1 9.48043 1.10536 9.29289 1.29289L3.29289 7.29289C3.10536 7.48043 3 7.73478 3 8V20C3 21.6569 4.34315 23 6 23H7C7.55228 23 8 22.5523 8 22C8 21.4477 7.55228 21 7 21H6C5.44772 21 5 20.5523 5 20V9H10C10.5523 9 11 8.55228 11 8V3H18C18.5523 3 19 3.44772 19 4V7C19 7.55228 19.4477 8 20 8C20.5523 8 21 7.55228 21 7V4C21 2.34315 19.6569 1 18 1H10ZM9 7H6.41421L9 4.41421V7ZM12.5 24",
    "fill-rule": "evenodd"
  }, var12 = {
    d: "M255.994,0.006C114.607,0.013,0.012,114.612,0,256c0.012,141.387,114.607,255.986,255.994,255.994 C397.393,511.986,511.992,397.387,512,256C511.992,114.612,397.393,0.013,255.994,0.006z M97.607,97.612 c23.34-23.328,51.761-41.475,83.455-52.725c-15.183,18.375-27.84,41.906-37.757,69.116H82.772 C87.452,108.308,92.396,102.824,97.607,97.612z M65.612,138.003h69.986c-9.008,31.929-14.41,67.834-15.363,105.997H32.327 C34.374,205.196,46.3,169.088,65.612,138.003z M65.612,373.997C46.3,342.912,34.374,306.804,32.327,268h87.991 c0.961,38.124,6.21,74.092,15.206,105.998H65.612z M97.607,414.386c-5.211-5.211-10.156-10.695-14.836-16.39h60.573 c4.28,11.774,9.019,22.944,14.312,33.21c6.954,13.438,14.758,25.468,23.348,35.89C149.332,455.846,120.931,437.699,97.607,414.386z M243.998,479.667c-3.746-0.196-7.469-0.477-11.164-0.86c-5.89-2.64-11.722-6.25-17.5-10.961 c-17.632-14.359-33.976-38.671-46.398-69.85h75.061V479.667z M243.998,373.997h-83.436c-9.477-31.171-15.316-67.311-16.328-105.998 h99.763V373.997z M243.998,244H144.31c1.008-38.71,6.875-74.819,16.359-105.997h83.33V244z M243.998,114.003h-74.951 c3.109-7.79,6.367-15.312,9.934-22.195c10.64-20.625,23.17-36.89,36.354-47.656c5.777-4.71,11.609-8.32,17.5-10.96 c3.695-0.382,7.417-0.664,11.164-0.859V114.003z M446.392,138.003c19.312,31.085,31.234,67.194,33.281,105.997h-87.991 c-0.961-38.124-6.21-74.092-15.21-105.997H446.392z M414.393,97.612c5.211,5.211,10.156,10.696,14.836,16.391h-60.577 c-4.281-11.773-9.023-22.945-14.312-33.21c-6.953-13.437-14.758-25.468-23.347-35.89C362.668,56.16,391.065,74.301,414.393,97.612z M267.998,32.333c3.746,0.195,7.469,0.484,11.16,0.859c5.89,2.649,11.723,6.25,17.504,10.96 c17.636,14.359,33.976,38.671,46.397,69.85h-75.061V32.333z M267.998,138.003h83.436c9.476,31.171,15.32,67.31,16.328,105.997 h-99.764V138.003z M267.998,268h99.685c-1.007,38.71-6.874,74.818-16.359,105.998h-83.326V268z M296.661,467.846 c-5.781,4.711-11.614,8.313-17.504,10.961c-3.691,0.375-7.414,0.664-11.16,0.86v-81.67h74.951 c-3.109,7.789-6.367,15.312-9.933,22.195C322.376,440.816,309.845,457.081,296.661,467.846z M414.393,414.386 c-23.336,23.328-51.764,41.476-83.459,52.725c15.187-18.375,27.835-41.905,37.757-69.115h60.538 C424.548,403.692,419.604,409.176,414.393,414.386z M446.392,373.997h-69.998c9.008-31.929,14.414-67.842,15.367-105.998h87.912 C477.626,306.804,465.704,342.912,446.392,373.997z"
  }, var13 = {
    fill: "none",
    height: "65%",
    viewBox: "00 0 512 512",
    width: "65%",
    x: "8",
    xmlns: "http://www.w3.org/2000/svg",
    y: "8"
  }, var14 = {
    fill: "none",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, var15 = {
    "class": "avplayer-ui-folder-icon url"
  }, var16 = {
    "clip-rule": "evenodd",
    d: "M10 1C9.73478 1 9.48043 1.10536 9.29289 1.29289L3.29289 7.29289C3.10536 7.48043 3 7.73478 3 8V20C3 21.6569 4.34315 23 6 23H7C7.55228 23 8 22.5523 8 22C8 21.4477 7.55228 21 7 21H6C5.44772 21 5 20.5523 5 20V9H10C10.5523 9 11 8.55228 11 8V3H18C18.5523 3 19 3.44772 19 4V7C19 7.55228 19.4477 8 20 8C20.5523 8 21 7.55228 21 7V4C21 2.34315 19.6569 1 18 1H10ZM9 7H6.41421L9 4.41421V7ZM12.5 24C13.8807 24 15 22.8807 15 21.5V12.8673L20 12.153V18.05C19.8384 18.0172 19.6712 18 19.5 18C18.1193 18 17 19.1193 17 20.5C17 21.8807 18.1193 23 19.5 23C20.8807 23 22 21.8807 22 20.5V11C22 10.7101 21.8742 10.4345 21.6552 10.2445C21.4362 10.0546 21.1456 9.96905 20.8586 10.0101L13.8586 11.0101C13.3659 11.0804 13 11.5023 13 12V19.05C12.8384 19.0172 12.6712 19 12.5 19C11.1193 19 10 20.1193 10 21.5C10 22.8807 11.1193 24 12.5 24Z",
    "fill-rule": "evenodd"
  }, var17 = {
    "class": "avplayer-ui-folder-icon music"
  }, var18 = {
    "clip-rule": "evenodd",
    d: "M10 1C9.73478 1 9.48043 1.10536 9.29289 1.29289L3.29289 7.29289C3.10536 7.48043 3 7.73478 3 8V20C3 21.6569 4.34315 23 6 23H8C8.55228 23 9 22.5523 9 22C9 21.4477 8.55228 21 8 21H6C5.44772 21 5 20.5523 5 20V9H10C10.5523 9 11 8.55228 11 8V3H18C18.5523 3 19 3.44772 19 4V7C19 7.55228 19.4477 8 20 8C20.5523 8 21 7.55228 21 7V4C21 2.34315 19.6569 1 18 1H10ZM9 7H6.41421L9 4.41421V7ZM12 17C12 14.2386 14.2386 12 17 12C19.7614 12 22 14.2386 22 17C22 19.7614 19.7614 22 17 22C14.2386 22 12 19.7614 12 17ZM17 10C13.134 10 10 13.134 10 17C10 20.866 13.134 24 17 24C20.866 24 24 20.866 24 17C24 13.134 20.866 10 17 10ZM16.5547 14.1679C16.2478 13.9634 15.8533 13.9443 15.5281 14.1183C15.203 14.2923 15 14.6312 15 15V19C15 19.3688 15.203 19.7077 15.5281 19.8817C15.8533 20.0557 16.2478 20.0366 16.5547 19.8321L19.5547 17.8321C19.8329 17.6466 20 17.3344 20 17C20 16.6656 19.8329 16.3534 19.5547 16.1679L16.5547 14.1679Z",
    "fill-rule": "evenodd"
  }, var19 = {
    "class": "avplayer-ui-folder-icon mov"
  }, var20 = {
    "class": "avplayer-ui-folder-node-name"
  }, var21 = {
    d: "M7 3a2 2 0 0 0-2 2v12a2 2 0 1 0 4 0V5a2 2 0 0 0-2-2zM15 3a2 2 0 0 0-2 2v12a2 2 0 1 0 4 0V5a2 2 0 0 0-2-2z"
  }, var22 = {
    viewBox: "0 0 22 22",
    xmlns: "http://www.w3.org/2000/svg"
  }, var23 = {
    d: "M17.982 9.275L8.06 3.27A2.013 2.013 0 0 0 5 4.994v12.011a2.017 2.017 0 0 0 3.06 1.725l9.922-6.005a2.017 2.017 0 0 0 0-3.45z"
  }, var24 = {
    d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"
  }, var25 = {
    "class": "avplayer-ui-folder-list",
    role: "list"
  }, var26 = {
    "class": "avplayer-ui-folder-list-li",
    role: "listitem"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              children: function () {
                var children = [];
                setValueHolder(
                  (
                    var0 = lookupProp(
                      stack,
                      stack.length - 1,
                      "isFolder",
                      filters && filters.isFolder || globalFilters.isFolder
                    ).value,
                    typeof var0 === "function" ? var0(
                      lookupProp(
                        stack,
                        stack.length - 1,
                        "node"
                      ).value
                    ) : logger.fatal(
                      "[isFolder(node)] is not a function."
                    )
                  )
                ).value ? (
                  children.push(
                    {
                      children: [
                        {
                          children: [
                            {
                              context: instance,
                              isPure: var3,
                              isStatic: var3,
                              isSvg: var3,
                              nativeAttrs: var5,
                              operator: elementVNodeOperator,
                              tag: "path",
                              type: 3
                            }
                          ],
                          context: instance,
                          isPure: var3,
                          isStatic: var3,
                          isSvg: var3,
                          nativeAttrs: var6,
                          operator: elementVNodeOperator,
                          tag: "svg",
                          type: 3
                        }
                      ],
                      context: instance,
                      events: {
                        click: renderEventMethod(
                          "click",
                          "toggle()",
                          "click",
                          "",
                          "toggle"
                        )
                      },
                      nativeAttrs: {
                        "class": "avplayer-ui-folder-expand hint--right",
                        "data-hint": lookupKeypath(
                          stack,
                          stack.length - 1,
                          "node.opened",
                          [
                            "node",
                            "opened"
                          ],
                          var3
                        ).value ? lookupKeypath(
                          stack,
                          stack.length - 1,
                          "language.TIP_FOLD",
                          [
                            "language",
                            "TIP_FOLD"
                          ],
                          var3
                        ).value : lookupKeypath(
                          stack,
                          stack.length - 1,
                          "language.TIP_UNFOLD",
                          [
                            "language",
                            "TIP_UNFOLD"
                          ],
                          var3
                        ).value,
                        "data-open": lookupKeypath(
                          stack,
                          stack.length - 1,
                          "node.opened",
                          [
                            "node",
                            "opened"
                          ],
                          var3
                        ).value ? 1 : 0
                      },
                      operator: elementVNodeOperator,
                      tag: "div",
                      type: 3
                    }
                  ),
                  children.push(
                    {
                      children: [
                        {
                          children: [
                            {
                              context: instance,
                              isPure: var3,
                              isStatic: var3,
                              isSvg: var3,
                              nativeAttrs: var7,
                              operator: elementVNodeOperator,
                              tag: "path",
                              type: 3
                            }
                          ],
                          context: instance,
                          isPure: var3,
                          isStatic: var3,
                          isSvg: var3,
                          nativeAttrs: var6,
                          operator: elementVNodeOperator,
                          tag: "svg",
                          type: 3
                        }
                      ],
                      context: instance,
                      isPure: var3,
                      isStatic: var3,
                      nativeAttrs: var8,
                      operator: elementVNodeOperator,
                      tag: "div",
                      type: 3
                    }
                  )
                ) : setValueHolder(
                  (
                    var0 = lookupProp(
                      stack,
                      stack.length - 1,
                      "isUrl",
                      filters && filters.isUrl || globalFilters.isUrl
                    ).value,
                    typeof var0 === "function" ? var0(
                      lookupProp(
                        stack,
                        stack.length - 1,
                        "node"
                      ).value
                    ) : logger.fatal(
                      "[isUrl(node)] is not a function."
                    )
                  )
                ).value ? children.push(
                  {
                    children: [
                      {
                        children: [
                          {
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            nativeAttrs: var9,
                            operator: elementVNodeOperator,
                            tag: "g",
                            type: 3
                          },
                          {
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            nativeAttrs: var10,
                            operator: elementVNodeOperator,
                            tag: "g",
                            type: 3
                          },
                          {
                            children: [
                              {
                                isPure: var3,
                                operator: textVNodeOperator,
                                text: " ",
                                type: 1
                              },
                              {
                                context: instance,
                                isPure: var3,
                                isStatic: var3,
                                isSvg: var3,
                                nativeAttrs: var11,
                                operator: elementVNodeOperator,
                                tag: "path",
                                type: 3
                              },
                              {
                                isPure: var3,
                                operator: textVNodeOperator,
                                text: " ",
                                type: 1
                              }
                            ],
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            operator: elementVNodeOperator,
                            tag: "g",
                            type: 3
                          },
                          {
                            children: [
                              {
                                children: [
                                  {
                                    context: instance,
                                    isPure: var3,
                                    isStatic: var3,
                                    isSvg: var3,
                                    nativeAttrs: var12,
                                    operator: elementVNodeOperator,
                                    tag: "path",
                                    type: 3
                                  },
                                  {
                                    isPure: var3,
                                    operator: textVNodeOperator,
                                    text: " ",
                                    type: 1
                                  }
                                ],
                                context: instance,
                                isPure: var3,
                                isStatic: var3,
                                isSvg: var3,
                                operator: elementVNodeOperator,
                                tag: "g",
                                type: 3
                              }
                            ],
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            nativeAttrs: var13,
                            operator: elementVNodeOperator,
                            tag: "svg",
                            type: 3
                          }
                        ],
                        context: instance,
                        isPure: var3,
                        isStatic: var3,
                        isSvg: var3,
                        nativeAttrs: var14,
                        operator: elementVNodeOperator,
                        tag: "svg",
                        type: 3
                      }
                    ],
                    context: instance,
                    isPure: var3,
                    isStatic: var3,
                    nativeAttrs: var15,
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                ) : setValueHolder(
                  (
                    var0 = lookupProp(
                      stack,
                      stack.length - 1,
                      "isMusic",
                      filters && filters.isMusic || globalFilters.isMusic
                    ).value,
                    typeof var0 === "function" ? var0(
                      lookupProp(
                        stack,
                        stack.length - 1,
                        "node"
                      ).value
                    ) : logger.fatal(
                      "[isMusic(node)] is not a function."
                    )
                  )
                ).value ? children.push(
                  {
                    children: [
                      {
                        children: [
                          {
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            nativeAttrs: var9,
                            operator: elementVNodeOperator,
                            tag: "g",
                            type: 3
                          },
                          {
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            nativeAttrs: var10,
                            operator: elementVNodeOperator,
                            tag: "g",
                            type: 3
                          },
                          {
                            children: [
                              {
                                isPure: var3,
                                operator: textVNodeOperator,
                                text: " ",
                                type: 1
                              },
                              {
                                context: instance,
                                isPure: var3,
                                isStatic: var3,
                                isSvg: var3,
                                nativeAttrs: var16,
                                operator: elementVNodeOperator,
                                tag: "path",
                                type: 3
                              },
                              {
                                isPure: var3,
                                operator: textVNodeOperator,
                                text: " ",
                                type: 1
                              }
                            ],
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            operator: elementVNodeOperator,
                            tag: "g",
                            type: 3
                          }
                        ],
                        context: instance,
                        isPure: var3,
                        isStatic: var3,
                        isSvg: var3,
                        nativeAttrs: var14,
                        operator: elementVNodeOperator,
                        tag: "svg",
                        type: 3
                      }
                    ],
                    context: instance,
                    isPure: var3,
                    isStatic: var3,
                    nativeAttrs: var17,
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                ) : children.push(
                  {
                    children: [
                      {
                        children: [
                          {
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            nativeAttrs: var9,
                            operator: elementVNodeOperator,
                            tag: "g",
                            type: 3
                          },
                          {
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            nativeAttrs: var10,
                            operator: elementVNodeOperator,
                            tag: "g",
                            type: 3
                          },
                          {
                            children: [
                              {
                                isPure: var3,
                                operator: textVNodeOperator,
                                text: " ",
                                type: 1
                              },
                              {
                                context: instance,
                                isPure: var3,
                                isStatic: var3,
                                isSvg: var3,
                                nativeAttrs: var18,
                                operator: elementVNodeOperator,
                                tag: "path",
                                type: 3
                              },
                              {
                                isPure: var3,
                                operator: textVNodeOperator,
                                text: " ",
                                type: 1
                              }
                            ],
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            operator: elementVNodeOperator,
                            tag: "g",
                            type: 3
                          }
                        ],
                        context: instance,
                        isPure: var3,
                        isStatic: var3,
                        isSvg: var3,
                        nativeAttrs: var14,
                        operator: elementVNodeOperator,
                        tag: "svg",
                        type: 3
                      }
                    ],
                    context: instance,
                    isPure: var3,
                    isStatic: var3,
                    nativeAttrs: var19,
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                );
                children.push(
                  {
                    context: instance,
                    events: {
                      mouseenter: renderEventMethod(
                        "mouseenter",
                        "mouseenter()",
                        "mouseenter",
                        "",
                        "mouseenter"
                      ),
                      mouseleave: renderEventMethod(
                        "mouseleave",
                        "mouseleave()",
                        "mouseleave",
                        "",
                        "mouseleave"
                      )
                    },
                    nativeAttrs: var20,
                    operator: elementVNodeOperator,
                    ref: "name",
                    tag: "div",
                    text: toString(
                      lookupKeypath(
                        stack,
                        stack.length - 1,
                        "node.name",
                        [
                          "node",
                          "name"
                        ],
                        var3
                      ).value
                    ),
                    type: 3
                  }
                );
                !setValueHolder(
                  (
                    var0 = lookupProp(
                      stack,
                      stack.length - 1,
                      "isFolder",
                      filters && filters.isFolder || globalFilters.isFolder
                    ).value,
                    typeof var0 === "function" ? var0(
                      lookupProp(
                        stack,
                        stack.length - 1,
                        "node"
                      ).value
                    ) : logger.fatal(
                      "[isFolder(node)] is not a function."
                    )
                  )
                ).value ? children.push(
                  {
                    children: function () {
                      var children = [];
                      lookupKeypath(
                        stack,
                        stack.length - 1,
                        "node.played",
                        [
                          "node",
                          "played"
                        ],
                        var3
                      ).value && !lookupKeypath(
                        stack,
                        stack.length - 1,
                        "node.paused",
                        [
                          "node",
                          "paused"
                        ],
                        var3
                      ).value ? children.push(
                        {
                          children: [
                            {
                              context: instance,
                              isPure: var3,
                              isStatic: var3,
                              isSvg: var3,
                              nativeAttrs: var21,
                              operator: elementVNodeOperator,
                              tag: "path",
                              type: 3
                            }
                          ],
                          context: instance,
                          isPure: var3,
                          isStatic: var3,
                          isSvg: var3,
                          nativeAttrs: var22,
                          operator: elementVNodeOperator,
                          tag: "svg",
                          type: 3
                        }
                      ) : children.push(
                        {
                          children: [
                            {
                              context: instance,
                              isPure: var3,
                              isStatic: var3,
                              isSvg: var3,
                              nativeAttrs: var23,
                              operator: elementVNodeOperator,
                              tag: "path",
                              type: 3
                            }
                          ],
                          context: instance,
                          isPure: var3,
                          isStatic: var3,
                          isSvg: var3,
                          nativeAttrs: var22,
                          operator: elementVNodeOperator,
                          tag: "svg",
                          type: 3
                        }
                      );
                      return children.length ? children : var1
                    }(),
                    context: instance,
                    events: {
                      click: renderEventMethod(
                        "click",
                        "play()",
                        "click",
                        "",
                        "play"
                      )
                    },
                    nativeAttrs: {
                      "class": "avplayer-ui-folder-icon play hint--top",
                      "data-hint": !lookupKeypath(
                        stack,
                        stack.length - 1,
                        "node.played",
                        [
                          "node",
                          "played"
                        ],
                        var3
                      ).value || lookupKeypath(
                        stack,
                        stack.length - 1,
                        "node.paused",
                        [
                          "node",
                          "paused"
                        ],
                        var3
                      ).value ? lookupKeypath(
                        stack,
                        stack.length - 1,
                        "language.TIP_PLAY",
                        [
                          "language",
                          "TIP_PLAY"
                        ],
                        var3
                      ).value : lookupKeypath(
                        stack,
                        stack.length - 1,
                        "language.TIP_PAUSE",
                        [
                          "language",
                          "TIP_PAUSE"
                        ],
                        var3
                      ).value
                    },
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                ) : children.push(
                  {
                    isPure: var3,
                    operator: commentVNodeOperator,
                    text: "",
                    type: 2
                  }
                );
                !lookupKeypath(
                  stack,
                  stack.length - 1,
                  "node.depth",
                  [
                    "node",
                    "depth"
                  ],
                  var3
                ).value ? children.push(
                  {
                    children: [
                      {
                        children: [
                          {
                            context: instance,
                            isPure: var3,
                            isStatic: var3,
                            isSvg: var3,
                            nativeAttrs: var24,
                            operator: elementVNodeOperator,
                            tag: "path",
                            type: 3
                          }
                        ],
                        context: instance,
                        isPure: var3,
                        isStatic: var3,
                        isSvg: var3,
                        nativeAttrs: var6,
                        operator: elementVNodeOperator,
                        tag: "svg",
                        type: 3
                      }
                    ],
                    context: instance,
                    events: {
                      click: renderEventMethod(
                        "click",
                        "delete()",
                        "click",
                        "",
                        "delete"
                      )
                    },
                    nativeAttrs: {
                      "class": "avplayer-ui-folder-icon delete hint--top",
                      "data-hint": lookupKeypath(
                        stack,
                        stack.length - 1,
                        "language.TIP_DELETE",
                        [
                          "language",
                          "TIP_DELETE"
                        ],
                        var3
                      ).value
                    },
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                ) : children.push(
                  {
                    isPure: var3,
                    operator: commentVNodeOperator,
                    text: "",
                    type: 2
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: {
                "class": "avplayer-ui-folder-node " + (lookupKeypath(
                  stack,
                  stack.length - 1,
                  "node.played",
                  [
                    "node",
                    "played"
                  ],
                  var3
                ).value ? "active" : "")
              },
              nativeStyles: renderStyleStyle(
                "padding-inline-start: " + toString(
                  setValueHolder(
                    (
                      var0 = lookupProp(
                        stack,
                        stack.length - 1,
                        "paddingStart",
                        filters && filters.paddingStart || globalFilters.paddingStart
                      ).value,
                      typeof var0 === "function" ? var0(
                        lookupProp(
                          stack,
                          stack.length - 1,
                          "node"
                        ).value
                      ) : logger.fatal(
                        "[paddingStart(node)] is not a function."
                      )
                    )
                  ).value
                ) + "px;"
              ),
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          setValueHolder(
            (
              var0 = lookupProp(
                stack,
                stack.length - 1,
                "isFolder",
                filters && filters.isFolder || globalFilters.isFolder
              ).value,
              typeof var0 === "function" ? var0(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "node"
                ).value
              ) : logger.fatal(
                "[isFolder(node)] is not a function."
              )
            )
          ).value && lookupKeypath(
            stack,
            stack.length - 1,
            "node.opened",
            [
              "node",
              "opened"
            ],
            var3
          ).value ? children.push(
            {
              children: function () {
                var children = [];
                renderEach(
                  lookupKeypath(
                    stack,
                    stack.length - 1,
                    "node.children",
                    [
                      "node",
                      "children"
                    ],
                    var3
                  ),
                  function (stack, $scope, $keypath, $length) {
                    children.push(
                      {
                        context: instance,
                        key: setValueHolder(
                          $scope.name,
                          stack[ stack.length - 1 ].getKeypath(
                            "name"
                          )
                        ).value,
                        operator: componentVNodeOperator,
                        props: {
                          language: lookupProp(
                            stack,
                            stack.length - 1,
                            "language"
                          ).value,
                          node: (
                            var0 = stack[ stack.length - 1 ],
                            setValueHolder(
                              var0.getScope(),
                              var0.keypath
                            )
                          ).value
                        },
                        ref: setValueHolder(
                          $scope.id,
                          stack[ stack.length - 1 ].getKeypath(
                            "id"
                          )
                        ).value,
                        tag: "FolderNode",
                        type: 4
                      }
                    )
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var25,
              operator: elementVNodeOperator,
              tag: "ul",
              type: 3
            }
          ) : children.push(
            {
              isPure: var3,
              operator: commentVNodeOperator,
              text: "",
              type: 2
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        nativeAttrs: var26,
        operator: elementVNodeOperator,
        tag: "li",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/info/Info.hbs":
/*!**************************************************!*\
  !*** ./src/ui/avplayer/components/info/Info.hbs ***!
  \**************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    "class": "avplayer-ui-info-title"
  }, var6 = {
    d: "m8 6.939 3.182-3.182a.75.75 0 1 1 1.061 1.061L9.061 8l3.182 3.182a.75.75 0 1 1-1.061 1.061L8 9.061l-3.182 3.182a.75.75 0 1 1-1.061-1.061L6.939 8 3.757 4.818a.75.75 0 1 1 1.061-1.061L8 6.939z"
  }, var7 = {
    "data-pointer": "none",
    space: "preserve",
    viewBox: "0 0 16 16",
    xmlns: "http://www.w3.org/2000/svg"
  }, var8 = {
    "class": "avplayer-ui-info-close"
  }, var9 = {
    "class": "avplayer-ui-info-format"
  }, var10 = {
    "class": "avplayer-ui-info-line-title"
  }, var11 = {
    "class": "avplayer-ui-info-line-value"
  }, var12 = {
    "class": "avplayer-ui-info-line"
  }, var13 = {
    "class": "avplayer-ui-info-panel"
  }, var14 = {
    type: "text/css"
  }, var15 = {
    "class": "avplayer-ui-info"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              context: instance,
              nativeAttrs: var5,
              operator: elementVNodeOperator,
              tag: "div",
              text: toString(
                lookupKeypath(
                  stack,
                  stack.length - 1,
                  "language.INFO_TITLE",
                  [
                    "language",
                    "INFO_TITLE"
                  ],
                  var3
                ).value
              ),
              type: 3
            }
          );
          children.push(
            {
              children: [
                {
                  children: [
                    {
                      context: instance,
                      isPure: var3,
                      isStatic: var3,
                      isSvg: var3,
                      nativeAttrs: var6,
                      operator: elementVNodeOperator,
                      tag: "path",
                      type: 3
                    }
                  ],
                  context: instance,
                  isPure: var3,
                  isStatic: var3,
                  isSvg: var3,
                  nativeAttrs: var7,
                  operator: elementVNodeOperator,
                  tag: "svg",
                  type: 3
                }
              ],
              context: instance,
              events: {
                click: renderEventMethod(
                  "click",
                  "close()",
                  "click",
                  "",
                  "close"
                )
              },
              nativeAttrs: var8,
              operator: elementVNodeOperator,
              tag: "span",
              type: 3
            }
          );
          children.push(
            {
              children: function () {
                var children = [];
                children.push(
                  {
                    children: function () {
                      var children = [];
                      children.push(
                        {
                          context: instance,
                          html: toString(
                            lookupProp(
                              stack,
                              stack.length - 1,
                              "info"
                            ).value
                          ),
                          operator: elementVNodeOperator,
                          tag: "span",
                          type: 3
                        }
                      );
                      return children.length ? children : var1
                    }(),
                    context: instance,
                    nativeAttrs: var9,
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                );
                renderEach(
                  lookupProp(
                    stack,
                    stack.length - 1,
                    "list"
                  ),
                  function (stack, $scope, $keypath, $length) {
                    children.push(
                      {
                        children: function () {
                          var children = [];
                          children.push(
                            {
                              context: instance,
                              nativeAttrs: var10,
                              operator: elementVNodeOperator,
                              tag: "span",
                              text: toString(
                                lookupProp(
                                  stack,
                                  stack.length - 1,
                                  "key"
                                ).value
                              ),
                              type: 3
                            }
                          );
                          children.push(
                            {
                              context: instance,
                              nativeAttrs: var11,
                              operator: elementVNodeOperator,
                              tag: "span",
                              text: toString(
                                lookupProp(
                                  stack,
                                  stack.length - 1,
                                  "value"
                                ).value
                              ),
                              type: 3
                            }
                          );
                          return children.length ? children : var1
                        }(),
                        context: instance,
                        nativeAttrs: var12,
                        operator: elementVNodeOperator,
                        tag: "div",
                        type: 3
                      }
                    )
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              events: {
                keydown: renderEventMethod(
                  "keydown",
                  "preventDefault()",
                  "keydown",
                  "",
                  "preventDefault"
                ),
                keyup: renderEventMethod(
                  "keyup",
                  "preventDefault()",
                  "keyup",
                  "",
                  "preventDefault"
                )
              },
              nativeAttrs: var13,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var14,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        nativeAttrs: var15,
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/loadingTip/LoadingTip.hbs":
/*!**************************************************************!*\
  !*** ./src/ui/avplayer/components/loadingTip/LoadingTip.hbs ***!
  \**************************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    "class": "avplayer-ui-loading-message-list"
  }, var6 = {
    type: "text/css"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              children: function () {
                var children = [];
                renderEach(
                  lookupProp(
                    stack,
                    stack.length - 1,
                    "message"
                  ),
                  function (stack, $scope, $keypath, $length, index) {
                    children.push(
                      {
                        context: instance,
                        key: (
                          var0 = stack[ stack.length - 1 ],
                          setValueHolder(
                            var0.getScope(),
                            var0.keypath
                          )
                        ).value,
                        nativeAttrs: {
                          "class": "avplayer-ui-loading-message",
                          "data-last": (lookupKeypath(
                            stack,
                            stack.length - 1,
                            "message.length",
                            [
                              "message",
                              "length"
                            ],
                            var3
                          ).value - 1) === index ? 1 : 0
                        },
                        nativeStyles: renderStyleStyle(
                          "bottom: " + toString(
                            ((lookupKeypath(
                              stack,
                              stack.length - 1,
                              "message.length",
                              [
                                "message",
                                "length"
                              ],
                              var3
                            ).value - 1) - index) * 30
                          ) + "px;"
                        ),
                        operator: elementVNodeOperator,
                        tag: "div",
                        text: toString(
                          (
                            var0 = stack[ stack.length - 1 ],
                            setValueHolder(
                              var0.getScope(),
                              var0.keypath
                            )
                          ).value
                        ),
                        type: 3
                      }
                    )
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var5,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var6,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        nativeAttrs: {
          "class": "avplayer-ui-loading-tip",
          "data-show": lookupProp(
            stack,
            stack.length - 1,
            "showMessage"
          ).value ? 1 : 0
        },
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/loading/Loading.hbs":
/*!********************************************************!*\
  !*** ./src/ui/avplayer/components/loading/Loading.hbs ***!
  \********************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    cx: "50",
    cy: "50",
    fill: "none",
    r: "20"
  }, var6 = {
    "class": "avplayer-ui-circular",
    viewBox: "25 25 50 50"
  }, var7 = {
    "class": "avplayer-ui-loading-spinner"
  }, var8 = {
    type: "text/css"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              children: [
                {
                  children: [
                    {
                      context: instance,
                      isPure: var3,
                      isStatic: var3,
                      isSvg: var3,
                      nativeAttrs: var5,
                      operator: elementVNodeOperator,
                      tag: "circle",
                      type: 3
                    }
                  ],
                  context: instance,
                  isPure: var3,
                  isStatic: var3,
                  isSvg: var3,
                  nativeAttrs: var6,
                  operator: elementVNodeOperator,
                  tag: "svg",
                  type: 3
                }
              ],
              context: instance,
              isPure: var3,
              isStatic: var3,
              nativeAttrs: var7,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var8,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        nativeAttrs: {
          "class": "avplayer-ui-loading-mask",
          "data-loading": lookupProp(
            stack,
            stack.length - 1,
            "loading"
          ).value ? 1 : 0
        },
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/pcmVisualization/PcmVisualization.hbs":
/*!**************************************************************************!*\
  !*** ./src/ui/avplayer/components/pcmVisualization/PcmVisualization.hbs ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    type: "text/css"
  }, var6 = {
    "class": "avplayer-ui-pcm-visualization"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              context: instance,
              operator: elementVNodeOperator,
              ref: "canvas",
              tag: "canvas",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var5,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        nativeAttrs: var6,
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/progress/Progress.hbs":
/*!**********************************************************!*\
  !*** ./src/ui/avplayer/components/progress/Progress.hbs ***!
  \**********************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    "class": "avplayer-ui-progress-hover"
  }, var6 = {
    "class": "avplayer-ui-progress-loaded"
  }, var7 = {
    "class": "avplayer-ui-progress-played"
  }, var8 = {
    "class": "avplayer-ui-progress-chapter-item"
  }, var9 = {
    "class": "avplayer-ui-progress-chapter"
  }, var10 = {
    "class": "avplayer-ui-icon-indicator"
  }, var11 = {
    "class": "avplayer-ui-progress-indicator"
  }, var12 = {
    "class": "avplayer-ui-progress-tip"
  }, var13 = {
    "class": "avplayer-ui-progress-inner"
  }, var14 = {
    "class": "libmedia-ui-progress-thumb"
  }, var15 = {
    type: "text/css"
  }, var16 = {
    "class": "avplayer-ui-progress"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              children: function () {
                var children = [];
                children.push(
                  {
                    context: instance,
                    nativeAttrs: var5,
                    nativeStyles: renderStyleStyle(
                      "width: " + toString(
                        lookupProp(
                          stack,
                          stack.length - 1,
                          "hoverWidth"
                        ).value
                      ) + "%;"
                    ),
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                );
                children.push(
                  {
                    context: instance,
                    nativeAttrs: var6,
                    nativeStyles: renderStyleStyle(
                      "width: " + toString(
                        lookupProp(
                          stack,
                          stack.length - 1,
                          "loadedWidth"
                        ).value
                      ) + "%;"
                    ),
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                );
                children.push(
                  {
                    context: instance,
                    nativeAttrs: var7,
                    nativeStyles: renderStyleStyle(
                      "width: " + toString(
                        lookupProp(
                          stack,
                          stack.length - 1,
                          "playedWidth"
                        ).value
                      ) + "%;"
                    ),
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                );
                children.push(
                  {
                    children: function () {
                      var children = [];
                      renderEach(
                        lookupProp(
                          stack,
                          stack.length - 1,
                          "chapters"
                        ),
                        function (stack, $scope, $keypath, $length) {
                          children.push(
                            {
                              context: instance,
                              events: {
                                click: renderEventMethod(
                                  "click",
                                  "chapterClick(this)",
                                  "click",
                                  "",
                                  "chapterClick",
                                  {
                                    execute: function ($event, $data) {
                                      return [
                                        (
                                          var0 = stack[ stack.length - 1 ],
                                          setValueHolder(
                                            var0.getScope(),
                                            var0.keypath
                                          )
                                        ).value
                                      ]
                                    }
                                  }
                                ),
                                mouseenter: renderEventMethod(
                                  "mouseenter",
                                  "chapterEnter(this)",
                                  "mouseenter",
                                  "",
                                  "chapterEnter",
                                  {
                                    execute: function ($event, $data) {
                                      return [
                                        (
                                          var0 = stack[ stack.length - 1 ],
                                          setValueHolder(
                                            var0.getScope(),
                                            var0.keypath
                                          )
                                        ).value
                                      ]
                                    }
                                  }
                                ),
                                mouseleave: renderEventMethod(
                                  "mouseleave",
                                  "chapterLeave(this)",
                                  "mouseleave",
                                  "",
                                  "chapterLeave",
                                  {
                                    execute: function ($event, $data) {
                                      return [
                                        (
                                          var0 = stack[ stack.length - 1 ],
                                          setValueHolder(
                                            var0.getScope(),
                                            var0.keypath
                                          )
                                        ).value
                                      ]
                                    }
                                  }
                                )
                              },
                              key: setValueHolder(
                                $scope.text,
                                stack[ stack.length - 1 ].getKeypath(
                                  "text"
                                )
                              ).value,
                              nativeAttrs: var8,
                              nativeStyles: renderStyleStyle(
                                "left: " + toString(
                                  lookupProp(
                                    stack,
                                    stack.length - 1,
                                    "left"
                                  ).value
                                ) + "%;"
                              ),
                              operator: elementVNodeOperator,
                              tag: "span",
                              type: 3
                            }
                          )
                        }
                      );
                      return children.length ? children : var1
                    }(),
                    context: instance,
                    nativeAttrs: var9,
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                );
                lookupProp(
                  stack,
                  stack.length - 1,
                  "indicatorUrl"
                ).value ? children.push(
                  {
                    children: function () {
                      var children = [];
                      children.push(
                        {
                          children: function () {
                            var children = [];
                            children.push(
                              {
                                context: instance,
                                nativeAttrs: {
                                  draggable: "false",
                                  height: lookupProp(
                                    stack,
                                    stack.length - 1,
                                    "indicatorSize"
                                  ).value,
                                  src: lookupProp(
                                    stack,
                                    stack.length - 1,
                                    "indicatorUrl"
                                  ).value,
                                  width: lookupProp(
                                    stack,
                                    stack.length - 1,
                                    "indicatorSize"
                                  ).value
                                },
                                operator: elementVNodeOperator,
                                tag: "img",
                                type: 3
                              }
                            );
                            return children.length ? children : var1
                          }(),
                          context: instance,
                          nativeAttrs: var10,
                          operator: elementVNodeOperator,
                          tag: "i",
                          type: 3
                        }
                      );
                      return children.length ? children : var1
                    }(),
                    context: instance,
                    events: {
                      mousedown: renderEventMethod(
                        "mousedown",
                        "indicatorDown()",
                        "mousedown",
                        "",
                        "indicatorDown"
                      )
                    },
                    nativeAttrs: var11,
                    nativeStyles: renderStyleStyle(
                      "left: " + toString(
                        lookupProp(
                          stack,
                          stack.length - 1,
                          "playedWidth"
                        ).value
                      ) + "%;"
                    ),
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                ) : children.push(
                  {
                    isPure: var3,
                    operator: commentVNodeOperator,
                    text: "",
                    type: 2
                  }
                );
                children.push(
                  {
                    context: instance,
                    nativeAttrs: var12,
                    nativeStyles: renderStyleStyle(
                      "left: " + toString(
                        lookupProp(
                          stack,
                          stack.length - 1,
                          "hoverWidth"
                        ).value
                      ) + "%; display: " + toString(
                        lookupProp(
                          stack,
                          stack.length - 1,
                          "showTip"
                        ).value ? "block" : "none"
                      ) + ";"
                    ),
                    operator: elementVNodeOperator,
                    tag: "div",
                    text: toString(
                      lookupProp(
                        stack,
                        stack.length - 1,
                        "hoverChapter"
                      ).value || setValueHolder(
                        (
                          var0 = lookupProp(
                            stack,
                            stack.length - 1,
                            "formatTime",
                            filters && filters.formatTime || globalFilters.formatTime
                          ).value,
                          typeof var0 === "function" ? var0(
                            lookupProp(
                              stack,
                              stack.length - 1,
                              "hoverTime"
                            ).value
                          ) : logger.fatal(
                            "[formatTime(hoverTime)] is not a function."
                          )
                        )
                      ).value
                    ),
                    type: 3
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              events: {
                click: renderEventMethod(
                  "click",
                  "hoverClick()",
                  "click",
                  "",
                  "hoverClick"
                ),
                mouseenter: renderEventMethod(
                  "mouseenter",
                  "hoverEnter()",
                  "mouseenter",
                  "",
                  "hoverEnter"
                ),
                mouseleave: renderEventMethod(
                  "mouseleave",
                  "hoverLeave()",
                  "mouseleave",
                  "",
                  "hoverLeave"
                ),
                mousemove: renderEventMethod(
                  "mousemove",
                  "hoverMove()",
                  "mousemove",
                  "",
                  "hoverMove"
                )
              },
              nativeAttrs: var13,
              operator: elementVNodeOperator,
              ref: "slider",
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              isPure: var3,
              isStatic: var3,
              nativeAttrs: var14,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var15,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        nativeAttrs: var16,
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/components/settings/Settings.hbs":
/*!**********************************************************!*\
  !*** ./src/ui/avplayer/components/settings/Settings.hbs ***!
  \**********************************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    "class": "avplayer-ui-settings-title"
  }, var6 = {
    d: "m8 6.939 3.182-3.182a.75.75 0 1 1 1.061 1.061L9.061 8l3.182 3.182a.75.75 0 1 1-1.061 1.061L8 9.061l-3.182 3.182a.75.75 0 1 1-1.061-1.061L6.939 8 3.757 4.818a.75.75 0 1 1 1.061-1.061L8 6.939z"
  }, var7 = {
    "data-pointer": "none",
    space: "preserve",
    viewBox: "0 0 16 16",
    xmlns: "http://www.w3.org/2000/svg"
  }, var8 = {
    "class": "avplayer-ui-settings-close"
  }, var9 = "tab", var10 = {
    "class": "avplayer-ui-settings-tabs"
  }, var11 = {
    "class": "avplayer-ui-settings-context"
  }, var12 = {
    "class": "avplayer-ui-settings-panel"
  }, var13 = {
    type: "text/css"
  }, var14 = {
    "class": "avplayer-ui-settings"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              context: instance,
              nativeAttrs: var5,
              operator: elementVNodeOperator,
              tag: "div",
              text: toString(
                lookupKeypath(
                  stack,
                  stack.length - 1,
                  "language.SETTINGS_TITLE",
                  [
                    "language",
                    "SETTINGS_TITLE"
                  ],
                  var3
                ).value
              ),
              type: 3
            }
          );
          children.push(
            {
              children: [
                {
                  children: [
                    {
                      context: instance,
                      isPure: var3,
                      isStatic: var3,
                      isSvg: var3,
                      nativeAttrs: var6,
                      operator: elementVNodeOperator,
                      tag: "path",
                      type: 3
                    }
                  ],
                  context: instance,
                  isPure: var3,
                  isStatic: var3,
                  isSvg: var3,
                  nativeAttrs: var7,
                  operator: elementVNodeOperator,
                  tag: "svg",
                  type: 3
                }
              ],
              context: instance,
              events: {
                click: renderEventMethod(
                  "click",
                  "close()",
                  "click",
                  "",
                  "close"
                )
              },
              nativeAttrs: var8,
              operator: elementVNodeOperator,
              tag: "span",
              type: 3
            }
          );
          children.push(
            {
              children: function () {
                var children = [];
                children.push(
                  {
                    children: function () {
                      var children = [];
                      renderEach(
                        lookupProp(
                          stack,
                          stack.length - 1,
                          "list"
                        ),
                        function (stack, $scope, $keypath, $length) {
                          children.push(
                            {
                              context: instance,
                              events: {
                                click: renderEventMethod(
                                  "click",
                                  "set(\'tab\', id)",
                                  "click",
                                  "",
                                  "set",
                                  {
                                    execute: function ($event, $data) {
                                      return [
                                        var9,
                                        lookupProp(
                                          stack,
                                          stack.length - 1,
                                          "id"
                                        ).value
                                      ]
                                    }
                                  }
                                )
                              },
                              nativeAttrs: {
                                "class": "avplayer-ui-settings-tab " + (lookupProp(
                                  stack,
                                  stack.length - 1,
                                  "id"
                                ).value === lookupProp(
                                  stack,
                                  stack.length - 1,
                                  "tab"
                                ).value ? "active" : "")
                              },
                              operator: elementVNodeOperator,
                              tag: "div",
                              text: toString(
                                lookupProp(
                                  stack,
                                  stack.length - 1,
                                  "name"
                                ).value
                              ),
                              type: 3
                            }
                          )
                        }
                      );
                      return children.length ? children : var1
                    }(),
                    context: instance,
                    nativeAttrs: var10,
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                );
                children.push(
                  {
                    context: instance,
                    isPure: var3,
                    isStatic: var3,
                    nativeAttrs: var11,
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var12,
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              html: toString(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "style"
                ).value
              ),
              nativeAttrs: var13,
              operator: elementVNodeOperator,
              tag: "style",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        nativeAttrs: var14,
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/components/slider/Slider.hbs":
/*!*********************************************!*\
  !*** ./src/ui/components/slider/Slider.hbs ***!
  \*********************************************/
/***/ ((module) => {

module.exports = (function () {
  var var0, var1 = void 0, var2 = null, var3 = !0, var4 = !1, var5 = {
    "class": "libmedia-ui-slider-inner"
  }, var6 = {
    "class": "libmedia-ui-slider-outer"
  }, var7 = {
    "class": "libmedia-ui-slider-thumb"
  };
  return function (renderStyleStyle, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNativeAttributeNumberValue, formatNativeAttributeBooleanValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transition, globalTransitions, stack, $scope, $keypath, children) {
    children.push(
      {
        children: function () {
          var children = [];
          children.push(
            {
              children: function () {
                var children = [];
                children.push(
                  {
                    context: instance,
                    nativeAttrs: var5,
                    nativeStyles: renderStyleExpr(
                      lookupProp(
                        stack,
                        stack.length - 1,
                        "offset"
                      ).value
                    ),
                    operator: elementVNodeOperator,
                    tag: "div",
                    type: 3
                  }
                );
                return children.length ? children : var1
              }(),
              context: instance,
              nativeAttrs: var6,
              operator: elementVNodeOperator,
              ref: "slider",
              tag: "div",
              type: 3
            }
          );
          children.push(
            {
              context: instance,
              events: {
                mousedown: renderEventMethod(
                  "mousedown",
                  "mousedown()",
                  "mousedown",
                  "",
                  "mousedown"
                )
              },
              nativeAttrs: var7,
              nativeStyles: renderStyleExpr(
                lookupProp(
                  stack,
                  stack.length - 1,
                  "offset"
                ).value
              ),
              operator: elementVNodeOperator,
              tag: "div",
              type: 3
            }
          );
          return children.length ? children : var1
        }(),
        context: instance,
        nativeAttrs: {
          "class": "libmedia-ui-slider",
          "data-direction": lookupProp(
            stack,
            stack.length - 1,
            "direction"
          ).value
        },
        operator: elementVNodeOperator,
        tag: "div",
        type: 3
      }
    )
  }
})();

/***/ }),

/***/ "./src/ui/avplayer/AVPlayer.styl":
/*!***************************************!*\
  !*** ./src/ui/avplayer/AVPlayer.styl ***!
  \***************************************/
/***/ ((module) => {

module.exports = `html{--libmedia-ui-theme:#23ade5;--libmedia-ui-font-color:#fff;--libmedia-ui-background-color:#000;--libmedia-ui-text-shadow-color:rgba(0,0,0,0.502);--libmedia-ui-transition-duration:.2s;--libmedia-ui-padding:10px;--libmedia-ui-border-radius:3px;--libmedia-ui-progress-height:6px;--libmedia-ui-progress-color:rgba(255,255,255,0.251);--libmedia-ui-hover-color:rgba(255,255,255,0.251);--libmedia-ui-loaded-color:rgba(255,255,255,0.251);--libmedia-ui-state-size:80px;--libmedia-ui-state-opacity:.8;--libmedia-ui-header-height:40px;--libmedia-ui-bottom-height:100px;--libmedia-ui-bottom-offset:51px;--libmedia-ui-bottom-gap:5px;--libmedia-ui-chapter-width:8px;--libmedia-ui-chapter-color:rgba(255,255,255,0.502);--libmedia-ui-control-height:46px;--libmedia-ui-control-opacity:.75;--libmedia-ui-control-icon-size:28px;--libmedia-ui-control-icon-scale:1.1;--libmedia-ui-volume-height:120px;--libmedia-ui-slider-thumb-size:14px;--libmedia-ui-slider-thickness:2px;--libmedia-ui-lock-size:36px;--libmedia-ui-indicator-scale:0;--libmedia-ui-indicator-size:16px;--libmedia-ui-fullscreen-web-index:9999;--libmedia-ui-settings-icon-size:24px;--libmedia-ui-settings-max-height:300px;--libmedia-ui-selector-max-height:300px;--libmedia-ui-contextmenus-min-width:250px;--libmedia-ui-subtitle-font-size:20px;--libmedia-ui-subtitle-gap:5px;--libmedia-ui-subtitle-bottom:15px;--libmedia-ui-subtitle-border:#000;--libmedia-ui-widget-background:rgba(0,0,0,0.851);--libmedia-ui-widget-hover-background:rgba(255,255,255,0.102);--libmedia-ui-tip-background:rgba(0,0,0,0.702);--libmedia-ui-tip-font-color:#fff;--libmedia-ui-scrollbar-size:4px;--libmedia-ui-scrollbar-background:rgba(255,255,255,0.251);--libmedia-ui-scrollbar-background-hover:rgba(255,255,255,0.502);--libmedia-ui-mini-progress-height:2px;--libmedia-ui-folder-width:300px}[class*="hint--"]{font-style:normal;position:relative}[class*="hint--"]:before,[class*="hint--"]:after{visibility:hidden;opacity:0;z-index:1000000;pointer-events:none;transition:all .3s;position:absolute;transform:translate3d(0,0,0)}[class*="hint--"]:hover:before,[class*="hint--"]:hover:after{visibility:visible;opacity:1;transition-delay:.1s}[class*="hint--"]:before{content:"";z-index:1000001;background:none;border:6px solid rgba(0,0,0,0);position:absolute}[class*="hint--"]:after{color:var(--libmedia-ui-tip-font-color);white-space:nowrap;background:var(--libmedia-ui-tip-background);padding:8px 10px;font-size:12px;line-height:12px}[class*="hint--"][data-hint]:after{content:attr(data-hint)}[data-hint=""]:before,[data-hint=""]:after{display:none !important}.hint--top-left:before,.hint--top-right:before,.hint--top:before{border-top-color:var(--libmedia-ui-tip-background)}.hint--bottom-left:before,.hint--bottom-right:before,.hint--bottom:before{border-bottom-color:var(--libmedia-ui-tip-background)}.hint--left:before{border-left-color:var(--libmedia-ui-tip-background)}.hint--right:before{border-right-color:var(--libmedia-ui-tip-background)}.hint--top:before{margin-bottom:-11px}.hint--top:before,.hint--top:after{bottom:100%;left:50%}.hint--top:before{left:calc(50% - 6px)}.hint--top:after{transform:translateX(-50%)}.hint--top:hover:before{transform:translateY(-8px)}.hint--top:hover:after{transform:translateX(-50%) translateY(-8px)}.hint--bottom:before{margin-top:-11px}.hint--bottom:before,.hint--bottom:after{top:100%;left:50%}.hint--bottom:before{left:calc(50% - 6px)}.hint--bottom:after{transform:translateX(-50%)}.hint--bottom:hover:before{transform:translateY(8px)}.hint--bottom:hover:after{transform:translateX(-50%) translateY(8px)}.hint--right:before{margin-bottom:-6px;margin-left:-11px}.hint--right:after{margin-bottom:-14px}.hint--right:before,.hint--right:after{bottom:50%;left:100%}.hint--right:hover:before,.hint--right:hover:after{transform:translateX(8px)}.hint--left:before{margin-bottom:-6px;margin-right:-11px}.hint--left:after{margin-bottom:-14px}.hint--left:before,.hint--left:after{bottom:50%;right:100%}.hint--left:hover:before,.hint--left:hover:after{transform:translateX(-8px)}.hint--top-left:before{margin-bottom:-11px}.hint--top-left:before,.hint--top-left:after{bottom:100%;left:50%}.hint--top-left:before{left:calc(50% - 6px)}.hint--top-left:after{margin-left:12px;transform:translateX(-100%)}.hint--top-left:hover:before{transform:translateY(-8px)}.hint--top-left:hover:after{transform:translateX(-100%) translateY(-8px)}.hint--top-right:before{margin-bottom:-11px}.hint--top-right:before,.hint--top-right:after{bottom:100%;left:50%}.hint--top-right:before{left:calc(50% - 6px)}.hint--top-right:after{margin-left:-12px;transform:translateX(0)}.hint--top-right:hover:before,.hint--top-right:hover:after{transform:translateY(-8px)}.hint--bottom-left:before{margin-top:-11px}.hint--bottom-left:before,.hint--bottom-left:after{top:100%;left:50%}.hint--bottom-left:before{left:calc(50% - 6px)}.hint--bottom-left:after{margin-left:12px;transform:translateX(-100%)}.hint--bottom-left:hover:before{transform:translateY(8px)}.hint--bottom-left:hover:after{transform:translateX(-100%) translateY(8px)}.hint--bottom-right:before{margin-top:-11px}.hint--bottom-right:before,.hint--bottom-right:after{top:100%;left:50%}.hint--bottom-right:before{left:calc(50% - 6px)}.hint--bottom-right:after{margin-left:-12px;transform:translateX(0)}.hint--bottom-right:hover:before,.hint--bottom-right:hover:after{transform:translateY(8px)}.hint--small:after,.hint--medium:after,.hint--large:after{white-space:normal;word-wrap:break-word;line-height:1.4em}.hint--small:after{width:80px}.hint--medium:after{width:150px}.hint--large:after{width:300px}[class*="hint--"]:after{text-shadow:0 -1px #000;box-shadow:4px 4px 8px rgba(0,0,0,0.302)}.hint--error:after{text-shadow:0 -1px #592726;background-color:#b34e4d}.hint--error.hint--top-left:before,.hint--error.hint--top-right:before,.hint--error.hint--top:before{border-top-color:#b34e4d}.hint--error.hint--bottom-left:before,.hint--error.hint--bottom-right:before,.hint--error.hint--bottom:before{border-bottom-color:#b34e4d}.hint--error.hint--left:before{border-left-color:#b34e4d}.hint--error.hint--right:before{border-right-color:#b34e4d}.hint--warning:after{text-shadow:0 -1px #6c5328;background-color:#c09854}.hint--warning.hint--top-left:before,.hint--warning.hint--top-right:before,.hint--warning.hint--top:before{border-top-color:#c09854}.hint--warning.hint--bottom-left:before,.hint--warning.hint--bottom-right:before,.hint--warning.hint--bottom:before{border-bottom-color:#c09854}.hint--warning.hint--left:before{border-left-color:#c09854}.hint--warning.hint--right:before{border-right-color:#c09854}.hint--info:after{text-shadow:0 -1px #1a3c4d;background-color:#3986ac}.hint--info.hint--top-left:before,.hint--info.hint--top-right:before,.hint--info.hint--top:before{border-top-color:#3986ac}.hint--info.hint--bottom-left:before,.hint--info.hint--bottom-right:before,.hint--info.hint--bottom:before{border-bottom-color:#3986ac}.hint--info.hint--left:before{border-left-color:#3986ac}.hint--info.hint--right:before{border-right-color:#3986ac}.hint--success:after{text-shadow:0 -1px #1a321a;background-color:#458746}.hint--success.hint--top-left:before,.hint--success.hint--top-right:before,.hint--success.hint--top:before{border-top-color:#458746}.hint--success.hint--bottom-left:before,.hint--success.hint--bottom-right:before,.hint--success.hint--bottom:before{border-bottom-color:#458746}.hint--success.hint--left:before{border-left-color:#458746}.hint--success.hint--right:before{border-right-color:#458746}.hint--always:after,.hint--always:before{opacity:1;visibility:visible}.hint--always.hint--top:before{transform:translateY(-8px)}.hint--always.hint--top:after{transform:translateX(-50%) translateY(-8px)}.hint--always.hint--top-left:before{transform:translateY(-8px)}.hint--always.hint--top-left:after{transform:translateX(-100%) translateY(-8px)}.hint--always.hint--top-right:before,.hint--always.hint--top-right:after{transform:translateY(-8px)}.hint--always.hint--bottom:before{transform:translateY(8px)}.hint--always.hint--bottom:after{transform:translateX(-50%) translateY(8px)}.hint--always.hint--bottom-left:before{transform:translateY(8px)}.hint--always.hint--bottom-left:after{transform:translateX(-100%) translateY(8px)}.hint--always.hint--bottom-right:before,.hint--always.hint--bottom-right:after{transform:translateY(8px)}.hint--always.hint--left:before,.hint--always.hint--left:after{transform:translateX(-8px)}.hint--always.hint--right:before,.hint--always.hint--right:after{transform:translateX(8px)}.hint--rounded:after{border-radius:4px}.hint--no-animate:before,.hint--no-animate:after{transition-duration:0s}.hint--bounce:before,.hint--bounce:after{transition:opacity .3s,visibility .3s,transform .3s cubic-bezier(.71,1.7,.77,1.24)}.hint--no-shadow:before,.hint--no-shadow:after{text-shadow:initial;box-shadow:initial}.hint--no-arrow:before{display:none}.libmedia-ui-selector{text-align:center;border-radius:var(--libmedia-ui-border-radius);opacity:0;pointer-events:none;bottom:var(--libmedia-ui-control-height);max-height:var(--libmedia-ui-selector-max-height);background-color:var(--libmedia-ui-widget-background);transition:all var(--libmedia-ui-transition-duration) ease;flex-direction:column;align-items:center;display:flex;position:absolute;overflow:hidden auto}.libmedia-ui-selector .libmedia-ui-selector-item{flex-shrink:0;justify-content:center;align-items:center;width:100%;padding:10px 15px;line-height:1;display:flex;cursor:pointer}.libmedia-ui-selector .libmedia-ui-selector-item.active{color:var(--libmedia-ui-theme)}.libmedia-ui-selector .libmedia-ui-selector-item:hover{background-color:var(--libmedia-ui-widget-hover-background)}.libmedia-ui-slider{cursor:pointer;width:100%;height:100%;position:relative;justify-content:center;display:flex}.libmedia-ui-slider .libmedia-ui-slider-outer{border-radius:var(--libmedia-ui-border-radius);background-color:rgba(255,255,255,0.251);justify-content:center;display:flex;position:relative;overflow:hidden}.libmedia-ui-slider .libmedia-ui-slider-outer .libmedia-ui-slider-inner{background-color:var(--libmedia-ui-theme);width:100%;height:100%;position:absolute}.libmedia-ui-slider .libmedia-ui-slider-thumb{width:var(--libmedia-ui-slider-thumb-size);height:var(--libmedia-ui-slider-thumb-size);background-color:var(--libmedia-ui-theme);transition:transform var(--libmedia-ui-transition-duration) ease;border-radius:100%;flex-shrink:0;position:absolute;transform:scale(1)}.libmedia-ui-slider[data-direction='vertical'] .libmedia-ui-slider-outer{width:var(--libmedia-ui-slider-thickness);height:100%}.libmedia-ui-slider[data-direction='vertical'] .libmedia-ui-slider-thumb{margin-top:calc(var(--libmedia-ui-slider-thumb-size) / -2)}.libmedia-ui-slider[data-direction='horizontal'] .libmedia-ui-slider-outer{width:100%;height:var(--libmedia-ui-slider-thickness)}.libmedia-ui-slider[data-direction='horizontal'] .libmedia-ui-slider-thumb{margin-right:calc(var(--libmedia-ui-slider-thumb-size) / -2)}.avplayer-ui-container{width:100%;height:100%;user-select:none;color:var(--libmedia-ui-font-color);background-color:var(--libmedia-ui-background-color);text-shadow:0 0 2px var(--libmedia-ui-text-shadow-color)}.avplayer-ui-container *{box-sizing:border-box;outline:none}.avplayer-ui-container svg{fill:var(--libmedia-ui-font-color)}.avplayer-ui-container .avplayer-ui-header{width:100%;height:var(--libmedia-ui-header-height);position:absolute;top:0;text-align:center;padding:0 var(--libmedia-ui-padding);transition:all var(--libmedia-ui-transition-duration) ease;background-size:100% var(--libmedia-ui-header-height);background-image:linear-gradient(to bottom,#000,rgba(0,0,0,0.4),rgba(0,0,0,0))}.avplayer-ui-container .avplayer-ui-header .avplayer-ui-title{line-height:var(--libmedia-ui-header-height);font-size:16px;max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.avplayer-ui-container .avplayer-ui-header a{position:absolute;right:calc((var(--libmedia-ui-header-height) - 16px) / 2);top:calc((var(--libmedia-ui-header-height) - 16px) / 2);height:16px}.avplayer-ui-container .avplayer-ui-header a svg{height:16px;width:16px}.avplayer-ui-container .avplayer-ui-player{width:100%;height:100%;position:absolute;top:0;left:0;overflow:hidden;cursor:pointer}.avplayer-ui-container .avplayer-ui-player canvas,.avplayer-ui-container .avplayer-ui-player video{background-color:#000}.avplayer-ui-container .avplayer-ui-footer{padding:0 var(--libmedia-ui-padding);transition:all var(--libmedia-ui-transition-duration) ease;background-size:100% var(--libmedia-ui-bottom-height);background-image:linear-gradient(to top,#000,rgba(0,0,0,0.4),rgba(0,0,0,0));flex-direction:column;justify-content:flex-end;width:100%;height:var(--libmedia-ui-bottom-height);display:flex;position:absolute;bottom:0}.avplayer-ui-container .avplayer-ui-footer .avplayer-ui-progress-container{pointer-events:auto;padding-bottom:var(--libmedia-ui-bottom-gap);position:relative;transition:transform var(--libmedia-ui-transition-duration) ease}.avplayer-ui-container .avplayer-ui-footer .avplayer-ui-control{height:var(--libmedia-ui-control-height);justify-content:space-between;align-items:center;display:flex;position:relative;transition:transform var(--libmedia-ui-transition-duration) ease}.avplayer-ui-container .avplayer-ui-footer .avplayer-ui-control .avplayer-ui-control-item{cursor:pointer;white-space:nowrap;opacity:var(--libmedia-ui-control-opacity);min-height:var(--libmedia-ui-control-height);min-width:var(--libmedia-ui-control-height);transition:opacity var(--libmedia-ui-transition-duration) ease;flex-shrink:0;justify-content:center;align-items:center;display:flex;position:relative}.avplayer-ui-container .avplayer-ui-footer .avplayer-ui-control .avplayer-ui-control-item svg{height:var(--libmedia-ui-control-icon-size);width:var(--libmedia-ui-control-icon-size);transform:scale(var(--libmedia-ui-control-icon-scale));transition:transform var(--libmedia-ui-transition-duration) ease}.avplayer-ui-container .avplayer-ui-footer .avplayer-ui-control .avplayer-ui-control-item:hover{cursor:pointer;opacity:1}.avplayer-ui-container .avplayer-ui-footer .avplayer-ui-control .avplayer-ui-footer-left{height:100%;display:flex}.avplayer-ui-container .avplayer-ui-footer .avplayer-ui-control .avplayer-ui-footer-right{height:100%;display:flex;justify-content:flex-end}.avplayer-ui-container .avplayer-ui-footer:hover .avplayer-ui-progress .avplayer-ui-progress-inner .avplayer-ui-progress-indicator{transform:scale(1)}.avplayer-ui-container .avplayer-ui-folder-container{position:absolute;top:0;left:0;transition:all var(--libmedia-ui-transition-duration) ease;width:var(--libmedia-ui-folder-width);bottom:calc(var(--libmedia-ui-progress-height) + var(--libmedia-ui-bottom-gap) + var(--libmedia-ui-control-height));box-shadow:2px 0 8px rgba(0,0,0,0.6);background-color:var(--libmedia-ui-widget-background);border-top-right-radius:8px;border-bottom-right-radius:8px}.avplayer-ui-container .avplayer-ui-folder-container .avplayer-ui-folder-toggle{width:24px;height:60px;justify-content:center;align-items:center;display:flex;cursor:pointer;border-top-right-radius:8px;border-bottom-right-radius:8px;box-shadow:2px 0 8px rgba(0,0,0,0.6);transition:all var(--libmedia-ui-transition-duration) ease;position:absolute;right:-24px;top:50%;transform:translateY(-50%);opacity:1}.avplayer-ui-container .avplayer-ui-folder-container .avplayer-ui-folder-toggle svg{width:24px;height:24px;opacity:var(--libmedia-ui-control-opacity);transform:rotate(180deg)}.avplayer-ui-container .avplayer-ui-folder-container .avplayer-ui-folder-toggle:hover svg{opacity:1}.avplayer-ui-container .avplayer-ui-folder-container[data-fold='1']{transform:translateX(calc(var(--libmedia-ui-folder-width) * -1))}.avplayer-ui-container .avplayer-ui-folder-container[data-fold='1'] .avplayer-ui-folder-toggle svg{transform:rotate(0)}.avplayer-ui-container .avplayer-ui-mask{pointer-events:none;justify-content:center;align-items:center;width:100%;height:100%;display:flex;position:absolute}.avplayer-ui-container .avplayer-ui-mask .avplayer-ui-state{opacity:0;width:var(--libmedia-ui-state-size);height:var(--libmedia-ui-state-size);transition:all var(--libmedia-ui-transition-duration) ease;justify-content:center;align-items:center;display:flex;transform:scale(2)}.avplayer-ui-container .avplayer-ui-mask .avplayer-ui-state img{vertical-align:top;max-width:100%}.avplayer-ui-container .avplayer-ui-mask .avplayer-ui-state[data-show='1']{cursor:pointer;pointer-events:auto;opacity:var(--libmedia-ui-state-opacity);transform:scale(1)}.avplayer-ui-container .avplayer-ui-mask.info{height:calc(100% - var(--libmedia-ui-bottom-height))}.avplayer-ui-container .avplayer-ui-mask.showSettings{height:calc(100% - var(--libmedia-ui-bottom-height))}.avplayer-ui-container .avplayer-ui-pcm-visualization-mask{pointer-events:none;justify-content:center;align-items:center;width:100%;height:100%;display:flex;position:absolute;transition:all var(--libmedia-ui-transition-duration) ease}.avplayer-ui-container .avplayer-ui-menu{position:fixed;border-radius:var(--libmedia-ui-border-radius);background-color:var(--libmedia-ui-widget-background);transition:all var(--libmedia-ui-transition-duration) ease}.avplayer-ui-container .avplayer-ui-menu .avplayer-ui-menu-item{padding:10px 60px;font-size:14px;cursor:pointer}.avplayer-ui-container .avplayer-ui-menu .avplayer-ui-menu-item:hover{background-color:var(--libmedia-ui-widget-hover-background)}.avplayer-ui-container[data-bar-show='0']{cursor:none}.avplayer-ui-container[data-bar-show='0'] .avplayer-ui-player{cursor:none}.avplayer-ui-container[data-bar-show='0'] .avplayer-ui-header{transform:translateY(calc(var(--libmedia-ui-header-height) * -1))}.avplayer-ui-container[data-bar-show='0'] .avplayer-ui-footer{transform:translateY(var(--libmedia-ui-bottom-height))}.avplayer-ui-container[data-bar-show='0'] .avplayer-ui-footer .avplayer-ui-progress-container{transform:translateY(calc((var(--libmedia-ui-bottom-height) - var(--libmedia-ui-bottom-gap) - var(--libmedia-ui-progress-height) * 0.5 - var(--libmedia-ui-control-height)) * -1))}.avplayer-ui-container[data-bar-show='0'] .avplayer-ui-folder-container{opacity:0;transform:translateX(calc(var(--libmedia-ui-folder-width) * -1))}.avplayer-ui-container[data-bar-show='0'] .avplayer-ui-folder-container .avplayer-ui-folder-toggle{pointer-events:none}.avplayer-ui-container[data-bar-show='0'] .avplayer-ui-pcm-visualization-mask{background-color:rgba(0,0,0,0.5)}@keyframes icon_scale{0%{transform:scale(1);transform-origin:center center}50%{transform:scale(1.2);transform-origin:center center}100%{transform:scale(1);transform-origin:center center}}@keyframes icon_rotate{0%{transform:rotate(0);transform-origin:center center}100%{transform:rotate(120deg);transform-origin:center center}}`;

/***/ }),

/***/ "./src/ui/avplayer/components/control/audioTrack/AudioTrack.styl":
/*!***********************************************************************!*\
  !*** ./src/ui/avplayer/components/control/audioTrack/AudioTrack.styl ***!
  \***********************************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-control-audio-track{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.avplayer-ui-control-audio-track:hover .libmedia-ui-selector{opacity:1;pointer-events:auto}`;

/***/ }),

/***/ "./src/ui/avplayer/components/control/fullscreen/Fullscreen.styl":
/*!***********************************************************************!*\
  !*** ./src/ui/avplayer/components/control/fullscreen/Fullscreen.styl ***!
  \***********************************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-control-fullscreen{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.avplayer-ui-control-fullscreen:hover svg{animation:icon_scale .4s ease both}`;

/***/ }),

/***/ "./src/ui/avplayer/components/control/loop/Loop.styl":
/*!***********************************************************!*\
  !*** ./src/ui/avplayer/components/control/loop/Loop.styl ***!
  \***********************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-control-loop{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.avplayer-ui-control-loop:hover svg{animation:icon_scale .4s ease both}`;

/***/ }),

/***/ "./src/ui/avplayer/components/control/pip/Pip.styl":
/*!*********************************************************!*\
  !*** ./src/ui/avplayer/components/control/pip/Pip.styl ***!
  \*********************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-control-pip{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.avplayer-ui-control-pip:hover svg{animation:icon_scale .4s ease both}`;

/***/ }),

/***/ "./src/ui/avplayer/components/control/play/Play.styl":
/*!***********************************************************!*\
  !*** ./src/ui/avplayer/components/control/play/Play.styl ***!
  \***********************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-control-play{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.avplayer-ui-control-play:hover svg{animation:icon_scale .4s ease both}`;

/***/ }),

/***/ "./src/ui/avplayer/components/control/playrate/Playrate.styl":
/*!*******************************************************************!*\
  !*** ./src/ui/avplayer/components/control/playrate/Playrate.styl ***!
  \*******************************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-control-play-rate{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.avplayer-ui-control-play-rate:hover .libmedia-ui-selector{opacity:1;pointer-events:auto}`;

/***/ }),

/***/ "./src/ui/avplayer/components/control/setting/Setting.styl":
/*!*****************************************************************!*\
  !*** ./src/ui/avplayer/components/control/setting/Setting.styl ***!
  \*****************************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-control-settings{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.avplayer-ui-control-settings:hover svg{animation:icon_rotate .4s ease both}`;

/***/ }),

/***/ "./src/ui/avplayer/components/control/subtitleTrack/SubtitleTrack.styl":
/*!*****************************************************************************!*\
  !*** ./src/ui/avplayer/components/control/subtitleTrack/SubtitleTrack.styl ***!
  \*****************************************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-control-subtitle-track{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.avplayer-ui-control-subtitle-track:hover .libmedia-ui-selector{opacity:1;pointer-events:auto}`;

/***/ }),

/***/ "./src/ui/avplayer/components/control/timer/Timer.styl":
/*!*************************************************************!*\
  !*** ./src/ui/avplayer/components/control/timer/Timer.styl ***!
  \*************************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-control-timer{display:flex;align-items:center;justify-content:center;cursor:pointer;padding:0 10px;opacity:var(--libmedia-ui-control-opacity)}.avplayer-ui-control-timer .avplayer-ui-time-label{min-width:66px}.avplayer-ui-control-timer .avplayer-ui-time-div{transform:translateX(-1px)}.avplayer-ui-control-timer:hover{opacity:1}`;

/***/ }),

/***/ "./src/ui/avplayer/components/control/videoTrack/VideoTrack.styl":
/*!***********************************************************************!*\
  !*** ./src/ui/avplayer/components/control/videoTrack/VideoTrack.styl ***!
  \***********************************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-control-video-track{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.avplayer-ui-control-video-track:hover .libmedia-ui-selector{opacity:1;pointer-events:auto}`;

/***/ }),

/***/ "./src/ui/avplayer/components/control/volume/Volume.styl":
/*!***************************************************************!*\
  !*** ./src/ui/avplayer/components/control/volume/Volume.styl ***!
  \***************************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-control-volume{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.avplayer-ui-control-volume:hover svg{animation:icon_scale .4s ease both}.avplayer-ui-control-volume:hover .avplayer-ui-volume-panel{opacity:1;pointer-events:auto}.avplayer-ui-control-volume .avplayer-ui-volume-icon{justify-content:center;align-items:center;display:flex}.avplayer-ui-control-volume .avplayer-ui-volume-panel{text-align:center;opacity:0;pointer-events:none;left:0;right:0;bottom:var(--libmedia-ui-control-height);width:var(--libmedia-ui-control-height);height:var(--libmedia-ui-volume-height);transition:all ease;transition:all var(--libmedia-ui-transition-duration) ease 0s;justify-content:center;align-items:center;padding:0 5px;font-size:12px;display:flex;position:absolute;z-index:1}.avplayer-ui-control-volume .avplayer-ui-volume-panel .avplayer-ui-volume-inner{border-radius:var(--libmedia-ui-border-radius);background-color:var(--libmedia-ui-widget-background);flex-direction:column;align-items:center;gap:10px;width:100%;height:100%;padding:10px 0 12px;display:flex}.avplayer-ui-control-volume .avplayer-ui-volume-panel .avplayer-ui-volume-inner .libmedia-ui-slider{flex:1}`;

/***/ }),

/***/ "./src/ui/avplayer/components/folder/Folder.styl":
/*!*******************************************************!*\
  !*** ./src/ui/avplayer/components/folder/Folder.styl ***!
  \*******************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-folder{width:100%;height:100%;padding:var(--libmedia-ui-padding) 0;transition:all var(--libmedia-ui-transition-duration) ease}.avplayer-ui-folder ul{margin:0;padding:0;list-style:none}.avplayer-ui-folder svg{width:24px;height:24px}.avplayer-ui-folder .avplayer-ui-folder-open{display:flex;justify-content:center;align-items:center;height:30px;margin-bottom:10px;width:var(--libmedia-ui-folder-width);padding-right:var(--libmedia-ui-padding)}.avplayer-ui-folder .avplayer-ui-folder-open .avplayer-ui-folder-open-dir{transform:scale(.9)}.avplayer-ui-folder .avplayer-ui-folder-open .avplayer-ui-folder-open-dir .avplayer-ui-folder-open-name{margin-left:3px}.avplayer-ui-folder .avplayer-ui-folder-open .avplayer-ui-folder-open-file{transform:scale(.9)}.avplayer-ui-folder .avplayer-ui-folder-open .avplayer-ui-folder-open-file svg{stroke:var(--libmedia-ui-font-color);fill:none}.avplayer-ui-folder .avplayer-ui-folder-open .item{cursor:pointer;display:flex;justify-content:center;align-items:center;opacity:var(--libmedia-ui-control-opacity);transition:opacity var(--libmedia-ui-transition-duration) ease}.avplayer-ui-folder .avplayer-ui-folder-open .item:hover{opacity:1}.avplayer-ui-folder .avplayer-ui-folder-open .avplayer-ui-folder-open-name{display:inline-block;font-size:12px}.avplayer-ui-folder .avplayer-ui-folder-open .item + .item{margin-left:20px}.avplayer-ui-folder .avplayer-ui-url-open{display:flex;justify-content:center;align-items:center;margin-bottom:10px;height:30px;width:var(--libmedia-ui-folder-width);padding:0 var(--libmedia-ui-padding);opacity:var(--libmedia-ui-control-opacity);transition:opacity var(--libmedia-ui-transition-duration) ease}.avplayer-ui-folder .avplayer-ui-url-open .avplayer-ui-url-open-input{flex:1;font-size:12px;border:1px;border-radius:4px;color:var(--libmedia-ui-font-color);outline:none;border:1px solid var(--libmedia-ui-font-color);background:none;height:28px;line-height:28px;margin-left:14px;padding-left:10px}.avplayer-ui-folder .avplayer-ui-url-open .avplayer-ui-url-open-input::placeholder{color:var(--libmedia-ui-font-color)}.avplayer-ui-folder .avplayer-ui-url-open .avplayer-ui-folder-icon{width:30px;transform:scale(.9)}.avplayer-ui-folder .avplayer-ui-url-open .avplayer-ui-folder-icon svg{stroke:var(--libmedia-ui-font-color)}.avplayer-ui-folder .avplayer-ui-url-open .avplayer-ui-folder-icon:hover{cursor:pointer}.avplayer-ui-folder .avplayer-ui-url-open .avplayer-ui-folder-icon:hover svg{animation:icon_scale .4s ease both}.avplayer-ui-folder .avplayer-ui-url-open .avplayer-ui-url-open-live{display:flex;justify-content:center;align-items:center;font-size:12px}.avplayer-ui-folder .avplayer-ui-url-open:hover{opacity:1}.avplayer-ui-folder .avplayer-ui-folder-list-container{position:absolute;top:90px;bottom:0;left:0;right:0;overflow:auto}.avplayer-ui-folder .avplayer-ui-folder-list-container::-webkit-scrollbar{display:none}.avplayer-ui-folder .avplayer-ui-folder-node{display:flex;flex-direction:row;justify-content:flex-start;align-items:center;height:30px;width:var(--libmedia-ui-folder-width);padding-right:var(--libmedia-ui-padding);opacity:var(--libmedia-ui-control-opacity);transition:opacity var(--libmedia-ui-transition-duration) ease}.avplayer-ui-folder .avplayer-ui-folder-node.active{background-color:var(--libmedia-ui-theme) !important}.avplayer-ui-folder .avplayer-ui-folder-node:hover{background-color:var(--libmedia-ui-widget-hover-background);opacity:1}.avplayer-ui-folder .avplayer-ui-folder-expand{cursor:pointer;font-size:0;display:flex;justify-content:center;align-items:center;transition:transform linear .1s;width:24px;height:100%}.avplayer-ui-folder .avplayer-ui-folder-expand svg{transform:rotate(0)}.avplayer-ui-folder .avplayer-ui-folder-expand[data-open='1'] svg{transform:rotate(90deg)}.avplayer-ui-folder .avplayer-ui-folder-icon{display:flex;justify-content:center;align-items:center;width:24px;height:100%}.avplayer-ui-folder .avplayer-ui-folder-icon.mov{margin-left:24px;transform:scale(.9)}.avplayer-ui-folder .avplayer-ui-folder-icon.music{margin-left:24px}.avplayer-ui-folder .avplayer-ui-folder-icon.url{margin-left:24px}.avplayer-ui-folder .avplayer-ui-folder-icon.play,.avplayer-ui-folder .avplayer-ui-folder-icon.delete{cursor:pointer;transform:scale(.8)}.avplayer-ui-folder .avplayer-ui-folder-icon.play:hover svg,.avplayer-ui-folder .avplayer-ui-folder-icon.delete:hover svg{animation:icon_scale .4s ease both}.avplayer-ui-folder .avplayer-ui-folder-node-name{padding:0 5px;min-width:100px;flex-grow:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.avplayer-ui-folder .avplayer-ui-folder-tip{text-shadow:0 -1px var(--libmedia-ui-tip-background);box-shadow:4px 4px 8px var(--libmedia-ui-tip-background);color:var(--libmedia-ui-tip-font-color);white-space:nowrap;background:var(--libmedia-ui-tip-background);padding:8px 10px;font-size:12px;line-height:12px;opacity:0;pointer-events:none;transition:all var(--libmedia-ui-transition-duration) ease .1s,top 0s ease 0s;position:absolute;transform:translate3d(0,0,0);left:100%}.avplayer-ui-folder .avplayer-ui-folder-tip::before{content:"";border:5px solid rgba(0,0,0,0);position:absolute;border-right-color:var(--libmedia-ui-tip-background);left:-10px;transform:translateY(1px)}.avplayer-ui-folder .avplayer-ui-folder-tip[data-show='1']{transform:translateX(8px);opacity:1}`;

/***/ }),

/***/ "./src/ui/avplayer/components/info/Info.styl":
/*!***************************************************!*\
  !*** ./src/ui/avplayer/components/info/Info.styl ***!
  \***************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-info{pointer-events:auto;background:var(--libmedia-ui-tip-background);border-radius:4px;color:#fff;line-height:18px;padding-bottom:15px;text-align:center;text-align:left;-webkit-font-smoothing:antialiased;position:relative;max-height:80%;max-width:80%;user-select:text;display:flex;flex-direction:column}.avplayer-ui-info .avplayer-ui-info-title{border-bottom:1px solid rgba(255,255,255,0.1);font-size:16px;line-height:40px;text-align:center;height:41px}.avplayer-ui-info .avplayer-ui-info-close{fill:#fff;color:#fff;cursor:pointer;height:22px;position:absolute;right:10px;top:8px;width:22px}.avplayer-ui-info .avplayer-ui-info-panel{flex:1;padding:15px 26px 0;position:relative;overflow:auto;scrollbar-width:thin}.avplayer-ui-info .avplayer-ui-info-panel::-webkit-scrollbar{width:8px;height:8px}.avplayer-ui-info .avplayer-ui-info-panel .avplayer-ui-info-format{font-size:12px;font-weight:500}.avplayer-ui-info .avplayer-ui-info-panel .avplayer-ui-info-line{min-width:290px}.avplayer-ui-info .avplayer-ui-info-panel .avplayer-ui-info-line .avplayer-ui-info-line-title{font-size:12px;font-weight:500;margin-right:10px;text-align:right;text-indent:-99em;width:190px;display:inline-block}.avplayer-ui-info .avplayer-ui-info-panel .avplayer-ui-info-line .avplayer-ui-info-line-value{color:#999;font-size:12px;font-weight:400;margin-right:6px}`;

/***/ }),

/***/ "./src/ui/avplayer/components/loadingTip/LoadingTip.styl":
/*!***************************************************************!*\
  !*** ./src/ui/avplayer/components/loadingTip/LoadingTip.styl ***!
  \***************************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-loading-tip{position:absolute;right:20px;bottom:calc(var(--libmedia-ui-bottom-height) + 10px);opacity:1;pointer-events:none;transition:all 1s ease}.avplayer-ui-loading-tip .avplayer-ui-loading-message{transition:bottom .1s ease,transform 1s ease;border-radius:var(--libmedia-ui-border-radius);white-space:nowrap;background-color:var(--libmedia-ui-tip-background);padding:3px 5px;font-size:12px;line-height:1;position:absolute;right:0}.avplayer-ui-loading-tip .avplayer-ui-loading-message[data-last='1']{animation:avplayer-ui-loading-message-last .1s ease}.avplayer-ui-loading-tip[data-show='0']{opacity:0}.avplayer-ui-loading-tip[data-show='0'] .avplayer-ui-loading-message{transform:translateY(-40px)}@keyframes avplayer-ui-loading-message-last{0%{opacity:0}100%{opacity:1}}`;

/***/ }),

/***/ "./src/ui/avplayer/components/loading/Loading.styl":
/*!*********************************************************!*\
  !*** ./src/ui/avplayer/components/loading/Loading.styl ***!
  \*********************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-loading-mask{position:absolute;width:100%;height:100%;text-align:center;top:0;left:0;display:flex;align-items:center;justify-content:center;opacity:0;pointer-events:none;transition:all var(--libmedia-ui-transition-duration) ease}.avplayer-ui-loading-mask .avplayer-ui-loading-spinner{top:50%;margin-top:-21px;width:100%;text-align:center;position:absolute}.avplayer-ui-loading-mask .avplayer-ui-loading-spinner .avplayer-ui-circular{height:42px;width:42px;animation:loading-rotate 2s linear infinite}.avplayer-ui-loading-mask .avplayer-ui-loading-spinner .avplayer-ui-circular circle{animation:loading-dash 1.5s ease-in-out infinite;stroke-dasharray:90,150;stroke-dashoffset:0;stroke-width:2;stroke:var(--libmedia-ui-theme);stroke-linecap:round}.avplayer-ui-loading-mask[data-loading='1']{opacity:1;pointer-events:auto}@keyframes loading-rotate{to{transform:rotate(1turn)}}@keyframes loading-dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40px}to{stroke-dasharray:90,150;stroke-dashoffset:-120px}}`;

/***/ }),

/***/ "./src/ui/avplayer/components/pcmVisualization/PcmVisualization.styl":
/*!***************************************************************************!*\
  !*** ./src/ui/avplayer/components/pcmVisualization/PcmVisualization.styl ***!
  \***************************************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-pcm-visualization{width:100%;height:100%}.avplayer-ui-pcm-visualization canvas{width:100%;height:100%}`;

/***/ }),

/***/ "./src/ui/avplayer/components/progress/Progress.styl":
/*!***********************************************************!*\
  !*** ./src/ui/avplayer/components/progress/Progress.styl ***!
  \***********************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-progress{cursor:pointer;height:var(--libmedia-ui-progress-height);justify-content:center;align-items:center;display:flex;position:relative}.avplayer-ui-progress:hover .avplayer-ui-progress-inner{height:100%}.avplayer-ui-progress .avplayer-ui-progress-inner{transition:height var(--libmedia-ui-transition-duration) ease;background-color:var(--libmedia-ui-progress-color);align-items:center;width:100%;height:50%;display:flex;position:relative}.avplayer-ui-progress .avplayer-ui-progress-inner .avplayer-ui-progress-hover{background-color:var(--libmedia-ui-hover-color);width:0%;height:100%;position:absolute}.avplayer-ui-progress .avplayer-ui-progress-inner .avplayer-ui-progress-loaded{background-color:var(--libmedia-ui-loaded-color);width:0%;height:100%;position:absolute}.avplayer-ui-progress .avplayer-ui-progress-inner .avplayer-ui-progress-played{background-color:var(--libmedia-ui-theme);width:0%;height:100%;position:absolute}.avplayer-ui-progress .avplayer-ui-progress-inner .avplayer-ui-progress-chapter{pointer-events:none;width:100%;height:100%;position:absolute}.avplayer-ui-progress .avplayer-ui-progress-inner .avplayer-ui-progress-indicator{width:var(--libmedia-ui-indicator-size);height:var(--libmedia-ui-indicator-size);transform:scale(var(--libmedia-ui-indicator-scale));margin-left:calc(var(--libmedia-ui-indicator-size) / -2);transition:transform var(--libmedia-ui-transition-duration) ease;border-radius:50%;justify-content:center;align-items:center;display:flex;position:absolute;left:0}.avplayer-ui-progress .avplayer-ui-progress-inner .avplayer-ui-progress-indicator:hover{transform:scale(1.2) !important}.avplayer-ui-progress .avplayer-ui-progress-inner .avplayer-ui-progress-indicator .avplayer-ui-icon-indicator{width:100%;height:100%}.avplayer-ui-progress .avplayer-ui-progress-inner .avplayer-ui-progress-chapter{pointer-events:none;width:100%;height:100%;position:absolute;overflow:hidden}.avplayer-ui-progress .avplayer-ui-progress-inner .avplayer-ui-progress-chapter .avplayer-ui-progress-chapter-item{pointer-events:auto;transform:translateX(calc(var(--libmedia-ui-chapter-width) / -2));background-color:var(--libmedia-ui-chapter-color);width:var(--libmedia-ui-chapter-width);height:100%;position:absolute}.avplayer-ui-progress .avplayer-ui-progress-inner .avplayer-ui-progress-tip{border-radius:var(--libmedia-ui-border-radius);white-space:nowrap;background-color:var(--libmedia-ui-tip-background);transform:translateX(-50%);padding:3px 5px;font-size:12px;line-height:1;display:none;position:absolute;top:-25px;left:0}.avplayer-ui-progress .libmedia-ui-progress-thumb{bottom:calc(var(--libmedia-ui-bottom-gap) + 10px);border-radius:var(--libmedia-ui-border-radius);pointer-events:none;background-color:var(--libmedia-ui-widget-background);display:none;position:absolute;left:0;box-shadow:0 1px 3px rgba(0,0,0,0.2),0 1px 2px -1px rgba(0,0,0,0.2)}`;

/***/ }),

/***/ "./src/ui/avplayer/components/settings/Settings.styl":
/*!***********************************************************!*\
  !*** ./src/ui/avplayer/components/settings/Settings.styl ***!
  \***********************************************************/
/***/ ((module) => {

module.exports = `.avplayer-ui-settings{pointer-events:auto;background:var(--libmedia-ui-tip-background);border-radius:4px;color:#fff;position:relative;max-height:100%;max-width:80%;width:600px;height:500px;display:flex;flex-direction:column}.avplayer-ui-settings .avplayer-ui-settings-title{border-bottom:1px solid rgba(255,255,255,0.1);font-size:16px;line-height:40px;text-align:center;height:41px}.avplayer-ui-settings .avplayer-ui-settings-close{fill:#fff;color:#fff;cursor:pointer;height:22px;position:absolute;right:10px;top:8px;width:22px}.avplayer-ui-settings .avplayer-ui-settings-panel{flex:1;position:relative;display:flex;overflow:hidden}.avplayer-ui-settings .avplayer-ui-settings-panel .avplayer-ui-settings-tabs{width:141px;height:100%;padding:20px;overflow:auto;transition:all var(--libmedia-ui-transition-duration) ease;border-right:1px solid rgba(255,255,255,0.1)}.avplayer-ui-settings .avplayer-ui-settings-panel .avplayer-ui-settings-tabs .avplayer-ui-settings-tab{width:100px;height:36px;text-align:center;line-height:36px;cursor:pointer;border-radius:4px;font-size:14px;opacity:var(--libmedia-ui-control-opacity);background-color:var(--libmedia-ui-widget-hover-background)}.avplayer-ui-settings .avplayer-ui-settings-panel .avplayer-ui-settings-tabs .avplayer-ui-settings-tab:hover{opacity:1}.avplayer-ui-settings .avplayer-ui-settings-panel .avplayer-ui-settings-tabs .avplayer-ui-settings-tab.active{opacity:1;background-color:var(--libmedia-ui-theme)}.avplayer-ui-settings .avplayer-ui-settings-panel .avplayer-ui-settings-tabs .avplayer-ui-settings-tab + .avplayer-ui-settings-tab{margin-top:10px}.avplayer-ui-settings .avplayer-ui-settings-panel .avplayer-ui-settings-context{flex:1;height:100%;overflow:auto;padding:20px}`;

/***/ }),

/***/ "./src/avrender/image/webgl/glsl/vertex.vert":
/*!***************************************************!*\
  !*** ./src/avrender/image/webgl/glsl/vertex.vert ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 point;\nattribute vec4 color;\nvarying vec4 v_color;\n\nuniform mat4 rotateMatrix;\n\nvoid main(void){\n  gl_Position = rotateMatrix * vec4(point, 1.0);\n  v_color = color;\n}\n");

/***/ }),

/***/ "./src/avrender/image/webgpu/wgsl/compute/uint2FloatBE.wgsl":
/*!******************************************************************!*\
  !*** ./src/avrender/image/webgpu/wgsl/compute/uint2FloatBE.wgsl ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("\r\nstruct Meta {\r\n  max: u32,\r\n  width: u32,\r\n  height: u32\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> metaData: Meta;\r\n@group(0) @binding(1) var input: texture_2d<u32>;\r\n@group(0) @binding(2) var output: texture_storage_2d<r32float, write>;\r\n\r\n@compute @workgroup_size(8, 8) fn main(\r\n  @builtin(workgroup_id) workgroup_id: vec3<u32>,\r\n  @builtin(local_invocation_id) local_invocation_id: vec3<u32>\r\n) {\r\n  var x = workgroup_id.x * 8 + local_invocation_id.x;\r\n  var y = workgroup_id.y * 8 + local_invocation_id.y;\r\n  if (x < metaData.width && y < metaData.height) {\r\n    var value: u32 = textureLoad(input, vec2(x, y), 0).x;\r\n    var low = value & 0xff;\r\n    var high = (value >> 8) & 0xff;\r\n    value = (low << 8) | high;\r\n    var value_no: f32 = f32(value) / f32(metaData.max);\r\n    textureStore(output, vec2(x, y), vec4(value_no, 0, 0, 0));\r\n  }\r\n}");

/***/ }),

/***/ "./src/avrender/image/webgpu/wgsl/compute/uint2FloatLE.wgsl":
/*!******************************************************************!*\
  !*** ./src/avrender/image/webgpu/wgsl/compute/uint2FloatLE.wgsl ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("\r\nstruct Meta {\r\n  max: u32,\r\n  width: u32,\r\n  height: u32\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> metaData: Meta;\r\n@group(0) @binding(1) var input: texture_2d<u32>;\r\n@group(0) @binding(2) var output: texture_storage_2d<r32float, write>;\r\n\r\n@compute @workgroup_size(8, 8) fn main(\r\n  @builtin(workgroup_id) workgroup_id: vec3<u32>,\r\n  @builtin(local_invocation_id) local_invocation_id: vec3<u32>\r\n) {\r\n  var x = workgroup_id.x * 8 + local_invocation_id.x;\r\n  var y = workgroup_id.y * 8 + local_invocation_id.y;\r\n  if (x < metaData.width && y < metaData.height) {\r\n    var value: u32 = textureLoad(input, vec2(x, y), 0).x;\r\n    var value_no: f32 = f32(value) / f32(metaData.max);\r\n    textureStore(output, vec2(x, y), vec4(value_no, 0, 0, 0));\r\n  }\r\n}");

/***/ }),

/***/ "./src/avrender/image/webgpu/wgsl/fragment/external.wgsl":
/*!***************************************************************!*\
  !*** ./src/avrender/image/webgpu/wgsl/fragment/external.wgsl ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("\r\n@group(0) @binding(1) var eTexture: texture_external;\r\n@group(0) @binding(2) var s: sampler;\r\n\r\n@fragment\r\nfn main(@location(0) in_texcoord: vec4<f32>) -> @location(0) vec4<f32> {\r\n  return textureSampleBaseClampToEdge(eTexture, s, in_texcoord.xy);\r\n}");

/***/ }),

/***/ "./src/avrender/image/webgpu/wgsl/vertex.wgsl":
/*!****************************************************!*\
  !*** ./src/avrender/image/webgpu/wgsl/vertex.wgsl ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("struct PositionColorInput {\r\n    @location(0) in_position_3d: vec3<f32>,\r\n    @location(1) in_color_rgba: vec4<f32>\r\n};\r\n\r\nstruct PositionColorOutput {\r\n    @builtin(position) coords_output: vec4<f32>,\r\n    @location(0) color_output: vec4<f32>\r\n};\r\n\r\nstruct RotateMatrix {\r\n    matrix: mat4x4<f32>\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> rotateMatrix: RotateMatrix;\r\n\r\n@vertex\r\nfn main(input: PositionColorInput) -> PositionColorOutput {\r\n    var output: PositionColorOutput;\r\n    output.color_output = input.in_color_rgba;\r\n    output.coords_output = rotateMatrix.matrix * vec4<f32>(input.in_position_3d, 1.0);\r\n    return output;\r\n}");

/***/ }),

/***/ "./src/audioresample/Resampler.ts":
/*!****************************************!*\
  !*** ./src/audioresample/Resampler.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Resampler)
/* harmony export */ });
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\audioresample\\Resampler.ts";


class Resampler {
    resampler;
    options;
    inputParameters;
    outputParameters;
    constructor(options) {
        this.options = options;
        this.resampler = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__["default"](this.options.resource);
    }
    async open(input, output) {
        this.inputParameters = input;
        this.outputParameters = output;
        await this.resampler.run();
        this.resampler.call('resample_set_input_parameters', input.sampleRate, input.channels, input.format, input.layout || 0);
        this.resampler.call('resample_set_output_parameters', output.sampleRate, output.channels, output.format, output.layout || 0);
        let ret = this.resampler.call('resample_init');
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`open resampler failed, ret: ${ret}`, cheap__fileName__0, 84);
        }
    }
    resample(input, output, numberOfFrames) {
        return this.resampler.call('resample_process', input, output, numberOfFrames);
    }
    getOutputSampleCount(numberOfFrames) {
        return this.resampler.call('resample_nb_sample', numberOfFrames);
    }
    close() {
        this.resampler.call('resample_destroy');
        this.resampler.destroy();
        this.resampler = null;
    }
    getInputPCMParameters() {
        return this.inputParameters;
    }
    getOutputPCMParameters() {
        return this.outputParameters;
    }
}


/***/ }),

/***/ "./src/audiostretchpitch/StretchPitcher.ts":
/*!*************************************************!*\
  !*** ./src/audiostretchpitch/StretchPitcher.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StretchPitcher)
/* harmony export */ });
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/*
 * libmedia audio stretch and pitcher
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class StretchPitcher {
    processor;
    options;
    constructor(options) {
        this.options = options;
        this.processor = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__["default"](this.options.resource);
    }
    async open(parameters) {
        await this.processor.run();
        this.processor.call('stretchpitch_init');
        this.processor.call('stretchpitch_set_channels', parameters.channels);
        this.processor.call('stretchpitch_set_samplerate', parameters.sampleRate);
    }
    setRate(rate) {
        this.processor.call('stretchpitch_set_rate', rate);
    }
    setRateChange(change) {
        this.processor.call('stretchpitch_set_rate_change', change);
    }
    setTempo(tempo) {
        this.processor.call('stretchpitch_set_tempo', tempo);
    }
    setTempoChange(change) {
        this.processor.call('stretchpitch_set_tempo_change', change);
    }
    setPitch(pitch) {
        this.processor.call('stretchpitch_set_pitch', pitch);
    }
    setPitchOctaves(pitch) {
        this.processor.call('stretchpitch_set_pitch_octaves', pitch);
    }
    setPitchSemiTones(pitch) {
        this.processor.call('stretchpitch_set_pitch_semi_tones', pitch);
    }
    sendSamples(input, nbSamples) {
        this.processor.call('stretchpitch_send_samples', input, nbSamples);
    }
    receiveSamples(output, maxSamples) {
        return this.processor.call('stretchpitch_receive_samples', output, maxSamples);
    }
    flush() {
        this.processor.call('stretchpitch_flush');
    }
    clear() {
        this.processor.call('stretchpitch_clear');
    }
    getUnprocessedSamplesCount() {
        return this.processor.call('stretchpitch_get_unprocessed_samples_num');
    }
    getInputOutputSamplesRatio() {
        return this.processor.call('stretchpitch_get_input_output_sample_ratio');
    }
    getLatency() {
        return this.processor.call('get_latency');
    }
    close() {
        this.processor.call('stretchpitch_destroy');
        this.processor.destroy();
        this.processor = null;
    }
}


/***/ }),

/***/ "./src/avcodec/function/getAudioCodec.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/function/getAudioCodec.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getAudioCodec)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avutil_stringEnum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/stringEnum */ "./src/avutil/stringEnum.ts");


function getAudioCodec(codecpar) {
    const codecId = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 4);
    let profile = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 48);
    let codec = avutil_stringEnum__WEBPACK_IMPORTED_MODULE_1__.CodecId2MimeType[codecId];
    if (codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */) {
        /*
         * mp4a.40.profile
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#iso_base_media_file_format_mp4_quicktime_and_3gp
         */
        codec = `${codec}.${profile}`;
    }
    return codec || 'unknown';
}


/***/ }),

/***/ "./src/avcodec/function/getHardwarePreference.ts":
/*!*******************************************************!*\
  !*** ./src/avcodec/function/getHardwarePreference.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getHardwarePreference: () => (/* binding */ getHardwarePreference)
/* harmony export */ });
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/*
 * libmedia webcodec hardware preference different chrome version
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function getHardwarePreference(enable) {
    if (enable) {
        if (!common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].chrome || common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '94', true)) {
            return 'prefer-hardware';
        }
        else {
            return 'allow';
        }
    }
    else {
        if (!common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].chrome || common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '94', true)) {
            return 'prefer-software';
        }
        else {
            return 'deny';
        }
    }
}


/***/ }),

/***/ "./src/avcodec/function/getVideoCodec.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/function/getVideoCodec.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getVideoCodec)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avutil_stringEnum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/stringEnum */ "./src/avutil/stringEnum.ts");
/* harmony import */ var avformat_codecs_av1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avformat/codecs/av1 */ "./src/avformat/codecs/av1.ts");
/* harmony import */ var avformat_codecs_vp8__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avformat/codecs/vp8 */ "./src/avformat/codecs/vp8.ts");
/* harmony import */ var avformat_codecs_vp9__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avformat/codecs/vp9 */ "./src/avformat/codecs/vp9.ts");
/* harmony import */ var avformat_codecs_vvc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avformat/codecs/vvc */ "./src/avformat/codecs/vvc.ts");
/* harmony import */ var common_util_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/string */ "./src/common/util/string.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_base32__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/util/base32 */ "./src/common/util/base32.ts");










function getVideoCodec(codecpar, extradata) {
    const codecId = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 4);
    let profile = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 48);
    let level = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 52);
    if (!extradata && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](codecpar + 12) !== 0 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 16)) {
        extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_8__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](codecpar + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 16));
    }
    let entry = avutil_stringEnum__WEBPACK_IMPORTED_MODULE_1__.CodecId2MimeType[codecId];
    let codec = '';
    if (codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */) {
        /*
         * avc1.profile_idc.constraint_set.level_idc
         *  1  16 
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#iso_base_media_file_format_mp4_quicktime_and_3gp
         */
        // High 10 Profile 
        if (profile === 110 /* H264Profile.kHigh10 */) {
            profile = 100 /* H264Profile.kHigh */;
        }
        codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%02x00%02x', entry, profile & 0xff, level & 0xff);
    }
    else if (codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */) {
        /**
         *
         * hev1.[general_profile_space?general_profile_idc].[general_profile_compatibility_flags( ][general_tier_flag general_level_idc][constraint_flags( ]
         * general_profile_space:
         *  A -> 1
         *  B -> 2
         *  C -> 3
         * empty -> 0
         *
         * general_tier_flag:
         *  L -> 0
         *  H -> 1
         *
         */
        let generalProfileSpace = 0;
        let generalProfileCompatibilityFlags = 0;
        let generalTierFlag = 0;
        let constraintFlags = 0;
        if (extradata?.length > 13) {
            generalProfileSpace = (extradata[1] >>> 6) & 0x03;
            generalTierFlag = (extradata[1] >>> 5) & 0x01;
            generalProfileCompatibilityFlags = extradata[2] | (extradata[3] << 8) | (extradata[4] << 16) | (extradata[5] << 24);
            // constraintFlags  4  bit
            constraintFlags = extradata[6] & 0xf0;
        }
        const generalProfileSpaceMap = {
            0: '',
            1: 'A',
            2: 'B',
            3: 'C'
        };
        codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%s%d.%x.%s%d.%x', entry, generalProfileSpaceMap[generalProfileSpace], profile, generalProfileCompatibilityFlags, generalTierFlag === 0 ? 'L' : 'H', level, constraintFlags);
    }
    else if (codecId === 196 /* AVCodecID.AV_CODEC_ID_VVC */) {
        /**
         *
         * vvc1.<sample entry 4CC>.<general_profile_idc>.[LH]<op_level_idc>{.C<general_constraint_info>}{.S<general_sub_profile_idc>}{.O{<OlsIdx>}{+<MaxTid>}}
         */
        let generalTierFlag = 0;
        if (extradata?.length > 13) {
            generalTierFlag = extradata[5] & 0x01;
        }
        codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%d.%s%d', entry, profile, generalTierFlag === 0 ? 'L' : 'H', level);
        if (extradata) {
            const params = avformat_codecs_vvc__WEBPACK_IMPORTED_MODULE_5__.parseExtraData(extradata);
            if (params.generalConstraintInfo.length) {
                let index = params.generalConstraintInfo.length - 1;
                while (index > 0 && params.generalConstraintInfo[index] === 0) {
                    index--;
                }
                const generalConstraintInfo = params.generalConstraintInfo.slice(0, index + 1);
                if (generalConstraintInfo.length) {
                    codec += `.C${common_util_base32__WEBPACK_IMPORTED_MODULE_9__.encode(new Uint8Array(generalConstraintInfo), false)}`;
                }
            }
            if (params.generalSubProfileIdc.length) {
                codec += `.S${params.generalSubProfileIdc.map((profile) => profile.toString(16)).join('+')}`;
            }
            codec += `.O${params.olsIdx}+${params.numSublayers}`;
        }
    }
    else if (codecId === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
        /*
         * av01.profile.level+seqTier.bitDepth[.monochrome[.chromaSubsampling[.colorPrimaries[.colorPrimaries[.matrixCoefficients]]]]]
         * url: https://aomediacodec.github.io/av1-isobmff/#codecsparam
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#av1
         */
        if (extradata) {
            const params = avformat_codecs_av1__WEBPACK_IMPORTED_MODULE_2__.parseExtraData(extradata);
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%d.%02d%s.%02d.%d.%d%d%d', entry, params.profile, params.level, params.tier ? 'H' : 'M', params.bitDepth, params.monochrome, params.chromaSubsamplingX, params.chromaSubsamplingY, params.chromaSamplePosition);
        }
        else {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%d.%02dM.08', entry, profile, level);
        }
    }
    else if (codecId === 139 /* AVCodecID.AV_CODEC_ID_VP8 */) {
        /*
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#videowebmcodecsvp08.00.41.08vorbis
         */
        if (extradata) {
            const params = avformat_codecs_vp8__WEBPACK_IMPORTED_MODULE_3__.parseExtraData(extradata);
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%02d.%02d.%02d', entry, params.profile, params.level, params.bitDepth);
        }
        else if (profile !== avutil_constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE && level !== avutil_constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE) {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%02d.%02d.08', entry, profile, level);
        }
        else {
            codec = entry;
        }
    }
    else if (codecId === 167 /* AVCodecID.AV_CODEC_ID_VP9 */) {
        /*
         * vp09.profile.level.colorDepth.chromaSubsampling[.colorPrimaries[.transferCharacteristics[.matrixCoefficients[.blackLevel and color range]]]]
         * url: https://www.webmproject.org/vp9/mp4/#CodecsParameterString
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#webm
         */
        if (extradata) {
            const params = avformat_codecs_vp9__WEBPACK_IMPORTED_MODULE_4__.parseExtraData(extradata);
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%02d.%02d.%02d.%02d.%02d.%02d.%02d.%02d', entry, params.profile, params.level, params.bitDepth, params.chromaSubsampling, params.colorPrimaries, params.colorTrc, params.colorSpace, params.fullRangeFlag);
        }
        else if (profile !== avutil_constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE && level !== avutil_constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE) {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%02d.%02d.08.00', entry, profile, level);
        }
        else {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%s.%02d.%02d.08.00', entry, 0, 40);
        }
    }
    else {
        codec = entry || 'unknown';
    }
    return codec;
}


/***/ }),

/***/ "./src/avcodec/subtitle/SubtitleDecoder.ts":
/*!*************************************************!*\
  !*** ./src/avcodec/subtitle/SubtitleDecoder.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SubtitleDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var _decoder_WebVttDecoder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./decoder/WebVttDecoder */ "./src/avcodec/subtitle/decoder/WebVttDecoder.ts");
/* harmony import */ var _decoder_AssDecoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./decoder/AssDecoder */ "./src/avcodec/subtitle/decoder/AssDecoder.ts");
/* harmony import */ var _decoder_TtmlDecoder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./decoder/TtmlDecoder */ "./src/avcodec/subtitle/decoder/TtmlDecoder.ts");
/* harmony import */ var _decoder_TimedTextDecoder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./decoder/TimedTextDecoder */ "./src/avcodec/subtitle/decoder/TimedTextDecoder.ts");
/* harmony import */ var _decoder_TextDecoder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./decoder/TextDecoder */ "./src/avcodec/subtitle/decoder/TextDecoder.ts");







class SubtitleDecoder {
    options;
    frame;
    decoder;
    constructor(options) {
        this.options = options;
    }
    getAVFrame() {
        if (this.frame) {
            return this.frame;
        }
        return this.frame = {
            pts: BigInt(0),
            duration: BigInt(0),
            rects: [],
            timeBase: {
                den: 1,
                num: 1
            }
        };
    }
    outputAVFrame() {
        if (this.frame) {
            if (this.options.onReceiveSubtitle) {
                this.options.onReceiveSubtitle(this.frame);
            }
            this.frame = null;
        }
    }
    receiveAVFrame() {
        return this.decoder.receiveAVFrame(this.getAVFrame());
    }
    async open(parameters) {
        switch (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4)) {
            case 94226 /* AVCodecID.AV_CODEC_ID_WEBVTT */:
                this.decoder = new _decoder_WebVttDecoder__WEBPACK_IMPORTED_MODULE_2__["default"]();
                break;
            // case AVCodecID.AV_CODEC_ID_SUBRIP:
            //   this.decoder = new SubRipDecoder()
            //   break
            case 94232 /* AVCodecID.AV_CODEC_ID_TTML */:
                this.decoder = new _decoder_TtmlDecoder__WEBPACK_IMPORTED_MODULE_4__["default"]();
                break;
            case 94210 /* AVCodecID.AV_CODEC_ID_TEXT */:
            case 94225 /* AVCodecID.AV_CODEC_ID_SUBRIP */:
                this.decoder = new _decoder_TextDecoder__WEBPACK_IMPORTED_MODULE_6__["default"]();
                break;
            case 94213 /* AVCodecID.AV_CODEC_ID_MOV_TEXT */:
                this.decoder = new _decoder_TimedTextDecoder__WEBPACK_IMPORTED_MODULE_5__["default"]();
                break;
            case 94212 /* AVCodecID.AV_CODEC_ID_SSA */:
            case 94230 /* AVCodecID.AV_CODEC_ID_ASS */:
                this.decoder = new _decoder_AssDecoder__WEBPACK_IMPORTED_MODULE_3__["default"]();
                break;
            default:
                return avutil_error__WEBPACK_IMPORTED_MODULE_1__.CODEC_NOT_SUPPORT;
        }
        return 0;
    }
    decode(avpacket) {
        let ret = this.decoder.sendAVPacket(avpacket);
        if (ret) {
            return ret;
        }
        while (true) {
            ret = this.receiveAVFrame();
            if (ret === 1) {
                this.outputAVFrame();
            }
            else if (ret < 0) {
                return ret;
            }
            else {
                break;
            }
        }
        return 0;
    }
    async flush() {
        this.decoder.flush();
        while (1) {
            const ret = this.receiveAVFrame();
            if (ret < 1) {
                return;
            }
            this.outputAVFrame();
        }
    }
    close() {
        if (this.frame) {
            this.frame = null;
        }
    }
}


/***/ }),

/***/ "./src/avcodec/subtitle/decoder/AssDecoder.ts":
/*!****************************************************!*\
  !*** ./src/avcodec/subtitle/decoder/AssDecoder.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _Decoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Decoder */ "./src/avcodec/subtitle/decoder/Decoder.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");




class TextDecoder extends _Decoder__WEBPACK_IMPORTED_MODULE_1__["default"] {
    queue;
    constructor() {
        super();
        this.queue = [];
    }
    sendAVPacket(avpacket) {
        this.queue.push({
            data: (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_2__.getAVPacketData)(avpacket).slice(),
            pts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8),
            duration: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 48),
            timeBase: {
                den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 76),
                num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 72)
            }
        });
        return 0;
    }
    receiveAVFrame(sub) {
        if (this.queue.length) {
            const item = this.queue.shift();
            sub.pts = item.pts;
            sub.duration = item.duration;
            sub.timeBase.den = item.timeBase.den;
            sub.timeBase.num = item.timeBase.num;
            let line = common_util_text__WEBPACK_IMPORTED_MODULE_3__.decode(item.data);
            if (!/^\w+?\s*:/.test(line)) {
                line = 'Dialogue: ' + line;
            }
            sub.rects.push({
                type: 3 /* AVSubtitleType.SUBTITLE_ASS */,
                text: line,
                flags: 0
            });
            return 1;
        }
        return 0;
    }
    flush() {
        return 0;
    }
}


/***/ }),

/***/ "./src/avcodec/subtitle/decoder/Decoder.ts":
/*!*************************************************!*\
  !*** ./src/avcodec/subtitle/decoder/Decoder.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Decoder)
/* harmony export */ });
class Decoder {
}


/***/ }),

/***/ "./src/avcodec/subtitle/decoder/TextDecoder.ts":
/*!*****************************************************!*\
  !*** ./src/avcodec/subtitle/decoder/TextDecoder.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _Decoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Decoder */ "./src/avcodec/subtitle/decoder/Decoder.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");




class TextDecoder extends _Decoder__WEBPACK_IMPORTED_MODULE_1__["default"] {
    queue;
    constructor() {
        super();
        this.queue = [];
    }
    sendAVPacket(avpacket) {
        this.queue.push({
            data: (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_2__.getAVPacketData)(avpacket).slice(),
            pts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8),
            duration: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 48),
            timeBase: {
                den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 76),
                num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 72)
            }
        });
        return 0;
    }
    receiveAVFrame(sub) {
        if (this.queue.length) {
            const item = this.queue.shift();
            sub.pts = item.pts;
            sub.duration = item.duration;
            sub.timeBase.den = item.timeBase.den;
            sub.timeBase.num = item.timeBase.num;
            sub.rects.push({
                type: 1 /* AVSubtitleType.SUBTITLE_TEXT */,
                text: common_util_text__WEBPACK_IMPORTED_MODULE_3__.decode(item.data),
                flags: 0
            });
            return 1;
        }
        return 0;
    }
    flush() {
        return 0;
    }
}


/***/ }),

/***/ "./src/avcodec/subtitle/decoder/TimedTextDecoder.ts":
/*!**********************************************************!*\
  !*** ./src/avcodec/subtitle/decoder/TimedTextDecoder.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TimedTextDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _Decoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Decoder */ "./src/avcodec/subtitle/decoder/Decoder.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avcodec\\subtitle\\decoder\\TimedTextDecoder.ts";





class TimedTextDecoder extends _Decoder__WEBPACK_IMPORTED_MODULE_1__["default"] {
    queue;
    constructor() {
        super();
        this.queue = [];
    }
    sendAVPacket(avpacket) {
        const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_2__.getAVPacketData)(avpacket).slice();
        if (data.length < 2) {
            return 0;
        }
        const length = (data[0] << 8) | data[1];
        if (length + 2 > data.length) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_4__.warn(`invalid timed text data, need ${length + 2} but got ${data.length}, ignore it`, cheap__fileName__0, 59);
            return 0;
        }
        const context = common_util_text__WEBPACK_IMPORTED_MODULE_3__.decode(data.subarray(2, 2 + length));
        this.queue.push({
            text: context,
            pts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8),
            duration: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 48),
            timeBase: {
                den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 76),
                num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 72)
            }
        });
        return 0;
    }
    receiveAVFrame(sub) {
        if (this.queue.length) {
            const item = this.queue.shift();
            sub.pts = item.pts;
            sub.duration = item.duration;
            sub.timeBase.den = item.timeBase.den;
            sub.timeBase.num = item.timeBase.num;
            sub.rects.push({
                type: 1 /* AVSubtitleType.SUBTITLE_TEXT */,
                text: item.text,
                flags: 0
            });
            return 1;
        }
        return 0;
    }
    flush() {
        return 0;
    }
}


/***/ }),

/***/ "./src/avcodec/subtitle/decoder/TtmlDecoder.ts":
/*!*****************************************************!*\
  !*** ./src/avcodec/subtitle/decoder/TtmlDecoder.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TtmlDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _Decoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Decoder */ "./src/avcodec/subtitle/decoder/Decoder.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avformat_formats_ttml_ittml__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avformat/formats/ttml/ittml */ "./src/avformat/formats/ttml/ittml.ts");






class TtmlDecoder extends _Decoder__WEBPACK_IMPORTED_MODULE_1__["default"] {
    queue;
    constructor() {
        super();
        this.queue = [];
    }
    sendAVPacket(avpacket) {
        let context = common_util_text__WEBPACK_IMPORTED_MODULE_2__.decode((0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.getAVPacketData)(avpacket));
        if (!context) {
            return 0;
        }
        if (/<tt/.test(context.trim())) {
            this.queue = this.queue.concat(avformat_formats_ttml_ittml__WEBPACK_IMPORTED_MODULE_5__.parse(context).queue);
        }
        else {
            this.queue.push({
                pts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8),
                duration: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 48),
                context,
                region: 'Default'
            });
        }
        return 0;
    }
    receiveAVFrame(sub) {
        if (this.queue.length) {
            const item = this.queue.shift();
            sub.pts = item.pts;
            sub.duration = item.duration;
            sub.timeBase.den = avutil_constant__WEBPACK_IMPORTED_MODULE_4__.AV_MILLI_TIME_BASE;
            sub.timeBase.num = 1;
            sub.rects.push({
                type: 2 /* AVSubtitleType.SUBTITLE_WEBVTT */,
                text: item.context,
                flags: 0
            });
            return 1;
        }
        return 0;
    }
    flush() {
        return 0;
    }
}


/***/ }),

/***/ "./src/avcodec/subtitle/decoder/WebVttDecoder.ts":
/*!*******************************************************!*\
  !*** ./src/avcodec/subtitle/decoder/WebVttDecoder.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebVttDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _Decoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Decoder */ "./src/avcodec/subtitle/decoder/Decoder.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var common_util_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/time */ "./src/common/util/time.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");






class WebVttDecoder extends _Decoder__WEBPACK_IMPORTED_MODULE_1__["default"] {
    queue;
    constructor() {
        super();
        this.queue = [];
    }
    findTimelineTag(constant) {
        const start = constant.indexOf('<');
        if (start >= 0) {
            const end = constant.indexOf('>', start);
            if (end > start) {
                if (/^(\d{2,}:)?\d{2}:\d{2}\.\d{1,3}$/.test(constant.substring(start + 1, end))) {
                    return {
                        start,
                        end
                    };
                }
            }
        }
        return {
            start: -1,
            end: -1,
        };
    }
    sendAVPacket(avpacket) {
        let context = common_util_text__WEBPACK_IMPORTED_MODULE_2__.decode((0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.getAVPacketData)(avpacket));
        let startPts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8);
        const endPts = startPts + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 48);
        const cache = [];
        while (true) {
            const { start, end } = this.findTimelineTag(context);
            if (start < 0) {
                break;
            }
            const pts = (0,common_util_time__WEBPACK_IMPORTED_MODULE_4__.hhColonDDColonSSDotMill2Int64)(context.substring(start + 1, end));
            cache.push(context.substring(0, start));
            this.queue.push({
                context: cache.join(''),
                pts: startPts,
                duration: pts - startPts,
                timeBase: {
                    den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 76),
                    num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 72)
                }
            });
            startPts = pts;
            context = context.substring(end + 1);
        }
        cache.push(context);
        this.queue.push({
            context: cache.join(''),
            pts: startPts,
            duration: endPts - startPts,
            timeBase: {
                den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 76),
                num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 72)
            }
        });
        return 0;
    }
    receiveAVFrame(sub) {
        if (this.queue.length) {
            const item = this.queue.shift();
            sub.pts = item.pts;
            sub.duration = item.duration;
            sub.timeBase.den = avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE;
            sub.timeBase.num = 1;
            sub.rects.push({
                type: 2 /* AVSubtitleType.SUBTITLE_WEBVTT */,
                text: item.context,
                flags: 0
            });
            return 1;
        }
        return 0;
    }
    flush() {
        return 0;
    }
}


/***/ }),

/***/ "./src/avcodec/wasmcodec/AudioDecoder.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/wasmcodec/AudioDecoder.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WasmAudioDecoder)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var avutil_struct_avdict__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/struct/avdict */ "./src/avutil/struct/avdict.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/util/avdict */ "./src/avutil/util/avdict.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
var cheap__fileName__1 = "src\\avcodec\\wasmcodec\\AudioDecoder.ts";










class WasmAudioDecoder {
    options;
    decoder;
    frame;
    decoderOptions = 0;
    constructor(options) {
        this.options = options;
        this.decoder = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_1__["default"](options.resource);
    }
    getAVFrame() {
        if (this.frame) {
            return this.frame;
        }
        return this.frame = this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__.createAVFrame)();
    }
    outputAVFrame() {
        if (this.frame) {
            if (this.options.onReceiveFrame) {
                this.options.onReceiveFrame(this.frame);
            }
            else {
                this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__.destroyAVFrame)(this.frame);
            }
            this.frame = 0;
        }
    }
    receiveAVFrame() {
        return this.decoder.call('decoder_receive', this.getAVFrame());
    }
    async open(parameters, opts = {}) {
        await this.decoder.run();
        if (common_util_object__WEBPACK_IMPORTED_MODULE_6__.keys(opts).length) {
            if (this.decoderOptions) {
                avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__.freeAVDict2(this.decoderOptions);
                cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.decoderOptions);
                this.decoderOptions = 0;
            }
            this.decoderOptions = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMallocz)(8);
            common_util_object__WEBPACK_IMPORTED_MODULE_6__.each(opts, (value, key) => {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_8__.string(value) || common_util_is__WEBPACK_IMPORTED_MODULE_8__.string(key)) {
                    avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__.avDictSet(this.decoderOptions, key, value);
                }
            });
        }
        let ret = 0;
        if (common_util_support__WEBPACK_IMPORTED_MODULE_4__["default"].jspi) {
            ret = await this.decoder.callAsync('decoder_open', parameters, 0, 1, this.decoderOptions);
        }
        else {
            ret = this.decoder.call('decoder_open', parameters, 0, 1, this.decoderOptions);
            await this.decoder.childrenThreadReady();
        }
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_3__.fatal(`open audio decoder failed, ret: ${ret}`, cheap__fileName__1, 113);
        }
    }
    decode(avpacket) {
        let ret = this.decoder.call('decoder_decode', avpacket);
        if (ret) {
            return ret;
        }
        while (true) {
            ret = this.receiveAVFrame();
            if (ret === 1) {
                this.outputAVFrame();
            }
            else if (ret < 0) {
                return ret;
            }
            else {
                break;
            }
        }
        return 0;
    }
    async flush() {
        this.decoder.call('decoder_flush');
        while (1) {
            const ret = this.receiveAVFrame();
            if (ret < 1) {
                return;
            }
            this.outputAVFrame();
        }
    }
    close() {
        this.decoder.call('decoder_close');
        this.decoder.destroy();
        this.decoder = null;
        if (this.frame) {
            this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__.destroyAVFrame)(this.frame);
            this.frame = 0;
        }
        if (this.decoderOptions) {
            avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__.freeAVDict2(this.decoderOptions);
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.decoderOptions);
            this.decoderOptions = 0;
        }
    }
}


/***/ }),

/***/ "./src/avcodec/wasmcodec/VideoDecoder.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/wasmcodec/VideoDecoder.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WasmVideoDecoder)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var avutil_struct_avdict__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/struct/avdict */ "./src/avutil/struct/avdict.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/util/avdict */ "./src/avutil/util/avdict.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
var cheap__fileName__1 = "src\\avcodec\\wasmcodec\\VideoDecoder.ts";










class WasmVideoDecoder {
    options;
    decoder;
    frame;
    parameters;
    decoderOptions = 0;
    constructor(options) {
        this.options = options;
        this.decoder = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_1__["default"](this.options.resource);
    }
    getAVFrame() {
        if (this.frame) {
            return this.frame;
        }
        return this.frame = this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__.createAVFrame)();
    }
    outputAVFrame() {
        if (this.frame) {
            if (this.options.onReceiveFrame) {
                this.options.onReceiveFrame(this.frame);
            }
            else {
                this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__.destroyAVFrame)(this.frame);
            }
            this.frame = 0;
        }
    }
    receiveAVFrame() {
        return this.decoder.call('decoder_receive', this.getAVFrame());
    }
    async open(parameters, threadCount = 1, opts = {}) {
        await this.decoder.run(null, threadCount);
        let ret = 0;
        if (common_util_object__WEBPACK_IMPORTED_MODULE_6__.keys(opts).length) {
            if (this.decoderOptions) {
                avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__.freeAVDict2(this.decoderOptions);
                cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.decoderOptions);
                this.decoderOptions = 0;
            }
            this.decoderOptions = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMallocz)(8);
            common_util_object__WEBPACK_IMPORTED_MODULE_6__.each(opts, (value, key) => {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_8__.string(value) || common_util_is__WEBPACK_IMPORTED_MODULE_8__.string(key)) {
                    avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__.avDictSet(this.decoderOptions, key, value);
                }
            });
        }
        if (common_util_support__WEBPACK_IMPORTED_MODULE_4__["default"].jspi) {
            ret = await this.decoder.callAsync('decoder_open', parameters, 0, threadCount, this.decoderOptions);
        }
        else {
            ret = this.decoder.call('decoder_open', parameters, 0, threadCount, this.decoderOptions);
            await this.decoder.childrenThreadReady();
        }
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_3__.fatal(`open video decoder failed, ret: ${ret}`, cheap__fileName__1, 151);
        }
        this.parameters = parameters;
        await this.decoder.childrenThreadReady();
    }
    decode(avpacket) {
        let ret = this.decoder.call('decoder_decode', avpacket);
        if (ret) {
            return ret;
        }
        while (true) {
            ret = this.receiveAVFrame();
            if (ret === 1) {
                this.outputAVFrame();
            }
            else if (ret < 0) {
                return ret;
            }
            else {
                break;
            }
        }
        return 0;
    }
    async flush() {
        this.decoder.call('decoder_flush');
        while (1) {
            const ret = this.receiveAVFrame();
            if (ret < 1) {
                return;
            }
            this.outputAVFrame();
        }
    }
    close() {
        this.decoder.call('decoder_close');
        this.decoder.destroy();
        this.decoder = null;
        if (this.frame) {
            this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__.destroyAVFrame)(this.frame);
            this.frame = 0;
        }
        this.parameters = 0;
        if (this.decoderOptions) {
            avutil_util_avdict__WEBPACK_IMPORTED_MODULE_7__.freeAVDict2(this.decoderOptions);
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.decoderOptions);
            this.decoderOptions = 0;
        }
    }
    setSkipFrameDiscard(discard) {
        this.decoder.call('decoder_discard', discard);
    }
}


/***/ }),

/***/ "./src/avcodec/webcodec/AudioDecoder.ts":
/*!**********************************************!*\
  !*** ./src/avcodec/webcodec/AudioDecoder.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebAudioDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _function_getAudioCodec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/getAudioCodec */ "./src/avcodec/function/getAudioCodec.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_function_avpacket2EncodedAudioChunk__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/function/avpacket2EncodedAudioChunk */ "./src/avutil/function/avpacket2EncodedAudioChunk.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__9 = "src\\avcodec\\webcodec\\AudioDecoder.ts";






class WebAudioDecoder {
    options;
    decoder;
    parameters;
    extradata;
    currentError;
    constructor(options) {
        this.options = options;
    }
    output(frame) {
        if (this.options.onReceiveFrame) {
            this.options.onReceiveFrame(frame);
        }
        else {
            frame.close();
        }
    }
    error(error) {
        this.currentError = error;
        this.options.onError(error);
    }
    async open(parameters) {
        this.currentError = null;
        this.parameters = parameters;
        this.extradata = null;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12) !== 0) {
            this.extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 16)).slice();
        }
        const config = {
            codec: (0,_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_1__["default"])(this.parameters),
            sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 136),
            numberOfChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 116),
            description: this.extradata
        };
        if (!config.description) {
            // description  arraybuffer 
            delete config.description;
        }
        const support = await AudioDecoder.isConfigSupported(config);
        if (!support.supported) {
            throw new Error('not support');
        }
        if (this.decoder && this.decoder.state !== 'closed') {
            this.decoder.close();
        }
        this.decoder = new AudioDecoder({
            output: this.output.bind(this),
            error: this.error.bind(this)
        });
        this.decoder.reset();
        this.decoder.configure(config);
        if (this.currentError) {
            throw this.currentError;
        }
    }
    changeExtraData(buffer) {
        if (buffer.length === this.extradata.length) {
            let same = true;
            for (let i = 0; i < buffer.length; i++) {
                if (buffer[i] !== this.extradata[i]) {
                    same = false;
                    break;
                }
            }
            if (same) {
                return;
            }
        }
        this.extradata = buffer.slice();
        this.decoder.reset();
        this.decoder.configure({
            codec: (0,_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_1__["default"])(this.parameters),
            sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.parameters + 136),
            numberOfChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.parameters + 116),
            description: this.extradata
        });
        if (this.currentError) {
            throw this.currentError;
        }
    }
    decode(avpacket, pts) {
        const element = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */);
        if (element !== 0) {
            this.changeExtraData((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](element), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](element + 4)));
        }
        const audioChunk = (0,avutil_function_avpacket2EncodedAudioChunk__WEBPACK_IMPORTED_MODULE_4__["default"])(avpacket, pts);
        try {
            this.decoder.decode(audioChunk);
        }
        catch (error) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`decode error, ${error}`, cheap__fileName__9, 155);
            return -1;
        }
        return 0;
    }
    async flush() {
        await this.decoder.flush();
    }
    close() {
        if (this.decoder.state !== 'closed') {
            this.decoder.close();
        }
        this.decoder = null;
    }
    getQueueLength() {
        return this.decoder.decodeQueueSize;
    }
    static async isSupported(parameters) {
        let extradata = null;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12) !== 0) {
            extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 16)).slice();
        }
        const config = {
            codec: (0,_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_1__["default"])(parameters),
            sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 136),
            numberOfChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 116),
            description: extradata
        };
        if (!config.description) {
            // description  arraybuffer 
            delete config.description;
        }
        const support = await AudioDecoder.isConfigSupported(config);
        return support.supported;
    }
}


/***/ }),

/***/ "./src/avcodec/webcodec/VideoDecoder.ts":
/*!**********************************************!*\
  !*** ./src/avcodec/webcodec/VideoDecoder.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebVideoDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var _function_getVideoCodec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/getVideoCodec */ "./src/avcodec/function/getVideoCodec.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../function/getHardwarePreference */ "./src/avcodec/function/getHardwarePreference.ts");
/* harmony import */ var avutil_function_avpacket2EncodedVideoChunk__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/function/avpacket2EncodedVideoChunk */ "./src/avutil/function/avpacket2EncodedVideoChunk.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__10 = "src\\avcodec\\webcodec\\VideoDecoder.ts";








class WebVideoDecoder {
    decoder;
    options;
    parameters;
    extradata;
    currentError;
    inputQueue;
    outputQueue;
    sort;
    keyframeRequire;
    constructor(options) {
        this.options = options;
        this.inputQueue = [];
        this.outputQueue = [];
        this.sort = common_util_browser__WEBPACK_IMPORTED_MODULE_1__["default"].safari;
    }
    async output(frame) {
        if (this.sort) {
            let i = 0;
            for (; i < this.outputQueue.length; i++) {
                if (this.outputQueue[i].timestamp > frame.timestamp) {
                    this.outputQueue.splice(i, 0, frame);
                    break;
                }
            }
            if (i === this.outputQueue.length) {
                this.outputQueue.push(frame);
            }
            while (this.outputQueue.length > 2
                && this.outputQueue[0].timestamp === this.inputQueue[0]) {
                const output = this.outputQueue.shift();
                if (this.options.onReceiveFrame) {
                    this.options.onReceiveFrame(output);
                }
                else {
                    output.close();
                }
                this.inputQueue.shift();
            }
        }
        else {
            if (this.options.onReceiveFrame) {
                this.options.onReceiveFrame(frame);
            }
            else {
                frame.close();
            }
        }
    }
    error(error) {
        this.currentError = error;
        this.options.onError(error);
    }
    changeExtraData(buffer) {
        if (buffer.length === this.extradata.length) {
            let same = true;
            for (let i = 0; i < buffer.length; i++) {
                if (buffer[i] !== this.extradata[i]) {
                    same = false;
                    break;
                }
            }
            if (same) {
                return;
            }
        }
        this.extradata = buffer.slice();
        this.decoder.reset();
        this.decoder.configure({
            codec: (0,_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_2__["default"])(this.parameters, buffer),
            description: this.extradata,
            hardwareAcceleration: (0,_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_5__.getHardwarePreference)(this.options.enableHardwareAcceleration ?? true)
        });
        this.keyframeRequire = true;
    }
    async open(parameters) {
        this.currentError = null;
        this.extradata = null;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12) !== 0) {
            this.extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 16)).slice();
        }
        this.parameters = parameters;
        const config = {
            codec: (0,_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_2__["default"])(parameters),
            codedWidth: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 56),
            codedHeight: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 60),
            description: (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 160) !== 2 /* BitFormat.ANNEXB */) ? this.extradata : undefined,
            hardwareAcceleration: (0,_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_5__.getHardwarePreference)(this.options.enableHardwareAcceleration ?? true)
        };
        if (!config.description) {
            // description  arraybuffer 
            delete config.description;
        }
        const support = await VideoDecoder.isConfigSupported(config);
        if (!support.supported) {
            throw new Error('not support');
        }
        if (this.decoder && this.decoder.state !== 'closed') {
            this.decoder.close();
        }
        this.decoder = new VideoDecoder({
            output: this.output.bind(this),
            error: this.error.bind(this)
        });
        this.decoder.reset();
        this.decoder.configure(config);
        if (this.currentError) {
            throw this.currentError;
        }
        this.keyframeRequire = true;
        this.inputQueue.length = 0;
        this.outputQueue.length = 0;
    }
    decode(avpacket) {
        const element = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_4__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */);
        if (element !== 0) {
            this.changeExtraData((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](element), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](element + 4)));
        }
        const key = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */;
        if (this.keyframeRequire && !key) {
            return 0;
        }
        const timestamp = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8));
        const videoChunk = (0,avutil_function_avpacket2EncodedVideoChunk__WEBPACK_IMPORTED_MODULE_6__["default"])(avpacket);
        if (this.sort) {
            let i = 0;
            for (; i < this.inputQueue.length; i++) {
                if (this.inputQueue[i] > timestamp) {
                    this.inputQueue.splice(i, 0, timestamp);
                    break;
                }
            }
            if (i === this.inputQueue.length) {
                this.inputQueue.push(timestamp);
            }
        }
        try {
            this.decoder.decode(videoChunk);
        }
        catch (error) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.error(`decode error, ${error}`, cheap__fileName__10, 223);
            return -1;
        }
        if (key) {
            this.keyframeRequire = false;
        }
        return 0;
    }
    async flush() {
        await this.decoder.flush();
        if (this.sort) {
            while (this.outputQueue.length) {
                const frame = this.outputQueue.shift();
                if (this.options.onReceiveFrame) {
                    this.options.onReceiveFrame(frame);
                }
                else {
                    frame.close();
                }
            }
        }
        this.keyframeRequire = true;
    }
    close() {
        if (this.decoder && this.decoder.state !== 'closed') {
            this.decoder.close();
        }
        this.decoder = null;
        this.currentError = null;
        if (this.outputQueue?.length) {
            this.outputQueue.forEach((frame) => {
                frame.close();
            });
        }
        this.inputQueue = null;
        this.outputQueue = null;
    }
    getQueueLength() {
        return this.decoder.decodeQueueSize;
    }
    setSkipFrameDiscard(discard) {
    }
    static async isSupported(parameters, enableHardwareAcceleration) {
        let extradata = null;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12) !== 0) {
            extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 16)).slice();
        }
        const config = {
            codec: (0,_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_2__["default"])(parameters),
            codedWidth: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 56),
            codedHeight: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 60),
            description: (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 160) !== 2 /* BitFormat.ANNEXB */) ? extradata : undefined,
            hardwareAcceleration: (0,_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_5__.getHardwarePreference)(enableHardwareAcceleration ?? true)
        };
        if (!config.description) {
            // description  arraybuffer 
            delete config.description;
        }
        const support = await VideoDecoder.isConfigSupported(config);
        return support.supported;
    }
}


/***/ }),

/***/ "./src/avformat/AVFormatContext.ts":
/*!*****************************************!*\
  !*** ./src/avformat/AVFormatContext.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVFormatContext: () => (/* binding */ AVFormatContext),
/* harmony export */   createAVIFormatContext: () => (/* binding */ createAVIFormatContext),
/* harmony export */   createAVOFormatContext: () => (/* binding */ createAVOFormatContext)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _AVStream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AVStream */ "./src/avformat/AVStream.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var cheap_staticData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/staticData */ "./src/cheap/staticData.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");






//  stream 
const streamCounter = cheap_staticData__WEBPACK_IMPORTED_MODULE_4__.malloc(4, 4);
const streamCounterMutex = cheap_staticData__WEBPACK_IMPORTED_MODULE_4__.malloc(4, 4);
class AVFormatContextInterval {
    packetBuffer;
    constructor() {
        this.packetBuffer = [];
    }
}
class AVFormatContext {
    metadataHeaderPadding = -1;
    metadata;
    streams;
    options;
    chapters;
    privateData;
    processPrivateData;
    iformat;
    oformat;
    // @ts-ignore
    ioReader;
    ioWriter;
    errorFlag;
    interval;
    streamIndex;
    getDecoderResource = null;
    constructor() {
        this.streams = [];
        this.errorFlag = 0;
        this.streamIndex = 0;
        this.interval = new AVFormatContextInterval();
        this.options = {};
        this.privateData = {};
        this.metadata = {};
        this.chapters = [];
    }
    get format() {
        if (this.iformat) {
            return this.iformat.type;
        }
        else if (this.oformat) {
            return this.oformat.type;
        }
        return -1 /* AVFormat.UNKNOWN */;
    }
    getStreamById(id) {
        return this.streams.find((stream) => stream.id === id);
    }
    getStreamByIndex(index) {
        return this.streams.find((stream) => stream.index === index);
    }
    getStreamByMediaType(mediaType) {
        return this.streams.find((stream) => stream.codecpar?.codecType === mediaType);
    }
    createStream() {
        const stream = new _AVStream__WEBPACK_IMPORTED_MODULE_2__["default"]();
        stream.index = this.streamIndex++;
        {
            (0,cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_5__.lock)(streamCounterMutex);
        }
        stream.id = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](streamCounter);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](streamCounter, stream.id + 1);
        {
            (0,cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_5__.unlock)(streamCounterMutex);
        }
        this.removeStreamByIndex(stream.index);
        this.streams.push(stream);
        return stream;
    }
    addStream(stream) {
        this.removeStreamByIndex(stream.index);
        this.streams.push(stream);
    }
    removeStream(stream) {
        this.removeStreamByIndex(stream.index);
    }
    removeStreamById(id) {
        const index = this.streams.findIndex((stream) => stream.id === id);
        if (index > -1) {
            const st = this.streams.splice(index, 1);
            if (st[0]) {
                st[0].destroy();
            }
        }
    }
    removeStreamByIndex(i) {
        const index = this.streams.findIndex((stream) => stream.index === i);
        if (index > -1) {
            const st = this.streams.splice(index, 1);
            if (st[0]) {
                st[0].destroy();
            }
        }
    }
    destroy() {
        if (this.oformat) {
            this.oformat.destroy(this);
        }
        if (this.iformat) {
            this.iformat.destroy(this);
        }
        if (this.interval.packetBuffer.length) {
            this.interval.packetBuffer.forEach((avpacket) => {
                (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(avpacket);
            });
        }
        this.streams.forEach((stream) => {
            stream.destroy();
        });
        this.streams = [];
        this.interval = null;
        this.ioReader = this.ioWriter = null;
        this.oformat = this.iformat = null;
    }
}
/**
 *  AVIFormatContext
 *
 * @returns
 */
function createAVIFormatContext() {
    return new AVFormatContext();
}
/**
 *  AVOFormatContext
 *
 * @returns
 */
function createAVOFormatContext() {
    return new AVFormatContext();
}


/***/ }),

/***/ "./src/avformat/AVStream.ts":
/*!**********************************!*\
  !*** ./src/avformat/AVStream.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVStream)
/* harmony export */ });
/* harmony import */ var _avutil_struct_avcodecparameters_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/struct/avcodecparameters */ "./src/avutil/struct/avcodecparameters.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");






/**
 * from FFmpeg
 *
 */
class AVStream {
    /**
     * stream index in AVFormatContext
     */
    index = avutil_constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE;
    /**
     * Format-specific stream ID.
     * decoding: set by libavformat
     * encoding: set by the user, replaced by libavformat if left unset
     */
    id = avutil_constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE;
    privData = null;
    codecpar = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_1__["default"])(new _avutil_struct_avcodecparameters_ts__WEBPACK_IMPORTED_MODULE_0__["default"](), _avutil_struct_avcodecparameters_ts__WEBPACK_IMPORTED_MODULE_0__["default"]);
    /**
     * An array of side data that applies to the whole stream (i.e. the
     * container does not allow it to change between packets).
     *
     * There may be no overlap between the side data in this array and side data
     * in the packets. I.e. a given side data is either exported by the muxer
     * (demuxing) / set by the caller (muxing) in this array, then it never
     * appears in the packets, or the side data is exported / sent through
     * the packets (always in the first packet where the value becomes known or
     * changes), then it does not appear in this array.
     *
     * - demuxing: Set by libavformat when the stream is created.
     * - muxing: May be set by the caller before write_header().
     *
     */
    sideData = {};
    /**
     * number of frames in this stream if known or 0
     */
    nbFrames = BigInt(0);
    metadata = {};
    /**
     * Decoding: duration of the stream, in stream time base.
     * If a source file does not specify a duration, but does specify
     * a bitrate, this value will be estimated from bitrate and file size.
     *
     * Encoding: May be set by the caller before avformat_write_header() to
     * provide a hint to the muxer about the estimated duration.
     */
    duration = avutil_constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT;
    /**
     * Decoding: pts of the first frame of the stream in presentation order, in stream time base.
     * Only set this if you are absolutely 100% sure that the value you set
     * it to really is the pts of the first frame.
     * This may be undefined (AV_NOPTS_VALUE).
     * @note The ASF header does NOT contain a correct start_time the ASF
     * demuxer must NOT set this.
     */
    startTime = avutil_constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT;
    /**
     *  packet  dts
     */
    firstDTS = BigInt(0);
    /**
     * AV_DISPOSITION_* bit field
     */
    disposition = 0 /* AVDisposition.NONE */;
    /**
     *
     * 
     *
     * decoding: set by libavformat
     * encoding: May be set by the caller before avformat_write_header() to
     *           provide a hint to the muxer about the desired timebase. In
     *           avformat_write_header(), the muxer will overwrite this field
     *           with the timebase that will actually be used for the timestamps
     *           written into the file (which may or may not be related to the
     *           user-provided one, depending on the format).
     */
    timeBase = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_1__["default"])(_avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational);
    /**
     *  seek
     */
    sampleIndexes = [];
    /**
     * pos  sample index 
     */
    sampleIndexesPosMap = new Map();
    destroy() {
        if (this.codecpar) {
            this.codecpar.destroy();
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_3__["default"])(this.codecpar);
            this.codecpar = null;
        }
        if (this.timeBase) {
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_3__["default"])(this.timeBase);
            this.timeBase = null;
        }
        this.sampleIndexes.length = 0;
        this.sampleIndexesPosMap.clear();
    }
}


/***/ }),

/***/ "./src/avformat/bsf/AVBSFilter.ts":
/*!****************************************!*\
  !*** ./src/avformat/bsf/AVBSFilter.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVBSFilter)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avutil_struct_avcodecparameters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/struct/avcodecparameters */ "./src/avutil/struct/avcodecparameters.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/codecparameters */ "./src/avutil/util/codecparameters.ts");




class AVBSFilter {
    inCodecpar;
    inTimeBase;
    outCodecpar;
    init(codecpar, timeBase) {
        this.inCodecpar = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__.avMallocz)(168);
        (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_3__.copyCodecParameters)(this.inCodecpar, codecpar);
        this.inTimeBase = {
            den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](timeBase + 4),
            num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](timeBase)
        };
        return 0;
    }
    destroy() {
        if (this.inCodecpar) {
            (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_3__.freeCodecParameters)(this.inCodecpar);
            this.inCodecpar = 0;
        }
    }
}


/***/ }),

/***/ "./src/avformat/bsf/h2645/Annexb2AvccFilter.ts":
/*!*****************************************************!*\
  !*** ./src/avformat/bsf/h2645/Annexb2AvccFilter.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Annexb2AvccFilter)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _AVBSFilter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../AVBSFilter */ "./src/avformat/bsf/AVBSFilter.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _codecs_h264__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../codecs/h264 */ "./src/avformat/codecs/h264.ts");
/* harmony import */ var _codecs_hevc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../codecs/hevc */ "./src/avformat/codecs/hevc.ts");
/* harmony import */ var _codecs_vvc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../codecs/vvc */ "./src/avformat/codecs/vvc.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/nalu */ "./src/avutil/util/nalu.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__6 = "src\\avformat\\bsf\\h2645\\Annexb2AvccFilter.ts";












class Annexb2AvccFilter extends _AVBSFilter__WEBPACK_IMPORTED_MODULE_2__["default"] {
    cache;
    cached;
    init(codecpar, timeBase) {
        super.init(codecpar, timeBase);
        this.cache = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.createAVPacket)();
        this.cached = false;
        return 0;
    }
    destroy() {
        super.destroy();
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(this.cache);
        this.cache = 0;
    }
    sendAVPacket(avpacket) {
        const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.mapSafeUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 80) === 1 /* h264.BitFormat.AVCC */ || !(0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.isAnnexb)(buffer)) {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.refAVPacket)(this.cache, avpacket);
        }
        else {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.copyAVPacketProps)(this.cache, avpacket);
            let convert;
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.inCodecpar + 4) === 27 /* AVCodecID.AV_CODEC_ID_H264 */) {
                convert = _codecs_h264__WEBPACK_IMPORTED_MODULE_4__.annexb2Avcc(buffer);
            }
            else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.inCodecpar + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */) {
                convert = _codecs_hevc__WEBPACK_IMPORTED_MODULE_5__.annexb2Avcc(buffer);
            }
            else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.inCodecpar + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */) {
                convert = _codecs_vvc__WEBPACK_IMPORTED_MODULE_6__.annexb2Avcc(buffer);
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal(`not support for codecId: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.inCodecpar + 4)}`, cheap__fileName__6, 91);
            }
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.cache + 80, 1 /* h264.BitFormat.AVCC */);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.addAVPacketData)(this.cache, convert.bufferPointer, convert.length);
            if (convert.key) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.cache + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.cache + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
            }
            if (convert.extradata) {
                const extradata = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_10__.avMalloc)(convert.extradata.length);
                (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.memcpyFromUint8Array)(extradata, convert.extradata.length, convert.extradata);
                (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.addAVPacketSideData)(this.cache, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradata, convert.extradata.length);
            }
        }
        this.cached = true;
        return 0;
    }
    receiveAVPacket(avpacket) {
        if (this.cached) {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.unrefAVPacket)(avpacket);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.refAVPacket)(avpacket, this.cache);
            this.cached = false;
            return 0;
        }
        else {
            return avutil_error__WEBPACK_IMPORTED_MODULE_8__.DATA_INVALID;
        }
    }
    reset() {
        return 0;
    }
}


/***/ }),

/***/ "./src/avformat/codecs/aac.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/aac.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AACProfile2Name: () => (/* binding */ AACProfile2Name),
/* harmony export */   avCodecParameters2Extradata: () => (/* binding */ avCodecParameters2Extradata),
/* harmony export */   parseADTSHeader: () => (/* binding */ parseADTSHeader),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseLATMHeader: () => (/* binding */ parseLATMHeader)
/* harmony export */ });
/* unused harmony exports MPEG4SamplingFrequencyIndex, MPEG4SamplingFrequencies, MPEG4Channels, getAVCodecParameters */
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/*
 * libmedia aac util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


const AACProfile2Name = {
    [1 /* MPEG4AudioObjectTypes.AAC_MAIN */]: 'Main',
    [2 /* MPEG4AudioObjectTypes.AAC_LC */]: 'LC',
    [3 /* MPEG4AudioObjectTypes.AAC_SSR */]: 'LC',
    [4 /* MPEG4AudioObjectTypes.AAC_LTP */]: 'LC',
    [5 /* MPEG4AudioObjectTypes.AAC_SBR */]: 'HE',
    [6 /* MPEG4AudioObjectTypes.AAC_SCALABLE */]: 'HE'
};
const MPEG4SamplingFrequencyIndex = {
    96000: 0,
    88200: 1,
    64000: 2,
    48000: 3,
    44100: 4,
    32000: 5,
    24000: 6,
    22050: 7,
    16000: 8,
    12000: 9,
    11025: 10,
    8000: 11,
    7350: 12
};
const MPEG4SamplingFrequencies = [
    96000,
    88200,
    64000,
    48000,
    44100,
    32000,
    24000,
    22050,
    16000,
    12000,
    11025,
    8000,
    7350,
    avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
    avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
    avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE
];
const MPEG4Channels = [
    avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
    1,
    2,
    3,
    4,
    5,
    6,
    7
];
/**
 *  AAC AudioSpecificConfig
 *
 *             frequency
 *              44100Hz        fill bit
 *               4 bit          3 bit
 *              -------         -----
 *    0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0
 *    ---------         -------
 *      5 bit            4 bit
 *     AAC LC           fl, fr
 *    profile           channel
 *
 * url: https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Audio_Specific_Config
 *
 */
function getAVCodecParameters(extradata) {
    let profile = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    let sampleRate = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    let channels = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    if (extradata.length >= 2) {
        profile = (extradata[0] >> 3) & 0x1f;
        sampleRate = MPEG4SamplingFrequencies[((extradata[0] & 0x07) << 1)
            | (extradata[1] >> 7)] ?? 48000;
        channels = MPEG4Channels[(extradata[1] >> 3) & 0x0f] ?? 2;
    }
    return {
        profile,
        sampleRate,
        channels
    };
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata) {
        const { profile, sampleRate, channels } = getAVCodecParameters(extradata);
        stream.codecpar.profile = profile;
        stream.codecpar.sampleRate = sampleRate;
        stream.codecpar.chLayout.nbChannels = channels;
    }
}
function avCodecParameters2Extradata(codecpar) {
    const samplingFreqIndex = MPEG4SamplingFrequencyIndex[codecpar.sampleRate];
    const channelConfig = codecpar.chLayout.nbChannels;
    const extradata = new Uint8Array(2);
    extradata[0] = ((codecpar.profile & 0x1f) << 3) | ((samplingFreqIndex & 0x0e) >> 1);
    extradata[1] = ((samplingFreqIndex & 0x01) << 7) | ((channelConfig & 0x0f) << 3);
    return extradata;
}
/**
 *
 * adts  raw
 *
 * bits
 * - 12  syncword
 * - 1   ID (MPEG  1)
 * - 2   Layer (  0)
 * - 1   Protection Absent (  CRC 1 
 * - 2   Profile
 * - 4   Sampling Frequency Index ( 
 * - 1   Private Bit (  0)
 * - 3   Channel Configuration ( 
 * - 1   Original Copy (  0)
 * - 1   Home (  0)
 * - 1   Copyright Identification Bit 0
 * - 1   Copyright Identification Start 0
 * - 13  Frame Length (  ADTS 
 * - 11  Buffer Fullness ( 
 * - 2   Number of Raw Data Blocks in Frame ( 
 * - 16  CRC (Protection Absent 
 * - N  raw aac data
 *
 */
function parseADTSHeader(buffer) {
    if (buffer.length < 7) {
        return -1;
    }
    const syncWord = (buffer[0] << 4) | (buffer[1] >> 4);
    if (syncWord !== 0xFFF) {
        return -1;
    }
    /*
      * const id = (buffer[1] & 0x08) >>> 3
      * const layer = (buffer[1] & 0x06) >>> 1
      */
    const protectionAbsent = buffer[1] & 0x01;
    const profile = (buffer[2] & 0xC0) >>> 6;
    const samplingFrequencyIndex = (buffer[2] & 0x3C) >>> 2;
    const channelConfiguration = ((buffer[2] & 0x01) << 2) | ((buffer[3] & 0xC0) >>> 6);
    // adts_variable_header()
    const aacFrameLength = ((buffer[3] & 0x03) << 11)
        | (buffer[4] << 3)
        | ((buffer[5] & 0xE0) >>> 5);
    const numberOfRawDataBlocksInFrame = buffer[6] & 0x03;
    let headerLength = protectionAbsent === 1 ? 7 : 9;
    let framePayloadLength = aacFrameLength - headerLength;
    return {
        syncWord,
        profile: profile + 1,
        sampleRate: MPEG4SamplingFrequencies[samplingFrequencyIndex],
        channels: MPEG4Channels[channelConfiguration],
        aacFrameLength,
        numberOfRawDataBlocksInFrame,
        headerLength,
        framePayloadLength
    };
}
function parseLATMHeader(buffer, bitReader) {
    if (!bitReader) {
        bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__["default"]();
        bitReader.appendBuffer(buffer);
    }
    function getLATMValue() {
        const bytesForValue = bitReader.readU(2);
        let value = 0;
        for (let i = 0; i <= bytesForValue; i++) {
            value = value << 8;
            value = value | bitReader.readU(8);
        }
        return value;
    }
    const now = bitReader.getPointer();
    const info = {
        syncWord: 0,
        profile: 0,
        sampleRate: 0,
        channels: 0,
        useSameStreamMux: false,
        headerLength: 0,
        framePayloadLength: 0,
        muxLengthBytes: 0
    };
    const syncWord = bitReader.readU(11);
    if (syncWord !== 0x2B7) {
        return -1;
    }
    info.syncWord = syncWord;
    info.muxLengthBytes = bitReader.readU(13);
    const useSameStreamMux = bitReader.readU1() === 0x01;
    info.useSameStreamMux = useSameStreamMux;
    if (!useSameStreamMux) {
        const audioMuxVersion = bitReader.readU1() === 0x01;
        const audioMuxVersionA = audioMuxVersion && bitReader.readU1() === 0x01;
        if (audioMuxVersionA) {
            return -1;
        }
        if (audioMuxVersion) {
            getLATMValue();
        }
        const allStreamsSameTimeFraming = bitReader.readU1() === 0x01;
        if (!allStreamsSameTimeFraming) {
            return -1;
        }
        const numSubFrames = bitReader.readU(6);
        if (numSubFrames !== 0) {
            return -1;
        }
        const numProgram = bitReader.readU(4);
        if (numProgram !== 0) {
            return -1;
        }
        const numLayer = bitReader.readU(3);
        if (numLayer !== 0) {
            return -1;
        }
        let fillBits = audioMuxVersion ? getLATMValue() : 0;
        const audioObjectType = bitReader.readU(5);
        fillBits -= 5;
        const samplingFreqIndex = bitReader.readU(4);
        fillBits -= 4;
        const channelConfig = bitReader.readU(4);
        fillBits -= 4;
        bitReader.readU(3);
        fillBits -= 3;
        if (fillBits > 0) {
            bitReader.readU(fillBits);
        }
        const frameLengthType = bitReader.readU(3);
        if (frameLengthType === 0) {
            bitReader.readU(8);
        }
        else {
            return -1;
        }
        const otherDataPresent = bitReader.readU1() === 0x01;
        if (otherDataPresent) {
            if (audioMuxVersion) {
                getLATMValue();
            }
            else {
                let otherDataLenBits = 0;
                while (true) {
                    otherDataLenBits = otherDataLenBits << 8;
                    const otherDataLenEsc = bitReader.readU1() === 0x01;
                    const otherDataLenTmp = bitReader.readU(8);
                    otherDataLenBits += otherDataLenTmp;
                    if (!otherDataLenEsc) {
                        break;
                    }
                }
            }
        }
        const crcCheckPresent = bitReader.readU1() === 0x01;
        if (crcCheckPresent) {
            bitReader.readU(8);
        }
        info.profile = audioObjectType + 1;
        info.sampleRate = MPEG4SamplingFrequencies[samplingFreqIndex];
        info.channels = MPEG4Channels[channelConfig];
    }
    let length = 0;
    while (true) {
        const tmp = bitReader.readU(8);
        length += tmp;
        if (tmp !== 0xff) {
            break;
        }
    }
    info.framePayloadLength = length;
    info.headerLength = bitReader.getPointer() - now + (bitReader.getBitLeft() === 8 ? 0 : 1);
    return info;
}


/***/ }),

/***/ "./src/avformat/codecs/ac3.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/ac3.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AC3ChannelLayout: () => (/* binding */ AC3ChannelLayout),
/* harmony export */   parseHeader: () => (/* binding */ parseHeader)
/* harmony export */ });
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/*
 * libmedia ac3 util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const AC3ChannelLayout = [
    3 /* AV_CH_LAYOUT.AV_CH_LAYOUT_STEREO */,
    4 /* AV_CH_LAYOUT.AV_CH_LAYOUT_MONO */,
    3 /* AV_CH_LAYOUT.AV_CH_LAYOUT_STEREO */,
    7 /* AV_CH_LAYOUT.AV_CH_LAYOUT_SURROUND */,
    259 /* AV_CH_LAYOUT.AV_CH_LAYOUT_2_1 */,
    263 /* AV_CH_LAYOUT.AV_CH_LAYOUT_4POINT0 */,
    1539 /* AV_CH_LAYOUT.AV_CH_LAYOUT_2_2 */,
    1543 /* AV_CH_LAYOUT.AV_CH_LAYOUT_5POINT0 */
];
const AC3FrameSizeTab = [
    [64, 69, 96],
    [64, 70, 96],
    [80, 87, 120],
    [80, 88, 120],
    [96, 104, 144],
    [96, 105, 144],
    [112, 121, 168],
    [112, 122, 168],
    [128, 139, 192],
    [128, 140, 192],
    [160, 174, 240],
    [160, 175, 240],
    [192, 208, 288],
    [192, 209, 288],
    [224, 243, 336],
    [224, 244, 336],
    [256, 278, 384],
    [256, 279, 384],
    [320, 348, 480],
    [320, 349, 480],
    [384, 417, 576],
    [384, 418, 576],
    [448, 487, 672],
    [448, 488, 672],
    [512, 557, 768],
    [512, 558, 768],
    [640, 696, 960],
    [640, 697, 960],
    [768, 835, 1152],
    [768, 836, 1152],
    [896, 975, 1344],
    [896, 976, 1344],
    [1024, 1114, 1536],
    [1024, 1115, 1536],
    [1152, 1253, 1728],
    [1152, 1254, 1728],
    [1280, 1393, 1920],
    [1280, 1394, 1920],
];
const CenterLevelsTab = [4, 5, 6, 5];
const SurroundLevelsTab = [4, 6, 7, 6];
const AC3SampleRateTab = [48000, 44100, 32000, 0];
const AC3BitrateTab = [
    32, 40, 48, 56, 64, 80, 96, 112, 128,
    160, 192, 224, 256, 320, 384, 448, 512, 576, 640
];
const AC3ChannelsTab = [
    2, 1, 2, 3, 3, 4, 4, 5
];
const EAC3Blocks = [
    1, 2, 3, 6
];
const AC3_HEADER_SIZE = 7;
function parseHeader(buf) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__["default"](buf.length);
    bitReader.appendBuffer(buf);
    const info = {
        syncWord: 0,
        crc1: 0,
        srCode: 0,
        bitstreamId: 0,
        bitstreamMode: 0,
        channelMode: 0,
        lfeOn: 0,
        frameType: 0,
        substreamId: 0,
        centerMixLevel: 0,
        surroundMixLevel: 0,
        channelMap: 0,
        numBlocks: 0,
        dolbySurroundMode: 0,
        srShift: 0,
        sampleRate: 0,
        bitrate: 0,
        channels: 0,
        frameSize: 0,
        channelLayout: BigInt(0),
        ac3BitrateCode: 0
    };
    info.syncWord = bitReader.readU(16);
    if (info.syncWord !== 0x0B77) {
        return -1;
    }
    info.bitstreamId = bitReader.peekU(29) & 0x1f;
    if (info.bitstreamId > 16) {
        return -2;
    }
    info.numBlocks = 6;
    info.ac3BitrateCode = -1;
    info.centerMixLevel = 5;
    info.surroundMixLevel = 6;
    info.dolbySurroundMode = 0 /* AC3DolbySurroundMode.AC3_DSURMOD_NOTINDICATED */;
    if (info.bitstreamId <= 10) {
        info.crc1 = bitReader.readU(16);
        info.srCode = bitReader.readU(2);
        if (info.srCode === 3) {
            return -3;
        }
        const frameSizeCode = bitReader.readU(6);
        if (frameSizeCode > 37) {
            return -4;
        }
        info.ac3BitrateCode = (frameSizeCode >> 1);
        bitReader.readU(5);
        info.bitstreamMode = bitReader.readU(3);
        info.channelMode = bitReader.readU(3);
        if (info.channelMode == 2 /* AC3ChannelMode.AC3_CHMODE_STEREO */) {
            info.dolbySurroundMode = bitReader.readU(2);
        }
        else {
            if ((info.channelMode & 1) && info.channelMode != 1 /* AC3ChannelMode.AC3_CHMODE_MONO */) {
                info.centerMixLevel = CenterLevelsTab[bitReader.readU(2)];
            }
            if (info.channelMode & 4) {
                info.surroundMixLevel = SurroundLevelsTab[bitReader.readU(2)];
            }
        }
        info.lfeOn = bitReader.readU(1);
        info.srShift = Math.max(info.bitstreamId, 8) - 8;
        info.sampleRate = AC3SampleRateTab[info.srCode] >> info.srShift;
        info.bitrate = (AC3BitrateTab[info.ac3BitrateCode] * 1000) >> info.srShift;
        info.channels = AC3ChannelsTab[info.channelMode] + info.lfeOn;
        info.frameSize = AC3FrameSizeTab[frameSizeCode][info.srCode] * 2;
        info.frameType = 2 /* EAC3FrameType.EAC3_FRAME_TYPE_AC3_CONVERT */;
        info.substreamId = 0;
    }
    else {
        /* Enhanced AC-3 */
        info.crc1 = 0;
        info.frameType = bitReader.readU(2);
        if (info.frameType == 3 /* EAC3FrameType.EAC3_FRAME_TYPE_RESERVED */) {
            return -5;
        }
        info.substreamId = bitReader.readU(3);
        info.frameSize = (bitReader.readU(11) + 1) << 1;
        if (info.frameSize < AC3_HEADER_SIZE) {
            return -6;
        }
        info.srCode = bitReader.readU(2);
        if (info.srCode == 3) {
            const srCode2 = bitReader.readU(2);
            if (srCode2 == 3) {
                return -7;
            }
            info.sampleRate = AC3SampleRateTab[srCode2] / 2;
            info.srShift = 1;
        }
        else {
            info.numBlocks = EAC3Blocks[bitReader.readU(2)];
            info.sampleRate = AC3SampleRateTab[info.srCode];
            info.srShift = 0;
        }
        info.channelMode = bitReader.readU(3);
        info.lfeOn = bitReader.readU(1);
        info.bitrate = 8 * info.frameSize * info.sampleRate / (info.numBlocks * 256);
        info.channels = AC3ChannelsTab[info.channelMode] + info.lfeOn;
    }
    info.channelLayout = BigInt(AC3ChannelLayout[info.channelMode]);
    if (info.lfeOn) {
        info.channelLayout |= BigInt(8 /* AV_CH_LAYOUT.AV_CH_LOW_FREQUENCY */);
    }
    return info;
}


/***/ }),

/***/ "./src/avformat/codecs/av1.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/av1.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AV1Profile2Name: () => (/* binding */ AV1Profile2Name),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseExtraData: () => (/* binding */ parseExtraData)
/* harmony export */ });
/* unused harmony exports LevelCapabilities, AV1LevelIdx, getLevelByResolution, parseSequenceHeader, splitOBU, generateExtradata */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/av1syntax */ "./src/avutil/util/av1syntax.ts");
/* harmony import */ var common_io_BitWriter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/io/BitWriter */ "./src/common/io/BitWriter.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");





const AV1Profile2Name = {
    [0 /* AV1Profile.Main */]: 'Main',
    [1 /* AV1Profile.High */]: 'High',
    [2 /* AV1Profile.Professional */]: 'Professional'
};
const LevelCapabilities = [
    { level: 20, maxResolution: 2359296 },
    { level: 21, maxResolution: 4460544 },
    { level: 30, maxResolution: 10653696 },
    { level: 31, maxResolution: 17040384 },
    { level: 40, maxResolution: 21233664 },
    { level: 41, maxResolution: 21233664 },
    { level: 50, maxResolution: 35651584 },
    { level: 51, maxResolution: 35651584 },
    { level: 52, maxResolution: 35651584 },
    { level: 53, maxResolution: 35651584 },
    { level: 60, maxResolution: 142606336 },
    { level: 61, maxResolution: 142606336 },
    { level: 62, maxResolution: 142606336 },
    { level: 63, maxResolution: 142606336 }
];
const AV1LevelIdx = [20, 21, 22, 23, 30, 31, 32, 33, 40, 41, 42, 43, 50, 51, 52, 53, 60, 61, 62, 63, 70, 71, 72, 73];
function getLevelByResolution(width, height, fps) {
    const resolution = width * height;
    for (const level of LevelCapabilities) {
        if (resolution <= level.maxResolution) {
            return level.level;
        }
    }
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 4) {
        const params = parseExtraData(extradata);
        stream.codecpar.profile = params.profile;
        stream.codecpar.level = params.level;
    }
}
/**
 * - 1 bit marker
 * - 7 bit version
 * - 3 bit profile
 * - 5 bit level
 * - 1 bit tier
 * - 1 bit bitdepth > 8
 * - 1 bit bitdepth == 12
 * - 1 bit monochrome
 * - 1 bit chroma_subsampling_x
 * - 1 bit chroma_subsampling_y
 * - 2 bit chroma_sample_position
 * - 8 bit padding
 *
 * @param header
 */
function parseExtraData(extradata) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__["default"](extradata.length);
    bitReader.appendBuffer(extradata);
    // marker
    bitReader.readU1();
    // version
    bitReader.readU(7);
    const profile = bitReader.readU(3);
    const level = bitReader.readU(5);
    const tier = bitReader.readU1();
    let bitDepth = bitReader.readU1() ? 10 : 8;
    if (bitReader.readU1()) {
        bitDepth = 12;
    }
    const monochrome = bitReader.readU1();
    const chromaSubsamplingX = bitReader.readU1();
    const chromaSubsamplingY = bitReader.readU1();
    const chromaSamplePosition = bitReader.readU(2);
    return {
        profile,
        level,
        tier,
        bitDepth,
        monochrome,
        chromaSubsamplingX,
        chromaSubsamplingY,
        chromaSamplePosition
    };
}
/* eslint-disable camelcase */
function parseSequenceHeader(header) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__["default"](header.length);
    bitReader.appendBuffer(header);
    bitReader.readU1();
    bitReader.readU(4);
    const extensionFlag = bitReader.readU1();
    const hasSizeFlag = bitReader.readU1();
    // obu_reserved_1bit
    bitReader.readU1();
    if (extensionFlag) {
        bitReader.readU(8);
    }
    if (hasSizeFlag) {
        avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.leb128(bitReader);
    }
    const seq_profile = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 3);
    const still_picture = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    const reduced_still_picture_header = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let timing_info_present_flag = 0;
    let decoder_model_info_present_flag = 0;
    let initial_display_delay_present_flag = 0;
    let operating_points_cnt_minus_1 = 0;
    let operating_point_idc = [0];
    let seq_level_idx = [0];
    let seq_tier = [0];
    let decoder_model_present_for_this_op = [0];
    let initial_display_delay_present_for_this_op = [0];
    let initial_display_delay_minus_1 = [0];
    let buffer_delay_length_minus_1 = 0;
    let decoder_buffer_delay = [0];
    let encoder_buffer_delay = [0];
    let low_delay_mode_flag = [0];
    if (reduced_still_picture_header) {
        seq_level_idx[0] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 5);
    }
    else {
        timing_info_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        if (timing_info_present_flag) {
            let num_units_in_display_tick = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 32);
            let time_scale = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 32);
            let equal_picture_interval = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
            if (equal_picture_interval) {
                let num_ticks_per_picture_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.uvlc(bitReader);
            }
            let decoder_model_info_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
            if (decoder_model_info_present_flag) {
                buffer_delay_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 5);
                let num_units_in_decoding_tick = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 32);
                let buffer_removal_time_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 5);
                let frame_presentation_time_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 5);
            }
        }
        else {
            decoder_model_info_present_flag = 0;
        }
        let initial_display_delay_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        let operating_points_cnt_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 5);
        for (let i = 0; i <= operating_points_cnt_minus_1; i++) {
            operating_point_idc[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 12);
            seq_level_idx[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 5);
            if (seq_level_idx[i] > 7) {
                seq_tier[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
            }
            else {
                seq_tier[i] = 0;
            }
            if (decoder_model_info_present_flag) {
                decoder_model_present_for_this_op[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
                if (decoder_model_present_for_this_op[i]) {
                    let n = buffer_delay_length_minus_1 + 1;
                    decoder_buffer_delay[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, n);
                    encoder_buffer_delay[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, n);
                    low_delay_mode_flag[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
                }
            }
            else {
                decoder_model_present_for_this_op[i] = 0;
            }
            if (initial_display_delay_present_flag) {
                initial_display_delay_present_for_this_op[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
                if (initial_display_delay_present_for_this_op[i]) {
                    initial_display_delay_minus_1[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 4);
                }
            }
        }
    }
    let frame_width_bits_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 4);
    let frame_height_bits_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 4);
    let n = frame_width_bits_minus_1 + 1;
    let max_frame_width_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, n);
    n = frame_height_bits_minus_1 + 1;
    let max_frame_height_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, n);
    let frame_id_numbers_present_flag = 0;
    let delta_frame_id_length_minus_2 = 0;
    let additional_frame_id_length_minus_1 = 0;
    if (reduced_still_picture_header) {
        frame_id_numbers_present_flag = 0;
    }
    else {
        frame_id_numbers_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    }
    if (frame_id_numbers_present_flag) {
        delta_frame_id_length_minus_2 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 4);
        additional_frame_id_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 3);
    }
    let use_128x128_superblock = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let enable_filter_intra = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let enable_intra_edge_filter = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let enable_interintra_compound = 0;
    let enable_masked_compound = 0;
    let enable_warped_motion = 0;
    let enable_dual_filter = 0;
    let enable_order_hint = 0;
    let enable_jnt_comp = 0;
    let enable_ref_frame_mvs = 0;
    let seq_force_screen_content_tools = 2;
    let seq_force_integer_mv = 2;
    let OrderHintBits = 0;
    if (!reduced_still_picture_header) {
        let enable_interintra_compound = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        enable_masked_compound = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        enable_warped_motion = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        enable_dual_filter = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        enable_order_hint = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        if (enable_order_hint) {
            enable_jnt_comp = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
            enable_ref_frame_mvs = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        }
        else {
            enable_jnt_comp = 0;
            enable_ref_frame_mvs = 0;
        }
        let seq_choose_screen_content_tools = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        if (seq_choose_screen_content_tools) {
            seq_force_screen_content_tools = 2;
        }
        else {
            seq_force_screen_content_tools = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        }
        if (seq_force_screen_content_tools > 0) {
            let seq_choose_integer_mv = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
            if (seq_choose_integer_mv) {
                seq_force_integer_mv = 2;
            }
            else {
                seq_force_integer_mv = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
            }
        }
        else {
            seq_force_integer_mv = 2;
        }
        if (enable_order_hint) {
            const order_hint_bits_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 3);
            OrderHintBits = order_hint_bits_minus_1 + 1;
        }
        else {
            OrderHintBits = 0;
        }
    }
    let enable_superres = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let enable_cdef = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let enable_restoration = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let high_bitdepth = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let twelve_bit = 0;
    let bit_depth = 0;
    let mono_chrome = 0;
    if (seq_profile == 2 && high_bitdepth) {
        twelve_bit = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        bit_depth = twelve_bit ? 12 : 10;
    }
    else if (seq_profile <= 2) {
        bit_depth = high_bitdepth ? 10 : 8;
    }
    if (seq_profile == 1) {
        mono_chrome = 0;
    }
    else {
        mono_chrome = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    }
    const color_description_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    let color_primaries = 0;
    let transfer_characteristics = 0;
    let matrix_coefficients = 0;
    if (color_description_present_flag) {
        color_primaries = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 8);
        transfer_characteristics = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 8);
        matrix_coefficients = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 8);
    }
    else {
        color_primaries = 2;
        transfer_characteristics = 2;
        matrix_coefficients = 2;
    }
    let color_range = 0;
    let subsampling_x = 0;
    let subsampling_y = 0;
    let chroma_sample_position = 0;
    let separate_uv_delta_q = 0;
    if (mono_chrome) {
        color_range = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        subsampling_x = 1;
        subsampling_y = 1;
        chroma_sample_position = 0;
        separate_uv_delta_q = 0;
    }
    else if (color_primaries == 1
        && transfer_characteristics == 13
        && matrix_coefficients == 0) {
        color_range = 1;
        subsampling_x = 0;
        subsampling_y = 0;
        separate_uv_delta_q = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    }
    else {
        color_range = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
        if (seq_profile == 0) {
            subsampling_x = 1;
            subsampling_y = 1;
        }
        else if (seq_profile == 1) {
            subsampling_x = 0;
            subsampling_y = 0;
        }
        else {
            if (bit_depth == 12) {
                subsampling_x = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
                if (subsampling_x) {
                    subsampling_y = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
                }
                else {
                    subsampling_y = 0;
                }
            }
            else {
                subsampling_x = 1;
                subsampling_y = 0;
            }
        }
        if (subsampling_x && subsampling_y) {
            chroma_sample_position = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 2);
        }
        separate_uv_delta_q = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    }
    let film_grain_params_present = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.f(bitReader, 1);
    return {
        width: max_frame_width_minus_1 + 1,
        height: max_frame_height_minus_1 + 1,
        profile: seq_profile,
        level: AV1LevelIdx[seq_level_idx[0]],
        tier: seq_tier[0],
        bitDepth: bit_depth,
        monoChrome: mono_chrome,
        colorRange: color_range,
        colorPrimaries: color_primaries,
        transferCharacteristics: transfer_characteristics,
        matrixCoefficients: matrix_coefficients,
        subsamplingX: subsampling_x,
        subsamplingY: subsampling_y,
        chromaSamplePosition: chroma_sample_position
    };
}
function splitOBU(buffer) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__["default"]();
    bitReader.appendBuffer(buffer);
    const list = [];
    while (bitReader.remainingLength()) {
        const now = bitReader.getPointer();
        // obu_forbidden_bit
        bitReader.readU1();
        const type = bitReader.readU(4);
        const extensionFlag = bitReader.readU1();
        const hasSizeFlag = bitReader.readU1();
        // obu_reserved_1bit
        bitReader.readU1();
        if (extensionFlag) {
            bitReader.readU(8);
        }
        const size = hasSizeFlag ? avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_2__.leb128(bitReader) : buffer.length - 1 - extensionFlag;
        const headerSize = bitReader.getPointer() - now;
        list.push(buffer.subarray(now, now + headerSize + size));
        bitReader.skip(size * 8);
    }
    return list;
}
function generateExtradata(codecpar, buffer) {
    const bitWriter = new common_io_BitWriter__WEBPACK_IMPORTED_MODULE_3__["default"](4);
    // marker
    bitWriter.writeU1(1);
    // version
    bitWriter.writeU(7, 1);
    const header = splitOBU(buffer).find((buffer) => {
        return ((buffer[0] >>> 3) & 0x0f) === 1 /* OBUType.SEQUENCE_HEADER */;
    });
    if (header) {
        const params = parseSequenceHeader(header);
        bitWriter.writeU(3, params.profile);
        bitWriter.writeU(5, params.level);
        bitWriter.writeU(1, params.tier);
        bitWriter.writeU(1, params.bitDepth > 8 ? 1 : 0);
        bitWriter.writeU(1, params.bitDepth === 12 ? 1 : 0);
        bitWriter.writeU(1, params.monoChrome);
        bitWriter.writeU(1, params.subsamplingX);
        bitWriter.writeU(1, params.subsamplingY);
        bitWriter.writeU(1, params.chromaSamplePosition);
    }
    else {
        const desc = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_4__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 28)];
        bitWriter.writeU(3, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 48));
        bitWriter.writeU(5, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 52));
        bitWriter.writeU(1, 0);
        bitWriter.writeU(1, desc.comp[0].depth > 8 ? 1 : 0);
        bitWriter.writeU(1, desc.comp[0].depth === 12 ? 1 : 0);
        bitWriter.writeU(1, 0);
        bitWriter.writeU(1, 1);
        bitWriter.writeU(1, 1);
        bitWriter.writeU(1, 0);
    }
    // padding
    bitWriter.writeU(8, 0);
    return bitWriter.getBuffer();
}


/***/ }),

/***/ "./src/avformat/codecs/h264.ts":
/*!*************************************!*\
  !*** ./src/avformat/codecs/h264.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H264Profile2Name: () => (/* binding */ H264Profile2Name),
/* harmony export */   annexb2Avcc: () => (/* binding */ annexb2Avcc),
/* harmony export */   annexbExtradata2AvccExtradata: () => (/* binding */ annexbExtradata2AvccExtradata),
/* harmony export */   extradata2SpsPps: () => (/* binding */ extradata2SpsPps),
/* harmony export */   isIDR: () => (/* binding */ isIDR),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseAnnexbExtraData: () => (/* binding */ parseAnnexbExtraData),
/* harmony export */   parseAvccExtraData: () => (/* binding */ parseAvccExtraData),
/* harmony export */   parseSPS: () => (/* binding */ parseSPS)
/* harmony export */ });
/* unused harmony exports NALULengthSizeMinusOne, LevelCapabilities, getLevelByResolution, spsPps2Extradata, avcc2Annexb */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/nalu */ "./src/avutil/util/nalu.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avutil/util/expgolomb */ "./src/avutil/util/expgolomb.ts");
/* harmony import */ var avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avutil/util/intread */ "./src/avutil/util/intread.ts");
var cheap__fileName__0 = "src\\avformat\\codecs\\h264.ts";


/*
 * libmedia h264 util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */











const NALULengthSizeMinusOne = 3;
const H264Profile2Name = {
    [66 /* H264Profile.kBaseline */]: 'Constrained Baseline',
    [77 /* H264Profile.kMain */]: 'Main',
    [100 /* H264Profile.kHigh */]: 'High',
    [110 /* H264Profile.kHigh10 */]: 'High10',
    [122 /* H264Profile.kHigh422 */]: 'High422',
    [244 /* H264Profile.kHigh444 */]: 'High444'
};
const LevelCapabilities = [
    { level: 10, maxResolution: 25344, maxFrameRate: 15 },
    { level: 11, maxResolution: 25344, maxFrameRate: 30 },
    { level: 12, maxResolution: 101376, maxFrameRate: 30 },
    { level: 13, maxResolution: 101376, maxFrameRate: 30 },
    { level: 20, maxResolution: 101376, maxFrameRate: 30 },
    { level: 21, maxResolution: 202752, maxFrameRate: 30 },
    { level: 22, maxResolution: 414720, maxFrameRate: 30 },
    { level: 30, maxResolution: 414720, maxFrameRate: 30 },
    { level: 31, maxResolution: 921600, maxFrameRate: 30 },
    { level: 32, maxResolution: 1310720, maxFrameRate: 60 },
    { level: 40, maxResolution: 2097152, maxFrameRate: 30 },
    { level: 41, maxResolution: 2097152, maxFrameRate: 60 },
    { level: 42, maxResolution: 2228224, maxFrameRate: 60 },
    { level: 50, maxResolution: 8912896, maxFrameRate: 30 },
    { level: 51, maxResolution: 8912896, maxFrameRate: 60 },
    { level: 52, maxResolution: 8912896, maxFrameRate: 120 },
    { level: 60, maxResolution: 35651584, maxFrameRate: 30 },
    { level: 61, maxResolution: 35651584, maxFrameRate: 60 },
    { level: 62, maxResolution: 35651584, maxFrameRate: 120 }
];
function getLevelByResolution(width, height, fps) {
    const resolution = width * height;
    for (const level of LevelCapabilities) {
        if (resolution <= level.maxResolution && fps <= level.maxFrameRate) {
            return level.level;
        }
    }
}
/**
 *
 * avcc  extradata  annexb sps pps
 *
 * bits
 * - 8   version ( always 0x01 )
 * - 8   avc profile ( sps[0][1] )
 * - 8   avc compatibility ( sps[0][2] )
 * - 8   avc level ( sps[0][3] )
 * - 6   reserved ( all bits on )
 * - 2   NALULengthSizeMinusOne
 * - 3   reserved ( all bits on )
 * - 5   number of SPS NALUs (usually 1)
 * - repeated once per SPS:
 *   - 16         SPS size
 *   - variable   SPS NALU data
 * - 8 number of PPS NALUs (usually 1)
 * - repeated once per PPS:
 *   - 16       PPS size
 *   - variable PPS NALU data
 *
 * - ext (profile !== 66 && profile !== 77 && profile !== 88)
 *  - 6 reserved ( all bits on )
 *  - 2 chroma_format_idc
 *  - 5 reserved ( all bits on )
 *  - 3 bit_depth_luma_minus8
 *  - 5 reserved ( all bits on )
 *  - 3 bit_depth_chroma_minus8
 *  - 8 number of SPS_EXT NALUs
 *    - 16 SPS_EXT size
 *    - variable   SPS_EXT NALU data
 *
 */
function extradata2SpsPps(extradata) {
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](extradata);
    bufferReader.skip(5);
    const spss = [];
    const ppss = [];
    const spsExts = [];
    const spsLength = bufferReader.readUint8() & 0x1f;
    for (let i = 0; i < spsLength; i++) {
        const length = bufferReader.readUint16();
        spss.push(bufferReader.readBuffer(length));
    }
    const ppsLength = bufferReader.readUint8();
    for (let i = 0; i < ppsLength; i++) {
        const length = bufferReader.readUint16();
        ppss.push(bufferReader.readBuffer(length));
    }
    if (bufferReader.remainingSize() > 4) {
        bufferReader.skip(3);
        const spsExtLength = bufferReader.readUint8();
        if (spsExtLength > 0) {
            for (let i = 0; i < spsExtLength; i++) {
                const length = bufferReader.readUint16();
                spsExts.push(bufferReader.readBuffer(length));
            }
        }
    }
    return {
        spss,
        ppss,
        spsExts
    };
}
function spsPps2Extradata(spss, ppss, spsExts = []) {
    if (spss.length > 32) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_6__.warn(`h264 metadata\'s sps max length is 32, but get ${spss.length}`, cheap__fileName__0, 210);
        spss = spss.slice(0, 32);
    }
    if (spss.length > 256) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_6__.warn(`h264 metadata\'s pps max length is 256, but get ${spss.length}`, cheap__fileName__0, 214);
        spss = spss.slice(0, 256);
    }
    let length = 7;
    length = spss.reduce((prev, sps) => {
        return prev + 2 + sps.length;
    }, length);
    length = ppss.reduce((prev, pps) => {
        return prev + 2 + pps.length;
    }, length);
    const sps = spss[0];
    const params = parseSPS(sps);
    if (params.profile !== 66 && params.profile !== 77 && params.profile !== 88) {
        length += 4;
        if (spsExts.length) {
            length = spsExts.reduce((prev, ext) => {
                return prev + 2 + ext.length;
            }, length);
        }
    }
    const buffer = new Uint8Array(length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(sps[1]);
    bufferWriter.writeUint8(sps[2]);
    bufferWriter.writeUint8(sps[3]);
    bufferWriter.writeUint8(0xfc | NALULengthSizeMinusOne);
    // sps
    bufferWriter.writeUint8(0xe0 | (spss.length & 0x1f));
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
        bufferWriter.writeUint16(sps.length);
        bufferWriter.writeBuffer(sps);
    });
    // pps
    bufferWriter.writeUint8(ppss.length);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
        bufferWriter.writeUint16(pps.length);
        bufferWriter.writeBuffer(pps);
    });
    if (params.profile !== 66 && params.profile !== 77 && params.profile !== 88) {
        bufferWriter.writeUint8(0xfc | params.chromaFormatIdc);
        bufferWriter.writeUint8(0xf8 | params.bitDepthLumaMinus8);
        bufferWriter.writeUint8(0xf8 | params.bitDepthChromaMinus8);
        if (spsExts.length) {
            common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spsExts, (ext) => {
                bufferWriter.writeUint16(ext.length);
                bufferWriter.writeBuffer(ext);
            });
        }
    }
    return buffer;
}
function annexbExtradata2AvccExtradata(data) {
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.splitNaluByStartCode)(data);
    if (nalus.length > 1) {
        const spss = [];
        const ppss = [];
        const spsExts = [];
        nalus.forEach((nalu) => {
            const type = nalu[0] & 0x1f;
            if (type === 7 /* H264NaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 8 /* H264NaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
            else if (type === 13 /* H264NaluType.kSPSExt */) {
                spsExts.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            return spsPps2Extradata(spss, ppss, spsExts);
        }
    }
}
/**
 *
 * annexb  NALU  avcc NALU
 *
 */
function annexb2Avcc(data) {
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.splitNaluByStartCode)(data);
    let extradata;
    let key = false;
    if (nalus.length > 1) {
        const spss = [];
        const ppss = [];
        const spsExts = [];
        nalus.forEach((nalu) => {
            const type = nalu[0] & 0x1f;
            if (type === 7 /* H264NaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 8 /* H264NaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
            else if (type === 13 /* H264NaluType.kSPSExt */) {
                spsExts.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            extradata = spsPps2Extradata(spss, ppss, spsExts);
        }
        nalus = nalus.filter((nalu) => {
            const type = nalu[0] & 0x1f;
            return type !== 9 /* H264NaluType.kSliceAUD */
                && type !== 8 /* H264NaluType.kSlicePPS */
                && type !== 7 /* H264NaluType.kSliceSPS */
                && type !== 13 /* H264NaluType.kSPSExt */;
        });
    }
    const length = nalus.reduce((prev, nalu) => {
        return prev + NALULengthSizeMinusOne + 1 + nalu.length;
    }, 0);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_10__.avMalloc)(length);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.mapUint8Array)(bufferPointer, length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu) => {
        if (NALULengthSizeMinusOne === 3) {
            bufferWriter.writeUint32(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 2) {
            bufferWriter.writeUint24(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 1) {
            bufferWriter.writeUint16(nalu.length);
        }
        else {
            bufferWriter.writeUint8(nalu.length);
        }
        bufferWriter.writeBuffer(nalu.subarray(0));
        const type = nalu[0] & 0x1f;
        if (type === 5 /* H264NaluType.kSliceIDR */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length,
        key,
        extradata
    };
}
/**
 * avcc  NALU  annexb NALU
 *
 */
function avcc2Annexb(data, extradata) {
    const naluLengthSizeMinusOne = extradata ? (extradata[4] & 0x03) : NALULengthSizeMinusOne;
    let spss = [];
    let ppss = [];
    let spsExts = [];
    let key = false;
    if (extradata) {
        const result = extradata2SpsPps(extradata);
        spss = result.spss;
        ppss = result.ppss;
        spsExts = result.spsExts;
        key = true;
    }
    const nalus = [];
    const seis = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = data.subarray(Number(BigInt.asIntN(32, bufferReader.getPos())), Number(BigInt.asIntN(32, bufferReader.getPos())) + length);
        bufferReader.skip(length);
        const naluType = nalu[0] & 0x1f;
        if (naluType === 6 /* H264NaluType.kSliceSEI */) {
            seis.push(nalu);
        }
        else if (naluType !== 9 /* H264NaluType.kSliceAUD */) {
            nalus.push(nalu);
        }
    }
    let length = spss.reduce((prev, sps) => {
        return prev + 4 + sps.length;
    }, 0);
    length = ppss.reduce((prev, pps) => {
        return prev + 4 + pps.length;
    }, length);
    length = spsExts.reduce((prev, ext) => {
        return prev + 4 + ext.length;
    }, length);
    length = seis.reduce((prev, sei) => {
        return prev + 4 + sei.length;
    }, length);
    length = nalus.reduce((prev, nalu, index) => {
        return prev + (index ? 3 : 4) + nalu.length;
    }, length);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_10__.avMalloc)(length + 6);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"]((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.mapUint8Array)(bufferPointer, length + 6));
    // AUD
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(0x09);
    bufferWriter.writeUint8(0xf0);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(seis, (sei) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(sei);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(sps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(pps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spsExts, (ext) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(ext);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu, index) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        if (!index) {
            bufferWriter.writeUint8(0x00);
        }
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(nalu);
        const type = nalu[0] & 0x1f;
        if (type === 5 /* H264NaluType.kSliceIDR */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length: length + 6,
        key
    };
}
function parseAvccExtraData(avpacket, stream) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if ((0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.isAnnexb)(data)) {
        return;
    }
    const naluLengthSizeMinusOne = stream.metadata.naluLengthSizeMinusOne ?? NALULengthSizeMinusOne;
    let spss = [];
    let ppss = [];
    let spsExts = [];
    let others = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = data.subarray(Number(BigInt.asIntN(32, bufferReader.getPos())), Number(BigInt.asIntN(32, bufferReader.getPos())) + length);
        bufferReader.skip(length);
        const naluType = nalu[0] & 0x1f;
        if (naluType === 7 /* H264NaluType.kSliceSPS */) {
            spss.push(nalu);
        }
        else if (naluType === 8 /* H264NaluType.kSlicePPS */) {
            ppss.push(nalu);
        }
        else if (naluType === 13 /* H264NaluType.kSPSExt */) {
            spsExts.push(nalu);
        }
        else {
            others.push(nalu);
        }
    }
    if (spss.length || ppss.length) {
        const extradata = spsPps2Extradata(spss, ppss, spsExts);
        const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_10__.avMalloc)(extradata.length);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
    }
}
function parseAnnexbExtraData(avpacket, force = false) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) && !force) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if (!(0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.isAnnexb)(data)) {
        return;
    }
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.splitNaluByStartCode)(data);
    if (nalus.length > 1) {
        const spss = [];
        const ppss = [];
        const spsExts = [];
        nalus.forEach((nalu) => {
            const type = nalu[0] & 0x1f;
            if (type === 7 /* H264NaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 8 /* H264NaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
            else if (type === 13 /* H264NaluType.kSPSExt */) {
                spsExts.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            const extradata = spsPps2Extradata(spss, ppss, spsExts);
            const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_10__.avMalloc)(extradata.length);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
        }
    }
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        stream.metadata.naluLengthSizeMinusOne = (extradata[4] & 0x03);
        const { spss } = extradata2SpsPps(extradata);
        if (spss.length) {
            const { profile, level, width, height } = parseSPS(spss[0]);
            stream.codecpar.profile = profile;
            stream.codecpar.level = level;
            stream.codecpar.width = width;
            stream.codecpar.height = height;
        }
    }
}
function isIDR(avpacket, naluLengthSize = 4) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 80) === 2 /* BitFormat.ANNEXB */) {
        let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.splitNaluByStartCode)((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28)));
        return nalus.some((nalu) => {
            const type = nalu[0] & 0x1f;
            return type === 5 /* H264NaluType.kSliceIDR */;
        });
    }
    else {
        const size = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28);
        let i = 0;
        while (i < (size - naluLengthSize)) {
            const type = avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + (i + naluLengthSize)) & 0x1f;
            if (type === 5 /* H264NaluType.kSliceIDR */) {
                return true;
            }
            if (naluLengthSize === 4) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.rb32(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else if (naluLengthSize === 3) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.rb24(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else if (naluLengthSize === 2) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.rb16(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            i += naluLengthSize;
        }
        return false;
    }
}
function parseSPS(sps) {
    if (!sps || sps.length < 3) {
        return;
    }
    let offset = 0;
    if (sps[0] === 0x00
        && sps[1] === 0x00
        && sps[2] === 0x00
        && sps[3] === 0x01) {
        offset = 4;
    }
    const buffer = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_9__.naluUnescape)(sps.subarray(offset));
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__["default"](buffer.length);
    bitReader.appendBuffer(buffer);
    // forbidden_zero_bit
    bitReader.readU1();
    // nal_ref_idc
    bitReader.readU(2);
    // nal_unit_type
    bitReader.readU(5);
    const profile = bitReader.readU(8);
    // constraint_set0_flag
    bitReader.readU1();
    // constraint_set1_flag
    bitReader.readU1();
    // constraint_set2_flag
    bitReader.readU1();
    // constraint_set3_flag
    bitReader.readU1();
    // constraint_set4_flag
    bitReader.readU1();
    // constraint_set4_flag
    bitReader.readU1();
    // reserved_zero_2bits
    bitReader.readU(2);
    const level = bitReader.readU(8);
    // seq_parameter_set_id
    avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    //  4:2:0
    let chromaFormatIdc = 1;
    let bitDepthLumaMinus8 = 0;
    let bitDepthChromaMinus8 = 0;
    if (profile == 100 || profile == 110 || profile == 122
        || profile == 244 || profile == 44 || profile == 83
        || profile == 86 || profile == 118 || profile == 128
        || profile == 138 || profile == 139 || profile == 134 || profile == 135) {
        chromaFormatIdc = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        if (chromaFormatIdc === 3) {
            // separate_colour_plane_flag
            bitReader.readU1();
        }
        // bit_depth_luma_minus8
        bitDepthLumaMinus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        // bit_depth_chroma_minus8
        bitDepthChromaMinus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        // qpprime_y_zero_transform_bypass_flag
        bitReader.readU1();
        let seqScalingMatrixPresentFlag = bitReader.readU1();
        if (seqScalingMatrixPresentFlag) {
            const seqScalingListPresentFlag = new Array(8);
            for (let i = 0; i < ((chromaFormatIdc != 3) ? 8 : 12); i++) {
                seqScalingListPresentFlag[i] = bitReader.readU1();
            }
        }
    }
    // log2_max_frame_num_minus4
    const log2MaxFrameNumMinus4 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    const picOrderCntType = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    let log2MaxPicOrderCntLsbMinus4 = 0;
    let deltaPicOrderAlwaysZeroFlag = 0;
    if (picOrderCntType === 0) {
        // log2_max_pic_order_cnt_lsb_minus4
        log2MaxPicOrderCntLsbMinus4 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    }
    else if (picOrderCntType === 1) {
        // delta_pic_order_always_zero_flag
        deltaPicOrderAlwaysZeroFlag = bitReader.readU1();
        // offset_for_non_ref_pic
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readSE(bitReader);
        // offset_for_top_to_bottom_field
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readSE(bitReader);
        const numRefFramesInPicOrderCntCycle = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        for (let i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
            avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readSE(bitReader);
        }
    }
    // max_num_ref_frames
    avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    // gaps_in_frame_num_value_allowed_flag
    bitReader.readU1();
    const picWidthInMbsMinus1 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    const picHeightInMapUnitsMinus1 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    const frameMbsOnlyFlag = bitReader.readU1();
    let width = (picWidthInMbsMinus1 + 1) * 16;
    let height = (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16;
    if (!frameMbsOnlyFlag) {
        // mb_adaptive_frame_field_flag
        bitReader.readU1();
    }
    // direct_8x8_inference_flag
    bitReader.readU1();
    const frameCroppingFlag = bitReader.readU1();
    if (frameCroppingFlag) {
        const frameCropLeftOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        const frameCropRightOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        const frameCropTopOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        const frameCropBottomOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        let cropUnitX = 1;
        let cropUnitY = 2 - frameCroppingFlag;
        if (chromaFormatIdc === 1) {
            cropUnitX = 2;
            cropUnitY = 2 * (2 - frameCroppingFlag);
        }
        else if (frameCroppingFlag === 2) {
            cropUnitX = 2;
            cropUnitY = 2 - frameCroppingFlag;
        }
        width -= cropUnitX * (frameCropLeftOffset + frameCropRightOffset);
        height -= cropUnitY * (frameCropTopOffset + frameCropBottomOffset);
    }
    return {
        profile,
        level,
        width,
        height,
        chromaFormatIdc,
        bitDepthLumaMinus8,
        bitDepthChromaMinus8,
        frameMbsOnlyFlag,
        picOrderCntType,
        log2MaxPicOrderCntLsbMinus4,
        deltaPicOrderAlwaysZeroFlag,
        log2MaxFrameNumMinus4
    };
}


/***/ }),

/***/ "./src/avformat/codecs/hevc.ts":
/*!*************************************!*\
  !*** ./src/avformat/codecs/hevc.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HEVCProfile2Name: () => (/* binding */ HEVCProfile2Name),
/* harmony export */   annexb2Avcc: () => (/* binding */ annexb2Avcc),
/* harmony export */   annexbExtradata2AvccExtradata: () => (/* binding */ annexbExtradata2AvccExtradata),
/* harmony export */   extradata2VpsSpsPps: () => (/* binding */ extradata2VpsSpsPps),
/* harmony export */   isIDR: () => (/* binding */ isIDR),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseAnnexbExtraData: () => (/* binding */ parseAnnexbExtraData),
/* harmony export */   parseAvccExtraData: () => (/* binding */ parseAvccExtraData),
/* harmony export */   parsePPS: () => (/* binding */ parsePPS),
/* harmony export */   parseSPS: () => (/* binding */ parseSPS)
/* harmony export */ });
/* unused harmony exports LevelCapabilities, getLevelByResolution, vpsSpsPps2Extradata, avcc2Annexb */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/util/nalu */ "./src/avutil/util/nalu.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/util/expgolomb */ "./src/avutil/util/expgolomb.ts");
/* harmony import */ var avutil_util_intread__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avutil/util/intread */ "./src/avutil/util/intread.ts");


/*
 * libmedia hevc util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */










const HEVCProfile2Name = {
    [1 /* HEVCProfile.Main */]: 'Main',
    [2 /* HEVCProfile.Main10 */]: 'Main10',
    [3 /* HEVCProfile.MainStillPicture */]: 'MainStillPicture',
    [4 /* HEVCProfile.Main444 */]: 'Main444'
};
const LevelCapabilities = [
    { level: 10, maxLumaSamplesPerSecond: 552960, maxLumaPictureSize: 36864, maxBitRate: { main: 128, main10: 150 } },
    { level: 20, maxLumaSamplesPerSecond: 3686400, maxLumaPictureSize: 122880, maxBitRate: { main: 1500, main10: 1875 } },
    { level: 21, maxLumaSamplesPerSecond: 7372800, maxLumaPictureSize: 245760, maxBitRate: { main: 3000, main10: 3750 } },
    { level: 30, maxLumaSamplesPerSecond: 16588800, maxLumaPictureSize: 552960, maxBitRate: { main: 6000, main10: 7500 } },
    { level: 31, maxLumaSamplesPerSecond: 33177600, maxLumaPictureSize: 983040, maxBitRate: { main: 10000, main10: 12500 } },
    { level: 40, maxLumaSamplesPerSecond: 66846720, maxLumaPictureSize: 2228224, maxBitRate: { main: 12000, main10: 15000 } },
    { level: 41, maxLumaSamplesPerSecond: 133693440, maxLumaPictureSize: 2228224, maxBitRate: { main: 20000, main10: 25000 } },
    { level: 50, maxLumaSamplesPerSecond: 267386880, maxLumaPictureSize: 8912896, maxBitRate: { main: 25000, main10: 40000 } },
    { level: 51, maxLumaSamplesPerSecond: 534773760, maxLumaPictureSize: 8912896, maxBitRate: { main: 40000, main10: 60000 } },
    { level: 52, maxLumaSamplesPerSecond: 1069547520, maxLumaPictureSize: 35651584, maxBitRate: { main: 60000, main10: 100000 } },
    { level: 60, maxLumaSamplesPerSecond: 1069547520, maxLumaPictureSize: 35651584, maxBitRate: { main: 60000, main10: 100000 } },
    { level: 61, maxLumaSamplesPerSecond: 2139095040, maxLumaPictureSize: 89128960, maxBitRate: { main: 120000, main10: 240000 } },
    { level: 62, maxLumaSamplesPerSecond: 4278190080, maxLumaPictureSize: 356515840, maxBitRate: { main: 240000, main10: 480000 } }
];
function getLevelByResolution(profile, width, height, fps, bitrate) {
    bitrate /= 1000;
    const selectedProfile = profile === 1 /* HEVCProfile.Main */ ? 'main' : 'main10';
    const lumaSamplesPerSecond = width * height * fps;
    for (const level of LevelCapabilities) {
        if (lumaSamplesPerSecond <= level.maxLumaSamplesPerSecond && width * height <= level.maxLumaPictureSize && bitrate <= level.maxBitRate[selectedProfile]) {
            return level.level;
        }
    }
}
const NALULengthSizeMinusOne = 3;
/**
 *
 * avcc  extradata  annexb vps sps pps
 *
 * bits
 * - 8   configurationVersion(    1)
 * - 2   general_profile_space
 * - 1   general_tier_flag
 * - 5   general_profile_idc
 * - 32  general_profile_compatibility_flags
 * - 48  general_constraint_indicator_flags (6  
 * - 8   general_level_idc
 * - 4   reserved1 (1111)
 * - 4   min_spatial_segmentation_idc_L
 * - 8   min_spatial_segmentation_idc_H
 * - 6   reserved2 (111111)
 * - 2   parallelismType
 * - 6   reserved3 (111111)
 * - 2   chromaFormat
 * - 5   reserved4 (11111)
 * - 3   bitDepthLumaMinus8
 * - 5   reserved5(11111)
 * - 3   bitDepthChromaMinus8
 * - 16  avgFrameRate
 * - 2   constantFrameRate
 * - 3   numTemporalLayers
 * - 1   temporalIdNested
 * - 2   lengthSizeMinusOne
 * - 8   numOfArrays
 * - repeated of array (vps/sps/pps)
 * - 1   array_completeness
 * - 1   reserved (0)
 * - 6   NAL_unit_type
 * - 16  numNalus
 * - repeated once per NAL
 * - 16  nalUnitLength
 * - N   NALU data
 *
 */
function extradata2VpsSpsPps(extradata) {
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](extradata, true);
    bufferReader.skip(22);
    let vpss = [];
    let spss = [];
    let ppss = [];
    const arrayLen = bufferReader.readUint8();
    for (let i = 0; i < arrayLen; i++) {
        const naluType = bufferReader.readUint8() & 0x3f;
        const count = bufferReader.readUint16();
        const list = [];
        for (let j = 0; j < count; j++) {
            const len = bufferReader.readUint16();
            list.push(bufferReader.readBuffer(len));
        }
        if (naluType === 32 /* HEVCNaluType.kSliceVPS */) {
            vpss = list;
        }
        else if (naluType === 33 /* HEVCNaluType.kSliceSPS */) {
            spss = list;
        }
        else if (naluType === 34 /* HEVCNaluType.kSlicePPS */) {
            ppss = list;
        }
    }
    return {
        vpss,
        spss,
        ppss
    };
}
function vpsSpsPps2Extradata(vpss, spss, ppss) {
    const sps = spss[0];
    let length = 23;
    if (vpss.length) {
        // type + count
        length += 3;
        length = vpss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    if (spss.length) {
        // type + count
        length += 3;
        length = spss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    if (ppss.length) {
        // type + count
        length += 3;
        length = ppss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    const buffer = new Uint8Array(length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer, true);
    const spsData = parseSPS(sps);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(sps[1]);
    bufferWriter.writeUint8(sps[2]);
    bufferWriter.writeUint8(sps[3]);
    bufferWriter.writeUint8(sps[4]);
    bufferWriter.writeUint8(sps[5]);
    // general_constraint_indicator_flags
    bufferWriter.writeUint8(sps[6]);
    bufferWriter.writeUint8(sps[7]);
    bufferWriter.writeUint8(sps[8]);
    bufferWriter.writeUint8(sps[9]);
    bufferWriter.writeUint8(sps[10]);
    bufferWriter.writeUint8(sps[11]);
    bufferWriter.writeUint8(spsData.level);
    // min_spatial_segmentation_idc
    bufferWriter.writeUint8((1020) | 0);
    bufferWriter.writeUint8(0);
    // parallelismType
    bufferWriter.writeUint8((16320) | 0);
    // chromaFormat
    bufferWriter.writeUint8((16320) | spsData.chroma_format_idc);
    // bitDepthLumaMinus8
    bufferWriter.writeUint8((8160) | spsData.bit_depth_luma_minus8);
    // bitDepthChromaMinus8
    bufferWriter.writeUint8((8160) | spsData.bit_depth_chroma_minus8);
    // avgFrameRate
    bufferWriter.writeUint16(0);
    // constantFrameRate numTemporalLayers temporalIdNested lengthSizeMinusOne
    bufferWriter.writeUint8((0) | (8) | ((sps[0] & 0x01) << 2) | NALULengthSizeMinusOne);
    // numOfArrays
    let numOfArrays = 0;
    if (vpss.length) {
        numOfArrays++;
    }
    if (spss.length) {
        numOfArrays++;
    }
    if (ppss.length) {
        numOfArrays++;
    }
    bufferWriter.writeUint8(numOfArrays);
    // vps
    if (vpss.length) {
        bufferWriter.writeUint8((128) | 32 /* HEVCNaluType.kSliceVPS */);
        bufferWriter.writeUint16(vpss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(vpss, (vps) => {
            bufferWriter.writeUint16(vps.length);
            bufferWriter.writeBuffer(vps);
        });
    }
    // sps
    if (spss.length) {
        bufferWriter.writeUint8((128) | 33 /* HEVCNaluType.kSliceSPS */);
        bufferWriter.writeUint16(spss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
            bufferWriter.writeUint16(sps.length);
            bufferWriter.writeBuffer(sps);
        });
    }
    // pps
    if (ppss.length) {
        bufferWriter.writeUint8((128) | 34 /* HEVCNaluType.kSlicePPS */);
        bufferWriter.writeUint16(ppss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
            bufferWriter.writeUint16(pps.length);
            bufferWriter.writeBuffer(pps);
        });
    }
    return buffer;
}
function annexbExtradata2AvccExtradata(data) {
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)(data);
    if (nalus.length >= 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[0] >>> 1) & 0x3f;
            if (type === 32 /* HEVCNaluType.kSliceVPS */) {
                vpss.push(nalu);
            }
            else if (type === 33 /* HEVCNaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 34 /* HEVCNaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            return vpsSpsPps2Extradata(vpss, spss, ppss);
        }
    }
}
/**
 *
 * annexb  NALU  avcc NALU
 *
 */
function annexb2Avcc(data) {
    let extradata;
    let key = false;
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)(data);
    if (nalus.length >= 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[0] >>> 1) & 0x3f;
            if (type === 32 /* HEVCNaluType.kSliceVPS */) {
                vpss.push(nalu);
            }
            else if (type === 33 /* HEVCNaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 34 /* HEVCNaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
            nalus = nalus.filter((nalu) => {
                const type = (nalu[0] >>> 1) & 0x3f;
                return type !== 32 /* HEVCNaluType.kSliceVPS */
                    && type !== 33 /* HEVCNaluType.kSliceSPS */
                    && type !== 34 /* HEVCNaluType.kSlicePPS */
                    && type !== 35 /* HEVCNaluType.kSliceAUD */;
            });
        }
    }
    const length = nalus.reduce((prev, nalu) => {
        return prev + NALULengthSizeMinusOne + 1 + nalu.length;
    }, 0);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(length);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(bufferPointer, length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu) => {
        if (NALULengthSizeMinusOne === 3) {
            bufferWriter.writeUint32(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 2) {
            bufferWriter.writeUint24(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 1) {
            bufferWriter.writeUint16(nalu.length);
        }
        else {
            bufferWriter.writeUint8(nalu.length);
        }
        bufferWriter.writeBuffer(nalu.subarray(0));
        const type = (nalu[0] >>> 1) & 0x3f;
        if (type === 19 /* HEVCNaluType.kSliceIDR_W_RADL */
            || type === 20 /* HEVCNaluType.kSliceIDR_N_LP */
            || type === 21 /* HEVCNaluType.kSliceCRA_NUT */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length,
        extradata,
        key
    };
}
/**
 * avcc  NALU  annexb NALU
 *
 */
function avcc2Annexb(data, extradata) {
    const naluLengthSizeMinusOne = extradata ? (extradata[21] & 0x03) : NALULengthSizeMinusOne;
    let vpss = [];
    let spss = [];
    let ppss = [];
    let key = false;
    if (extradata) {
        const result = extradata2VpsSpsPps(extradata);
        vpss = result.vpss;
        spss = result.spss;
        ppss = result.ppss;
        key = true;
    }
    const nalus = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        nalus.push(bufferReader.readBuffer(length));
    }
    let length = vpss.reduce((prev, vps) => {
        return prev + 4 + vps.length;
    }, 0);
    length = spss.reduce((prev, sps) => {
        return prev + 4 + sps.length;
    }, length);
    length = ppss.reduce((prev, pps) => {
        return prev + 4 + pps.length;
    }, length);
    length = nalus.reduce((prev, nalu, index) => {
        return prev + (index ? 3 : 4) + nalu.length;
    }, length);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(length + 7);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(bufferPointer, length + 7);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer);
    // AUD
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(35 /* HEVCNaluType.kSliceAUD */ << 1);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0xf0);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(vpss, (vps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(vps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(sps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(pps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu, index) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        if (!index) {
            bufferWriter.writeUint8(0x00);
        }
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(nalu);
        const type = (nalu[0] >>> 1) & 0x3f;
        if (type === 19 /* HEVCNaluType.kSliceIDR_W_RADL */
            || type === 20 /* HEVCNaluType.kSliceIDR_N_LP */
            || type === 21 /* HEVCNaluType.kSliceCRA_NUT */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length: length + 7,
        key
    };
}
function parseAvccExtraData(avpacket, stream) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if ((0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.isAnnexb)(data)) {
        return;
    }
    const naluLengthSizeMinusOne = stream.metadata.naluLengthSizeMinusOne ?? NALULengthSizeMinusOne;
    let vpss = [];
    let spss = [];
    let ppss = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = data.subarray(Number(BigInt.asIntN(32, bufferReader.getPos())), Number(BigInt.asIntN(32, bufferReader.getPos())) + length);
        bufferReader.skip(length);
        const naluType = (nalu[0] >>> 1) & 0x3f;
        if (naluType === 33 /* HEVCNaluType.kSliceSPS */) {
            spss.push(nalu);
        }
        else if (naluType === 34 /* HEVCNaluType.kSlicePPS */) {
            ppss.push(nalu);
        }
        else if (naluType === 32 /* HEVCNaluType.kSliceVPS */) {
            vpss.push(nalu);
        }
    }
    if (spss.length || ppss.length || vpss.length) {
        const extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
        const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(extradata.length);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
    }
}
function parseAnnexbExtraData(avpacket, force = false) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) && !force) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if (!(0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.isAnnexb)(data)) {
        return;
    }
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)(data);
    if (nalus.length > 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[0] >>> 1) & 0x3f;
            if (type === 32 /* HEVCNaluType.kSliceVPS */) {
                vpss.push(nalu);
            }
            else if (type === 33 /* HEVCNaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 34 /* HEVCNaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
        });
        if (vpss.length && spss.length && ppss.length) {
            const extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
            const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(extradata.length);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
        }
    }
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        stream.metadata.naluLengthSizeMinusOne = (extradata[21] & 0x03);
        const { spss } = extradata2VpsSpsPps(extradata);
        if (spss.length) {
            const { profile, level, width, height } = parseSPS(spss[0]);
            stream.codecpar.profile = profile;
            stream.codecpar.level = level;
            stream.codecpar.width = width;
            stream.codecpar.height = height;
        }
    }
}
function isIDR(avpacket, naluLengthSize = 4) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 80) === 2 /* BitFormat.ANNEXB */) {
        let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28)));
        return nalus.some((nalu) => {
            const type = (nalu[0] >>> 1) & 0x3f;
            return type === 20 /* HEVCNaluType.kSliceIDR_N_LP */ || type === 19 /* HEVCNaluType.kSliceIDR_W_RADL */;
        });
    }
    else {
        const size = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28);
        let i = 0;
        while (i < (size - naluLengthSize)) {
            const type = (avutil_util_intread__WEBPACK_IMPORTED_MODULE_11__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + (i + naluLengthSize)) >>> 1) & 0x3f;
            if (type === 20 /* HEVCNaluType.kSliceIDR_N_LP */ || type === 19 /* HEVCNaluType.kSliceIDR_W_RADL */) {
                return true;
            }
            if (naluLengthSize === 4) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_11__.rb32(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else if (naluLengthSize === 3) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_11__.rb24(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else if (naluLengthSize === 2) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_11__.rb16(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_11__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            i += naluLengthSize;
        }
        return false;
    }
}
function parseSPS(sps) {
    if (!sps || sps.length < 3) {
        return;
    }
    let offset = 0;
    if (sps[0] === 0x00
        && sps[1] === 0x00
        && sps[2] === 0x00
        && sps[3] === 0x01) {
        offset = 4;
    }
    let profile = 0;
    let level = 0;
    let width = 0;
    let height = 0;
    let bit_depth_luma_minus8 = 0;
    let bit_depth_chroma_minus8 = 0;
    let chroma_format_idc = 1;
    let general_profile_space = 0;
    let general_tier_flag = 0;
    let general_profile_compatibility_flags = 0;
    let constraint_flags = 0;
    const buffer = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.naluUnescape)(sps.subarray(offset));
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__["default"](buffer.length);
    bitReader.appendBuffer(buffer);
    // forbidden_zero_bit
    bitReader.readU1();
    // nalu type
    bitReader.readU(6);
    // layerId
    bitReader.readU(6);
    // tid
    bitReader.readU(3);
    // sps_video_parameter_set_id
    bitReader.readU(4);
    // The value of sps_max_sub_layers_minus1 shall be in the range of 0 to 6, inclusive.
    const spsMaxSubLayersMinus1 = bitReader.readU(3);
    // sps_temporal_id_nesting_flag
    bitReader.readU1();
    let separate_colour_plane_flag = 0;
    if (spsMaxSubLayersMinus1 <= 6) {
        // profile_tier_level(sps_max_sub_layers_minus1)
        // general_profile_space
        general_profile_space = bitReader.readU(2);
        // general_tier_flag
        general_tier_flag = bitReader.readU1();
        // general_profile_idc
        profile = bitReader.readU(5);
        // general_profile_compatibility_flag[32]
        general_profile_compatibility_flags = bitReader.readU(32);
        /**
         * 1 general_progressive_source_flag
         * 1 general_interlaced_source_flag
         * 1 general_non_packed_constraint_flag
         * 1 general_frame_only_constraint_flag
         * 44 general_reserved_zero_44bits
         */
        constraint_flags = bitReader.readU(48);
        // general_level_idc
        level = bitReader.readU(8);
        const subLayerProfilePresentFlag = new Array(6);
        const subLayerLevelPresentFlag = new Array(6);
        for (let i = 0; i < spsMaxSubLayersMinus1; i++) {
            subLayerProfilePresentFlag[i] = bitReader.readU1();
            subLayerLevelPresentFlag[i] = bitReader.readU1();
        }
        if (spsMaxSubLayersMinus1 > 0) {
            for (let i = spsMaxSubLayersMinus1; i < 8; i++) {
                // reserved_zero_2bits
                bitReader.readU(2);
            }
        }
        for (let i = 0; i < spsMaxSubLayersMinus1; i++) {
            if (subLayerProfilePresentFlag[i]) {
                // sub_layer_profile_space[i]
                bitReader.readU(2);
                // sub_layer_tier_flag[i]
                bitReader.readU(1);
                // sub_layer_profile_idc[i]
                bitReader.readU(5);
                // sub_layer_profile_compatibility_flag[i][32]
                bitReader.readU(32);
                // sub_layer_progressive_source_flag[i]
                bitReader.readU(1);
                // sub_layer_interlaced_source_flag[i]
                bitReader.readU(1);
                // sub_layer_non_packed_constraint_flag[i]
                bitReader.readU(1);
                // sub_layer_frame_only_constraint_flag[i]
                bitReader.readU(1);
                // sub_layer_reserved_zero_44bits[i]
                bitReader.readU(44);
            }
            if (subLayerLevelPresentFlag[i]) {
                // sub_layer_level_idc[i]
                bitReader.readU(8);
            }
        }
        // "The  value  of sps_seq_parameter_set_id shall be in the range of 0 to 15, inclusive."
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        chroma_format_idc = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        if (chroma_format_idc === 3) {
            // separate_colour_plane_flag
            separate_colour_plane_flag = bitReader.readU(1);
        }
        width = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        height = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        const conformanceWindowFlag = bitReader.readU1();
        let confWinLeftOffset = 0;
        let confWinRightOffset = 0;
        let confWinTopOffset = 0;
        let confWinBottomOffset = 0;
        if (conformanceWindowFlag) {
            confWinLeftOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
            confWinRightOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
            confWinTopOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
            confWinBottomOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        }
        bit_depth_luma_minus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        bit_depth_chroma_minus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        let SubWidthC = 2;
        let SubHeightC = 2;
        if (chroma_format_idc === 0) {
            SubWidthC = SubHeightC = 0;
        }
        else if (chroma_format_idc === 2) {
            SubWidthC = 2;
            SubHeightC = 1;
        }
        else if (chroma_format_idc === 3) {
            SubWidthC = SubHeightC = 1;
        }
        const cropUnitX = SubWidthC * (1 << (bit_depth_luma_minus8 + 1));
        const cropUnitY = SubHeightC * (1 << (bit_depth_luma_minus8 + 1));
        width -= cropUnitX * (confWinLeftOffset + confWinRightOffset);
        height -= cropUnitY * (confWinTopOffset + confWinBottomOffset);
    }
    const log2_max_poc_lsb = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader) + 4;
    const sublayer_ordering_info_flag = bitReader.readU1();
    const start = sublayer_ordering_info_flag ? 0 : spsMaxSubLayersMinus1;
    for (let i = start; i < (spsMaxSubLayersMinus1 + 1); i++) {
        // max_dec_pic_buffering
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        // num_reorder_pics
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        // max_latency_increase
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    }
    const log2_min_cb_size = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader) + 3;
    const log2_diff_max_min_coding_block_size = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    const log2_min_tb_size = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader) + 2;
    const log2_diff_max_min_transform_block_size = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    const log2_max_trafo_size = log2_diff_max_min_transform_block_size + log2_min_tb_size;
    const log2_ctb_size = log2_min_cb_size + log2_diff_max_min_coding_block_size;
    const log2_min_pu_size = log2_min_cb_size - 1;
    const ctb_width = (width + (1 << log2_ctb_size) - 1) >> log2_ctb_size;
    const ctb_height = (height + (1 << log2_ctb_size) - 1) >> log2_ctb_size;
    const ctb_size = ctb_width * ctb_height;
    const min_cb_width = width >> log2_min_cb_size;
    const min_cb_height = height >> log2_min_cb_size;
    const min_tb_width = width >> log2_min_tb_size;
    const min_tb_height = height >> log2_min_tb_size;
    const min_pu_width = width >> log2_min_pu_size;
    const min_pu_height = height >> log2_min_pu_size;
    return {
        profile,
        level,
        width,
        height,
        chroma_format_idc,
        bit_depth_luma_minus8,
        bit_depth_chroma_minus8,
        general_profile_space,
        general_tier_flag,
        general_profile_compatibility_flags,
        constraint_flags,
        separate_colour_plane_flag,
        log2_min_cb_size,
        log2_diff_max_min_coding_block_size,
        log2_min_tb_size,
        log2_diff_max_min_transform_block_size,
        log2_max_trafo_size,
        log2_ctb_size,
        log2_min_pu_size,
        ctb_width,
        ctb_height,
        ctb_size,
        min_cb_width,
        min_cb_height,
        min_tb_width,
        min_tb_height,
        min_pu_width,
        min_pu_height,
        log2_max_poc_lsb
    };
}
function parsePPS(pps) {
    if (!pps || pps.length < 3) {
        return;
    }
    let offset = 0;
    if (pps[0] === 0x00
        && pps[1] === 0x00
        && pps[2] === 0x00
        && pps[3] === 0x01) {
        offset = 4;
    }
    const buffer = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.naluUnescape)(pps.subarray(offset));
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__["default"](buffer.length);
    bitReader.appendBuffer(buffer);
    const pps_pic_parameter_set_id = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    const pps_seq_parameter_set_id = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    const dependent_slice_segment_flag = bitReader.readU1();
    const output_flag_present_flag = bitReader.readU1();
    const num_extra_slice_header_bits = bitReader.readU(3);
    return {
        pps_pic_parameter_set_id,
        pps_seq_parameter_set_id,
        dependent_slice_segment_flag,
        output_flag_present_flag,
        num_extra_slice_header_bits
    };
}


/***/ }),

/***/ "./src/avformat/codecs/mp3.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/mp3.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MP3Profile2Name: () => (/* binding */ MP3Profile2Name),
/* harmony export */   getBitRateByVersionLayerIndex: () => (/* binding */ getBitRateByVersionLayerIndex),
/* harmony export */   getFrameSizeByVersionLayer: () => (/* binding */ getFrameSizeByVersionLayer),
/* harmony export */   getProfileByLayer: () => (/* binding */ getProfileByLayer),
/* harmony export */   getSampleRateByVersionIndex: () => (/* binding */ getSampleRateByVersionIndex),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/*
 * libmedia mp3 util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const MpegAudioV10SampleRateTable = [44100, 48000, 32000, 0];
const MpegAudioV20SampleRateTable = [22050, 24000, 16000, 0];
const MpegAudioV25SampleRateTable = [11025, 12000, 8000, 0];
const MpegAudioV10FrameSizeTable = [0, 1152, 1152, 384];
const MpegAudioV20FrameSizeTable = [0, 576, 1152, 384];
const MpegAudioV25FrameSizeTable = [0, 576, 1152, 384];
const MpegAudioV1L1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1];
const MpegAudioV1L2BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1];
const MpegAudioV1L3BitRateTable = [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1];
const MpegAudioV2L1BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, -1];
const MpegAudioV2L2L3BitRateTable = [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1];
function getSampleRateByVersionIndex(version, samplingFreqIndex) {
    switch (version) {
        case 0:
            // MPEG 2.5
            return MpegAudioV25SampleRateTable[samplingFreqIndex];
        case 2:
            // MPEG 2
            return MpegAudioV20SampleRateTable[samplingFreqIndex];
        case 3:
            // MPEG 1
            return MpegAudioV10SampleRateTable[samplingFreqIndex];
    }
    return avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
}
function getFrameSizeByVersionLayer(version, layer) {
    switch (version) {
        case 0:
            // MPEG 2.5
            return MpegAudioV25FrameSizeTable[layer];
        case 2:
            // MPEG 2
            return MpegAudioV20FrameSizeTable[layer];
        case 3:
            // MPEG 1
            return MpegAudioV10FrameSizeTable[layer];
    }
    return avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
}
function getBitRateByVersionLayerIndex(version, layer, index) {
    switch (layer) {
        // layer3
        case 1:
            switch (version) {
                case 0:
                case 2:
                    return MpegAudioV2L2L3BitRateTable[index];
                case 3:
                    return MpegAudioV1L3BitRateTable[index];
            }
            break;
        // layer2
        case 2:
            switch (version) {
                case 0:
                case 2:
                    return MpegAudioV2L2L3BitRateTable[index];
                case 3:
                    return MpegAudioV1L2BitRateTable[index];
            }
        // layer1
        case 3:
            switch (version) {
                case 0:
                case 2:
                    return MpegAudioV2L1BitRateTable[index];
                case 3:
                    return MpegAudioV1L1BitRateTable[index];
            }
    }
    return avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
}
function getProfileByLayer(layer) {
    switch (layer) {
        case 1:
            // Layer 3
            return 34;
        case 2:
            // Layer 2
            return 33;
        case 3:
            // Layer 1
            return 32;
    }
    return avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
}
const MP3Profile2Name = {
    [32 /* MP3Profile.Layer1 */]: 'Layer1',
    [33 /* MP3Profile.Layer2 */]: 'Layer2',
    [34 /* MP3Profile.Layer3 */]: 'Layer3'
};
function parseAVCodecParameters(stream, buffer) {
    if (buffer && buffer.length >= 4) {
        const ver = (buffer[1] >>> 3) & 0x03;
        const layer = (buffer[1] & 0x06) >> 1;
        // const bitrateIndex = (buffer[2] & 0xF0) >>> 4
        const samplingFreqIndex = (buffer[2] & 0x0C) >>> 2;
        const channelMode = (buffer[3] >>> 6) & 0x03;
        const channelCount = channelMode !== 3 ? 2 : 1;
        const profile = getProfileByLayer(layer);
        const sampleRate = getSampleRateByVersionIndex(ver, samplingFreqIndex);
        stream.codecpar.profile = profile;
        stream.codecpar.sampleRate = sampleRate;
        stream.codecpar.chLayout.nbChannels = channelCount;
    }
}


/***/ }),

/***/ "./src/avformat/codecs/vp8.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/vp8.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseExtraData: () => (/* binding */ parseExtraData)
/* harmony export */ });
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/*
 * libmedia vp8 util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        const params = parseExtraData(extradata);
        stream.codecpar.profile = params.profile;
        stream.codecpar.level = params.level;
    }
}
/**
 * - 1 byte profile
 * - 1 byte level
 * - 4 bit bitdepth
 * - 3 bit chroma_subsampling
 * - 1 bit full_range_flag
 * - 1 byte color_primaries
 * - 1 byte color_trc
 * - 1 byte color_space
 *
 * @param extradata
 */
function parseExtraData(extradata) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__["default"](extradata.length);
    bitReader.appendBuffer(extradata.subarray(4));
    const profile = bitReader.readU(8);
    const level = bitReader.readU(8);
    let bitDepth = bitReader.readU(4);
    const chromaSubsampling = bitReader.readU(3);
    const fullRangeFlag = bitReader.readU1();
    const colorPrimaries = bitReader.readU(8);
    const colorTrc = bitReader.readU(8);
    const colorSpace = bitReader.readU(8);
    return {
        profile,
        level,
        bitDepth,
        chromaSubsampling,
        fullRangeFlag,
        colorPrimaries,
        colorTrc,
        colorSpace
    };
}


/***/ }),

/***/ "./src/avformat/codecs/vp9.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/vp9.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VP9Profile2Name: () => (/* binding */ VP9Profile2Name),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseExtraData: () => (/* binding */ parseExtraData)
/* harmony export */ });
/* unused harmony exports LevelCapabilities, getLevelByResolution, generateExtradata */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./..\..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");








const VP9Profile2Name = {
    [0 /* VP9Profile.Profile0 */]: 'Profile0',
    [1 /* VP9Profile.Profile1 */]: 'Profile1',
    [2 /* VP9Profile.Profile2 */]: 'Profile2',
    [3 /* VP9Profile.Profile3 */]: 'Profile3'
};
const LevelCapabilities = [
    { level: 10, maxResolution: 196608, maxFrameRate: 30 },
    { level: 11, maxResolution: 196608, maxFrameRate: 60 },
    { level: 20, maxResolution: 518400, maxFrameRate: 30 },
    { level: 21, maxResolution: 518400, maxFrameRate: 60 },
    { level: 30, maxResolution: 2073600, maxFrameRate: 30 },
    { level: 31, maxResolution: 2073600, maxFrameRate: 60 },
    { level: 40, maxResolution: 3686400, maxFrameRate: 30 },
    { level: 41, maxResolution: 3686400, maxFrameRate: 60 },
    { level: 50, maxResolution: 8294400, maxFrameRate: 30 },
    { level: 51, maxResolution: 8294400, maxFrameRate: 60 },
    { level: 60, maxResolution: 8847360, maxFrameRate: 30 },
    { level: 61, maxResolution: 8847360, maxFrameRate: 60 },
    { level: 70, maxResolution: 35389440, maxFrameRate: 30 },
    { level: 71, maxResolution: 35389440, maxFrameRate: 60 }
];
function getLevelByResolution(width, height, fps) {
    const resolution = width * height;
    for (const level of LevelCapabilities) {
        if (resolution <= level.maxResolution && fps <= level.maxFrameRate) {
            return level.level;
        }
    }
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        const params = parseExtraData(extradata);
        stream.codecpar.profile = params.profile;
        stream.codecpar.level = params.level;
    }
}
/**
 * - 1 byte profile
 * - 1 byte level
 * - 4 bit bitdepth
 * - 3 bit chroma_subsampling
 * - 1 bit full_range_flag
 * - 1 byte color_primaries
 * - 1 byte color_trc
 * - 1 byte color_space
 *
 * @param extradata
 */
function parseExtraData(extradata) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_3__["default"](extradata.length);
    bitReader.appendBuffer(extradata);
    const profile = bitReader.readU(8);
    const level = bitReader.readU(8);
    let bitDepth = bitReader.readU(4);
    const chromaSubsampling = bitReader.readU(3);
    const fullRangeFlag = bitReader.readU1();
    const colorPrimaries = bitReader.readU(8);
    const colorTrc = bitReader.readU(8);
    const colorSpace = bitReader.readU(8);
    return {
        profile,
        level,
        bitDepth,
        chromaSubsampling,
        fullRangeFlag,
        colorPrimaries,
        colorTrc,
        colorSpace
    };
}
function getVpccFeature(codecpar) {
    let profile = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 48);
    let level = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 52);
    if (level === avutil_constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE) {
        level = getLevelByResolution(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 56), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 60), (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_6__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__["default"])(codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_1__.Rational)));
    }
    const desc = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 28)];
    let bitDepth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 40);
    let chromaSubsampling = 1 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_COLLOCATED_WITH_LUMA */;
    if (desc) {
        bitDepth = desc.comp[0].depth;
        if (desc.log2ChromaW === 1 && desc.log2ChromaH === 1) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 100) === 1 /* AVChromaLocation.AVCHROMA_LOC_LEFT */) {
                chromaSubsampling = 0 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_VERTICAL */;
            }
        }
        else if (desc.log2ChromaW === 1 && desc.log2ChromaH === 0) {
            chromaSubsampling = 2 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_422 */;
        }
        else if (desc.log2ChromaW === 0 && desc.log2ChromaH === 0) {
            chromaSubsampling = 3 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_444 */;
        }
    }
    const fullRange = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 84) === 2 /* AVColorRange.AVCOL_RANGE_JPEG */ ? 1 : 0;
    if (profile === avutil_constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE && bitDepth) {
        if (chromaSubsampling == 0 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_VERTICAL */
            || chromaSubsampling == 1 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_COLLOCATED_WITH_LUMA */) {
            profile = (bitDepth == 8) ? 0 /* VP9Profile.Profile0 */ : 2 /* VP9Profile.Profile2 */;
        }
        else {
            profile = (bitDepth == 8) ? 1 /* VP9Profile.Profile1 */ : 3 /* VP9Profile.Profile3 */;
        }
    }
    return {
        profile,
        level,
        bitDepth,
        chromaSubsampling,
        fullRange
    };
}
function generateExtradata(codecpar) {
    const ioWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_7__["default"](new Uint8Array(8));
    const vpcc = getVpccFeature(codecpar);
    ioWriter.writeUint8(vpcc.profile);
    ioWriter.writeUint8(vpcc.level);
    ioWriter.writeUint8((vpcc.bitDepth << 4) | (vpcc.chromaSubsampling << 1) | vpcc.fullRange);
    ioWriter.writeUint8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 88));
    ioWriter.writeUint8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 92));
    ioWriter.writeUint8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 96));
    ioWriter.writeUint16(0);
    return ioWriter.getWroteBuffer();
}


/***/ }),

/***/ "./src/avformat/codecs/vvc.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/vvc.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annexb2Avcc: () => (/* binding */ annexb2Avcc),
/* harmony export */   annexbExtradata2AvccExtradata: () => (/* binding */ annexbExtradata2AvccExtradata),
/* harmony export */   isIDR: () => (/* binding */ isIDR),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseAVCodecParametersBySps: () => (/* binding */ parseAVCodecParametersBySps),
/* harmony export */   parseAnnexbExtraData: () => (/* binding */ parseAnnexbExtraData),
/* harmony export */   parseAvccExtraData: () => (/* binding */ parseAvccExtraData),
/* harmony export */   parseExtraData: () => (/* binding */ parseExtraData),
/* harmony export */   parseSPS: () => (/* binding */ parseSPS)
/* harmony export */ });
/* unused harmony exports extradata2VpsSpsPps, vpsSpsPps2Extradata, avcc2Annexb */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/util/nalu */ "./src/avutil/util/nalu.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/util/expgolomb */ "./src/avutil/util/expgolomb.ts");
/* harmony import */ var common_io_BitWriter__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/io/BitWriter */ "./src/common/io/BitWriter.ts");
/* harmony import */ var avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avutil/util/intread */ "./src/avutil/util/intread.ts");


/*
 * libmedia vvc util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */











const NALULengthSizeMinusOne = 3;
/* eslint-disable camelcase */
function parsePTL(bitReader) {
    const olsIdx = bitReader.readU(9);
    const numSublayers = bitReader.readU(3);
    const constantFrameRate = bitReader.readU(2);
    const chromaFormatIdc = bitReader.readU(2);
    const bitDepthMinus8 = bitReader.readU(3);
    bitReader.readU(5);
    // VvcPTLRecord
    bitReader.readU(2);
    const num_bytes_constraint_info = bitReader.readU(6);
    const generalProfileIdc = bitReader.readU(7);
    const generalTierFlag = bitReader.readU(1);
    const generalLevelIdc = bitReader.readU(8);
    const ptlFrameOnlyConstraintFlag = bitReader.readU(1);
    const ptlMultilayerEnabledFlag = bitReader.readU(1);
    const generalConstraintInfo = [];
    const sublayerLevelIdc = [];
    if (num_bytes_constraint_info) {
        for (let i = 0; i < num_bytes_constraint_info - 1; i++) {
            generalConstraintInfo[i] = bitReader.readU(8);
        }
        generalConstraintInfo[num_bytes_constraint_info - 1] = bitReader.readU(6);
    }
    else {
        bitReader.readU(6);
    }
    if (numSublayers > 1) {
        let ptl_sublayer_present_mask = 0;
        for (let j = numSublayers - 2; j >= 0; --j) {
            const val = bitReader.readU(1);
            ptl_sublayer_present_mask |= val << j;
        }
        for (let j = numSublayers; j <= 8 && numSublayers > 1; ++j) {
            bitReader.readU(1);
        }
        for (let j = numSublayers - 2; j >= 0; --j) {
            if (ptl_sublayer_present_mask & (1 << j)) {
                sublayerLevelIdc[j] = bitReader.readU(8);
            }
        }
    }
    const ptl_num_sub_profiles = bitReader.readU(8);
    const generalSubProfileIdc = [];
    if (ptl_num_sub_profiles) {
        for (let i = 0; i < ptl_num_sub_profiles; i++) {
            generalSubProfileIdc.push(bitReader.readU(8));
        }
    }
    const maxPictureWidth = bitReader.readU(16);
    const maxPictureHeight = bitReader.readU(16);
    const avgFramerate = bitReader.readU(16);
    return {
        olsIdx,
        numSublayers,
        bitDepthMinus8,
        chromaFormatIdc,
        constantFrameRate,
        generalProfileIdc,
        generalTierFlag,
        generalLevelIdc,
        ptlFrameOnlyConstraintFlag,
        ptlMultilayerEnabledFlag,
        generalConstraintInfo,
        sublayerLevelIdc,
        generalSubProfileIdc,
        maxPictureWidth,
        maxPictureHeight,
        avgFramerate
    };
}
/* eslint-enable camelcase */
/**
 *
 * vvcc  extradata  annexb vps sps pps
 *
 * bits
 * - 5   reserved (11111)
 * - 2   lengthSizeMinusOne
 * - 1   ptl_present_flag
 * if ptl_present_flag
 *   - 9   ols_idx
 *   - 3  num_sublayers
 *   - 2  constant_frame_rate
 *   - 2  chroma_format_idc
 *   - 3  bit_depth_minus8
 *   - 5  reserved (11111)
 *   VvcPTLRecord
 *   - 2 reserved (11)
 *   - 6 num_bytes_constraint_info
 *   - 7 general_profile_idc
 *   - 1 general_tier_flag
 *   - 8 general_level_idc
 *   - 1 general_level_idc
 *   - 1 ptl_multilayer_enabled_flag
 *   if num_bytes_constraint_info > 0
 *      for (i = 0; i < num_bytes_constraint_info - 1; i++)
 *        - 8 general_constraint_info[i]
 *      - 6 general_constraint_info[num_bytes_constraint_info - 1]
 *   else
 *      - 6 reserved
 *   if num_sublayers > 1
 *      - num_sublayers - 2 ptl_sublayer_level_present_flag
 *      - 8 - num_sublayers + 1 ptl_reserved_zero_bit
 *      for (i = num_sublayers -2; i >= 0; i--)
 *        if ptl_sublayer_present_mask & (1 << i)
 *          - 8 sublayer_level_idc[i]
 *    - 8 ptl_num_sub_profiles
 *    if ptl_num_sub_profiles
 *      for (i = 0; i < ptl_num_sub_profiles; i++)
 *        - 32 general_sub_profile_idc[i]
 *    - 16 max_picture_width
 *    - 16 max_picture_height
 *    - 16 avg_frame_rate
 * - 8   numOfArrays
 * - repeated of array (vps/sps/pps)
 * - 1   array_completeness
 * - 2   reserved (0)
 * - 5   NAL_unit_type
 * if nalu_type != VVC_NALU_DEC_PARAM && nalu_type != VVC_NALU_OPI
 *    - 16  numNalus
 * else
 *   numNalus = 1
 * - repeated once per NAL
 * - 16  nalUnitLength
 * - N   NALU data
 *
 */
function extradata2VpsSpsPps(extradata) {
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](extradata, true);
    const ptlPresentFlag = bufferReader.readUint8() & 0x01;
    if (ptlPresentFlag) {
        const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__["default"]();
        bitReader.appendBuffer(extradata.subarray(1));
        parsePTL(bitReader);
        bufferReader.skip(bitReader.getPointer());
    }
    let vpss = [];
    let spss = [];
    let ppss = [];
    const arrayLen = bufferReader.readUint8();
    for (let i = 0; i < arrayLen; i++) {
        const naluType = bufferReader.readUint8() & 0x1f;
        let count = 1;
        if (naluType !== 13 /* VVCNaluType.kDCI_NUT */ && naluType !== 12 /* VVCNaluType.kOPI_NUT */) {
            count = bufferReader.readUint16();
        }
        const list = [];
        for (let j = 0; j < count; j++) {
            const len = bufferReader.readUint16();
            list.push(bufferReader.readBuffer(len));
        }
        if (naluType === 14 /* VVCNaluType.kVPS_NUT */) {
            vpss = list;
        }
        else if (naluType === 15 /* VVCNaluType.kSPS_NUT */) {
            spss = list;
        }
        else if (naluType === 16 /* VVCNaluType.kPPS_NUT */) {
            ppss = list;
        }
    }
    return {
        vpss,
        spss,
        ppss
    };
}
function vpsSpsPps2Extradata(vpss, spss, ppss) {
    const sps = spss[0];
    let ptl;
    if (sps) {
        const spsParams = parseSPS(sps);
        let generalConstraintInfo = spsParams.generalConstraintInfo;
        if (!generalConstraintInfo.length) {
            generalConstraintInfo = new Array(12).fill(0);
        }
        const biWriter = new common_io_BitWriter__WEBPACK_IMPORTED_MODULE_11__["default"]();
        biWriter.writeU(9, 0);
        biWriter.writeU(3, spsParams.spsMaxSublayersMinus1 + 1);
        biWriter.writeU(2, 1);
        biWriter.writeU(2, spsParams.chromaFormatIdc);
        biWriter.writeU(3, spsParams.bitDepthMinus8);
        biWriter.writeU(5, 0b11111);
        biWriter.writeU(2, 0);
        biWriter.writeU(6, generalConstraintInfo.length);
        biWriter.writeU(7, spsParams.profile);
        biWriter.writeU1(spsParams.tierFlag);
        biWriter.writeU(8, spsParams.level);
        biWriter.writeU1(spsParams.ptlFrameOnlyConstraintFlag);
        biWriter.writeU1(spsParams.ptlMultilayerEnabledFlag);
        if (generalConstraintInfo.length) {
            for (let i = 0; i < generalConstraintInfo.length - 1; i++) {
                biWriter.writeU(8, generalConstraintInfo[i]);
            }
            biWriter.writeU(6, generalConstraintInfo[generalConstraintInfo.length - 1]);
        }
        else {
            biWriter.writeU(6, 0b111111);
        }
        if (spsParams.spsMaxSublayersMinus1 + 1 > 1) {
            let ptlSubLayerLevelPresentFlags = 0;
            for (let i = spsParams.spsMaxSublayersMinus1 - 1; i >= 0; i--) {
                ptlSubLayerLevelPresentFlags = (ptlSubLayerLevelPresentFlags << 1 | spsParams.ptlSublayerLevelPresentFlag[i]);
            }
            biWriter.writeU(spsParams.spsMaxSublayersMinus1, ptlSubLayerLevelPresentFlags);
            for (let j = spsParams.spsMaxSublayersMinus1 + 1; j <= 8 && spsParams.spsMaxSublayersMinus1 > 0; ++j) {
                biWriter.writeU1(0);
            }
            for (let i = spsParams.spsMaxSublayersMinus1 - 1; i >= 0; i--) {
                if (spsParams.ptlSublayerLevelPresentFlag[i]) {
                    biWriter.writeU(8, spsParams.sublayerLevelIdc[i]);
                }
            }
        }
        biWriter.writeU(8, spsParams.generalSubProfileIdc.length);
        for (let i = 0; i < spsParams.generalSubProfileIdc.length; i++) {
            biWriter.writeU(8, spsParams.sublayerLevelIdc[i]);
        }
        biWriter.writeU(16, spsParams.width);
        biWriter.writeU(16, spsParams.height);
        biWriter.writeU(16, 0);
        biWriter.padding();
        ptl = biWriter.getBuffer().subarray(0, biWriter.getPointer());
    }
    let length = 2 + (ptl ? ptl.length : 0);
    if (vpss.length) {
        // type + count
        length += 3;
        length = vpss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    if (spss.length) {
        // type + count
        length += 3;
        length = spss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    if (ppss.length) {
        // type + count
        length += 3;
        length = ppss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    const buffer = new Uint8Array(length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer, true);
    bufferWriter.writeUint8(NALULengthSizeMinusOne << 1 | (ptl ? 1 : 0) | 0xf8);
    if (ptl) {
        bufferWriter.writeBuffer(ptl);
    }
    // numOfArrays
    let numOfArrays = 0;
    if (vpss.length) {
        numOfArrays++;
    }
    if (spss.length) {
        numOfArrays++;
    }
    if (ppss.length) {
        numOfArrays++;
    }
    bufferWriter.writeUint8(numOfArrays);
    // vps
    if (vpss.length) {
        bufferWriter.writeUint8((128) | 14 /* VVCNaluType.kVPS_NUT */);
        bufferWriter.writeUint16(vpss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(vpss, (vps) => {
            bufferWriter.writeUint16(vps.length);
            bufferWriter.writeBuffer(vps);
        });
    }
    // sps
    if (spss.length) {
        bufferWriter.writeUint8((128) | 15 /* VVCNaluType.kSPS_NUT */);
        bufferWriter.writeUint16(spss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
            bufferWriter.writeUint16(sps.length);
            bufferWriter.writeBuffer(sps);
        });
    }
    // pps
    if (ppss.length) {
        bufferWriter.writeUint8((128) | 16 /* VVCNaluType.kPPS_NUT */);
        bufferWriter.writeUint16(ppss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
            bufferWriter.writeUint16(pps.length);
            bufferWriter.writeBuffer(pps);
        });
    }
    return buffer;
}
function annexbExtradata2AvccExtradata(data) {
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)(data);
    if (nalus.length >= 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[1] >>> 3) & 0x1f;
            if (type === 14 /* VVCNaluType.kVPS_NUT */) {
                vpss.push(nalu);
            }
            else if (type === 15 /* VVCNaluType.kSPS_NUT */) {
                spss.push(nalu);
            }
            else if (type === 16 /* VVCNaluType.kPPS_NUT */) {
                ppss.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            return vpsSpsPps2Extradata(vpss, spss, ppss);
        }
    }
}
/**
 *
 * annexb  NALU  avcc NALU
 *
 */
function annexb2Avcc(data) {
    let extradata;
    let key = false;
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)(data);
    if (nalus.length >= 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[1] >>> 3) & 0x1f;
            if (type === 14 /* VVCNaluType.kVPS_NUT */) {
                vpss.push(nalu);
            }
            else if (type === 15 /* VVCNaluType.kSPS_NUT */) {
                spss.push(nalu);
            }
            else if (type === 16 /* VVCNaluType.kPPS_NUT */) {
                ppss.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
            nalus = nalus.filter((nalu) => {
                const type = (nalu[1] >>> 3) & 0x1f;
                return type !== 14 /* VVCNaluType.kVPS_NUT */
                    && type !== 15 /* VVCNaluType.kSPS_NUT */
                    && type !== 16 /* VVCNaluType.kPPS_NUT */
                    && type !== 20 /* VVCNaluType.kAUD_NUT */;
            });
        }
    }
    const length = nalus.reduce((prev, nalu) => {
        return prev + NALULengthSizeMinusOne + 1 + nalu.length;
    }, 0);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(length);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(bufferPointer, length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu) => {
        if (NALULengthSizeMinusOne === 3) {
            bufferWriter.writeUint32(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 2) {
            bufferWriter.writeUint24(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 1) {
            bufferWriter.writeUint16(nalu.length);
        }
        else {
            bufferWriter.writeUint8(nalu.length);
        }
        bufferWriter.writeBuffer(nalu.subarray(0));
        const type = (nalu[1] >>> 3) & 0x1f;
        if (type === 8 /* VVCNaluType.kIDR_N_LP */
            || type === 7 /* VVCNaluType.kIDR_W_RADL */
            || type === 9 /* VVCNaluType.kCRA_NUT */
            || type === 10 /* VVCNaluType.kGDR_NUT */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length,
        extradata,
        key
    };
}
/**
 * avcc  NALU  annexb NALU
 *
 */
function avcc2Annexb(data, extradata) {
    const naluLengthSizeMinusOne = extradata ? ((extradata[0] >>> 1) & 0x03) : NALULengthSizeMinusOne;
    let vpss = [];
    let spss = [];
    let ppss = [];
    let key = false;
    if (extradata) {
        const result = extradata2VpsSpsPps(extradata);
        vpss = result.vpss;
        spss = result.spss;
        ppss = result.ppss;
        key = true;
    }
    const nalus = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        nalus.push(bufferReader.readBuffer(length));
    }
    let length = vpss.reduce((prev, vps) => {
        return prev + 4 + vps.length;
    }, 0);
    length = spss.reduce((prev, sps) => {
        return prev + 4 + sps.length;
    }, length);
    length = ppss.reduce((prev, pps) => {
        return prev + 4 + pps.length;
    }, length);
    length = nalus.reduce((prev, nalu, index) => {
        return prev + (index ? 3 : 4) + nalu.length;
    }, length);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(length + 7);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(bufferPointer, length + 7);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer);
    // AUD
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(20 /* VVCNaluType.kAUD_NUT */ << 3);
    bufferWriter.writeUint8(0xf0);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(vpss, (vps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(vps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(sps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(pps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu, index) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        if (!index) {
            bufferWriter.writeUint8(0x00);
        }
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(nalu);
        const type = (nalu[1] >>> 3) & 0x1f;
        if (type === 8 /* VVCNaluType.kIDR_N_LP */
            || type === 7 /* VVCNaluType.kIDR_W_RADL */
            || type === 9 /* VVCNaluType.kCRA_NUT */
            || type === 10 /* VVCNaluType.kGDR_NUT */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length: length + 7,
        key
    };
}
function parseAvccExtraData(avpacket, stream) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if ((0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.isAnnexb)(data)) {
        return;
    }
    const naluLengthSizeMinusOne = stream.metadata.naluLengthSizeMinusOne ?? NALULengthSizeMinusOne;
    let vpss = [];
    let spss = [];
    let ppss = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_4__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = data.subarray(Number(BigInt.asIntN(32, bufferReader.getPos())), Number(BigInt.asIntN(32, bufferReader.getPos())) + length);
        bufferReader.skip(length);
        const naluType = (nalu[1] >>> 3) & 0x1f;
        if (naluType === 15 /* VVCNaluType.kSPS_NUT */) {
            spss.push(nalu);
        }
        else if (naluType === 16 /* VVCNaluType.kPPS_NUT */) {
            ppss.push(nalu);
        }
        else if (naluType === 14 /* VVCNaluType.kVPS_NUT */) {
            vpss.push(nalu);
        }
    }
    if (spss.length || ppss.length || vpss.length) {
        const extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
        const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(extradata.length);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
    }
}
function parseAnnexbExtraData(avpacket, force = false) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) && !force) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if (!(0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.isAnnexb)(data)) {
        return;
    }
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)(data);
    if (nalus.length > 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[1] >>> 3) & 0x1f;
            if (type === 14 /* VVCNaluType.kVPS_NUT */) {
                vpss.push(nalu);
            }
            else if (type === 15 /* VVCNaluType.kSPS_NUT */) {
                spss.push(nalu);
            }
            else if (type === 16 /* VVCNaluType.kPPS_NUT */) {
                ppss.push(nalu);
            }
        });
        if (vpss.length && spss.length && ppss.length) {
            const extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
            const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_9__.avMalloc)(extradata.length);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
        }
    }
}
function parseAVCodecParametersBySps(stream, sps) {
    const { profile, level, width, height } = parseSPS(sps);
    stream.codecpar.profile = profile;
    stream.codecpar.level = level;
    stream.codecpar.width = width;
    stream.codecpar.height = height;
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        stream.metadata.naluLengthSizeMinusOne = (extradata[0] >>> 1) & 0x03;
        const { spss } = extradata2VpsSpsPps(extradata);
        if (spss.length) {
            parseAVCodecParametersBySps(stream, spss[0]);
        }
    }
}
function isIDR(avpacket, naluLengthSize = 4) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 80) === 2 /* BitFormat.ANNEXB */) {
        let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.splitNaluByStartCode)((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28)));
        return nalus.some((nalu) => {
            const type = (nalu[1] >>> 3) & 0x1f;
            return type === 8 /* VVCNaluType.kIDR_N_LP */ || type === 7 /* VVCNaluType.kIDR_W_RADL */;
        });
    }
    else {
        const size = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28);
        let i = 0;
        while (i < (size - naluLengthSize)) {
            const type = (avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + (i + naluLengthSize + 1)) >>> 3) & 0x1f;
            if (type === 8 /* VVCNaluType.kIDR_N_LP */ || type === 7 /* VVCNaluType.kIDR_W_RADL */) {
                return true;
            }
            if (naluLengthSize === 4) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.rb32(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else if (naluLengthSize === 3) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.rb24(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else if (naluLengthSize === 2) {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.rb16(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            else {
                i += avutil_util_intread__WEBPACK_IMPORTED_MODULE_12__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24) + i);
            }
            i += naluLengthSize;
        }
        return false;
    }
}
function parseSPS(sps) {
    if (!sps || sps.length < 3) {
        return;
    }
    let offset = 0;
    if (sps[0] === 0x00
        && sps[1] === 0x00
        && sps[2] === 0x00
        && sps[3] === 0x01) {
        offset = 4;
    }
    let profile = 0;
    let level = 0;
    let width = 0;
    let height = 0;
    let bitDepthMinus8 = 0;
    let chromaFormatIdc = 1;
    let generalProfileSpace = 0;
    let tierFlag = 0;
    let ptlFrameOnlyConstraintFlag = 0;
    let ptlMultilayerEnabledFlag = 0;
    const generalConstraintInfo = [];
    const ptlSublayerLevelPresentFlag = [];
    const sublayerLevelIdc = [];
    const generalSubProfileIdc = [];
    const buffer = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_7__.naluUnescape)(sps.subarray(offset));
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__["default"](buffer.length);
    bitReader.appendBuffer(buffer);
    // forbidden_zero_bit
    bitReader.readU1();
    // nuh_reserved_zero_bit
    bitReader.readU1();
    // layerId
    bitReader.readU(6);
    // nalu type
    bitReader.readU(5);
    // tid
    bitReader.readU(3);
    // sps_seq_parameter_set_id && sps_video_parameter_set_id
    bitReader.readU(8);
    const spsMaxSublayersMinus1 = bitReader.readU(3);
    chromaFormatIdc = bitReader.readU(2);
    const sps_log2_ctu_size_minus5 = bitReader.readU(2);
    const sps_ptl_dpb_hrd_params_present_flag = bitReader.readU(1);
    if (sps_ptl_dpb_hrd_params_present_flag) {
        profile = bitReader.readU(7);
        tierFlag = bitReader.readU(1);
        level = bitReader.readU(8);
        ptlFrameOnlyConstraintFlag = bitReader.readU(1);
        ptlMultilayerEnabledFlag = bitReader.readU(1);
        const gci_present_flag = bitReader.readU(1);
        if (gci_present_flag) {
            for (let j = 0; j < 8; j++) {
                generalConstraintInfo[j] = bitReader.readU(8);
            }
            generalConstraintInfo[8] = bitReader.readU(7);
            const gci_num_reserved_bits = bitReader.readU(8);
            bitReader.readU(gci_num_reserved_bits);
        }
        bitReader.skipPadding();
        for (let i = spsMaxSublayersMinus1 - 1; i >= 0; i--) {
            ptlSublayerLevelPresentFlag[i] = bitReader.readU(1);
        }
        bitReader.skipPadding();
        for (let i = spsMaxSublayersMinus1 - 1; i >= 0; i--) {
            if (ptlSublayerLevelPresentFlag[i]) {
                sublayerLevelIdc[i] = bitReader.readU(8);
            }
        }
        const ptl_num_sub_profiles = bitReader.readU(8);
        if (ptl_num_sub_profiles) {
            for (let i = 0; i < ptl_num_sub_profiles; i++) {
                generalSubProfileIdc[i] = bitReader.readU(32);
            }
        }
    }
    // sps_gdr_enabled_flag
    bitReader.readU1();
    const sps_ref_pic_resampling_enabled_flag = bitReader.readU1();
    if (sps_ref_pic_resampling_enabled_flag) {
        // sps_res_change_in_clvs_allowed_flag
        bitReader.readU1();
    }
    const sps_pic_width_max_in_luma_samples = width = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    const sps_pic_height_max_in_luma_samples = height = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    if (bitReader.readU1()) {
        // sps_conf_win_left_offset
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        // sps_conf_win_right_offset
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        // sps_conf_win_top_offset
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        // sps_conf_win_bottom_offset
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    }
    if (bitReader.readU1()) {
        const sps_num_subpics_minus1 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        const ctb_log2_size_y = sps_log2_ctu_size_minus5 + 5;
        const ctb_size_y = 1 << ctb_log2_size_y;
        const tmp_width_val = sps_pic_width_max_in_luma_samples / (1 << ctb_log2_size_y);
        const tmp_height_val = sps_pic_height_max_in_luma_samples / (1 << ctb_log2_size_y);
        const wlen = Math.ceil(Math.log2(tmp_width_val));
        const hlen = Math.ceil(Math.log2(tmp_height_val));
        let sps_subpic_id_len = 0;
        let sps_subpic_same_size_flag = 0;
        let sps_independent_subpics_flag = 0;
        // sps_num_subpics_minus1
        if (sps_num_subpics_minus1 > 0) {
            sps_independent_subpics_flag = bitReader.readU1();
            sps_subpic_same_size_flag = bitReader.readU1();
        }
        for (let i = 0; sps_num_subpics_minus1 > 0 && i <= sps_num_subpics_minus1; i++) {
            if (!sps_subpic_same_size_flag || i == 0) {
                if (i > 0 && sps_pic_width_max_in_luma_samples > ctb_size_y) {
                    bitReader.readU(wlen);
                }
                if (i > 0 && sps_pic_height_max_in_luma_samples > ctb_size_y) {
                    bitReader.readU(hlen);
                }
                if (i < sps_num_subpics_minus1 && sps_pic_width_max_in_luma_samples > ctb_size_y) {
                    bitReader.readU(wlen);
                }
                if (i < sps_num_subpics_minus1 && sps_pic_height_max_in_luma_samples > ctb_size_y) {
                    bitReader.readU(hlen);
                }
            }
            if (!sps_independent_subpics_flag) {
                // sps_subpic_treated_as_pic_flag && sps_loop_filter_across_subpic_enabled_flag
                bitReader.readU(2);
            }
        }
        sps_subpic_id_len = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader) + 1;
        // sps_subpic_id_mapping_explicitly_signalled_flag
        if (bitReader.readU(1)) {
            // sps_subpic_id_mapping_present_flag
            if (bitReader.readU(1)) {
                for (let i = 0; i <= sps_num_subpics_minus1; i++) {
                    // sps_subpic_id[i]
                    bitReader.readU(sps_subpic_id_len);
                }
            }
        }
    }
    bitDepthMinus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    // sps_entropy_coding_sync_enabled_flag
    bitReader.readU(1);
    // sps_entry_point_offsets_present_flag
    bitReader.readU(1);
    const sps_log2_max_pic_order_cnt_lsb_minus4 = bitReader.readU(4);
    const sps_poc_msb_cycle_flag = bitReader.readU(1);
    let sps_poc_msb_cycle_len_minus1 = 0;
    if (sps_poc_msb_cycle_flag) {
        sps_poc_msb_cycle_len_minus1 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
    }
    const sps_extra_ph_bit_present_flag = [];
    const sps_num_extra_ph_bytes = bitReader.readU(2);
    for (let i = 0; i < (sps_num_extra_ph_bytes * 8); i++) {
        sps_extra_ph_bit_present_flag[i] = bitReader.readU(1);
    }
    return {
        profile,
        level,
        width,
        height,
        chromaFormatIdc,
        bitDepthMinus8,
        generalProfileSpace,
        tierFlag,
        generalConstraintInfo,
        generalSubProfileIdc,
        ptlFrameOnlyConstraintFlag,
        ptlMultilayerEnabledFlag,
        spsMaxSublayersMinus1,
        ptlSublayerLevelPresentFlag,
        sublayerLevelIdc,
        sps_log2_max_pic_order_cnt_lsb_minus4,
        sps_poc_msb_cycle_flag,
        sps_poc_msb_cycle_len_minus1,
        sps_num_extra_ph_bytes,
        sps_extra_ph_bit_present_flag
    };
}
function parseExtraData(extradata) {
    if (extradata[0] === 0 && extradata[1] === 0 && extradata[2] === 0 && extradata[3] === 1) {
        extradata = annexbExtradata2AvccExtradata(extradata);
    }
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_5__["default"]();
    bitReader.appendBuffer(extradata);
    const ptlPresentFlag = bitReader.readU(8) & 0x01;
    if (ptlPresentFlag) {
        return parsePTL(bitReader);
    }
    return {};
}


/***/ }),

/***/ "./src/avformat/config.ts":
/*!********************************!*\
  !*** ./src/avformat/config.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DURATION_MAX_READ_SIZE: () => (/* binding */ DURATION_MAX_READ_SIZE),
/* harmony export */   SAMPLE_INDEX_STEP: () => (/* binding */ SAMPLE_INDEX_STEP)
/* harmony export */ });
/*
 * libmedia avformat config
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const DURATION_MAX_READ_SIZE = 256000;
const SAMPLE_INDEX_STEP = BigInt(5000);


/***/ }),

/***/ "./src/avformat/demux.ts":
/*!*******************************!*\
  !*** ./src/avformat/demux.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   analyzeStreams: () => (/* binding */ analyzeStreams),
/* harmony export */   open: () => (/* binding */ open),
/* harmony export */   readAVPacket: () => (/* binding */ readAVPacket),
/* harmony export */   seek: () => (/* binding */ seek)
/* harmony export */ });
/* unused harmony export DefaultDemuxOptions */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_audiosample_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\avutil\struct\audiosample.ts */ "./src/avutil/struct/audiosample.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var _function_checkStreamParameters__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./function/checkStreamParameters */ "./src/avformat/function/checkStreamParameters.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./config */ "./src/avformat/config.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! avcodec/wasmcodec/VideoDecoder */ "./src/avcodec/wasmcodec/VideoDecoder.ts");
/* harmony import */ var avcodec_wasmcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avcodec/wasmcodec/AudioDecoder */ "./src/avcodec/wasmcodec/AudioDecoder.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
var cheap__fileName__0 = "src\\avformat\\demux.ts";

















const DefaultDemuxOptions = {
    fastOpen: false,
    maxAnalyzeDuration: 1000
};
// @ts-ignore
async function open(formatContext, options = {}) {
    const opts = common_util_object__WEBPACK_IMPORTED_MODULE_5__.extend({}, DefaultDemuxOptions, options);
    if (!formatContext.ioReader) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_13__.fatal('need IOReader', cheap__fileName__0, 65);
    }
    if (!formatContext.iformat) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_13__.fatal('need iformat', cheap__fileName__0, 68);
    }
    if (formatContext.iformat.type === 2 /* AVFormat.MPEGTS */) {
        // mpegts  2 mpegts  dts  1.4 
        opts.maxAnalyzeDuration = Math.max(opts.maxAnalyzeDuration, 2000);
    }
    formatContext.iformat.init(formatContext);
    formatContext.options = opts;
    return formatContext.iformat.readHeader(formatContext);
}
// @ts-ignore
async function estimateDurationFromPts(formatContext) {
    const fileSize = await formatContext.ioReader.fileSize();
    if (fileSize <= BigInt(0)) {
        return;
    }
    const cache = formatContext.interval.packetBuffer;
    formatContext.interval.packetBuffer = [];
    let now = formatContext.ioReader.getPos();
    let retry = 0;
    while (retry < 4) {
        const pos = fileSize - BigInt(Math.floor(_config__WEBPACK_IMPORTED_MODULE_11__.DURATION_MAX_READ_SIZE << retry));
        const nextPos = await formatContext.iformat.seek(formatContext, null, pos, 2 /* AVSeekFlags.BYTE */);
        if (nextPos > BigInt(0)) {
            now = nextPos;
        }
        const lastDurationMap = {};
        const avpacket = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.createAVPacket)();
        while (true) {
            const ret = await readAVPacket(formatContext, avpacket);
            if (ret < 0) {
                break;
            }
            else {
                let duration = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8);
                const stream = formatContext.getStreamByIndex(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32));
                if (stream.startTime !== avutil_constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE_BIGINT) {
                    duration -= stream.startTime;
                }
                else {
                    duration -= stream.firstDTS;
                }
                if (duration > BigInt(0)) {
                    if (stream.duration === avutil_constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE_BIGINT
                        || !lastDurationMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32)]
                        || (stream.duration < duration
                            && Math.abs(Number(duration - stream.duration)) < 60 * stream.timeBase.den / stream.timeBase.num)) {
                        stream.duration = duration;
                    }
                    lastDurationMap[avpacket.streamIndex] = duration;
                }
            }
        }
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.destroyAVPacket)(avpacket);
        let hasDuration = true;
        common_util_array__WEBPACK_IMPORTED_MODULE_6__.each(formatContext.streams, (stream) => {
            if (stream.duration === avutil_constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE_BIGINT) {
                hasDuration = false;
                return false;
            }
        });
        if (hasDuration) {
            break;
        }
        retry++;
    }
    common_util_array__WEBPACK_IMPORTED_MODULE_6__.each(formatContext.interval.packetBuffer, (avpacket) => {
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.destroyAVPacket)(avpacket);
    });
    formatContext.interval.packetBuffer = cache;
    await formatContext.iformat.seek(formatContext, null, now, 2 /* AVSeekFlags.BYTE */);
}
// @ts-ignore
async function analyzeStreams(formatContext) {
    const needStreams = formatContext.iformat.getAnalyzeStreamsCount();
    const streamFirstGotMap = {};
    const streamDtsMap = {};
    const streamBitMap = {};
    let avpacket = 0;
    const caches = [];
    let ret = 0;
    const decoderMap = {};
    const pictureGot = {};
    function checkPictureGot() {
        if (!formatContext.getDecoderResource) {
            return true;
        }
        for (let i = 0; i < formatContext.streams.length; i++) {
            if (decoderMap[formatContext.streams[i].index] && !pictureGot[formatContext.streams[i].index]) {
                return false;
            }
        }
        return true;
    }
    while (true) {
        if (formatContext.streams.length >= needStreams
            && (0,_function_checkStreamParameters__WEBPACK_IMPORTED_MODULE_8__.checkStreamParameters)(formatContext)
            && formatContext.options.fastOpen
            && checkPictureGot()) {
            break;
        }
        if (!avpacket) {
            avpacket = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.createAVPacket)();
        }
        let packetCached = false;
        ret = await readAVPacket(formatContext, avpacket);
        if (ret !== 0) {
            break;
        }
        const stream = formatContext.getStreamByIndex(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28)) {
            packetCached = true;
            caches.push(avpacket);
            if (!streamFirstGotMap[stream.index]) {
                stream.firstDTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16);
                stream.startTime = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8);
                streamFirstGotMap[stream.index] = true;
            }
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8) < stream.startTime) {
                stream.startTime = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8);
            }
            if (streamDtsMap[stream.index]) {
                streamDtsMap[stream.index].push(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16));
            }
            else {
                streamDtsMap[stream.index] = [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16)];
            }
            if (streamBitMap[stream.index]) {
                streamBitMap[stream.index] += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28);
            }
            else {
                streamBitMap[stream.index] = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28);
            }
            if (!pictureGot[stream.index] && formatContext.getDecoderResource) {
                let decoder = decoderMap[stream.index];
                if (!decoder) {
                    const resource = await formatContext.getDecoderResource(stream.codecpar.codecType, stream.codecpar.codecId);
                    if (resource) {
                        if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                            decoder = new avcodec_wasmcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_15__["default"]({
                                resource,
                                onReceiveFrame: (avframe) => {
                                    stream.codecpar.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 80);
                                    stream.codecpar.frameSize = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 76);
                                    stream.codecpar.sampleRate = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 152);
                                    stream.codecpar.chLayout = (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avframe + 288, _avutil_struct_audiosample_ts__WEBPACK_IMPORTED_MODULE_2__.AVChannelLayout);
                                    (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_16__.destroyAVFrame)(avframe);
                                    pictureGot[stream.index] = true;
                                },
                                onError: () => {
                                    pictureGot[stream.index] = true;
                                }
                            });
                        }
                        else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                            if (resource.threadModule) {
                                delete resource.threadModule;
                            }
                            decoder = new avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_14__["default"]({
                                resource,
                                onReceiveFrame: (avframe) => {
                                    stream.codecpar.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 80);
                                    stream.codecpar.colorSpace = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 220);
                                    stream.codecpar.colorPrimaries = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 212);
                                    stream.codecpar.colorTrc = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 216);
                                    stream.codecpar.chromaLocation = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 224);
                                    stream.codecpar.sampleAspectRatio = (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avframe + 92, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational);
                                    stream.codecpar.width = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 68);
                                    stream.codecpar.height = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 72);
                                    (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_16__.destroyAVFrame)(avframe);
                                    pictureGot[stream.index] = true;
                                },
                                onError: () => {
                                    pictureGot[stream.index] = true;
                                }
                            });
                        }
                        await decoder.open(stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
                        decoderMap[stream.index] = decoder;
                    }
                }
                if (decoder) {
                    decoder.decode(avpacket);
                }
            }
        }
        if (streamDtsMap[stream.index] && streamDtsMap[stream.index].length === 12) {
            let count = BigInt(0);
            for (let i = 1; i < streamDtsMap[stream.index].length; i++) {
                count += streamDtsMap[stream.index][i] - streamDtsMap[stream.index][i - 1];
            }
            let value = Number(count) / (streamDtsMap[stream.index].length - 1);
            if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                && stream.codecpar.sampleRate > 0) {
                stream.codecpar.frameSize = Math.round(value / stream.timeBase.den * stream.timeBase.num * stream.codecpar.sampleRate);
            }
            else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                const framerate = stream.timeBase.den * stream.timeBase.num / value;
                stream.codecpar.framerate.num = Math.round(framerate);
                stream.codecpar.framerate.den = 1;
            }
            const duration = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16) - stream.firstDTS) * stream.timeBase.num / stream.timeBase.den;
            if (duration) {
                stream.codecpar.bitrate = BigInt(Math.floor(streamBitMap[stream.index] * 8 / duration));
            }
        }
        if ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16) - stream.startTime) > (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_9__.avRescaleQ)(BigInt(Math.floor(formatContext.options.maxAnalyzeDuration)), avutil_constant__WEBPACK_IMPORTED_MODULE_7__.AV_MILLI_TIME_BASE_Q, stream.timeBase)) {
            common_util_object__WEBPACK_IMPORTED_MODULE_5__.each(streamDtsMap, (list, id) => {
                const stream = formatContext.getStreamByIndex(+id);
                if (list && list.length > 1) {
                    let count = BigInt(0);
                    for (let i = 1; i < list.length; i++) {
                        count += list[i] - list[i - 1];
                    }
                    let value = Number(count) / (streamDtsMap[stream.index].length - 1);
                    if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                        && stream.codecpar.sampleRate > 0) {
                        stream.codecpar.frameSize = Math.round(value / stream.timeBase.den * stream.timeBase.num * stream.codecpar.sampleRate);
                    }
                    else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                        const framerate = stream.timeBase.den * stream.timeBase.num / value;
                        stream.codecpar.framerate.num = Math.round(framerate);
                        stream.codecpar.framerate.den = 1;
                    }
                    const duration = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16) - stream.firstDTS) * stream.timeBase.num / stream.timeBase.den;
                    if (duration) {
                        stream.codecpar.bitrate = BigInt(Math.floor(streamBitMap[stream.index] * 8 / duration));
                    }
                }
            });
            if (packetCached) {
                avpacket = 0;
            }
            break;
        }
        if (packetCached) {
            avpacket = 0;
        }
    }
    if (avpacket) {
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.destroyAVPacket)(avpacket);
    }
    if (caches.length) {
        formatContext.interval.packetBuffer = caches.concat(formatContext.interval.packetBuffer);
    }
    common_util_object__WEBPACK_IMPORTED_MODULE_5__.each(decoderMap, (decoder) => {
        if (decoder) {
            decoder.close();
        }
    });
    if (ret === -1048576 /* IOError.END */) {
        return 0;
    }
    else if (ret !== 0) {
        return ret;
    }
    if ((formatContext.iformat.type === 2 /* AVFormat.MPEGTS */)
        && (formatContext.ioReader.flags & 1 /* IOFlags.SEEKABLE */)) {
        await estimateDurationFromPts(formatContext);
    }
    return 0;
}
function addSample(stream, avpacket) {
    const index = common_util_array__WEBPACK_IMPORTED_MODULE_6__.binarySearch(stream.sampleIndexes, (sample) => {
        if (sample.pts < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8)) {
            return 1;
        }
        else {
            return -1;
        }
    });
    const sample = {
        dts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16),
        pts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8),
        pos: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 56),
        size: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28),
        duration: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 48),
        flags: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 36)
    };
    if (index > -1) {
        stream.sampleIndexesPosMap.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 56), index);
        stream.sampleIndexes.splice(index, 0, sample);
    }
    else {
        stream.sampleIndexesPosMap.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 56), stream.sampleIndexes.length);
        stream.sampleIndexes.push(sample);
    }
}
// @ts-ignore
async function packetNeedRead(formatContext, avpacket) {
    const stream = formatContext.getStreamByIndex(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32));
    let ret = 0;
    // h264 hevc aac  extradata
    if (stream
        && (stream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */
            || stream.codecpar.codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
            || stream.codecpar.codecId === 196 /* AVCodecID.AV_CODEC_ID_VVC */
            || stream.codecpar.codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */)) {
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28)
            && (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.hasAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */)) {
            while (1) {
                const tmpPacket = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.createAVPacket)();
                ret = await formatContext.iformat.readAVPacket(formatContext, tmpPacket);
                if (ret !== 0) {
                    if (formatContext.interval.packetBuffer.length) {
                        let cache = formatContext.interval.packetBuffer.shift();
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.unrefAVPacket)(avpacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.refAVPacket)(avpacket, cache);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.destroyAVPacket)(cache);
                        return packetNeedRead(formatContext, avpacket);
                    }
                    return ret;
                }
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](tmpPacket + 32) === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32)) {
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](tmpPacket + 28)) {
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.copyAVPacketData)(avpacket, tmpPacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.destroyAVPacket)(tmpPacket);
                        return 0;
                    }
                    else {
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.unrefAVPacket)(avpacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.refAVPacket)(avpacket, tmpPacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.destroyAVPacket)(tmpPacket);
                        continue;
                    }
                }
                else {
                    formatContext.interval.packetBuffer.push(tmpPacket);
                }
            }
        }
        else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 36) & 32 /* AVPacketFlags.AV_PKT_FLAG_END */) {
            return readAVPacket(formatContext, avpacket);
        }
    }
    if (formatContext.ioReader.flags & 1 /* IOFlags.SEEKABLE */) {
        if (!stream.sampleIndexesPosMap.has(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 56))) {
            if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                    addSample(stream, avpacket);
                }
            }
            else if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                const index = common_util_array__WEBPACK_IMPORTED_MODULE_6__.binarySearch(stream.sampleIndexes, (sample) => {
                    if (sample.pts < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8)) {
                        return 1;
                    }
                    else {
                        return -1;
                    }
                });
                if (!stream.sampleIndexes.length
                    || (index < 0
                        && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_9__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8) - stream.sampleIndexes[stream.sampleIndexes.length - 1].pts, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_7__.AV_MILLI_TIME_BASE_Q) >= _config__WEBPACK_IMPORTED_MODULE_11__.SAMPLE_INDEX_STEP)
                    || (index > 0
                        && index < stream.sampleIndexes.length - 1
                        && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_9__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8) - stream.sampleIndexes[index - 1].pts, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_7__.AV_MILLI_TIME_BASE_Q) >= _config__WEBPACK_IMPORTED_MODULE_11__.SAMPLE_INDEX_STEP)
                    || (index === 0
                        && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_9__.avRescaleQ)(stream.sampleIndexes[0].pts - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_7__.AV_MILLI_TIME_BASE_Q) >= _config__WEBPACK_IMPORTED_MODULE_11__.SAMPLE_INDEX_STEP)) {
                    addSample(stream, avpacket);
                }
            }
        }
    }
    return 0;
}
// @ts-ignore
async function readAVPacket(formatContext, avpacket) {
    let ret = 0;
    (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.unrefAVPacket)(avpacket);
    if (formatContext.interval.packetBuffer.length) {
        const cache = formatContext.interval.packetBuffer.shift();
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.refAVPacket)(avpacket, cache);
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.destroyAVPacket)(cache);
        return packetNeedRead(formatContext, avpacket);
    }
    ret = await formatContext.iformat.readAVPacket(formatContext, avpacket);
    if (ret !== 0) {
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.unrefAVPacket)(avpacket);
        return ret;
    }
    return packetNeedRead(formatContext, avpacket);
}
// @ts-ignore
async function seek(formatContext, streamIndex, timestamp, flags) {
    let stream = streamIndex > -1 ? formatContext.streams.find((stream) => stream.index === streamIndex) : null;
    if (!stream) {
        stream = formatContext.getStreamByMediaType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
        if (!stream) {
            stream = formatContext.getStreamByMediaType(1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
        }
        if (!stream) {
            stream = formatContext.getStreamByMediaType(3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */);
        }
    }
    if (!stream) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_13__.error(`not found any stream to seek, streamIndex: ${stream.index}`, cheap__fileName__0, 547);
        return BigInt(avutil_error__WEBPACK_IMPORTED_MODULE_12__.DATA_INVALID);
    }
    common_util_logger__WEBPACK_IMPORTED_MODULE_13__.debug(`seek in ${stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */
        ? 'video'
        : 'audio'} stream, streamIndex: ${stream.index}, timestamp: ${timestamp}, flags: ${flags}`, cheap__fileName__0, 551);
    timestamp = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_9__.avRescaleQ)(timestamp, avutil_constant__WEBPACK_IMPORTED_MODULE_7__.AV_MILLI_TIME_BASE_Q, stream.timeBase);
    const ret = await formatContext.iformat.seek(formatContext, stream, timestamp, flags);
    if (ret >= BigInt(0)) {
        common_util_array__WEBPACK_IMPORTED_MODULE_6__.each(formatContext.interval.packetBuffer, (avpacket) => {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.destroyAVPacket)(avpacket);
        });
        formatContext.interval.packetBuffer.length = 0;
        return BigInt(0);
    }
    return ret;
}


/***/ }),

/***/ "./src/avformat/dump.ts":
/*!******************************!*\
  !*** ./src/avformat/dump.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ dump),
/* harmony export */   dumpCodecName: () => (/* binding */ dumpCodecName),
/* harmony export */   dumpFormatName: () => (/* binding */ dumpFormatName),
/* harmony export */   dumpKey: () => (/* binding */ dumpKey)
/* harmony export */ });
/* unused harmony exports dumpTime, dumpInt64, dumpBitrate, dumpProfileName, dumpAVStreamInterface, dumpAVFormatContextInterface */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _AVFormatContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AVFormatContext */ "./src/avformat/AVFormatContext.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/stringEnum */ "./src/avutil/stringEnum.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_string__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/util/string */ "./src/common/util/string.ts");
/* harmony import */ var common_function_toString__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/function/toString */ "./src/common/function/toString.ts");
/* harmony import */ var _codecs_aac__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./codecs/aac */ "./src/avformat/codecs/aac.ts");
/* harmony import */ var _codecs_h264__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./codecs/h264 */ "./src/avformat/codecs/h264.ts");
/* harmony import */ var _codecs_hevc__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./codecs/hevc */ "./src/avformat/codecs/hevc.ts");
/* harmony import */ var _codecs_av1__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./codecs/av1 */ "./src/avformat/codecs/av1.ts");
/* harmony import */ var _codecs_vp9__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./codecs/vp9 */ "./src/avformat/codecs/vp9.ts");
/* harmony import */ var _codecs_mp3__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./codecs/mp3 */ "./src/avformat/codecs/mp3.ts");


















function dumpTime(time) {
    if (time < 0) {
        time = BigInt(0);
    }
    const ms = Number(BigInt.asIntN(32, time % BigInt(1000)));
    const secs = Number(BigInt.asIntN(32, time / BigInt(1000) % BigInt(60)));
    const mins = Number(BigInt.asIntN(32, time / BigInt(1000) / BigInt(60) % BigInt(60)));
    const hours = Number(BigInt.asIntN(32, time / BigInt(1000) / BigInt(3600)));
    return common_util_string__WEBPACK_IMPORTED_MODULE_10__.format('%02d:%02d:%02d.%03d', hours, mins, secs, ms);
}
function dumpInt64(v) {
    if (v < BigInt(10000)) {
        return (0,common_function_toString__WEBPACK_IMPORTED_MODULE_11__["default"])(Number(BigInt.asIntN(32, v)));
    }
    return Number(BigInt.asIntN(32, v / BigInt(1000))) + 'k';
}
function dumpBitrate(v) {
    if (v < BigInt(10000)) {
        return (0,common_function_toString__WEBPACK_IMPORTED_MODULE_11__["default"])(Number(BigInt.asIntN(32, v))) + ' bps/s';
    }
    return Number(BigInt.asIntN(32, v / BigInt(1000))) + ' kbps/s';
}
function dumpKey(obj, value, defaultValue = 'unknown') {
    let name = defaultValue;
    common_util_object__WEBPACK_IMPORTED_MODULE_5__.each(obj, (v, k) => {
        if (value === v) {
            name = k;
            return false;
        }
    });
    return name;
}
function dumpCodecName(codecType, codecId) {
    if (codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
        return dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.AudioCodecString2CodecId, codecId);
    }
    else if (codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
        return dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.VideoCodecString2CodecId, codecId);
    }
    else if (codecType === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */) {
        return dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.SubtitleCodecString2CodecId, codecId);
    }
    return 'unknown';
}
function dumpFormatName(format) {
    return dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.Format2AVFormat, format);
}
function dumpProfileName(codecId, profile) {
    switch (codecId) {
        case 86018 /* AVCodecID.AV_CODEC_ID_AAC */:
            return _codecs_aac__WEBPACK_IMPORTED_MODULE_12__.AACProfile2Name[profile] || 'LC';
        case 86017 /* AVCodecID.AV_CODEC_ID_MP3 */:
            return _codecs_mp3__WEBPACK_IMPORTED_MODULE_17__.MP3Profile2Name[profile] || 'Layer3';
        case 27 /* AVCodecID.AV_CODEC_ID_H264 */:
            return _codecs_h264__WEBPACK_IMPORTED_MODULE_13__.H264Profile2Name[profile] || 'High';
        case 173 /* AVCodecID.AV_CODEC_ID_HEVC */:
            return _codecs_hevc__WEBPACK_IMPORTED_MODULE_14__.HEVCProfile2Name[profile] || 'Main';
        case 225 /* AVCodecID.AV_CODEC_ID_AV1 */:
            return _codecs_av1__WEBPACK_IMPORTED_MODULE_15__.AV1Profile2Name[profile] || 'Main';
        case 167 /* AVCodecID.AV_CODEC_ID_VP9 */:
            return _codecs_vp9__WEBPACK_IMPORTED_MODULE_16__.VP9Profile2Name[profile] || 'Profile0';
    }
}
function dumpAVStreamInterface(stream, index, prefix) {
    const mediaType = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.mediaType2AVMediaType, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar));
    const list = [];
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
        const profileName = dumpProfileName(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 48));
        const codecName = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.AudioCodecString2CodecId, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 4));
        list.push(`${codecName}${profileName ? ` (${profileName})` : ''}`);
        list.push(`${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 136)} Hz`);
        let channel = `${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 116)} channels`;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 116) === 1) {
            channel = 'mono';
        }
        else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 116) === 2) {
            channel = 'stereo';
        }
        list.push(channel);
        list.push(dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.SampleFmtString2SampleFormat, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 28)));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32) > BigInt(0)) {
            list.push(`${dumpBitrate(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32))}`);
        }
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
        const profileName = dumpProfileName(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 48));
        const codecName = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.VideoCodecString2CodecId, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 4));
        list.push(`${codecName}${profileName ? ` (${profileName})` : ''}`);
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 28) !== avutil_constant__WEBPACK_IMPORTED_MODULE_9__.NOPTS_VALUE) {
            const pixfmt = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.PixfmtString2AVPixelFormat, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 28));
            const range = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.colorRange2AVColorRange, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 84), 'tv');
            const space = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.colorSpace2AVColorSpace, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 96), 'bt709');
            list.push(`${pixfmt}(${range}, ${space})`);
        }
        const dar = {
            num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 56) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 64),
            den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 60) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 68)
        };
        (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avReduce)(dar);
        list.push(`${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 56)}x${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 60)} [SAR: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 64)}:${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 68)} DAR ${dar.num}:${dar.den}]`);
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32) > BigInt(0)) {
            list.push(`${dumpBitrate(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32))}`);
        }
        if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(stream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational)) > 0) {
            list.push(`${(0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(stream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational)).toFixed(2)} fps`);
            list.push(`${(0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(stream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational)).toFixed(2)} tbr`);
        }
        list.push(`${dumpInt64(BigInt(Math.floor((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avQ2D)({
            num: stream.timeBase.den,
            den: stream.timeBase.num
        }))))} tbn`);
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar) === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */) {
        const codecName = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.SubtitleCodecString2CodecId, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](stream.codecpar + 4));
        list.push(codecName);
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32) > BigInt(0)) {
            list.push(`${dumpBitrate(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32))}`);
        }
    }
    else {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32) > BigInt(0)) {
            list.push(`${dumpBitrate(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32))}`);
        }
    }
    let disposition = '';
    if (stream.disposition) {
        disposition = ' ';
        if (stream.disposition & 1 /* AVDisposition.DEFAULT */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 1 /* AVDisposition.DEFAULT */)}) `;
        }
        if (stream.disposition & 2 /* AVDisposition.DUB */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 2 /* AVDisposition.DUB */)}) `;
        }
        if (stream.disposition & 4 /* AVDisposition.ORIGINAL */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 4 /* AVDisposition.ORIGINAL */)}) `;
        }
        if (stream.disposition & 8 /* AVDisposition.COMMENT */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 8 /* AVDisposition.COMMENT */)}) `;
        }
        if (stream.disposition & 16 /* AVDisposition.LYRICS */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 16 /* AVDisposition.LYRICS */)}) `;
        }
        if (stream.disposition & 32 /* AVDisposition.KARAOKE */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 32 /* AVDisposition.KARAOKE */)}) `;
        }
        if (stream.disposition & 64 /* AVDisposition.FORCED */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 64 /* AVDisposition.FORCED */)}) `;
        }
        if (stream.disposition & 128 /* AVDisposition.HEARING_IMPAIRED */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 128 /* AVDisposition.HEARING_IMPAIRED */)}) `;
        }
        if (stream.disposition & 256 /* AVDisposition.VISUAL_IMPAIRED */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 256 /* AVDisposition.VISUAL_IMPAIRED */)}) `;
        }
        if (stream.disposition & 512 /* AVDisposition.CLEAN_EFFECTS */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 512 /* AVDisposition.CLEAN_EFFECTS */)}) `;
        }
        if (stream.disposition & 1024 /* AVDisposition.ATTACHED_PIC */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 1024 /* AVDisposition.ATTACHED_PIC */)}) `;
        }
        if (stream.disposition & 2048 /* AVDisposition.TIMED_THUMBNAILS */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 2048 /* AVDisposition.TIMED_THUMBNAILS */)}) `;
        }
        if (stream.disposition & 65536 /* AVDisposition.CAPTIONS */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 65536 /* AVDisposition.CAPTIONS */)}) `;
        }
        if (stream.disposition & 131072 /* AVDisposition.DESCRIPTIONS */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 131072 /* AVDisposition.DESCRIPTIONS */)}) `;
        }
        if (stream.disposition & 262144 /* AVDisposition.METADATA */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 262144 /* AVDisposition.METADATA */)}) `;
        }
        if (stream.disposition & 524288 /* AVDisposition.DEPENDENT */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 524288 /* AVDisposition.DEPENDENT */)}) `;
        }
        if (stream.disposition & 1048576 /* AVDisposition.STILL_IMAGE */) {
            disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.disposition2AVDisposition, 1048576 /* AVDisposition.STILL_IMAGE */)}) `;
        }
    }
    let dump = `${prefix}Stream #${index}:${stream.index} ${mediaType}: ${list.join(', ')}${disposition}\n`;
    if (Object.keys(stream.metadata).length) {
        dump += `${prefix}  Metadata:\n`;
        common_util_object__WEBPACK_IMPORTED_MODULE_5__.each(stream.metadata, (value, key) => {
            if (!common_util_is__WEBPACK_IMPORTED_MODULE_7__.object(value) && !common_util_is__WEBPACK_IMPORTED_MODULE_7__.array(value)) {
                dump += `${prefix}    ${key}: ${value}\n`;
            }
        });
    }
    return dump;
}
function dumpAVFormatContextInterface(formatContext, index, input) {
    let dump = `${input.tag} #${index}, ${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_6__.Format2AVFormat, formatContext.format)}, from '${input.from}':\n`;
    if (Object.keys(formatContext.metadata).length) {
        dump += '  Metadata:\n';
        common_util_object__WEBPACK_IMPORTED_MODULE_5__.each(formatContext.metadata, (value, key) => {
            if (!common_util_is__WEBPACK_IMPORTED_MODULE_7__.object(value) || !common_util_is__WEBPACK_IMPORTED_MODULE_7__.array(value)) {
                dump += `    ${key}: ${value}\n`;
            }
        });
    }
    let duration = BigInt(0);
    let bitrate = BigInt(0);
    let start = -BigInt(1);
    formatContext.streams.forEach((stream) => {
        const d = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(stream.duration, stream.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_9__.AV_MILLI_TIME_BASE_Q);
        const s = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_8__.avRescaleQ)(stream.startTime, stream.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_9__.AV_MILLI_TIME_BASE_Q);
        if (d > duration) {
            duration = d;
        }
        if (s < start || start === -BigInt(1)) {
            start = s;
        }
        bitrate += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](stream.codecpar + 32);
    });
    dump += `  Duration: ${dumpTime(duration)}, start: ${dumpTime(start)}, bitrate: ${dumpBitrate(bitrate)}\n`;
    formatContext.streams.forEach((stream, i) => {
        dump += dumpAVStreamInterface(stream, index, '  ');
    });
    return dump;
}
function dump(formatContexts, inputs) {
    let dump = '';
    formatContexts.forEach((formatContext, index) => {
        if (formatContext instanceof _AVFormatContext__WEBPACK_IMPORTED_MODULE_4__.AVFormatContext) {
            const streams = [];
            for (let i = 0; i < formatContext.streams.length; i++) {
                const stream = formatContext.streams[i];
                streams.push({
                    index: stream.index,
                    id: stream.id,
                    codecpar: stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    nbFrames: stream.nbFrames,
                    metadata: stream.metadata,
                    duration: stream.duration,
                    startTime: stream.startTime,
                    disposition: stream.disposition,
                    timeBase: stream.timeBase
                });
            }
            formatContext = {
                metadata: formatContext.metadata,
                format: formatContext.format,
                chapters: formatContext.chapters,
                streams
            };
        }
        dump += dumpAVFormatContextInterface(formatContext, index, inputs[index]);
    });
    return dump;
}


/***/ }),

/***/ "./src/avformat/formats/OFormat.ts":
/*!*****************************************!*\
  !*** ./src/avformat/formats/OFormat.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OFormatSupportedCodecs: () => (/* binding */ OFormatSupportedCodecs),
/* harmony export */   "default": () => (/* binding */ OFormat)
/* harmony export */ });
/*
 * libmedia abstract format encoder
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class OFormat {
    type = -1 /* AVFormat.UNKNOWN */;
    destroy(formatContext) { }
}
const OFormatSupportedCodecs = {
    [13 /* AVFormat.AAC */]: [86018 /* AVCodecID.AV_CODEC_ID_AAC */],
    [8 /* AVFormat.AVI */]: [
        86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
        86019 /* AVCodecID.AV_CODEC_ID_AC3 */,
        86018 /* AVCodecID.AV_CODEC_ID_AAC */,
        12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
        27 /* AVCodecID.AV_CODEC_ID_H264 */
    ],
    [15 /* AVFormat.FLAC */]: [86028 /* AVCodecID.AV_CODEC_ID_FLAC */],
    [0 /* AVFormat.FLV */]: [
        86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
        86018 /* AVCodecID.AV_CODEC_ID_AAC */,
        86051 /* AVCodecID.AV_CODEC_ID_SPEEX */,
        69645 /* AVCodecID.AV_CODEC_ID_ADPCM_SWF */,
        86049 /* AVCodecID.AV_CODEC_ID_NELLYMOSER */,
        65543 /* AVCodecID.AV_CODEC_ID_PCM_ALAW */,
        65542 /* AVCodecID.AV_CODEC_ID_PCM_MULAW */,
        12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
        27 /* AVCodecID.AV_CODEC_ID_H264 */,
        173 /* AVCodecID.AV_CODEC_ID_HEVC */,
        225 /* AVCodecID.AV_CODEC_ID_AV1 */,
        167 /* AVCodecID.AV_CODEC_ID_VP9 */,
        196 /* AVCodecID.AV_CODEC_ID_VVC */
    ],
    [5 /* AVFormat.IVF */]: [139 /* AVCodecID.AV_CODEC_ID_VP8 */, 167 /* AVCodecID.AV_CODEC_ID_VP9 */],
    [6 /* AVFormat.MATROSKA */]: [
        86021 /* AVCodecID.AV_CODEC_ID_VORBIS */,
        86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
        86018 /* AVCodecID.AV_CODEC_ID_AAC */,
        86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
        86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
        86032 /* AVCodecID.AV_CODEC_ID_ALAC */,
        86020 /* AVCodecID.AV_CODEC_ID_DTS */,
        86056 /* AVCodecID.AV_CODEC_ID_EAC3 */,
        65557 /* AVCodecID.AV_CODEC_ID_PCM_F32LE */,
        65537 /* AVCodecID.AV_CODEC_ID_PCM_S16BE */,
        65536 /* AVCodecID.AV_CODEC_ID_PCM_S16LE */,
        139 /* AVCodecID.AV_CODEC_ID_VP8 */,
        167 /* AVCodecID.AV_CODEC_ID_VP9 */,
        225 /* AVCodecID.AV_CODEC_ID_AV1 */,
        27 /* AVCodecID.AV_CODEC_ID_H264 */,
        173 /* AVCodecID.AV_CODEC_ID_HEVC */,
        196 /* AVCodecID.AV_CODEC_ID_VVC */,
        12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
        30 /* AVCodecID.AV_CODEC_ID_THEORA */,
        94226 /* AVCodecID.AV_CODEC_ID_WEBVTT */
    ],
    [7 /* AVFormat.WEBM */]: [
        86021 /* AVCodecID.AV_CODEC_ID_VORBIS */,
        86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
        139 /* AVCodecID.AV_CODEC_ID_VP8 */,
        167 /* AVCodecID.AV_CODEC_ID_VP9 */,
        225 /* AVCodecID.AV_CODEC_ID_AV1 */,
        94226 /* AVCodecID.AV_CODEC_ID_WEBVTT */
    ],
    [1 /* AVFormat.MOV */]: [
        86021 /* AVCodecID.AV_CODEC_ID_VORBIS */,
        86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
        86018 /* AVCodecID.AV_CODEC_ID_AAC */,
        86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
        86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
        86051 /* AVCodecID.AV_CODEC_ID_SPEEX */,
        86019 /* AVCodecID.AV_CODEC_ID_AC3 */,
        86056 /* AVCodecID.AV_CODEC_ID_EAC3 */,
        167 /* AVCodecID.AV_CODEC_ID_VP9 */,
        225 /* AVCodecID.AV_CODEC_ID_AV1 */,
        27 /* AVCodecID.AV_CODEC_ID_H264 */,
        173 /* AVCodecID.AV_CODEC_ID_HEVC */,
        196 /* AVCodecID.AV_CODEC_ID_VVC */,
        12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
        94226 /* AVCodecID.AV_CODEC_ID_WEBVTT */,
        94213 /* AVCodecID.AV_CODEC_ID_MOV_TEXT */
    ],
    [12 /* AVFormat.MP3 */]: [86017 /* AVCodecID.AV_CODEC_ID_MP3 */],
    [2 /* AVFormat.MPEGTS */]: [
        86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
        86018 /* AVCodecID.AV_CODEC_ID_AAC */,
        86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
        86019 /* AVCodecID.AV_CODEC_ID_AC3 */, ,
        86020 /* AVCodecID.AV_CODEC_ID_DTS */,
        86065 /* AVCodecID.AV_CODEC_ID_AAC_LATM */,
        86056 /* AVCodecID.AV_CODEC_ID_EAC3 */,
        12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
        225 /* AVCodecID.AV_CODEC_ID_AV1 */,
        27 /* AVCodecID.AV_CODEC_ID_H264 */,
        173 /* AVCodecID.AV_CODEC_ID_HEVC */,
        196 /* AVCodecID.AV_CODEC_ID_VVC */
    ],
    [3 /* AVFormat.MPEGPS */]: [
        86058 /* AVCodecID.AV_CODEC_ID_MP1 */,
        86016 /* AVCodecID.AV_CODEC_ID_MP2 */,
        86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
        86019 /* AVCodecID.AV_CODEC_ID_AC3 */, ,
        86020 /* AVCodecID.AV_CODEC_ID_DTS */,
        2 /* AVCodecID.AV_CODEC_ID_MPEG2VIDEO */,
        12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
        27 /* AVCodecID.AV_CODEC_ID_H264 */,
        173 /* AVCodecID.AV_CODEC_ID_HEVC */,
        196 /* AVCodecID.AV_CODEC_ID_VVC */
    ],
    [4 /* AVFormat.OGG */]: [
        86021 /* AVCodecID.AV_CODEC_ID_VORBIS */,
        86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
        86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
        86051 /* AVCodecID.AV_CODEC_ID_SPEEX */
    ],
    [14 /* AVFormat.WAV */]: [],
    [16 /* AVFormat.WEBVTT */]: [94226 /* AVCodecID.AV_CODEC_ID_WEBVTT */],
    [18 /* AVFormat.ASS */]: [94230 /* AVCodecID.AV_CODEC_ID_ASS */, 94212 /* AVCodecID.AV_CODEC_ID_SSA */],
    [17 /* AVFormat.SUBRIP */]: [94225 /* AVCodecID.AV_CODEC_ID_SUBRIP */],
    [19 /* AVFormat.TTML */]: [94232 /* AVCodecID.AV_CODEC_ID_TTML */],
    [9 /* AVFormat.H264 */]: [27 /* AVCodecID.AV_CODEC_ID_H264 */],
    [10 /* AVFormat.HEVC */]: [173 /* AVCodecID.AV_CODEC_ID_HEVC */],
    [11 /* AVFormat.VVC */]: [196 /* AVCodecID.AV_CODEC_ID_VVC */]
};


/***/ }),

/***/ "./src/avformat/formats/OMovFormat.ts":
/*!********************************************!*\
  !*** ./src/avformat/formats/OMovFormat.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OMovFormat)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _OFormat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./OFormat */ "./src/avformat/formats/OFormat.ts");
/* harmony import */ var _mov_function_createMovContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mov/function/createMovContext */ "./src/avformat/formats/mov/function/createMovContext.ts");
/* harmony import */ var _function_mktag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../function/mktag */ "./src/avformat/function/mktag.ts");
/* harmony import */ var _mov_omov__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mov/omov */ "./src/avformat/formats/mov/omov.ts");
/* harmony import */ var _mov_function_createMovStreamContext__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mov/function/createMovStreamContext */ "./src/avformat/formats/mov/function/createMovStreamContext.ts");
/* harmony import */ var _mov_function_createFragmentTrack__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mov/function/createFragmentTrack */ "./src/avformat/formats/mov/function/createFragmentTrack.ts");
/* harmony import */ var common_io_IOWriterSync__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/io/IOWriterSync */ "./src/common/io/IOWriterSync.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/function/concatTypeArray */ "./src/common/function/concatTypeArray.ts");
/* harmony import */ var _mov_function_updatePositionSize__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./mov/function/updatePositionSize */ "./src/avformat/formats/mov/function/updatePositionSize.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var _function_rewriteIO__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../function/rewriteIO */ "./src/avformat/function/rewriteIO.ts");
/* harmony import */ var _function_arrayItemSame__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../function/arrayItemSame */ "./src/avformat/function/arrayItemSame.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _bsf_h2645_Annexb2AvccFilter__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../bsf/h2645/Annexb2AvccFilter */ "./src/avformat/bsf/h2645/Annexb2AvccFilter.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _codecs_ac3__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../codecs/ac3 */ "./src/avformat/codecs/ac3.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
var cheap__fileName__2 = "src\\avformat\\formats\\OMovFormat.ts";




/*
 * libmedia mov encoder
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





















const defaultOptions = {
    fragmentMode: 0 /* FragmentMode.GOP */,
    movMode: 0 /* MovMode.MP4 */,
    fragment: false,
    fastOpen: false,
    defaultBaseIsMoof: false
};
class OMovFormat extends _OFormat__WEBPACK_IMPORTED_MODULE_4__["default"] {
    type = 1 /* AVFormat.MOV */;
    context;
    options;
    annexb2AvccFilter;
    constructor(options = {}) {
        super();
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_16__.extend({}, defaultOptions, options);
        this.context = (0,_mov_function_createMovContext__WEBPACK_IMPORTED_MODULE_5__["default"])();
    }
    init(formatContext) {
        formatContext.ioWriter.setEndian(true);
        const videoStream = formatContext.getStreamByMediaType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
        if (videoStream) {
            this.annexb2AvccFilter = new _bsf_h2645_Annexb2AvccFilter__WEBPACK_IMPORTED_MODULE_21__["default"]();
            this.annexb2AvccFilter.init(videoStream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress], videoStream.timeBase[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
        }
        return 0;
    }
    destroy(formatContext) {
        super.destroy(formatContext);
        if (this.annexb2AvccFilter) {
            this.annexb2AvccFilter.destroy();
            this.annexb2AvccFilter = null;
        }
    }
    /*
     * stream.disposition controls the "enabled" flag in the tkhd tag.
     * QuickTime will not play a track if it is not enabled.  So make sure
     * that one track of each type (audio, video, subtitle) is enabled.
     *
     * Subtitles are special.  For audio and video, setting "enabled" also
     * makes the track "default" (i.e. it is rendered when played). For
     * subtitles, an "enabled" subtitle is not rendered by default, but
     * if no subtitle is enabled, the subtitle menu in QuickTime will be
     * empty!
     */
    enableStreams(formatContext) {
        const enabled = [];
        const first = [];
        for (let i = 0; i < 5 /* AVMediaType.AVMEDIA_TYPE_NB */; i++) {
            enabled[i] = 0;
            first[i] = -1;
        }
        common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(formatContext.streams, (stream, index) => {
            if (stream.codecpar.codecType === -1 /* AVMediaType.AVMEDIA_TYPE_UNKNOWN */
                || stream.codecpar.codecType >= 5 /* AVMediaType.AVMEDIA_TYPE_NB */) {
                return true;
            }
            if (first[stream.codecpar.codecType] < 0) {
                first[stream.codecpar.codecType] = index;
            }
            if (stream.disposition & 1 /* AVDisposition.DEFAULT */) {
                enabled[stream.codecpar.codecType]++;
                stream.privData.flags |= 1 /* TKHDFlags.ENABLED */;
            }
        });
        for (let i = 0; i < 5 /* AVMediaType.AVMEDIA_TYPE_NB */; i++) {
            switch (i) {
                case 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */:
                case 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */:
                case 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */:
                    if (enabled[i] > 1) {
                        formatContext.streams[enabled[i]].privData.perStreamGrouping = true;
                    }
                    if (!enabled[i] && first[i] >= 0) {
                        formatContext.streams[first[i]].privData.flags |= 1 /* TKHDFlags.ENABLED */;
                    }
                    break;
            }
        }
    }
    writeHeader(formatContext) {
        this.context.majorBrand = (0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('isom');
        this.context.minorVersion = 512;
        this.context.compatibleBrand = [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('isom')];
        this.context.timescale = 1000;
        if (this.options.fragment) {
            this.context.compatibleBrand.push((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('iso6'));
            this.context.fragment = true;
        }
        if (this.options.movMode === 1 /* MovMode.MOV */) {
            this.context.isom = true;
            this.context.majorBrand = (0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('qt  ');
            this.context.compatibleBrand = [this.context.majorBrand];
        }
        if (this.options.movMode !== 1 /* MovMode.MOV */) {
            this.context.compatibleBrand.push((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('iso2'));
            const videoStream = formatContext.getStreamByMediaType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
            if (videoStream && videoStream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */) {
                this.context.compatibleBrand.push((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('avc1'));
            }
            this.context.compatibleBrand.push((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])('mp41'));
        }
        _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeFtyp(formatContext.ioWriter, this.context);
        this.context.holdMoovPos = formatContext.ioWriter.getPos();
        if (this.options.fragment) {
            this.context.currentFragment = {
                pos: BigInt(0),
                currentTrack: null,
                sequence: 1,
                tracks: [],
                size: 0,
                firstWrote: false
            };
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(formatContext.streams, (stream, index) => {
                const streamContext = (0,_mov_function_createMovStreamContext__WEBPACK_IMPORTED_MODULE_8__["default"])();
                stream.privData = streamContext;
                streamContext.chunkOffsets = [];
                streamContext.cttsSampleCounts = [];
                streamContext.cttsSampleOffsets = [];
                streamContext.stscFirstChunk = [];
                streamContext.stscSamplesPerChunk = [];
                streamContext.stscSampleDescriptionIndex = [];
                streamContext.stssSampleNumbers = [];
                streamContext.sampleSizes = [];
                streamContext.sttsSampleCounts = [];
                streamContext.sttsSampleDeltas = [];
                streamContext.alternateGroup = index;
                const track = (0,_mov_function_createFragmentTrack__WEBPACK_IMPORTED_MODULE_9__["default"])();
                track.baseIsMoof = this.options.defaultBaseIsMoof;
                track.streamIndex = stream.index;
                track.trackId = this.context.nextTrackId++;
                streamContext.trackId = track.trackId;
                track.ioWriter = new common_io_IOWriterSync__WEBPACK_IMPORTED_MODULE_10__["default"]();
                track.ioWriter.onFlush = (data) => {
                    track.buffers.push(data.slice());
                    return 0;
                };
                this.context.currentFragment.tracks.push(track);
            });
            this.enableStreams(formatContext);
            _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeMoov(formatContext.ioWriter, formatContext, this.context);
            formatContext.ioWriter.flush();
        }
        else {
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(formatContext.streams, (stream, index) => {
                const streamContext = (0,_mov_function_createMovStreamContext__WEBPACK_IMPORTED_MODULE_8__["default"])();
                stream.privData = streamContext;
                streamContext.trackId = this.context.nextTrackId++;
                streamContext.chunkOffsets = [];
                streamContext.cttsSampleCounts = [];
                streamContext.cttsSampleOffsets = [];
                streamContext.stscFirstChunk = [];
                streamContext.stscSamplesPerChunk = [];
                streamContext.stscSampleDescriptionIndex = [];
                streamContext.stssSampleNumbers = [];
                streamContext.sampleSizes = [];
                streamContext.sttsSampleCounts = [];
                streamContext.sttsSampleDeltas = [];
                streamContext.alternateGroup = index;
            });
            this.enableStreams(formatContext);
            const pos = formatContext.ioWriter.getPos();
            formatContext.ioWriter.writeUint32(0);
            formatContext.ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])("mdat" /* BoxType.MDAT */));
            this.context.boxsPositionInfo.push({
                pos,
                type: "mdat" /* BoxType.MDAT */,
                size: 0
            });
        }
        return 0;
    }
    updateCurrentChunk(formatContext) {
        let currentChunk = this.context.currentChunk;
        if (!currentChunk.sampleCount) {
            return;
        }
        const prevStream = formatContext.streams.find((stream) => {
            return stream.index === currentChunk.streamIndex;
        });
        const prevMovStreamContext = prevStream.privData;
        prevMovStreamContext.chunkCount++;
        prevMovStreamContext.chunkOffsets.push(currentChunk.pos);
        if (!prevMovStreamContext.stscFirstChunk.length) {
            prevMovStreamContext.stscFirstChunk.push(prevMovStreamContext.chunkCount);
            prevMovStreamContext.stscSamplesPerChunk.push(currentChunk.sampleCount);
            prevMovStreamContext.stscSampleDescriptionIndex.push(1);
            prevMovStreamContext.lastStscCount = currentChunk.sampleCount;
        }
        else {
            if (prevMovStreamContext.lastStscCount !== currentChunk.sampleCount) {
                prevMovStreamContext.stscFirstChunk.push(prevMovStreamContext.chunkCount);
                prevMovStreamContext.stscSamplesPerChunk.push(currentChunk.sampleCount);
                prevMovStreamContext.stscSampleDescriptionIndex.push(1);
                prevMovStreamContext.lastStscCount = currentChunk.sampleCount;
            }
        }
    }
    checkMdat(formatContext, len) {
        const mdat = this.context.boxsPositionInfo[this.context.boxsPositionInfo.length - 1];
        if (mdat.type !== "mdat" /* BoxType.MDAT */) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.error('last box is not mdat', cheap__fileName__2, 302);
            return;
        }
        const pos = formatContext.ioWriter.getPos();
        const size = Number(pos - mdat.pos);
        if (size + len > avutil_constant__WEBPACK_IMPORTED_MODULE_15__.UINT32_MAX) {
            mdat.size = size;
            formatContext.ioWriter.writeUint32(0);
            formatContext.ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])("mdat" /* BoxType.MDAT */));
            this.context.boxsPositionInfo.push({
                pos,
                type: "mdat" /* BoxType.MDAT */,
                size: 0
            });
        }
    }
    updateCurrentFragment(formatContext, currentDts) {
        if (this.context.currentFragment.firstWrote) {
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(this.context.currentFragment.tracks, (track) => {
                const stream = formatContext.streams.find((stream) => {
                    return stream.index === track.streamIndex;
                });
                if (!track.sampleCount || !stream) {
                    return true;
                }
                const streamContext = stream.privData;
                track.baseDataOffset = formatContext.ioWriter.getPos();
                if (!track.sampleDurations.length) {
                    if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                        if (currentDts) {
                            track.sampleDurations.push(Number(currentDts - streamContext.lastDts));
                        }
                        else if (stream.codecpar.frameSize > 0) {
                            track.sampleDurations.push(Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(BigInt(stream.codecpar.frameSize / stream.codecpar.sampleRate * avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE), avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE_Q, stream.timeBase)));
                        }
                        else if (stream.codecpar.codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */) {
                            track.sampleDurations.push(Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(BigInt(1024 / stream.codecpar.sampleRate * avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE), avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE_Q, stream.timeBase)));
                        }
                        else {
                            //  fragment  sampleDuration QuickTime 
                            track.sampleDurations.push(Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(BigInt(1024 / stream.codecpar.sampleRate * avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE), avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE_Q, stream.timeBase)));
                        }
                    }
                    else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                        if (currentDts) {
                            track.sampleDurations.push(Number(currentDts - streamContext.lastDts));
                        }
                        else if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avQ2D)(stream.codecpar.framerate) > 0) {
                            track.sampleDurations.push(Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(BigInt(Math.floor(1 / (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avQ2D)(stream.codecpar.framerate) * avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE)), avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE_Q, stream.timeBase)));
                        }
                        else {
                            //  fragment  sampleDuration QuickTime 
                            //  30
                            track.sampleDurations.push((stream.timeBase.den / (30 * stream.timeBase.num)) >>> 0);
                        }
                    }
                    else {
                        track.sampleDurations.push(0);
                    }
                }
                else if (currentDts && track.sampleDurations.length === track.sampleSizes.length - 1) {
                    track.sampleDurations.push(Number(currentDts - streamContext.lastDts));
                }
                streamContext.lastDuration = track.sampleDurations[track.sampleSizes.length - 1];
                if (track.sampleFlags.length === 1 || (0,_function_arrayItemSame__WEBPACK_IMPORTED_MODULE_18__["default"])(track.sampleFlags, 1)) {
                    track.firstSampleFlags = track.sampleFlags[0];
                    track.defaultSampleFlags = track.sampleFlags[1] ?? track.firstSampleFlags;
                    track.sampleFlags = [];
                }
                if (track.sampleSizes.length === 1 || (0,_function_arrayItemSame__WEBPACK_IMPORTED_MODULE_18__["default"])(track.sampleSizes)) {
                    track.defaultSampleSize = track.sampleSizes[0];
                    track.sampleSizes = [];
                }
                if (track.sampleDurations.length === 1 || (0,_function_arrayItemSame__WEBPACK_IMPORTED_MODULE_18__["default"])(track.sampleDurations)) {
                    track.defaultSampleDuration = track.sampleDurations[0];
                    track.sampleDurations = [];
                }
                if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                    track.defaultSampleFlags = 33554432 /* SampleFlags.DEPENDS_NO */;
                }
                else if (track.sampleFlags.length) {
                    track.defaultSampleFlags = track.sampleFlags[0];
                }
                if (track.sampleSizes.length) {
                    track.defaultSampleSize = track.sampleSizes[0];
                }
                if (track.sampleDurations.length) {
                    track.defaultSampleDuration = track.sampleDurations[0];
                }
            });
            formatContext.ioWriter.flush();
            _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeMoof(formatContext.ioWriter, formatContext, this.context);
            let dataOffset = this.context.currentFragment.size + 8;
            const buffers = [];
            let mdatSize = 8;
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(this.context.currentFragment.tracks, (track) => {
                if (!track.sampleCount) {
                    return true;
                }
                track.ioWriter.flush();
                const buffer = (0,common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_13__["default"])(Uint8Array, track.buffers);
                track.dataOffset = dataOffset;
                dataOffset += buffer.length;
                mdatSize += buffer.length;
                buffers.push(buffer);
                (0,_function_rewriteIO__WEBPACK_IMPORTED_MODULE_17__["default"])(formatContext.ioWriter, track.dataOffsetPos, track.dataOffset, 'int32');
                track.buffers = [];
                track.sampleFlags = [];
                track.sampleSizes = [];
                track.sampleDurations = [];
                track.sampleCompositionTimeOffset = [];
                track.sampleCount = 0;
                track.firstSampleFlags = 0;
            });
            formatContext.ioWriter.writeUint32(mdatSize);
            formatContext.ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_6__["default"])("mdat" /* BoxType.MDAT */));
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(buffers, (buffer) => {
                formatContext.ioWriter.writeBuffer(buffer);
            });
            (0,_mov_function_updatePositionSize__WEBPACK_IMPORTED_MODULE_14__["default"])(formatContext.ioWriter, this.context);
            formatContext.ioWriter.flush();
            this.context.currentFragment.firstWrote = false;
            this.context.currentFragment.sequence++;
        }
    }
    handleEAC3(avpacket, stream) {
        if (!this.context.ac3Info) {
            this.context.ac3Info = {
                done: false,
                numBlocks: 0,
                dataRate: 0,
                ac3BitrateCode: -1,
                numIndSub: 0,
                substream: []
            };
        }
        const ac3Info = this.context.ac3Info;
        const info = _codecs_ac3__WEBPACK_IMPORTED_MODULE_23__.parseHeader((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_24__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28)));
        if (common_util_is__WEBPACK_IMPORTED_MODULE_22__.number(info)) {
            ac3Info.done = true;
            return;
        }
        ac3Info.dataRate = Math.max(ac3Info.dataRate, info.bitrate / 1000);
        ac3Info.ac3BitrateCode = Math.max(ac3Info.ac3BitrateCode, info.ac3BitrateCode);
        if (!ac3Info.done) {
            if (info.bitstreamId <= 10 && info.substreamId != 0) {
                return;
            }
            if (info.frameType === 0 /* ac3.EAC3FrameType.EAC3_FRAME_TYPE_INDEPENDENT */
                || info.frameType == 2 /* ac3.EAC3FrameType.EAC3_FRAME_TYPE_AC3_CONVERT */) {
                /* substream ids must be incremental */
                if (info.substreamId > ac3Info.numIndSub + 1) {
                    return;
                }
                if (info.substreamId == ac3Info.numIndSub + 1) {
                    return;
                }
                else if (info.substreamId < ac3Info.numIndSub ||
                    info.substreamId == 0 && ac3Info.substream[0]?.bsid) {
                    ac3Info.done = true;
                    return;
                }
            }
            else {
                if (info.substreamId != 0) {
                    return;
                }
            }
            if (!ac3Info.substream[info.substreamId]) {
                ac3Info.substream[info.substreamId] = {
                    fscod: 0,
                    bsid: 0,
                    bsmod: 0,
                    acmod: 0,
                    lfeon: 0,
                    numDepSub: 0,
                    chanLoc: 0
                };
            }
            ac3Info.substream[info.substreamId].fscod = info.srCode;
            ac3Info.substream[info.substreamId].bsid = info.bitstreamId;
            ac3Info.substream[info.substreamId].bsmod = info.bitstreamMode;
            ac3Info.substream[info.substreamId].acmod = info.channelMode;
            ac3Info.substream[info.substreamId].lfeon = info.lfeOn;
            if (stream.codecpar.codecId === 86019 /* AVCodecID.AV_CODEC_ID_AC3 */) {
                ac3Info.done = true;
                return;
            }
        }
    }
    writeAVPacket(formatContext, avpacket) {
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28)) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.warn(`packet\'s size is 0: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32)}, ignore it`, cheap__fileName__2, 543);
            return 0;
        }
        const stream = formatContext.getStreamByIndex(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32));
        if (!stream) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.warn(`can not found the stream width the avpacket\'s streamIndex: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32)}, ignore it`, cheap__fileName__2, 550);
            return;
        }
        const streamContext = stream.privData;
        const dts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational), stream.timeBase);
        const pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8) < BigInt(0) ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 16) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational), stream.timeBase);
        if ((stream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */
            || stream.codecpar.codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
            || stream.codecpar.codecId === 196 /* AVCodecID.AV_CODEC_ID_VVC */)
            && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 80) === 2 /* BitFormat.ANNEXB */) {
            this.annexb2AvccFilter.sendAVPacket(avpacket);
            this.annexb2AvccFilter.receiveAVPacket(avpacket);
        }
        else if ((stream.codecpar.codecId === 86019 /* AVCodecID.AV_CODEC_ID_AC3 */
            || stream.codecpar.codecId === 86056 /* AVCodecID.AV_CODEC_ID_EAC3 */)
            && (!this.context.ac3Info || !this.context.ac3Info.done)) {
            this.handleEAC3(avpacket, stream);
        }
        if (this.context.fragment) {
            const track = this.context.currentFragment.tracks.find((track) => {
                return track.streamIndex === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32);
            });
            if (track) {
                if (this.options.fragmentMode === 0 /* FragmentMode.GOP */
                    && stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */
                    && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */
                    || this.options.fragmentMode === 1 /* FragmentMode.FRAME */) {
                    if (this.context.currentFragment.tracks.length === 1) {
                        this.updateCurrentFragment(formatContext, dts);
                    }
                    else {
                        this.updateCurrentFragment(formatContext);
                    }
                }
                track.ioWriter.writeBuffer((0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_20__.getAVPacketData)(avpacket));
                if (!track.sampleSizes.length) {
                    track.baseMediaDecodeTime = dts;
                }
                if (track.sampleSizes.length
                    && (!track.sampleDurations[track.sampleSizes.length - 1]
                        || track.sampleDurations[track.sampleSizes.length - 1] <= 0)) {
                    track.sampleDurations[track.sampleSizes.length - 1] = Number(dts - streamContext.lastDts);
                }
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 48) > 0) {
                    track.sampleDurations.push(Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avpacket + 48), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_2__.Rational), stream.timeBase)));
                }
                track.sampleSizes.push(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28));
                if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    let flag = 0;
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                        flag |= 33554432 /* SampleFlags.DEPENDS_NO */;
                    }
                    else {
                        flag |= (16777216 /* SampleFlags.DEPENDS_YES */ | 65536 /* SampleFlags.IS_NON_SYN */);
                    }
                    track.sampleCompositionTimeOffset.push(Number((pts || dts) - dts));
                    track.sampleFlags.push(flag);
                }
                track.sampleCount++;
                streamContext.lastPts = pts > streamContext.lastPts ? pts : streamContext.lastPts;
                streamContext.lastDts = dts;
                this.context.currentFragment.firstWrote = true;
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.warn(`can not found track width streamIndex ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32)}, ignore it`, cheap__fileName__2, 636);
            }
        }
        else {
            this.checkMdat(formatContext, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28));
            const pos = formatContext.ioWriter.getPos();
            let currentChunk = this.context.currentChunk;
            if (!currentChunk) {
                currentChunk = this.context.currentChunk = {
                    pos,
                    streamIndex: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32),
                    sampleCount: 1
                };
            }
            else if (currentChunk.streamIndex !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32)) {
                this.updateCurrentChunk(formatContext);
                currentChunk.streamIndex = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 32);
                currentChunk.sampleCount = 1;
                currentChunk.pos = pos;
            }
            else {
                currentChunk.sampleCount++;
            }
            formatContext.ioWriter.writeBuffer((0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_20__.getAVPacketData)(avpacket));
            streamContext.sampleSizes.push(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28));
            if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */
                && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                streamContext.stssSampleNumbers.push(streamContext.sampleSizes.length);
            }
            if (!streamContext.firstWrote) {
                streamContext.startDts = dts;
                streamContext.startCT = Number((pts || dts) - dts);
                streamContext.firstWrote = true;
            }
            else {
                const deltas = Number(dts - streamContext.lastDts);
                if (!streamContext.sttsSampleCounts.length) {
                    streamContext.sttsSampleCounts.push(1);
                    streamContext.sttsSampleDeltas.push(deltas);
                }
                else {
                    if (streamContext.sttsSampleDeltas[streamContext.sttsSampleDeltas.length - 1] === deltas) {
                        streamContext.sttsSampleCounts[streamContext.sttsSampleCounts.length - 1]++;
                    }
                    else {
                        streamContext.sttsSampleCounts.push(1);
                        streamContext.sttsSampleDeltas.push(deltas);
                    }
                }
            }
            if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                const ctts = Number((pts || dts) - dts);
                if (!streamContext.cttsSampleCounts.length) {
                    streamContext.cttsSampleCounts.push(1);
                    streamContext.cttsSampleOffsets.push(ctts);
                }
                else {
                    if (streamContext.cttsSampleOffsets[streamContext.cttsSampleOffsets.length - 1]
                        === ctts) {
                        streamContext.cttsSampleCounts[streamContext.cttsSampleCounts.length - 1]++;
                    }
                    else {
                        streamContext.cttsSampleCounts.push(1);
                        streamContext.cttsSampleOffsets.push(ctts);
                    }
                }
            }
            streamContext.lastPts = (pts || dts) > streamContext.lastPts ? (pts || dts) : streamContext.lastPts;
            streamContext.lastDts = dts;
        }
        return 0;
    }
    writeTrailer(formatContext) {
        if (!this.context.fragment) {
            this.updateCurrentChunk(formatContext);
            let lastPts = BigInt(0);
            let timeBase;
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(formatContext.streams, (stream) => {
                const streamContext = stream.privData;
                if (streamContext.sampleSizes.length) {
                    if (streamContext.sttsSampleDeltas.length) {
                        streamContext.sttsSampleCounts[streamContext.sttsSampleCounts.length - 1]++;
                    }
                    else {
                        streamContext.sttsSampleCounts = [1];
                        streamContext.sttsSampleDeltas = [0];
                    }
                }
                if (streamContext.lastPts > lastPts) {
                    lastPts = streamContext.lastPts;
                    timeBase = stream.timeBase;
                }
            });
            if (lastPts) {
                this.context.duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(lastPts, timeBase, { den: 1000, num: 1 });
            }
            const mdat = this.context.boxsPositionInfo[this.context.boxsPositionInfo.length - 1];
            if (mdat.type !== "mdat" /* BoxType.MDAT */) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.error('last box is not mdat', cheap__fileName__2, 752);
            }
            mdat.size = Number(formatContext.ioWriter.getPos() - mdat.pos);
            (0,_mov_function_updatePositionSize__WEBPACK_IMPORTED_MODULE_14__["default"])(formatContext.ioWriter, this.context);
            if (this.options.fastOpen) {
                formatContext.ioWriter.flush();
                let buffers = [];
                const rawFlush = formatContext.ioWriter.onFlush;
                formatContext.ioWriter.onFlush = (buffer) => {
                    buffers.push(buffer.slice());
                    return 0;
                };
                _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeMoov(formatContext.ioWriter, formatContext, this.context);
                formatContext.ioWriter.flush();
                let data = (0,common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_13__["default"])(Uint8Array, buffers);
                common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(formatContext.streams, (stream) => {
                    const streamContext = stream.privData;
                    if (streamContext.chunkOffsets.length) {
                        for (let i = 0; i < streamContext.chunkOffsets.length; i++) {
                            streamContext.chunkOffsets[i] += BigInt(Math.floor(data.length));
                        }
                    }
                });
                buffers = [];
                _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeMoov(formatContext.ioWriter, formatContext, this.context);
                formatContext.ioWriter.flush();
                data = (0,common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_13__["default"])(Uint8Array, buffers);
                if (rawFlush) {
                    rawFlush(data, this.context.holdMoovPos);
                }
                formatContext.ioWriter.onFlush = rawFlush;
            }
            else {
                _mov_omov__WEBPACK_IMPORTED_MODULE_7__.writeMoov(formatContext.ioWriter, formatContext, this.context);
                formatContext.ioWriter.flush();
            }
        }
        else {
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(this.context.currentFragment.tracks, (track) => {
                const stream = formatContext.streams.find((stream) => {
                    return stream.index === track.streamIndex;
                });
                const streamContext = stream.privData;
                if (track.sampleCount) {
                    if (track.sampleDurations.length) {
                        track.sampleDurations.push(track.sampleDurations[track.sampleDurations.length - 1]);
                    }
                    else {
                        track.sampleDurations = [streamContext.lastDuration];
                    }
                }
            });
            this.updateCurrentFragment(formatContext);
            formatContext.ioWriter.writeUint32(8);
            formatContext.ioWriter.writeString("mfra" /* BoxType.MFRA */);
            formatContext.ioWriter.flush();
        }
        return 0;
    }
    flush(formatContext) {
        if (this.options.fragment) {
            common_util_array__WEBPACK_IMPORTED_MODULE_11__.each(this.context.currentFragment.tracks, (track) => {
                const stream = formatContext.streams.find((stream) => {
                    return stream.index === track.streamIndex;
                });
                const streamContext = stream.privData;
                if (track.sampleCount) {
                    if (track.sampleDurations.length) {
                        track.sampleDurations.push(track.sampleDurations[track.sampleDurations.length - 1]);
                    }
                    else {
                        track.sampleDurations = [streamContext.lastDuration];
                    }
                }
            });
            this.updateCurrentFragment(formatContext);
        }
        formatContext.ioWriter.flush();
        return 0;
    }
}


/***/ }),

/***/ "./src/avformat/formats/ass/ass.ts":
/*!*****************************************!*\
  !*** ./src/avformat/formats/ass/ass.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AssEventsFormatList: () => (/* binding */ AssEventsFormatList),
/* harmony export */   AssStylesFormatList: () => (/* binding */ AssStylesFormatList)
/* harmony export */ });
/*
 * libmedia ass defined
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const AssStylesFormatList = [
    "Name" /* AssStylesFormat.Name */,
    "Fontname" /* AssStylesFormat.FontName */,
    "Fontsize" /* AssStylesFormat.FontSize */,
    "PrimaryColour" /* AssStylesFormat.PrimaryColour */,
    "SecondaryColour" /* AssStylesFormat.SecondaryColour */,
    "OutlineColour" /* AssStylesFormat.OutlineColour */,
    "BackColour" /* AssStylesFormat.BackColour */,
    "Bold" /* AssStylesFormat.Bold */,
    "Italic" /* AssStylesFormat.Italic */,
    "Underline" /* AssStylesFormat.Underline */,
    "StrikeOut" /* AssStylesFormat.StrikeOut */,
    "ScaleX" /* AssStylesFormat.ScaleX */,
    "ScaleY" /* AssStylesFormat.ScaleY */,
    "Spacing" /* AssStylesFormat.Spacing */,
    "Angle" /* AssStylesFormat.Angle */,
    "BorderStyle" /* AssStylesFormat.BorderStyle */,
    "Outline" /* AssStylesFormat.Outline */,
    "Shadow" /* AssStylesFormat.Shadow */,
    "Alignment" /* AssStylesFormat.Alignment */,
    "MarginL" /* AssStylesFormat.MarginL */,
    "MarginR" /* AssStylesFormat.MarginR */,
    "MarginV" /* AssStylesFormat.MarginV */,
    "Encoding" /* AssStylesFormat.Encoding */
];
const AssEventsFormatList = [
    "ReadOrder" /* AssEventsFormat.ReadOrder */,
    "Layer" /* AssEventsFormat.Layer */,
    "Start" /* AssEventsFormat.Start */,
    "End" /* AssEventsFormat.End */,
    "Style" /* AssEventsFormat.Style */,
    "Name" /* AssEventsFormat.Name */,
    "MarginL" /* AssEventsFormat.MarginL */,
    "MarginR" /* AssEventsFormat.MarginR */,
    "MarginV" /* AssEventsFormat.MarginV */,
    "Effect" /* AssEventsFormat.Effect */,
    "Text" /* AssEventsFormat.Text */
];


/***/ }),

/***/ "./src/avformat/formats/ass/iass.ts":
/*!******************************************!*\
  !*** ./src/avformat/formats/ass/iass.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getEventLineTime: () => (/* binding */ getEventLineTime),
/* harmony export */   parseEvent: () => (/* binding */ parseEvent),
/* harmony export */   parseEventFormat: () => (/* binding */ parseEventFormat)
/* harmony export */ });
/* unused harmony exports parseFormat, parseStyleFormat, parseEventLine, parseDrawing, parseStyle */
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _ass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ass */ "./src/avformat/formats/ass/ass.ts");
/* harmony import */ var common_util_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/time */ "./src/common/util/time.ts");
/* harmony import */ var ass_compiler_src_parser_effect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ass-compiler/src/parser/effect */ "./node_modules/ass-compiler/src/parser/effect.js");
/* harmony import */ var ass_compiler_src_parser_text__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ass-compiler/src/parser/text */ "./node_modules/ass-compiler/src/parser/text.js");
var cheap__fileName__0 = "src\\avformat\\formats\\ass\\iass.ts";
/*
 * libmedia ass input util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





function parseFormat(fields, format) {
    const items = format.match(/Format\s*:\s*(.*)/i)[1].split(/\s*,\s*/);
    const result = [];
    for (let i = 0; i < items.length; i++) {
        const field = fields.find((f) => f.toLowerCase() === items[i].toLowerCase());
        if (!field) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_0__.warn(`not support ass field(${items[i]})`, cheap__fileName__0, 40);
        }
        result.push(field || items[i]);
    }
    return result;
}
function parseStyleFormat(format) {
    return parseFormat(_ass__WEBPACK_IMPORTED_MODULE_1__.AssStylesFormatList, format);
}
function parseEventFormat(format) {
    return parseFormat(_ass__WEBPACK_IMPORTED_MODULE_1__.AssEventsFormatList, format);
}
function parseEventLine(formats, text) {
    let fields = text.split(',');
    if (fields.length > formats.length) {
        const textField = fields.slice(formats.length - 1).join(',');
        fields = fields.slice(0, formats.length - 1);
        fields.push(textField);
    }
    return fields;
}
function getEventLineTime(formats, event, startIndex, endIndex) {
    const [, , value] = event.match(/^(\w+?)\s*:\s*(.*)/i);
    const fields = parseEventLine(formats, value);
    return {
        start: (0,common_util_time__WEBPACK_IMPORTED_MODULE_2__.hhColonDDColonSSDotMill2Int64)(fields[startIndex]),
        end: (0,common_util_time__WEBPACK_IMPORTED_MODULE_2__.hhColonDDColonSSDotMill2Int64)(fields[endIndex])
    };
}
function parseDrawing(text) {
    if (!text) {
        return [];
    }
    return text
        .toLowerCase()
        // numbers
        .replace(/([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)/g, ' $1 ')
        // commands
        .replace(/([mnlbspc])/g, ' $1 ')
        .trim()
        .replace(/\s+/g, ' ')
        .split(/\s(?=[mnlbspc])/)
        .map((cmd) => (cmd.split(' ').filter((x, i) => !(i && Number.isNaN(+x)))));
}
function parseStyle(styleFormat, style) {
    const values = style.match(/Style\s*:\s*(.*)/i)[1].split(/\s*,\s*/);
    const result = {};
    for (let i = 0; i < values.length; i++) {
        result[styleFormat[i]] = values[i];
    }
    return result;
}
function parseEvent(formats, event) {
    const [, key, value] = event.match(/^(\w+?)\s*:\s*(.*)/i);
    let type = 0 /* AssEventType.NONE */;
    switch (key) {
        case 'Comment':
            type = 2 /* AssEventType.Comment */;
            break;
        case 'Dialogue':
            type = 1 /* AssEventType.Dialogue */;
            break;
        case 'Command':
            type = 6 /* AssEventType.Command */;
            break;
        case 'Movie':
            type = 5 /* AssEventType.Movie */;
            break;
        case 'Picture':
            type = 3 /* AssEventType.Picture */;
            break;
        case 'Sound':
            type = 4 /* AssEventType.Sound */;
            break;
    }
    const fields = parseEventLine(formats, value);
    const result = {
        type
    };
    for (let i = 0; i < fields.length; i++) {
        result[formats[i]] = fields[i];
        const fmt = formats[i];
        const fld = fields[i].trim();
        switch (fmt) {
            case 'Layer':
            case 'MarginL':
            case 'MarginR':
            case 'MarginV':
                result[fmt] = +fld;
                break;
            case 'Start':
            case 'End':
                result[fmt] = (0,common_util_time__WEBPACK_IMPORTED_MODULE_2__.hhColonDDColonSSDotMill2Int64)(fld);
                break;
            case 'Effect':
                result[fmt] = (0,ass_compiler_src_parser_effect__WEBPACK_IMPORTED_MODULE_3__.parseEffect)(fld);
                break;
            case 'Text':
                result[fmt] = (0,ass_compiler_src_parser_text__WEBPACK_IMPORTED_MODULE_4__.parseText)(fld);
                break;
            default:
                result[fmt] = fld;
        }
    }
    return result;
}


/***/ }),

/***/ "./src/avformat/formats/mov/boxType.ts":
/*!*********************************************!*\
  !*** ./src/avformat/formats/mov/boxType.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContainerBoxs: () => (/* binding */ ContainerBoxs),
/* harmony export */   FullBoxs: () => (/* binding */ FullBoxs)
/* harmony export */ });
/* unused harmony export BasicBoxs */
/*
 * libmedia mp4 box defined
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const BasicBoxs = [
    "ftyp" /* BoxType.FTYP */,
    "mdat" /* BoxType.MDAT */,
    "idat" /* BoxType.IDAT */,
    "free" /* BoxType.FREE */,
    "skip" /* BoxType.SKIP */,
    "meco" /* BoxType.MECO */,
    "strk" /* BoxType.STRK */,
];
const FullBoxs = [
    "hmhd" /* BoxType.HMHD */,
    "nmhd" /* BoxType.NMHD */,
    "iods" /* BoxType.IODS */,
    "xml " /* BoxType.XML */,
    "url " /* BoxType.URL */,
    "bxml" /* BoxType.BXML */,
    "ipro" /* BoxType.IPRO */,
    "mere" /* BoxType.MERE */,
    "stts" /* BoxType.STTS */,
    "ctts" /* BoxType.CTTS */,
    "stss" /* BoxType.STSS */,
    "stsz" /* BoxType.STSZ */,
    "stz2" /* BoxType.STZ2 */,
    "stsc" /* BoxType.STSC */,
    "stco" /* BoxType.STCO */,
    "co64" /* BoxType.CO64 */,
    "stsd" /* BoxType.STSD */,
    "dref" /* BoxType.DREF */,
    "mvhd" /* BoxType.MVHD */,
    "tkhd" /* BoxType.TKHD */,
    "mdhd" /* BoxType.MDHD */,
    "hdlr" /* BoxType.HDLR */
];
const ContainerBoxs = [
    "moov" /* BoxType.MOOV */,
    "trak" /* BoxType.TRAK */,
    "edts" /* BoxType.EDTS */,
    "mdia" /* BoxType.MDIA */,
    "minf" /* BoxType.MINF */,
    "dinf" /* BoxType.DINF */,
    "stbl" /* BoxType.STBL */,
    "mvex" /* BoxType.MVEX */,
    "moof" /* BoxType.MOOF */,
    "traf" /* BoxType.TRAF */,
    "vttc" /* BoxType.VTTC */,
    "tref" /* BoxType.TREF */,
    "iref" /* BoxType.IREF */,
    "mfra" /* BoxType.MFRA */,
    "hnti" /* BoxType.HNTI */,
    "hinf" /* BoxType.HINF */,
    "strd" /* BoxType.STRD */,
    "sinf" /* BoxType.SINF */,
    "rinf" /* BoxType.RINF */,
    "schi" /* BoxType.SCHI */,
    "trgr" /* BoxType.TRGR */,
    "udta" /* BoxType.UDTA */,
    "iprp" /* BoxType.IPRP */,
    "ipco" /* BoxType.IPCO */,
    "strk" /* BoxType.STRK */,
    "meco" /* BoxType.MECO */
];


/***/ }),

/***/ "./src/avformat/formats/mov/function/createFragmentTrack.ts":
/*!******************************************************************!*\
  !*** ./src/avformat/formats/mov/function/createFragmentTrack.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createFragmentTrack)
/* harmony export */ });
/*
 * libmedia create fragment track
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function createFragmentTrack() {
    return {
        trackId: 0,
        baseDataOffset: BigInt(0),
        defaultSampleDuration: 0,
        defaultSampleSize: 0,
        defaultSampleFlags: 0,
        baseMediaDecodeTime: BigInt(0),
        sampleCount: 0,
        dataOffset: 0,
        dataOffsetPos: BigInt(0),
        firstSampleFlags: 0,
        sampleDurations: [],
        sampleSizes: [],
        sampleFlags: [],
        sampleCompositionTimeOffset: [],
        baseIsMoof: false,
        ioWriter: null,
        buffers: []
    };
}


/***/ }),

/***/ "./src/avformat/formats/mov/function/createMovContext.ts":
/*!***************************************************************!*\
  !*** ./src/avformat/formats/mov/function/createMovContext.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createMovContext)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/*
 * libmedia create mov context
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function createMovContext() {
    return {
        isom: false,
        timescale: avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
        duration: avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT,
        foundMoov: false,
        foundMdat: false,
        majorBrand: 0,
        minorVersion: 0,
        compatibleBrand: [],
        creationTime: BigInt(0),
        modificationTime: BigInt(0),
        rate: avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
        volume: avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
        matrix: null,
        nextTrackId: 1,
        fragment: false,
        trexs: [],
        currentFragment: null,
        boxsPositionInfo: [],
        holdMoovPos: BigInt(0),
        currentChunk: null
    };
}


/***/ }),

/***/ "./src/avformat/formats/mov/function/createMovStreamContext.ts":
/*!*********************************************************************!*\
  !*** ./src/avformat/formats/mov/function/createMovStreamContext.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createMovStreamContext)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/*
 * libmedia create mov stream context
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function createMovStreamContext() {
    return {
        chunkOffsets: null,
        cttsSampleCounts: null,
        cttsSampleOffsets: null,
        stscFirstChunk: null,
        stscSamplesPerChunk: null,
        stscSampleDescriptionIndex: null,
        stssSampleNumbersMap: null,
        stssSampleNumbers: null,
        sampleSizes: null,
        sttsSampleCounts: null,
        sttsSampleDeltas: null,
        timescale: 0,
        duration: BigInt(0),
        trackId: avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
        layer: 0,
        alternateGroup: 0,
        volume: 0,
        matrix: null,
        width: 0,
        height: 0,
        audioCid: 0,
        samplesPerFrame: 0,
        bytesPerFrame: 0,
        currentSample: 0,
        sampleEnd: false,
        samplesIndex: [],
        fragIndexes: [],
        lastPts: BigInt(0),
        lastDts: BigInt(0),
        startDts: BigInt(0),
        startCT: 0,
        lastDuration: 0,
        chunkCount: 0,
        firstWrote: false,
        lastStscCount: 0,
        perStreamGrouping: false,
        index: 0,
        flags: 0
    };
}


/***/ }),

/***/ "./src/avformat/formats/mov/function/updatePositionSize.ts":
/*!*****************************************************************!*\
  !*** ./src/avformat/formats/mov/function/updatePositionSize.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updatePositionSize)
/* harmony export */ });
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/*
 * libmedia update box position size
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function updatePositionSize(ioWriter, movContext) {
    const pos = ioWriter.getPos();
    const pointer = ioWriter.getPointer();
    const minPos = pos - BigInt(Math.floor(pointer));
    const seeks = [];
    common_util_array__WEBPACK_IMPORTED_MODULE_0__.each(movContext.boxsPositionInfo, (item) => {
        if (item.pos < pos && item.pos >= minPos) {
            ioWriter.seekInline(pointer + Number(item.pos - pos));
            ioWriter.writeUint32(item.size);
        }
        else {
            seeks.push(item);
        }
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_0__.each(seeks, (item) => {
        ioWriter.seek(item.pos);
        ioWriter.writeUint32(item.size);
    });
    if (seeks.length) {
        ioWriter.seek(pos);
    }
    else {
        ioWriter.seekInline(pointer);
    }
    movContext.boxsPositionInfo = [];
}


/***/ }),

/***/ "./src/avformat/formats/mov/layout.ts":
/*!********************************************!*\
  !*** ./src/avformat/formats/mov/layout.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FragmentTrackBoxLayoutMap: () => (/* binding */ FragmentTrackBoxLayoutMap),
/* harmony export */   MoofTrafBoxLayout: () => (/* binding */ MoofTrafBoxLayout),
/* harmony export */   TrackBoxLayoutMap: () => (/* binding */ TrackBoxLayoutMap)
/* harmony export */ });
/*
 * libmedia mp4 box layout
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function getTrackBoxAudioLayout(context) {
    return [
        {
            type: "tkhd" /* BoxType.TKHD */
        },
        {
            type: "edts" /* BoxType.EDTS */
        },
        {
            type: "mdia" /* BoxType.MDIA */,
            children: [
                {
                    type: "mdhd" /* BoxType.MDHD */
                },
                {
                    type: "hdlr" /* BoxType.HDLR */
                },
                {
                    type: "minf" /* BoxType.MINF */,
                    children: [
                        {
                            type: "smhd" /* BoxType.SMHD */
                        },
                        context.isom
                            ? {
                                type: "minf_hdlr" /* BoxType.MINF_HDLR */
                            }
                            : null,
                        {
                            type: "dinf" /* BoxType.DINF */,
                            children: [
                                {
                                    type: "dref" /* BoxType.DREF */,
                                    children: [
                                        {
                                            type: "url " /* BoxType.URL */
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            type: "stbl" /* BoxType.STBL */,
                            children: [
                                {
                                    type: "stsd" /* BoxType.STSD */
                                },
                                {
                                    type: "stts" /* BoxType.STTS */
                                },
                                {
                                    type: "stsc" /* BoxType.STSC */
                                },
                                {
                                    type: "stsz" /* BoxType.STSZ */
                                },
                                {
                                    type: "stco" /* BoxType.STCO */
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ];
}
function getTrackBoxVideoLayout(context) {
    return [
        {
            type: "tkhd" /* BoxType.TKHD */
        },
        {
            type: "edts" /* BoxType.EDTS */
        },
        {
            type: "mdia" /* BoxType.MDIA */,
            children: [
                {
                    type: "mdhd" /* BoxType.MDHD */
                },
                {
                    type: "hdlr" /* BoxType.HDLR */
                },
                {
                    type: "minf" /* BoxType.MINF */,
                    children: [
                        {
                            type: "vmhd" /* BoxType.VMHD */
                        },
                        context.isom
                            ? {
                                type: "minf_hdlr" /* BoxType.MINF_HDLR */
                            }
                            : null,
                        {
                            type: "dinf" /* BoxType.DINF */,
                            children: [
                                {
                                    type: "dref" /* BoxType.DREF */,
                                    children: [
                                        {
                                            type: "url " /* BoxType.URL */
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            type: "stbl" /* BoxType.STBL */,
                            children: [
                                {
                                    type: "stsd" /* BoxType.STSD */
                                },
                                {
                                    type: "stts" /* BoxType.STTS */
                                },
                                {
                                    type: "stss" /* BoxType.STSS */
                                },
                                {
                                    type: "ctts" /* BoxType.CTTS */
                                },
                                {
                                    type: "stsc" /* BoxType.STSC */
                                },
                                {
                                    type: "stsz" /* BoxType.STSZ */
                                },
                                {
                                    type: "stco" /* BoxType.STCO */
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ];
}
function getFragmentTrackAudioBoxLayout(context) {
    return [
        {
            type: "tkhd" /* BoxType.TKHD */
        },
        {
            type: "mdia" /* BoxType.MDIA */,
            children: [
                {
                    type: "mdhd" /* BoxType.MDHD */
                },
                {
                    type: "hdlr" /* BoxType.HDLR */
                },
                {
                    type: "minf" /* BoxType.MINF */,
                    children: [
                        {
                            type: "smhd" /* BoxType.SMHD */
                        },
                        context.isom
                            ? {
                                type: "minf_hdlr" /* BoxType.MINF_HDLR */
                            }
                            : null,
                        {
                            type: "dinf" /* BoxType.DINF */,
                            children: [
                                {
                                    type: "dref" /* BoxType.DREF */,
                                    children: [
                                        {
                                            type: "url " /* BoxType.URL */
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            type: "stbl" /* BoxType.STBL */,
                            children: [
                                {
                                    type: "stsd" /* BoxType.STSD */
                                },
                                {
                                    type: "stts" /* BoxType.STTS */
                                },
                                {
                                    type: "stsc" /* BoxType.STSC */
                                },
                                {
                                    type: "stsz" /* BoxType.STSZ */
                                },
                                {
                                    type: "stco" /* BoxType.STCO */
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ];
}
function getFragmentTrackVideoBoxLayout(context) {
    return [
        {
            type: "tkhd" /* BoxType.TKHD */
        },
        {
            type: "mdia" /* BoxType.MDIA */,
            children: [
                {
                    type: "mdhd" /* BoxType.MDHD */
                },
                {
                    type: "hdlr" /* BoxType.HDLR */
                },
                {
                    type: "minf" /* BoxType.MINF */,
                    children: [
                        {
                            type: "vmhd" /* BoxType.VMHD */
                        },
                        context.isom
                            ? {
                                type: "minf_hdlr" /* BoxType.MINF_HDLR */
                            }
                            : null,
                        {
                            type: "dinf" /* BoxType.DINF */,
                            children: [
                                {
                                    type: "dref" /* BoxType.DREF */,
                                    children: [
                                        {
                                            type: "url " /* BoxType.URL */
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            type: "stbl" /* BoxType.STBL */,
                            children: [
                                {
                                    type: "stsd" /* BoxType.STSD */
                                },
                                {
                                    type: "stts" /* BoxType.STTS */
                                },
                                {
                                    type: "stsc" /* BoxType.STSC */
                                },
                                {
                                    type: "stsz" /* BoxType.STSZ */
                                },
                                {
                                    type: "stco" /* BoxType.STCO */
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ];
}
const FragmentTrackBoxLayoutMap = {
    [1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */]: getFragmentTrackAudioBoxLayout,
    [0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */]: getFragmentTrackVideoBoxLayout
};
const TrackBoxLayoutMap = {
    [1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */]: getTrackBoxAudioLayout,
    [0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */]: getTrackBoxVideoLayout
};
const MoofTrafBoxLayout = [
    {
        type: "tfhd" /* BoxType.TFHD */
    },
    {
        type: "tfdt" /* BoxType.TFDT */
    },
    {
        type: "trun" /* BoxType.TRUN */
    }
];


/***/ }),

/***/ "./src/avformat/formats/mov/mov.ts":
/*!*****************************************!*\
  !*** ./src/avformat/formats/mov/mov.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVCodecID2Mp4a: () => (/* binding */ AVCodecID2Mp4a),
/* harmony export */   HandlerType2MediaType: () => (/* binding */ HandlerType2MediaType),
/* harmony export */   Mp4aObj2AVCodecID: () => (/* binding */ Mp4aObj2AVCodecID),
/* harmony export */   tag2CodecId: () => (/* binding */ tag2CodecId)
/* harmony export */ });
/* unused harmony export Mp4Tag2AVCodecID */
/* harmony import */ var _function_mktag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../function/mktag */ "./src/avformat/function/mktag.ts");
/*
 * libmedia mp4 identify defined
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const Mp4Tag2AVCodecID = {
    mp4v: 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
    avc1: 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    avc3: 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    hev1: 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    hvc1: 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    vvc1: 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    vvi1: 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    vp09: 167 /* AVCodecID.AV_CODEC_ID_VP9 */,
    av01: 225 /* AVCodecID.AV_CODEC_ID_AV1 */,
    mp4a: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    opus: 86076 /* AVCodecID.AV_CODEC_ID_OPUS */
};
const AVCodecID2Mp4a = {
    [86018 /* AVCodecID.AV_CODEC_ID_AAC */]: 0x40,
    [86017 /* AVCodecID.AV_CODEC_ID_MP3 */]: 0x69,
    [86076 /* AVCodecID.AV_CODEC_ID_OPUS */]: 0xAD,
    [86028 /* AVCodecID.AV_CODEC_ID_FLAC */]: 0xC1,
    [86021 /* AVCodecID.AV_CODEC_ID_VORBIS */]: 0xDD,
    [12 /* AVCodecID.AV_CODEC_ID_MPEG4 */]: 0x20,
    [27 /* AVCodecID.AV_CODEC_ID_H264 */]: 0x21,
    [173 /* AVCodecID.AV_CODEC_ID_HEVC */]: 0x23,
    [196 /* AVCodecID.AV_CODEC_ID_VVC */]: 0x33,
    [167 /* AVCodecID.AV_CODEC_ID_VP9 */]: 0xB1,
    [0 /* AVCodecID.AV_CODEC_ID_NONE */]: 0
};
const Mp4aObj2AVCodecID = {
    0x20: 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
    0x21: 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    0x23: 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    0x33: 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    0xB1: 167 /* AVCodecID.AV_CODEC_ID_VP9 */,
    0x40: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    0x66: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    0x67: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    0x68: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    0x69: 86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
    0x6B: 86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
    0xAD: 86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
    0xC1: 86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
    0xDD: 86021 /* AVCodecID.AV_CODEC_ID_VORBIS */,
    0: 0 /* AVCodecID.AV_CODEC_ID_NONE */
};
const HandlerType2MediaType = {
    vide: 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */,
    soun: 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */,
    clcp: 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */,
    sbtl: 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */,
    subt: 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */,
    subp: 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */,
    text: 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */
};
const tag2CodecId = {
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("mp4a" /* BoxType.MP4A */)]: 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    [0x6D730055]: 86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('Opus')]: 86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('fLaC')]: 86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('spex')]: 86051 /* AVCodecID.AV_CODEC_ID_SPEEX */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('SPXN')]: 86051 /* AVCodecID.AV_CODEC_ID_SPEEX */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('ac-3')]: 86019 /* AVCodecID.AV_CODEC_ID_AC3 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('sac3')]: 86019 /* AVCodecID.AV_CODEC_ID_AC3 */,
    [_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"]["mp4v" /* BoxType.MP4V */]]: 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('av01')]: 225 /* AVCodecID.AV_CODEC_ID_AV1 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('vp08')]: 139 /* AVCodecID.AV_CODEC_ID_VP8 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('vp09')]: 167 /* AVCodecID.AV_CODEC_ID_VP9 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('avc1')]: 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('hev1')]: 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('hvc1')]: 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('vvc1')]: 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('vvi1')]: 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('text')]: 94213 /* AVCodecID.AV_CODEC_ID_MOV_TEXT */,
    [(0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('tx3g')]: 94213 /* AVCodecID.AV_CODEC_ID_MOV_TEXT */
};


/***/ }),

/***/ "./src/avformat/formats/mov/omov.ts":
/*!******************************************!*\
  !*** ./src/avformat/formats/mov/omov.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   writeFtyp: () => (/* binding */ writeFtyp),
/* harmony export */   writeMoof: () => (/* binding */ writeMoof),
/* harmony export */   writeMoov: () => (/* binding */ writeMoov)
/* harmony export */ });
/* unused harmony export updateSize */
/* harmony import */ var _function_mktag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../function/mktag */ "./src/avformat/function/mktag.ts");
/* harmony import */ var _boxType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./boxType */ "./src/avformat/formats/mov/boxType.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var _writing_writers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./writing/writers */ "./src/avformat/formats/mov/writing/writers.ts");
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./layout */ "./src/avformat/formats/mov/layout.ts");
/* harmony import */ var _function_updatePositionSize__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./function/updatePositionSize */ "./src/avformat/formats/mov/function/updatePositionSize.ts");
/*
 * libmedia mp4 encode util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */






function updateSize(ioWriter, pointer, size) {
    const current = ioWriter.getPointer();
    ioWriter.seekInline(pointer);
    ioWriter.writeUint32(size);
    ioWriter.seekInline(current);
}
function writeFtyp(ioWriter, context) {
    ioWriter.flush();
    const pointer = ioWriter.getPointer();
    const now = ioWriter.getPos();
    ioWriter.writeUint32(0);
    ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("ftyp" /* BoxType.FTYP */));
    ioWriter.writeUint32(context.majorBrand || (0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])('isom'));
    ioWriter.writeUint32(context.minorVersion || 512);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(context.compatibleBrand, (value) => {
        ioWriter.writeUint32(value);
    });
    updateSize(ioWriter, pointer, Number(ioWriter.getPos() - now));
    if (context.isom) {
        ioWriter.writeUint32(8);
        ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("wide" /* BoxType.WIDE */));
    }
    else if (!context.fragment) {
        ioWriter.writeUint32(8);
        ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("free" /* BoxType.FREE */));
    }
}
function writeEmptyBox(ioWriter, tag) {
    const isFullBox = common_util_array__WEBPACK_IMPORTED_MODULE_2__.has(_boxType__WEBPACK_IMPORTED_MODULE_1__.FullBoxs, tag);
    ioWriter.writeUint32(isFullBox ? 12 : 8);
    ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])(tag));
    if (isFullBox) {
        // version & flags
        ioWriter.writeUint32(0);
    }
}
function writeLayout(ioWriter, layouts, stream, movContext) {
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(layouts, (layout) => {
        if (!layout) {
            return true;
        }
        if (_writing_writers__WEBPACK_IMPORTED_MODULE_3__["default"][layout.type]) {
            _writing_writers__WEBPACK_IMPORTED_MODULE_3__["default"][layout.type](ioWriter, stream, movContext);
        }
        else if (layout.children) {
            const pos = ioWriter.getPos();
            ioWriter.writeUint32(0);
            ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])(layout.type));
            writeLayout(ioWriter, layout.children, stream, movContext);
            movContext.boxsPositionInfo.push({
                pos,
                type: layout.type,
                size: Number(ioWriter.getPos() - pos)
            });
        }
        else {
            writeEmptyBox(ioWriter, layout.type);
        }
    });
}
function writeMoov(ioWriter, formatContext, movContext) {
    const pos = ioWriter.getPos();
    ioWriter.writeUint32(0);
    ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("moov" /* BoxType.MOOV */));
    _writing_writers__WEBPACK_IMPORTED_MODULE_3__["default"]["mvhd" /* BoxType.MVHD */](ioWriter, null, movContext);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(formatContext.streams, (stream) => {
        const pos = ioWriter.getPos();
        ioWriter.writeUint32(0);
        ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("trak" /* BoxType.TRAK */));
        writeLayout(ioWriter, movContext.fragment
            ? _layout__WEBPACK_IMPORTED_MODULE_4__.FragmentTrackBoxLayoutMap[stream.codecpar.codecType](movContext)
            : _layout__WEBPACK_IMPORTED_MODULE_4__.TrackBoxLayoutMap[stream.codecpar.codecType](movContext), stream, movContext);
        movContext.boxsPositionInfo.push({
            pos,
            type: "trak" /* BoxType.TRAK */,
            size: Number(ioWriter.getPos() - pos)
        });
    });
    if (movContext.fragment) {
        const pos = ioWriter.getPos();
        ioWriter.writeUint32(0);
        ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("mvex" /* BoxType.MVEX */));
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(formatContext.streams, (stream) => {
            _writing_writers__WEBPACK_IMPORTED_MODULE_3__["default"]["trex" /* BoxType.TREX */](ioWriter, stream, movContext);
        });
        movContext.boxsPositionInfo.push({
            pos,
            type: "mvex" /* BoxType.MVEX */,
            size: Number(ioWriter.getPos() - pos)
        });
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: "moov" /* BoxType.MOOV */,
        size: Number(ioWriter.getPos() - pos)
    });
    (0,_function_updatePositionSize__WEBPACK_IMPORTED_MODULE_5__["default"])(ioWriter, movContext);
}
function writeMoof(ioWriter, formatContext, movContext) {
    const pos = ioWriter.getPos();
    ioWriter.writeUint32(0);
    ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("moof" /* BoxType.MOOF */));
    _writing_writers__WEBPACK_IMPORTED_MODULE_3__["default"]["mfhd" /* BoxType.MFHD */](ioWriter, null, movContext);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(movContext.currentFragment.tracks, (track) => {
        if (!track.sampleCount) {
            return true;
        }
        const pos = ioWriter.getPos();
        ioWriter.writeUint32(0);
        ioWriter.writeUint32((0,_function_mktag__WEBPACK_IMPORTED_MODULE_0__["default"])("traf" /* BoxType.TRAF */));
        const stream = formatContext.streams.find((stream) => {
            return stream.privData.trackId === track.trackId;
        });
        writeLayout(ioWriter, _layout__WEBPACK_IMPORTED_MODULE_4__.MoofTrafBoxLayout, stream, movContext);
        movContext.boxsPositionInfo.push({
            pos,
            type: "traf" /* BoxType.TRAF */,
            size: Number(ioWriter.getPos() - pos)
        });
    });
    const size = Number(ioWriter.getPos() - pos);
    movContext.boxsPositionInfo.push({
        pos,
        type: "moof" /* BoxType.MOOF */,
        size
    });
    movContext.currentFragment.size = size;
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/av1c.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/av1c.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 av1c box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(8 + stream.codecpar.extradataSize ?? 0);
    // tag
    ioWriter.writeString("av1C" /* BoxType.AV1C */);
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
        }
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/avcc.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/avcc.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 avcc box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(8 + stream.codecpar.extradataSize ?? 0);
    // tag
    ioWriter.writeString("avcC" /* BoxType.AVCC */);
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
        }
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/btrt.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/btrt.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 btrt box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(20);
    // tag
    ioWriter.writeString("btrt" /* BoxType.BTRT */);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/co64.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/co64.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 co64 box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const chunkOffsets = stream.privData.chunkOffsets || [];
    // size
    ioWriter.writeUint32(8 + chunkOffsets.length * 8);
    // tag
    ioWriter.writeString("co64" /* BoxType.CO64 */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(chunkOffsets.length);
    for (let i = 0; i < chunkOffsets.length; i++) {
        ioWriter.writeUint64(chunkOffsets[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/colr.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/colr.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 colr box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const icc = stream.sideData[28 /* AVPacketSideDataType.AV_PKT_DATA_ICC_PROFILE */];
    if (icc) {
        // size
        ioWriter.writeUint32(12 + icc.length);
        // tag
        ioWriter.writeString("colr" /* BoxType.COLR */);
        ioWriter.writeString('prof');
        ioWriter.writeBuffer(icc);
    }
    else {
        const fullRange = stream.codecpar.colorRange === 2 /* AVColorRange.AVCOL_RANGE_JPEG */;
        // size
        ioWriter.writeUint32(19);
        // tag
        ioWriter.writeString("colr" /* BoxType.COLR */);
        ioWriter.writeString('nclx');
        ioWriter.writeUint16(stream.codecpar.colorPrimaries);
        ioWriter.writeUint16(stream.codecpar.colorTrc);
        ioWriter.writeUint16(stream.codecpar.colorSpace);
        ioWriter.writeUint8(fullRange ? (128) : 0);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/ctts.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/ctts.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avformat\\formats\\mov\\writing\\ctts.ts";

function write(ioWriter, stream, movContext) {
    const context = stream.privData;
    const sampleCounts = context.cttsSampleCounts || [];
    const sampleOffsets = context.cttsSampleOffsets || [];
    if (sampleCounts.length !== sampleOffsets.length) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('ctts sampleCounts\'s length is not match sampleOffsets\'s length', cheap__fileName__0, 39);
    }
    const entryCount = Math.min(sampleCounts.length, sampleOffsets.length);
    // size
    ioWriter.writeUint32(16 + entryCount * 8);
    // tag
    ioWriter.writeString("ctts" /* BoxType.CTTS */);
    // version use int
    ioWriter.writeUint8(1);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(entryCount);
    for (let i = 0; i < entryCount; i++) {
        ioWriter.writeUint32(sampleCounts[i]);
        ioWriter.writeInt32(sampleOffsets[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/dac3.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/dac3.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var common_io_BitWriter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BitWriter */ "./src/common/io/BitWriter.ts");
/*
 * libmedia mp4 dac3 box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(11);
    // tag
    ioWriter.writeString("dac3" /* BoxType.DAC3 */);
    const bitWriter = new common_io_BitWriter__WEBPACK_IMPORTED_MODULE_0__["default"](3);
    const info = movContext.ac3Info;
    bitWriter.writeU(2, info.substream[0].fscod);
    bitWriter.writeU(5, info.substream[0].bsid);
    bitWriter.writeU(3, info.substream[0].bsmod);
    bitWriter.writeU(3, info.substream[0].acmod);
    bitWriter.writeU(1, info.substream[0].lfeon);
    bitWriter.writeU(5, info.ac3BitrateCode);
    bitWriter.writeU(5, 0);
    ioWriter.writeBuffer(bitWriter.getBuffer());
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/dec3.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/dec3.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var common_io_BitWriter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BitWriter */ "./src/common/io/BitWriter.ts");
/*
 * libmedia mp4 dec3 box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    const info = movContext.ac3Info;
    const bitWriter = new common_io_BitWriter__WEBPACK_IMPORTED_MODULE_0__["default"](2 + ((34 * (info.numIndSub + 1) + 7) >> 3));
    bitWriter.writeU(13, info.dataRate);
    bitWriter.writeU(3, info.numIndSub);
    for (let i = 0; i < info.numIndSub; i++) {
        bitWriter.writeU(2, info.substream[i].fscod);
        bitWriter.writeU(5, info.substream[i].bsid);
        bitWriter.writeU(1, 0);
        bitWriter.writeU(1, 0);
        bitWriter.writeU(3, info.substream[i].bsmod);
        bitWriter.writeU(3, info.substream[i].acmod);
        bitWriter.writeU(1, info.substream[i].lfeon);
        bitWriter.writeU(5, 0);
        bitWriter.writeU(4, info.substream[i].numDepSub);
        if (!info.substream[i].numDepSub) {
            bitWriter.writeU(1, 0);
        }
        else {
            bitWriter.writeU(9, info.substream[i].chanLoc);
        }
    }
    bitWriter.padding();
    const size = bitWriter.getPointer();
    // size
    ioWriter.writeUint32(8 + size);
    // tag
    ioWriter.writeString("dec3" /* BoxType.DEC3 */);
    ioWriter.writeBuffer(bitWriter.getBuffer().subarray(0, size));
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/dfla.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/dfla.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avformat\\formats\\mov\\writing\\dfla.ts";


function write(ioWriter, stream, movContext) {
    let extradata;
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize);
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize);
        }
    }
    if (!extradata) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.error('invalid extradata', cheap__fileName__0, 56);
    }
    else {
        // size
        ioWriter.writeUint32(extradata.length + 16);
        // tag
        ioWriter.writeString("dfLa" /* BoxType.DFLA */);
        // version
        ioWriter.writeUint8(0);
        // flags
        ioWriter.writeUint24(0);
        ioWriter.writeUint8((128) | 0 /* FlacMetadataType.FLAC_METADATA_TYPE_STREAMINFO */);
        ioWriter.writeUint24(extradata.length);
        ioWriter.writeBuffer(extradata);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/dops.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/dops.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/*
 * libmedia mp4 dops box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function write(ioWriter, stream, movContext) {
    let extradata;
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize);
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize);
        }
    }
    if (!extradata || extradata.length < 19) {
        ioWriter.writeUint32(19);
        ioWriter.writeString("dOps" /* BoxType.DOPS */);
        ioWriter.writeUint8(0);
        ioWriter.writeUint8(stream.codecpar.chLayout.nbChannels);
        ioWriter.writeUint16(stream.codecpar.initialPadding);
        ioWriter.writeUint32(stream.codecpar.sampleRate);
        ioWriter.writeUint16(0);
        ioWriter.writeUint8(0);
    }
    else {
        const reader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_1__["default"](extradata, false);
        // size
        ioWriter.writeUint32(extradata.length);
        // tag
        ioWriter.writeString("dOps" /* BoxType.DOPS */);
        // Version
        ioWriter.writeUint8(0);
        reader.seek(9);
        ioWriter.writeUint8(reader.readUint8());
        ioWriter.writeUint16(reader.readUint16());
        ioWriter.writeUint32(reader.readUint32());
        ioWriter.writeUint16(reader.readUint16());
        ioWriter.writeBuffer(extradata.subarray(18));
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/dref.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/dref.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 dref box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(28);
    // tag
    ioWriter.writeString("dref" /* BoxType.DREF */);
    // version & flags
    ioWriter.writeUint32(0);
    // entry count
    ioWriter.writeUint32(1);
    // size
    ioWriter.writeUint32(0x0c);
    ioWriter.writeString("url " /* BoxType.URL */);
    // version & flags
    ioWriter.writeUint32(1);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/edts.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/edts.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/*
 * libmedia mp4 edts box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function write(ioWriter, stream, movContext) {
    const streamContext = stream.privData;
    let duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_1__.avRescaleQ)(streamContext.lastPts, stream.timeBase, {
        den: movContext.timescale,
        num: 1
    });
    let startCT = streamContext.startCT;
    const delay = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_1__.avRescaleQ)(streamContext.startDts + BigInt(Math.floor(startCT)), stream.timeBase, {
        den: streamContext.timescale,
        num: 1
    });
    let version = duration < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.INT32_MAX ? 0 : 1;
    version |= delay < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.INT32_MAX ? 0 : 1;
    const entrySize = (version === 1) ? 20 : 12;
    const entryCount = 1 + (delay > 0 ? 1 : 0);
    const size = 24 + entryCount * entrySize;
    // size
    ioWriter.writeUint32(size);
    // tag
    ioWriter.writeString("edts" /* BoxType.EDTS */);
    ioWriter.writeUint32(size - 8);
    ioWriter.writeString("elst" /* BoxType.ELST */);
    ioWriter.writeUint8(version);
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(entryCount);
    if (delay > 0) {
        if (version === 1) {
            ioWriter.writeUint64(delay);
            ioWriter.writeInt64(avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT);
        }
        else {
            ioWriter.writeUint32(Number(delay));
            ioWriter.writeInt32(-1);
        }
        ioWriter.writeUint32(0x00010000);
    }
    else {
        startCT = -Math.min(Number(streamContext.startDts), 0);
        duration += delay;
    }
    if (movContext.fragment) {
        duration = BigInt(0);
    }
    if (version === 1) {
        ioWriter.writeUint64(duration);
        ioWriter.writeInt64(BigInt(Math.floor(startCT)));
    }
    else {
        ioWriter.writeUint32(Number(duration));
        ioWriter.writeInt32(startCT);
    }
    ioWriter.writeUint32(0x00010000);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/esds.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/esds.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var _mov__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mov */ "./src/avformat/formats/mov/mov.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 esds box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function writeDescriptorLength(ioWriter, tag, size) {
    ioWriter.writeUint8(tag);
    for (let i = 3; i > 0; i--) {
        ioWriter.writeUint8((size >> (7 * i)) | 0x80);
    }
    ioWriter.writeUint8(size & 0x7F);
}
function write(ioWriter, stream, movContext) {
    const streamContext = stream.privData;
    const decoderSpecificInfoLen = stream.codecpar.extradata ? 5 + stream.codecpar.extradataSize : 0;
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("esds" /* BoxType.ESDS */);
    // version = 0
    ioWriter.writeUint32(0);
    // ES descriptor
    writeDescriptorLength(ioWriter, 3 /* MP4Tag.MP4_ES_DESCR_TAG */, 21 + decoderSpecificInfoLen + 5 + 1);
    ioWriter.writeUint16(streamContext.trackId);
    // ioWriter
    ioWriter.writeUint8(0x00);
    // DecoderConfig descriptor
    writeDescriptorLength(ioWriter, 4 /* MP4Tag.MP4_DEC_CONFIG_DESCR_TAG */, 13 + decoderSpecificInfoLen);
    // Object type indication
    if ((stream.codecpar.codecId === 86016 /* AVCodecID.AV_CODEC_ID_MP2 */ || stream.codecpar.codecId === 86017 /* AVCodecID.AV_CODEC_ID_MP3 */)
        && stream.codecpar.sampleRate > 24000) {
        // 11172-3
        ioWriter.writeUint8(0x6B);
    }
    else {
        ioWriter.writeUint8(_mov__WEBPACK_IMPORTED_MODULE_0__.AVCodecID2Mp4a[stream.codecpar.codecId]);
    }
    if (stream.codecpar.codecId === 94208 /* AVCodecID.AV_CODEC_ID_DVD_SUBTITLE */) {
        // flags (= NeroSubpicStream)
        ioWriter.writeUint8((224) | 1);
    }
    else if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
        // flags (= Audiostream)
        ioWriter.writeUint8(0x15);
    }
    else {
        // flags (= Visualstream)
        ioWriter.writeUint8(0x11);
    }
    //  Buffersize DB
    ioWriter.writeUint24(0);
    // maxbitrate
    ioWriter.writeUint32(0);
    // avgbitrate
    ioWriter.writeUint32(0);
    if (stream.codecpar.extradata) {
        writeDescriptorLength(ioWriter, 5 /* MP4Tag.MP4_DEC_SPECIFIC_DESCR_TAG */, stream.codecpar.extradataSize);
        ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
    }
    // SL descriptor
    writeDescriptorLength(ioWriter, 6 /* MP4Tag.MP4_SL_DESCR_TAG */, 1);
    ioWriter.writeUint8(0x02);
    movContext.boxsPositionInfo.push({
        pos,
        type: "esds" /* BoxType.ESDS */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/function/writeMatrix.ts":
/*!******************************************************************!*\
  !*** ./src/avformat/formats/mov/writing/function/writeMatrix.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ writeMatrix)
/* harmony export */ });
/*
 * libmedia write matrix
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
/**
 * transformation matrix
 *  |a  b  u|
 *  |c  d  v|
 *  |tx ty w|
 */
function writeMatrix(ioWriter, a, b, c, d, tx, ty) {
    ioWriter.writeUint32(a << 16);
    ioWriter.writeUint32(b << 16);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(c << 16);
    ioWriter.writeUint32(d << 16);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(tx << 16);
    ioWriter.writeUint32(ty << 16);
    ioWriter.writeUint32(1073741824);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/hdlr.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/hdlr.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 hdlr box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("hdlr" /* BoxType.HDLR */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    let hdlr = 'dhlr';
    let hdlrType = 'url ';
    let descr = 'DataHandler';
    if (stream) {
        hdlr = 'mhlr';
        if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
            hdlrType = 'soun';
            descr = 'SoundHandler';
        }
        else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
            hdlrType = 'vide';
            descr = 'VideoHandler';
        }
        else if (stream.codecpar.codecType === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */) {
            hdlrType = 'text';
            descr = 'SubtitleHandler';
        }
        else {
            if (stream.metadata['handlerName']) {
                descr = stream.metadata['handlerName'];
            }
            if (stream.metadata['hdlrType']) {
                hdlrType = stream.metadata['hdlrType'];
            }
        }
    }
    // handler
    ioWriter.writeString(hdlr);
    // handler type 
    ioWriter.writeString(hdlrType);
    // reserved
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
    if (!stream || movContext.isom) {
        ioWriter.writeUint8(descr.length);
    }
    ioWriter.writeString(descr);
    if (stream && !movContext.isom) {
        // c string
        ioWriter.writeUint8(0);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: "hdlr" /* BoxType.HDLR */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/hvcc.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/hvcc.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 hvcc box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(8 + stream.codecpar.extradataSize ?? 0);
    // tag
    ioWriter.writeString("hvcC" /* BoxType.HVCC */);
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
        }
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/mdhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/mdhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/*
 * libmedia mp4 mdhd box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    const streamContext = stream.privData;
    const duration = streamContext.lastPts;
    const creationTime = stream.metadata['creationTime'] || 0;
    const modificationTime = stream.metadata['modificationTime'] || 0;
    const languge = stream.metadata['language'] || 21956;
    let version = duration < BigInt(avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX) ? 0 : 1;
    version = creationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    version = modificationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    // size
    ioWriter.writeUint32(version === 1 ? 44 : 32);
    // tag
    ioWriter.writeString("mdhd" /* BoxType.MDHD */);
    // version
    ioWriter.writeUint8(version);
    // flags
    ioWriter.writeUint24(0);
    if (version === 1) {
        ioWriter.writeUint64(creationTime);
        ioWriter.writeUint64(modificationTime);
    }
    else {
        ioWriter.writeUint32(Number(creationTime));
        ioWriter.writeUint32(Number(modificationTime));
    }
    // timescale
    ioWriter.writeUint32(stream.timeBase.den);
    if (version === 1) {
        ioWriter.writeUint64(duration);
    }
    else {
        ioWriter.writeUint32(Number(duration));
    }
    // language
    ioWriter.writeUint16(languge);
    // reserved (quality) 
    ioWriter.writeUint16(0);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/mfhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/mfhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 mfhd box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(16);
    // tag
    ioWriter.writeString("mfhd" /* BoxType.MFHD */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(movContext.currentFragment.sequence);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/minfHdlr.ts":
/*!******************************************************!*\
  !*** ./src/avformat/formats/mov/writing/minfHdlr.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var _hdlr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hdlr */ "./src/avformat/formats/mov/writing/hdlr.ts");
/*
 * libmedia mp4 hdlr box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    (0,_hdlr__WEBPACK_IMPORTED_MODULE_0__["default"])(ioWriter, null, movContext);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/mvhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/mvhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var _function_writeMatrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./function/writeMatrix */ "./src/avformat/formats/mov/writing/function/writeMatrix.ts");
/*
 * libmedia mp4 mvhd box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function write(ioWriter, stream, movContext) {
    const duration = movContext.duration;
    const creationTime = movContext.creationTime || 0;
    const modificationTime = movContext.modificationTime || 0;
    const timescale = movContext.timescale || 0;
    let nextTrackId = movContext.nextTrackId || 1;
    if (movContext.fragment) {
        nextTrackId = 2;
    }
    let version = duration < BigInt(avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX) ? 0 : 1;
    version = creationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    version = modificationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    // size
    ioWriter.writeUint32(version === 1 ? 120 : 108);
    // tag
    ioWriter.writeString("mvhd" /* BoxType.MVHD */);
    // version
    ioWriter.writeUint8(version);
    // flags
    ioWriter.writeUint24(0);
    if (version === 1) {
        ioWriter.writeUint64(creationTime);
        ioWriter.writeUint64(modificationTime);
    }
    else {
        ioWriter.writeUint32(Number(creationTime));
        ioWriter.writeUint32(Number(modificationTime));
    }
    // timescale
    ioWriter.writeUint32(timescale);
    if (version === 1) {
        ioWriter.writeUint64(duration);
    }
    else {
        ioWriter.writeUint32(Number(duration));
    }
    // reserved (preferred rate) 1.0 = normal
    ioWriter.writeUint32(0x00010000);
    // reserved (preferred volume) 1.0 = normal
    ioWriter.writeUint16(0x0100);
    // reserved
    ioWriter.writeUint16(0);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
    (0,_function_writeMatrix__WEBPACK_IMPORTED_MODULE_1__["default"])(ioWriter, 1, 0, 0, 1, 0, 0);
    // reserved (preview time)
    ioWriter.writeUint32(0);
    // reserved (preview duration)
    ioWriter.writeUint32(0);
    // reserved (poster time)
    ioWriter.writeUint32(0);
    // reserved (selection time)
    ioWriter.writeUint32(0);
    // reserved (selection time)
    ioWriter.writeUint32(0);
    // reserved (current time)
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(nextTrackId);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/pasp.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/pasp.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 pasp box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(16);
    // tag
    ioWriter.writeString("pasp" /* BoxType.PASP */);
    ioWriter.writeUint32(1);
    ioWriter.writeUint32(1);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/smhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/smhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 smhd box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(16);
    // tag
    ioWriter.writeString("smhd" /* BoxType.SMHD */);
    // version & flags
    ioWriter.writeUint32(0);
    // reserved (balance, normally = 0
    ioWriter.writeUint16(0);
    // reserved
    ioWriter.writeUint16(0);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stco.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stco.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 stco box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const context = stream.privData;
    const chunkOffsets = context.chunkOffsets || [];
    // size
    ioWriter.writeUint32(16 + chunkOffsets.length * 4);
    // tag
    ioWriter.writeString("stco" /* BoxType.STCO */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(chunkOffsets.length);
    for (let i = 0; i < chunkOffsets.length; i++) {
        ioWriter.writeUint32(Number(chunkOffsets[i]));
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stsc.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stsc.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avformat\\formats\\mov\\writing\\stsc.ts";

function write(ioWriter, stream, movContext) {
    const context = stream.privData;
    const firstChunk = context.stscFirstChunk;
    const samplesPerChunk = context.stscSamplesPerChunk;
    const sampleDescriptionIndex = context.stscSampleDescriptionIndex;
    if (firstChunk.length !== samplesPerChunk.length
        || firstChunk.length !== sampleDescriptionIndex.length) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('ctts firstChunk\'s length is not match samplesPerChunk\'s length or sampleDescriptionIndex\'s length', cheap__fileName__0, 42);
    }
    const entryCount = Math.min(firstChunk.length, samplesPerChunk.length, sampleDescriptionIndex.length);
    // size
    ioWriter.writeUint32(16 + entryCount * 12);
    // tag
    ioWriter.writeString("stsc" /* BoxType.STSC */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(entryCount);
    for (let i = 0; i < entryCount; i++) {
        ioWriter.writeUint32(firstChunk[i]);
        ioWriter.writeUint32(samplesPerChunk[i]);
        ioWriter.writeUint32(sampleDescriptionIndex[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stsd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stsd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var _avcc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./avcc */ "./src/avformat/formats/mov/writing/avcc.ts");
/* harmony import */ var _hvcc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hvcc */ "./src/avformat/formats/mov/writing/hvcc.ts");
/* harmony import */ var _vvcc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vvcc */ "./src/avformat/formats/mov/writing/vvcc.ts");
/* harmony import */ var _vpcc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vpcc */ "./src/avformat/formats/mov/writing/vpcc.ts");
/* harmony import */ var _av1c__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./av1c */ "./src/avformat/formats/mov/writing/av1c.ts");
/* harmony import */ var _dfla__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dfla */ "./src/avformat/formats/mov/writing/dfla.ts");
/* harmony import */ var _dops__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dops */ "./src/avformat/formats/mov/writing/dops.ts");
/* harmony import */ var _esds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./esds */ "./src/avformat/formats/mov/writing/esds.ts");
/* harmony import */ var _colr__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./colr */ "./src/avformat/formats/mov/writing/colr.ts");
/* harmony import */ var _pasp__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./pasp */ "./src/avformat/formats/mov/writing/pasp.ts");
/* harmony import */ var _btrt__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./btrt */ "./src/avformat/formats/mov/writing/btrt.ts");
/* harmony import */ var _wave__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./wave */ "./src/avformat/formats/mov/writing/wave.ts");
/* harmony import */ var _dac3__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./dac3 */ "./src/avformat/formats/mov/writing/dac3.ts");
/* harmony import */ var _dec3__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dec3 */ "./src/avformat/formats/mov/writing/dec3.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _function_digital2Tag__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../../function/digital2Tag */ "./src/avformat/function/digital2Tag.ts");
/*
 * libmedia mp4 stsd box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
















const AVCodecID2Tag = {
    [27 /* AVCodecID.AV_CODEC_ID_H264 */]: "avc1" /* BoxType.AVC1 */,
    [173 /* AVCodecID.AV_CODEC_ID_HEVC */]: "hvc1" /* BoxType.HVC1 */,
    [196 /* AVCodecID.AV_CODEC_ID_VVC */]: "vvc1" /* BoxType.VVC1 */,
    [225 /* AVCodecID.AV_CODEC_ID_AV1 */]: "av01" /* BoxType.AV01 */,
    [167 /* AVCodecID.AV_CODEC_ID_VP9 */]: "vp09" /* BoxType.VP09 */,
    [86019 /* AVCodecID.AV_CODEC_ID_AC3 */]: "ac-3" /* BoxType.AC_3 */,
    [86056 /* AVCodecID.AV_CODEC_ID_EAC3 */]: "ec-3" /* BoxType.EC_3 */,
};
function getTag(codecpar) {
    if (codecpar.codecTag) {
        return (0,_function_digital2Tag__WEBPACK_IMPORTED_MODULE_15__["default"])(codecpar.codecTag);
    }
    let tag = AVCodecID2Tag[codecpar.codecId];
    if (!tag) {
        if (codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
            tag = "mp4v" /* BoxType.MP4V */;
        }
        else if (codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
            if (codecpar.codecId === 86076 /* AVCodecID.AV_CODEC_ID_OPUS */) {
                tag = "Opus" /* BoxType.OPUS */;
            }
            else if (codecpar.codecId === 86028 /* AVCodecID.AV_CODEC_ID_FLAC */) {
                tag = "fLaC" /* BoxType.FLAC */;
            }
            else {
                tag = "mp4a" /* BoxType.MP4A */;
            }
        }
        else if (codecpar.codecType === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */) {
            tag = "text" /* BoxType.TEXT */;
        }
        else {
            tag = "none" /* BoxType.NONE */;
        }
    }
    return tag;
}
function writeAudioTag(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    const tag = getTag(stream.codecpar);
    const version = movContext.isom ? 1 : 0;
    // size
    ioWriter.writeUint32(0);
    ioWriter.writeString(tag);
    // Reserved
    ioWriter.writeUint32(0);
    // Reserved
    ioWriter.writeUint16(0);
    // Data-reference index
    ioWriter.writeUint16(1);
    // SoundDescription Version
    ioWriter.writeUint16(version);
    // SoundDescription Revision level
    ioWriter.writeUint16(0);
    // Reserved
    ioWriter.writeUint32(0);
    if (movContext.isom) {
        ioWriter.writeUint16(stream.codecpar.chLayout.nbChannels);
        if (stream.codecpar.codecId === 65541 /* AVCodecID.AV_CODEC_ID_PCM_U8 */
            || stream.codecpar.codecId === 65540 /* AVCodecID.AV_CODEC_ID_PCM_S8 */) {
            ioWriter.writeUint16(8);
        }
        else if (stream.codecpar.codecId === 69643 /* AVCodecID.AV_CODEC_ID_ADPCM_G726 */) {
            ioWriter.writeUint16(stream.codecpar.bitsPerCodedSample);
        }
        else {
            ioWriter.writeUint16(16);
        }
        ioWriter.writeUint16(-2);
    }
    else {
        if (stream.codecpar.codecId === 86028 /* AVCodecID.AV_CODEC_ID_FLAC */
            || stream.codecpar.codecId === 86032 /* AVCodecID.AV_CODEC_ID_ALAC */
            || stream.codecpar.codecId === 86076 /* AVCodecID.AV_CODEC_ID_OPUS */) {
            ioWriter.writeUint16(stream.codecpar.chLayout.nbChannels);
        }
        else {
            ioWriter.writeUint16(2);
        }
        if (stream.codecpar.codecId === 86028 /* AVCodecID.AV_CODEC_ID_FLAC */
            || stream.codecpar.codecId === 86032 /* AVCodecID.AV_CODEC_ID_ALAC */) {
            ioWriter.writeUint16(stream.codecpar.bitsPerCodedSample);
        }
        else {
            ioWriter.writeUint16(16);
        }
        ioWriter.writeUint16(0);
    }
    // packet size (= 0) 
    ioWriter.writeUint16(0);
    if (stream.codecpar.codecId === 86076 /* AVCodecID.AV_CODEC_ID_OPUS */) {
        ioWriter.writeUint16(48000);
    }
    else if (stream.codecpar.codecId === 86060 /* AVCodecID.AV_CODEC_ID_TRUEHD */) {
        ioWriter.writeUint32(stream.codecpar.sampleRate);
    }
    else {
        ioWriter.writeUint16(stream.codecpar.sampleRate);
    }
    if (stream.codecpar.codecId !== 86060 /* AVCodecID.AV_CODEC_ID_TRUEHD */) {
        // Reserved
        ioWriter.writeUint16(0);
    }
    // SoundDescription V1 extended info
    if (version === 1) {
        // Samples per packet
        ioWriter.writeUint32(stream.codecpar.frameSize);
        // Bytes per packet
        ioWriter.writeUint32(0);
        // Bytes per frame
        ioWriter.writeUint32(0);
        // Bytes per sample
        ioWriter.writeUint32(2);
    }
    if (movContext.isom
        && (stream.codecpar.codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */
            || stream.codecpar.codecId === 86019 /* AVCodecID.AV_CODEC_ID_AC3 */
            || stream.codecpar.codecId === 86056 /* AVCodecID.AV_CODEC_ID_EAC3 */
            || stream.codecpar.codecId === 73728 /* AVCodecID.AV_CODEC_ID_AMR_NB */
            || stream.codecpar.codecId === 86032 /* AVCodecID.AV_CODEC_ID_ALAC */
            || stream.codecpar.codecId === 69638 /* AVCodecID.AV_CODEC_ID_ADPCM_MS */
            || stream.codecpar.codecId === 69633 /* AVCodecID.AV_CODEC_ID_ADPCM_IMA_WAV */
            || stream.codecpar.codecId === 86035 /* AVCodecID.AV_CODEC_ID_QDM2 */)) {
        (0,_wave__WEBPACK_IMPORTED_MODULE_11__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 86028 /* AVCodecID.AV_CODEC_ID_FLAC */) {
        (0,_dfla__WEBPACK_IMPORTED_MODULE_5__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 86076 /* AVCodecID.AV_CODEC_ID_OPUS */) {
        (0,_dops__WEBPACK_IMPORTED_MODULE_6__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 86019 /* AVCodecID.AV_CODEC_ID_AC3 */) {
        (0,_dac3__WEBPACK_IMPORTED_MODULE_12__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 86056 /* AVCodecID.AV_CODEC_ID_EAC3 */) {
        (0,_dec3__WEBPACK_IMPORTED_MODULE_13__["default"])(ioWriter, stream, movContext);
    }
    else if (tag == "mp4a" /* BoxType.MP4A */) {
        (0,_esds__WEBPACK_IMPORTED_MODULE_7__["default"])(ioWriter, stream, movContext);
    }
    if (!movContext.isom) {
        (0,_btrt__WEBPACK_IMPORTED_MODULE_10__["default"])(ioWriter, stream, movContext);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: tag,
        size: Number(ioWriter.getPos() - pos)
    });
}
function writeVideoTag(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    const tag = getTag(stream.codecpar);
    const uncompressedYcbcr = ((stream.codecpar.codecId == 13 /* AVCodecID.AV_CODEC_ID_RAWVIDEO */
        && stream.codecpar.format == 15 /* AVPixelFormat.AV_PIX_FMT_UYVY422 */)
        || (stream.codecpar.codecId == 13 /* AVCodecID.AV_CODEC_ID_RAWVIDEO */
            && stream.codecpar.format == 1 /* AVPixelFormat.AV_PIX_FMT_YUYV422 */)
        || stream.codecpar.codecId == 202 /* AVCodecID.AV_CODEC_ID_V308 */
        || stream.codecpar.codecId == 203 /* AVCodecID.AV_CODEC_ID_V408 */
        || stream.codecpar.codecId == 156 /* AVCodecID.AV_CODEC_ID_V410 */
        || stream.codecpar.codecId == 127 /* AVCodecID.AV_CODEC_ID_V210 */);
    // size
    ioWriter.writeUint32(0);
    ioWriter.writeString(tag);
    // Reserved
    ioWriter.writeUint32(0);
    // Reserved
    ioWriter.writeUint16(0);
    // Data-reference index
    ioWriter.writeUint16(1);
    // Codec stream version
    ioWriter.writeUint16(uncompressedYcbcr ? 2 : 0);
    // Codec stream revision (=0)
    ioWriter.writeUint16(0);
    // Reserved
    if (movContext.isom) {
        ioWriter.writeString('FFMP');
        if (stream.codecpar.codecId === 13 /* AVCodecID.AV_CODEC_ID_RAWVIDEO */ || uncompressedYcbcr) {
            /* Temporal Quality */
            ioWriter.writeUint32(0);
            /* Spatial Quality = lossless*/
            ioWriter.writeUint32(0x400);
        }
        else {
            /* Temporal Quality = normal */
            ioWriter.writeUint32(0x200);
            /* Spatial Quality = normal */
            ioWriter.writeUint32(0x200);
        }
    }
    else {
        ioWriter.writeUint32(0);
        ioWriter.writeUint32(0);
        ioWriter.writeUint32(0);
    }
    ioWriter.writeUint16(stream.codecpar.width);
    ioWriter.writeUint16(stream.codecpar.height);
    // Horizontal resolution 72dpi
    ioWriter.writeUint32(0x00480000);
    // Vertical resolution 72dpi
    ioWriter.writeUint32(0x00480000);
    // Data size (= 0)
    ioWriter.writeUint32(0);
    // Frame count (= 1)
    ioWriter.writeUint16(1);
    let compressorName = (stream.metadata['compressorName'] || '');
    compressorName = compressorName.slice(0, 31);
    ioWriter.writeUint8(compressorName.length);
    ioWriter.writeString(compressorName);
    if (compressorName.length < 31) {
        let len = 31 - compressorName.length;
        while (len > 0) {
            ioWriter.writeUint8(0);
            len--;
        }
    }
    // Reserved
    if (movContext.isom && stream.codecpar.bitsPerCodedSample) {
        ioWriter.writeUint16(stream.codecpar.bitsPerCodedSample);
    }
    else {
        ioWriter.writeUint16(0x18);
    }
    ioWriter.writeUint16(0xffff);
    if (tag === "mp4v" /* BoxType.MP4V */) {
        (0,_esds__WEBPACK_IMPORTED_MODULE_7__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */) {
        (0,_avcc__WEBPACK_IMPORTED_MODULE_0__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */) {
        (0,_hvcc__WEBPACK_IMPORTED_MODULE_1__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 196 /* AVCodecID.AV_CODEC_ID_VVC */) {
        (0,_vvcc__WEBPACK_IMPORTED_MODULE_2__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 167 /* AVCodecID.AV_CODEC_ID_VP9 */) {
        (0,_vpcc__WEBPACK_IMPORTED_MODULE_3__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecId === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
        (0,_av1c__WEBPACK_IMPORTED_MODULE_4__["default"])(ioWriter, stream, movContext);
    }
    (0,_colr__WEBPACK_IMPORTED_MODULE_8__["default"])(ioWriter, stream, movContext);
    (0,_pasp__WEBPACK_IMPORTED_MODULE_9__["default"])(ioWriter, stream, movContext);
    if (!movContext.isom) {
        (0,_btrt__WEBPACK_IMPORTED_MODULE_10__["default"])(ioWriter, stream, movContext);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: tag,
        size: Number(ioWriter.getPos() - pos)
    });
}
function writeSubtitleTag(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    const tag = getTag(stream.codecpar);
    // size
    ioWriter.writeUint32(0);
    ioWriter.writeString(tag);
    // Reserved
    ioWriter.writeUint32(0);
    // Reserved
    ioWriter.writeUint16(0);
    // Data-reference index
    ioWriter.writeUint16(1);
    if (stream.codecpar.codecId === 94208 /* AVCodecID.AV_CODEC_ID_DVD_SUBTITLE */) {
        (0,_esds__WEBPACK_IMPORTED_MODULE_7__["default"])(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.extradata) {
        ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_14__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
    }
    if (!movContext.isom) {
        (0,_btrt__WEBPACK_IMPORTED_MODULE_10__["default"])(ioWriter, stream, movContext);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: tag,
        size: Number(ioWriter.getPos() - pos)
    });
}
function write(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("stsd" /* BoxType.STSD */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    // entry count
    ioWriter.writeUint32(1);
    if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
        writeAudioTag(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
        writeVideoTag(ioWriter, stream, movContext);
    }
    else if (stream.codecpar.codecType === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */) {
        writeSubtitleTag(ioWriter, stream, movContext);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: "esds" /* BoxType.ESDS */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stss.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stss.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 stss box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const sampleNumbers = stream.privData.stssSampleNumbers;
    // size
    ioWriter.writeUint32(16 + sampleNumbers.length * 4);
    // tag
    ioWriter.writeString("stss" /* BoxType.STSS */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(sampleNumbers.length);
    for (let i = 0; i < sampleNumbers.length; i++) {
        ioWriter.writeUint32(sampleNumbers[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stsz.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stsz.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 stsz box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const sampleSizes = stream.privData.sampleSizes;
    // size
    ioWriter.writeUint32(20 + sampleSizes.length * 4);
    // tag
    ioWriter.writeString("stsz" /* BoxType.STSZ */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(sampleSizes.length);
    for (let i = 0; i < sampleSizes.length; i++) {
        ioWriter.writeUint32(sampleSizes[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/stts.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/stts.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avformat\\formats\\mov\\writing\\stts.ts";

function write(ioWriter, stream, movContext) {
    const context = stream.privData;
    const sampleCounts = context.sttsSampleCounts || [];
    const sampleDeltas = context.sttsSampleDeltas || [];
    if (sampleCounts.length !== sampleDeltas.length) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('stts sampleCounts\'s length is not match sampleDeltas\'s length', cheap__fileName__0, 39);
    }
    const entryCount = Math.min(sampleCounts.length, sampleDeltas.length);
    // size
    ioWriter.writeUint32(16 + entryCount * 8);
    // tag
    ioWriter.writeString("stts" /* BoxType.STTS */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(entryCount);
    for (let i = 0; i < entryCount; i++) {
        ioWriter.writeUint32(sampleCounts[i]);
        ioWriter.writeInt32(sampleDeltas[i]);
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/tfdt.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/tfdt.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 tfdt box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const track = movContext.currentFragment.tracks.find((track) => {
        return track.trackId === stream.privData.trackId;
    });
    const baseMediaDecodeTime = track ? track.baseMediaDecodeTime : BigInt(0);
    // size
    ioWriter.writeUint32(20);
    // tag
    ioWriter.writeString("tfdt" /* BoxType.TFDT */);
    // version use int64
    ioWriter.writeUint8(1);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint64(baseMediaDecodeTime);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/tfhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/tfhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 tfhd box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const track = movContext.currentFragment.tracks.find((track) => {
        return track.trackId === stream.privData.trackId;
    });
    let flags = 1 /* TFHDFlags.BASE_DATA_OFFSET */
        | 8 /* TFHDFlags.SAMPLE_DURATION */
        | 16 /* TFHDFlags.SAMPLE_SIZE */
        | 32 /* TFHDFlags.SAMPLE_FLAGS */;
    if (track.baseIsMoof) {
        flags &= ~1 /* TFHDFlags.BASE_DATA_OFFSET */;
        flags |= 131072 /* TFHDFlags.DEFAULT_BASE_IS_MOOF */;
    }
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("tfhd" /* BoxType.TFHD */);
    // version use int64
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(flags);
    ioWriter.writeUint32(track.trackId);
    if (flags & 1 /* TFHDFlags.BASE_DATA_OFFSET */) {
        ioWriter.writeUint64(track.baseDataOffset);
    }
    if (flags & 8 /* TFHDFlags.SAMPLE_DURATION */) {
        ioWriter.writeUint32(track.defaultSampleDuration);
    }
    if (flags & 16 /* TFHDFlags.SAMPLE_SIZE */) {
        ioWriter.writeUint32(track.defaultSampleSize);
    }
    if (flags & 32 /* TFHDFlags.SAMPLE_FLAGS */) {
        ioWriter.writeUint32(track.defaultSampleFlags);
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: "tfhd" /* BoxType.TFHD */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/tkhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/tkhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var _function_writeMatrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./function/writeMatrix */ "./src/avformat/formats/mov/writing/function/writeMatrix.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/*
 * libmedia mp4 tkhd box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function write(ioWriter, stream, movContext) {
    const streamContext = stream.privData;
    const duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(streamContext.lastPts, stream.timeBase, {
        den: movContext.timescale,
        num: 1
    });
    const creationTime = stream.metadata['creationTime'] || 0;
    const modificationTime = stream.metadata['modificationTime'] || 0;
    const layer = streamContext.layer || 0;
    const alternateGroup = streamContext.alternateGroup || 0;
    let width = stream.codecpar.width > 0 ? stream.codecpar.width : 0;
    let height = stream.codecpar.height > 0 ? stream.codecpar.height : 0;
    if (width < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT16_MAX) {
        width = width << 16;
    }
    if (height < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT16_MAX) {
        height = height << 16;
    }
    let version = duration < BigInt(avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX) ? 0 : 1;
    version = creationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    version = modificationTime < avutil_constant__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX ? 0 : 1;
    let flags = 2 /* TKHDFlags.IN_MOVIE */;
    if (streamContext.flags & 1 /* TKHDFlags.ENABLED */) {
        flags |= 1 /* TKHDFlags.ENABLED */;
    }
    // size
    ioWriter.writeUint32(version === 1 ? 100 : 92);
    // tag
    ioWriter.writeString("tkhd" /* BoxType.TKHD */);
    // version
    ioWriter.writeUint8(version);
    // flags
    ioWriter.writeUint24(flags);
    if (version === 1) {
        ioWriter.writeUint64(creationTime);
        ioWriter.writeUint64(modificationTime);
    }
    else {
        ioWriter.writeUint32(Number(creationTime));
        ioWriter.writeUint32(Number(modificationTime));
    }
    // trackId
    ioWriter.writeUint32(streamContext.trackId);
    // reserved
    ioWriter.writeUint32(0);
    if (version === 1) {
        ioWriter.writeUint64(duration);
    }
    else {
        ioWriter.writeUint32(Number(duration));
    }
    // reserved
    ioWriter.writeUint32(0);
    ioWriter.writeUint32(0);
    ioWriter.writeInt16(layer);
    ioWriter.writeInt16(streamContext.perStreamGrouping ? alternateGroup : stream.codecpar.codecType);
    if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
        ioWriter.writeInt16(0x0100);
    }
    else {
        ioWriter.writeInt16(0);
    }
    // reserved
    ioWriter.writeInt16(0);
    (0,_function_writeMatrix__WEBPACK_IMPORTED_MODULE_1__["default"])(ioWriter, 1, 0, 0, 1, 0, 0);
    ioWriter.writeUint32(width);
    ioWriter.writeUint32(height);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/trex.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/trex.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 trex box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const track = movContext.currentFragment.tracks.find((track) => {
        return track.trackId === stream.privData.trackId;
    });
    const trex = movContext.trexs.find((trex) => {
        trex.trackId === stream.privData.trackId;
    });
    const duration = trex?.duration ?? 0;
    const size = trex?.size ?? 0;
    const flags = trex?.flags ?? 0;
    // size
    ioWriter.writeUint32(32);
    // tag
    ioWriter.writeString("trex" /* BoxType.TREX */);
    // version use int64
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    ioWriter.writeUint32(track.trackId);
    // default_sample_description_index
    ioWriter.writeUint32(1);
    ioWriter.writeUint32(duration);
    ioWriter.writeUint32(size);
    ioWriter.writeUint32(flags);
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/trun.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/trun.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 trun box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    const streamContext = stream.privData;
    const track = movContext.currentFragment.tracks.find((track) => {
        return track.trackId === streamContext.trackId;
    });
    const firstSampleFlags = track.firstSampleFlags || 0;
    const dataOffset = track.dataOffset || 0;
    const sampleDurations = track.sampleDurations;
    const sampleSizes = track.sampleSizes;
    const sampleFlags = track.sampleFlags;
    const sampleCompositionTimeOffset = track.sampleCompositionTimeOffset;
    const sampleCount = track.sampleCount;
    const hasSampleDurations = sampleDurations.length > 0;
    const hasSampleSizes = sampleSizes.length > 0;
    const hasSampleFlags = sampleFlags.length > 0;
    const hasSampleCompositionTimeOffset = sampleCompositionTimeOffset.length > 0;
    const hasFirstFlag = firstSampleFlags !== 0;
    let flags = 1 /* TRUNFlags.DATA_OFFSET */;
    if (hasFirstFlag) {
        flags |= 4 /* TRUNFlags.FIRST_FLAG */;
    }
    if (hasSampleDurations) {
        flags |= 256 /* TRUNFlags.DURATION */;
    }
    if (hasSampleSizes) {
        flags |= 512 /* TRUNFlags.SIZE */;
    }
    if (hasSampleFlags) {
        flags |= 1024 /* TRUNFlags.FLAGS */;
    }
    if (hasSampleCompositionTimeOffset) {
        flags |= 2048 /* TRUNFlags.CTS_OFFSET */;
    }
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("trun" /* BoxType.TRUN */);
    // version use int32
    ioWriter.writeUint8(1);
    // flags
    ioWriter.writeUint24(flags);
    ioWriter.writeUint32(sampleCount);
    track.dataOffsetPos = ioWriter.getPos();
    ioWriter.writeInt32(dataOffset);
    if (hasFirstFlag) {
        ioWriter.writeUint32(firstSampleFlags);
    }
    for (let i = 0; i < sampleCount; i++) {
        if (hasSampleDurations) {
            ioWriter.writeUint32(sampleDurations[i] || 0);
        }
        if (hasSampleSizes) {
            ioWriter.writeUint32(sampleSizes[i] || 0);
        }
        if (hasSampleFlags) {
            ioWriter.writeUint32(sampleFlags[i] || 0);
        }
        if (hasSampleCompositionTimeOffset) {
            ioWriter.writeInt32(sampleCompositionTimeOffset[i] || 0);
        }
    }
    movContext.boxsPositionInfo.push({
        pos,
        type: "trun" /* BoxType.TRUN */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/vmhd.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/vmhd.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/*
 * libmedia mp4 vmhd box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(20);
    // tag
    ioWriter.writeString("vmhd" /* BoxType.VMHD */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(1);
    // reserved (graphics mode = copy)
    ioWriter.writeUint64(BigInt(0));
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/vpcc.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/vpcc.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 vpcc box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(12 + stream.codecpar.extradataSize ?? 0);
    // tag
    ioWriter.writeString("vpcC" /* BoxType.VPCC */);
    // version
    ioWriter.writeUint8(1);
    // flags
    ioWriter.writeUint24(0);
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
        }
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/vvcc.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/vvcc.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/*
 * libmedia mp4 vvcc box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function write(ioWriter, stream, movContext) {
    // size
    ioWriter.writeUint32(8 + stream.codecpar.extradataSize ?? 0);
    // tag
    ioWriter.writeString("vvcC" /* BoxType.VVCC */);
    // version
    ioWriter.writeUint8(0);
    // flags
    ioWriter.writeUint24(0);
    if (movContext.fragment) {
        if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
            ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
            delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    else {
        if (stream.codecpar.extradata) {
            ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
        }
    }
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/wave.ts":
/*!**************************************************!*\
  !*** ./src/avformat/formats/mov/writing/wave.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _esds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./esds */ "./src/avformat/formats/mov/writing/esds.ts");
/*
 * libmedia mp4 wave box write
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function write(ioWriter, stream, movContext) {
    const pos = ioWriter.getPos();
    // size
    ioWriter.writeUint32(0);
    // tag
    ioWriter.writeString("wave" /* BoxType.WAVE */);
    if (stream.codecpar.codecId !== 86035 /* AVCodecID.AV_CODEC_ID_QDM2 */) {
        ioWriter.writeUint32(12);
        ioWriter.writeString("frma" /* BoxType.FRMA */);
        ioWriter.writeUint32(stream.codecpar.codecTag);
    }
    if (stream.codecpar.codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */) {
        // seless atom needed by mplayer, ipod, not needed by quicktime
        ioWriter.writeUint32(12);
        ioWriter.writeString("mp4a" /* BoxType.MP4A */);
        ioWriter.writeUint32(0);
        (0,_esds__WEBPACK_IMPORTED_MODULE_1__["default"])(ioWriter, stream, movContext);
    }
    else {
        if (movContext.fragment) {
            if (stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
                ioWriter.writeBuffer(stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]);
                delete stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
            }
            else {
                if (stream.codecpar.extradata) {
                    ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
                }
            }
        }
        else {
            if (stream.codecpar.extradata) {
                ioWriter.writeBuffer((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(stream.codecpar.extradata, stream.codecpar.extradataSize));
            }
        }
    }
    // null tag
    ioWriter.writeUint32(8);
    ioWriter.writeUint32(0);
    movContext.boxsPositionInfo.push({
        pos,
        type: "wave" /* BoxType.WAVE */,
        size: Number(ioWriter.getPos() - pos)
    });
}


/***/ }),

/***/ "./src/avformat/formats/mov/writing/writers.ts":
/*!*****************************************************!*\
  !*** ./src/avformat/formats/mov/writing/writers.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stts */ "./src/avformat/formats/mov/writing/stts.ts");
/* harmony import */ var _ctts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ctts */ "./src/avformat/formats/mov/writing/ctts.ts");
/* harmony import */ var _stss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stss */ "./src/avformat/formats/mov/writing/stss.ts");
/* harmony import */ var _stsz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stsz */ "./src/avformat/formats/mov/writing/stsz.ts");
/* harmony import */ var _stsc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stsc */ "./src/avformat/formats/mov/writing/stsc.ts");
/* harmony import */ var _stco__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./stco */ "./src/avformat/formats/mov/writing/stco.ts");
/* harmony import */ var _co64__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./co64 */ "./src/avformat/formats/mov/writing/co64.ts");
/* harmony import */ var _mdhd__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mdhd */ "./src/avformat/formats/mov/writing/mdhd.ts");
/* harmony import */ var _mvhd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mvhd */ "./src/avformat/formats/mov/writing/mvhd.ts");
/* harmony import */ var _tkhd__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tkhd */ "./src/avformat/formats/mov/writing/tkhd.ts");
/* harmony import */ var _hdlr__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./hdlr */ "./src/avformat/formats/mov/writing/hdlr.ts");
/* harmony import */ var _stsd__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./stsd */ "./src/avformat/formats/mov/writing/stsd.ts");
/* harmony import */ var _vmhd__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./vmhd */ "./src/avformat/formats/mov/writing/vmhd.ts");
/* harmony import */ var _edts__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./edts */ "./src/avformat/formats/mov/writing/edts.ts");
/* harmony import */ var _smhd__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./smhd */ "./src/avformat/formats/mov/writing/smhd.ts");
/* harmony import */ var _dref__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./dref */ "./src/avformat/formats/mov/writing/dref.ts");
/* harmony import */ var _trex__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./trex */ "./src/avformat/formats/mov/writing/trex.ts");
/* harmony import */ var _mfhd__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./mfhd */ "./src/avformat/formats/mov/writing/mfhd.ts");
/* harmony import */ var _tfhd__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./tfhd */ "./src/avformat/formats/mov/writing/tfhd.ts");
/* harmony import */ var _tfdt__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./tfdt */ "./src/avformat/formats/mov/writing/tfdt.ts");
/* harmony import */ var _trun__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./trun */ "./src/avformat/formats/mov/writing/trun.ts");
/* harmony import */ var _minfHdlr__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./minfHdlr */ "./src/avformat/formats/mov/writing/minfHdlr.ts");
/*
 * libmedia mp4 box writers
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */






















const writers = {
    ["stts" /* BoxType.STTS */]: _stts__WEBPACK_IMPORTED_MODULE_0__["default"],
    ["ctts" /* BoxType.CTTS */]: _ctts__WEBPACK_IMPORTED_MODULE_1__["default"],
    ["stss" /* BoxType.STSS */]: _stss__WEBPACK_IMPORTED_MODULE_2__["default"],
    ["stsz" /* BoxType.STSZ */]: _stsz__WEBPACK_IMPORTED_MODULE_3__["default"],
    ["stsc" /* BoxType.STSC */]: _stsc__WEBPACK_IMPORTED_MODULE_4__["default"],
    ["stco" /* BoxType.STCO */]: _stco__WEBPACK_IMPORTED_MODULE_5__["default"],
    ["co64" /* BoxType.CO64 */]: _co64__WEBPACK_IMPORTED_MODULE_6__["default"],
    ["mdhd" /* BoxType.MDHD */]: _mdhd__WEBPACK_IMPORTED_MODULE_7__["default"],
    ["mvhd" /* BoxType.MVHD */]: _mvhd__WEBPACK_IMPORTED_MODULE_8__["default"],
    ["tkhd" /* BoxType.TKHD */]: _tkhd__WEBPACK_IMPORTED_MODULE_9__["default"],
    ["hdlr" /* BoxType.HDLR */]: _hdlr__WEBPACK_IMPORTED_MODULE_10__["default"],
    ["stsd" /* BoxType.STSD */]: _stsd__WEBPACK_IMPORTED_MODULE_11__["default"],
    ["vmhd" /* BoxType.VMHD */]: _vmhd__WEBPACK_IMPORTED_MODULE_12__["default"],
    ["edts" /* BoxType.EDTS */]: _edts__WEBPACK_IMPORTED_MODULE_13__["default"],
    ["smhd" /* BoxType.SMHD */]: _smhd__WEBPACK_IMPORTED_MODULE_14__["default"],
    ["dref" /* BoxType.DREF */]: _dref__WEBPACK_IMPORTED_MODULE_15__["default"],
    ["trex" /* BoxType.TREX */]: _trex__WEBPACK_IMPORTED_MODULE_16__["default"],
    ["mfhd" /* BoxType.MFHD */]: _mfhd__WEBPACK_IMPORTED_MODULE_17__["default"],
    ["tfhd" /* BoxType.TFHD */]: _tfhd__WEBPACK_IMPORTED_MODULE_18__["default"],
    ["tfdt" /* BoxType.TFDT */]: _tfdt__WEBPACK_IMPORTED_MODULE_19__["default"],
    ["trun" /* BoxType.TRUN */]: _trun__WEBPACK_IMPORTED_MODULE_20__["default"],
    ["minf_hdlr" /* BoxType.MINF_HDLR */]: _minfHdlr__WEBPACK_IMPORTED_MODULE_21__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (writers);


/***/ }),

/***/ "./src/avformat/formats/ttml/ittml.ts":
/*!********************************************!*\
  !*** ./src/avformat/formats/ttml/ittml.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parse: () => (/* binding */ parse)
/* harmony export */ });
/* harmony import */ var common_util_xml2Json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/xml2Json */ "./src/common/util/xml2Json.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_util_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/time */ "./src/common/util/time.ts");




function parse(text) {
    const xml = (0,common_util_xml2Json__WEBPACK_IMPORTED_MODULE_0__["default"])(text, {
        aloneValueName: 'context'
    });
    if (!xml.tt) {
        return {
            queue: [],
            head: {}
        };
    }
    const queue = [];
    function formatContext(list) {
        let context = '';
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(list, ((c) => {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.string(c)) {
                context += c;
            }
            else {
                if (c.context) {
                    context += `<${c.tagName}>${c.context}</${c.tagName}>`;
                }
                else {
                    context += `<${c.tagName}/>`;
                }
            }
        }));
        return context;
    }
    function add(p, start, end) {
        const pts = (0,common_util_time__WEBPACK_IMPORTED_MODULE_3__.hhColonDDColonSSDotMill2Int64)(start || p.begin);
        let context = p.context || '';
        let region = p.region || 'Default';
        if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.array(context)) {
            context = formatContext(context);
        }
        if (p.span?.context) {
            if (p.span.region) {
                region = p.span.region;
            }
            if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.string(p.span.context)) {
                context += p.span.context;
            }
            else {
                context += formatContext(p.span.context);
            }
        }
        queue.push({
            context,
            pts,
            region: region,
            duration: p.dur ? (0,common_util_time__WEBPACK_IMPORTED_MODULE_3__.hhColonDDColonSSDotMill2Int64)(p.dur) : ((0,common_util_time__WEBPACK_IMPORTED_MODULE_3__.hhColonDDColonSSDotMill2Int64)(end || p.end) - pts),
        });
    }
    function praseP(p, start, end) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.array(p)) {
            common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(p, (_) => {
                add(_, start, end);
            });
        }
        else {
            add(p, start, end);
        }
    }
    if (xml.tt.body) {
        if (xml.tt.body.div) {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.array(xml.tt.body.div)) {
                common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(xml.tt.body.div, (div) => {
                    if (div.p) {
                        praseP(div.p, div.begin, div.end);
                    }
                });
            }
            else {
                if (xml.tt.body.div.p) {
                    praseP(xml.tt.body.div.p, xml.tt.body.div.begin, xml.tt.body.end);
                }
            }
        }
    }
    return {
        queue,
        head: xml.tt.head || {}
    };
}


/***/ }),

/***/ "./src/avformat/function/arrayItemSame.ts":
/*!************************************************!*\
  !*** ./src/avformat/function/arrayItemSame.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ arrayItemSame)
/* harmony export */ });
/*
 * libmedia array item is all same
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function arrayItemSame(data, start = 0) {
    if (!data) {
        return false;
    }
    if (data.length < 2) {
        return true;
    }
    let first = data[start];
    let i = start + 1;
    for (; i < data.length; i++) {
        if (first !== data[i]) {
            break;
        }
    }
    return i === data.length;
}


/***/ }),

/***/ "./src/avformat/function/checkStreamParameters.ts":
/*!********************************************************!*\
  !*** ./src/avformat/function/checkStreamParameters.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkStreamParameters: () => (/* binding */ checkStreamParameters)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/*
 * libmedia check stream parameters
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function checkStreamParameters(context) {
    let result = true;
    common_util_array__WEBPACK_IMPORTED_MODULE_1__.each(context.streams, (stream) => {
        switch (stream.codecpar.codecType) {
            case 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */:
                if (stream.codecpar.chLayout.nbChannels === avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE
                    || stream.codecpar.sampleRate === avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE
                    || stream.codecpar.frameSize === avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE
                    || stream.codecpar.bitrate === BigInt(0)) {
                    result = false;
                }
                break;
            case 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */:
                if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avQ2D)(stream.codecpar.framerate) === 0
                    || stream.codecpar.width === avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE
                    || stream.codecpar.height === avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE
                    || stream.codecpar.bitrate === BigInt(0)) {
                    result = false;
                }
                if ((stream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */
                    || stream.codecpar.codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                    || stream.codecpar.codecId === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                    || stream.codecpar.codecId === 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */)
                    && (stream.codecpar.profile === avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE
                        || stream.codecpar.level === avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE)) {
                    result = false;
                }
                break;
        }
    });
    return result;
}


/***/ }),

/***/ "./src/avformat/function/digital2Tag.ts":
/*!**********************************************!*\
  !*** ./src/avformat/function/digital2Tag.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ digital2Tag)
/* harmony export */ });
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/*
 * libmedia number to tag string
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function digital2Tag(value, len = 4) {
    let tag = '';
    for (let i = 0; i < len; i++) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.number(value)) {
            tag = String.fromCharCode(value & 0xff) + tag;
            value >>>= 8;
        }
        else {
            tag = String.fromCharCode(Number(value & BigInt(0xff))) + tag;
            value >>= BigInt(8);
        }
    }
    return tag;
}


/***/ }),

/***/ "./src/avformat/function/mktag.ts":
/*!****************************************!*\
  !*** ./src/avformat/function/mktag.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mktag)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avformat\\function\\mktag.ts";
/*
 * libmedia string tag to uint32 in big end
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function mktag(tag) {
    if (tag.length !== 4) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.warn(`tag length is not 4, tag: ${tag}`, cheap__fileName__0, 30);
    }
    let value = 0;
    for (let i = 0; i < 4; i++) {
        value = (value << 8) | tag.charCodeAt(i);
    }
    return value;
}


/***/ }),

/***/ "./src/avformat/function/rewriteIO.ts":
/*!********************************************!*\
  !*** ./src/avformat/function/rewriteIO.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rewriteIO)
/* harmony export */ });
/*
 * libmedia rewrite value with pos
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function rewriteIO(ioWriter, pos, value, type) {
    const nowPos = ioWriter.getPos();
    const pointer = ioWriter.getPointer();
    const minPos = nowPos - BigInt(Math.floor(pointer));
    let inline = false;
    if (pos < nowPos && pos >= minPos) {
        ioWriter.seekInline(pointer + Number(pos - nowPos));
        inline = true;
    }
    else {
        ioWriter.seek(pos);
    }
    switch (type) {
        case 'uint8':
            ioWriter.writeUint8((value & 0xff));
            break;
        case 'int8':
            ioWriter.writeInt8(value);
            break;
        case 'uint16':
            ioWriter.writeUint16((value & 0xffff));
            break;
        case 'int16':
            ioWriter.writeInt16(value);
            break;
        case 'uint32':
            ioWriter.writeUint32((value >>> 0));
            break;
        case 'int32':
            ioWriter.writeInt32(value);
            break;
        case 'uint64':
            ioWriter.writeUint64(BigInt.asUintN(64, value));
            break;
        case 'int64':
            ioWriter.writeInt64(value);
            break;
        case 'float':
            ioWriter.writeFloat(value);
            break;
        case 'double':
            ioWriter.writeDouble(value);
            break;
    }
    if (inline) {
        ioWriter.seekInline(pointer);
    }
    else {
        ioWriter.seek(nowPos);
    }
}


/***/ }),

/***/ "./src/avformat/mux.ts":
/*!*****************************!*\
  !*** ./src/avformat/mux.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   flush: () => (/* binding */ flush),
/* harmony export */   open: () => (/* binding */ open),
/* harmony export */   writeAVPacket: () => (/* binding */ writeAVPacket),
/* harmony export */   writeHeader: () => (/* binding */ writeHeader),
/* harmony export */   writeTrailer: () => (/* binding */ writeTrailer)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _formats_OFormat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formats/OFormat */ "./src/avformat/formats/OFormat.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var _dump__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dump */ "./src/avformat/dump.ts");
var cheap__fileName__0 = "src\\avformat\\mux.ts";








const defaultMuxOptions = {
    paddingZero: false
};
function open(formatContext, options = {}) {
    const opts = common_util_object__WEBPACK_IMPORTED_MODULE_2__.extend({}, defaultMuxOptions, options);
    if (!formatContext.ioWriter) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_3__.fatal('need ioWriter', cheap__fileName__0, 52);
    }
    if (!formatContext.oformat) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_3__.fatal('need oformat', cheap__fileName__0, 55);
    }
    formatContext.options = opts;
    formatContext.processPrivateData = {
        first: new Map()
    };
    let supportCodecs = _formats_OFormat__WEBPACK_IMPORTED_MODULE_4__.OFormatSupportedCodecs[formatContext.oformat.type];
    if (supportCodecs) {
        for (let i = 0; i < formatContext.streams.length; i++) {
            const codecId = formatContext.streams[i].codecpar.codecId;
            if (formatContext.oformat.type === 14 /* AVFormat.WAV */) {
                if (codecId < 65536 /* AVCodecID.AV_CODEC_ID_PCM_S16LE */
                    || codecId > 69683 /* AVCodecID.AV_CODEC_ID_ADPCM_XMD */) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_3__.error(`format ${(0,_dump__WEBPACK_IMPORTED_MODULE_7__.dumpFormatName)(formatContext.oformat.type)} not support codecId ${(0,_dump__WEBPACK_IMPORTED_MODULE_7__.dumpCodecName)(formatContext.streams[i].codecpar.codecType, codecId)}`, cheap__fileName__0, 71);
                    return avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT;
                }
            }
            else if (!common_util_array__WEBPACK_IMPORTED_MODULE_5__.has(supportCodecs, codecId)) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_3__.error(`format ${(0,_dump__WEBPACK_IMPORTED_MODULE_7__.dumpFormatName)(formatContext.oformat.type)} not support codecId ${(0,_dump__WEBPACK_IMPORTED_MODULE_7__.dumpCodecName)(formatContext.streams[i].codecpar.codecType, codecId)}`, cheap__fileName__0, 76);
                return avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT;
            }
        }
    }
    return formatContext.oformat.init(formatContext);
}
function writeHeader(formatContext) {
    formatContext.oformat.writeHeader(formatContext);
    return 0;
}
function writeAVPacket(formatContext, avpacket) {
    const privateData = formatContext.processPrivateData;
    if (!privateData.first.has(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 32))) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16) > BigInt(0)) {
            privateData.first.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 32), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16));
        }
        else {
            privateData.first.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 32), BigInt(0));
        }
    }
    if (formatContext.options.paddingZero) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avpacket + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16) - privateData.first.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 32)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avpacket + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8) - privateData.first.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 32)));
    }
    return formatContext.oformat.writeAVPacket(formatContext, avpacket);
}
function writeTrailer(formatContext) {
    formatContext.oformat.writeTrailer(formatContext);
    return 0;
}
function flush(formatContext) {
    formatContext.oformat.flush(formatContext);
}


/***/ }),

/***/ "./src/avnetwork/ioLoader/CustomIOLoader.ts":
/*!**************************************************!*\
  !*** ./src/avnetwork/ioLoader/CustomIOLoader.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CustomIOLoader)
/* harmony export */ });
/*
 * libmedia custom loader
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class CustomIOLoader {
    constructor() {
    }
    /**
     * 
     */
    get ext() {
        throw new Error('need implemented ext getter');
    }
    /**
     * 
     */
    get name() {
        return 'CustomIOLoader.' + Math.random();
    }
    /**
     *  4
     *
     *  jitter buffer 
     */
    get minBuffer() {
        return 4;
    }
}


/***/ }),

/***/ "./src/avnetwork/ioLoader/FetchIOLoader.ts":
/*!*************************************************!*\
  !*** ./src/avnetwork/ioLoader/FetchIOLoader.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FetchIOLoader)
/* harmony export */ });
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var _IOLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IOLoader */ "./src/avnetwork/ioLoader/IOLoader.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
var cheap__fileName__0 = "src\\avnetwork\\ioLoader\\FetchIOLoader.ts";
/*
 * libmedia fetch loader
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





class FetchIOLoader extends _IOLoader__WEBPACK_IMPORTED_MODULE_1__["default"] {
    contentLength;
    receivedLength;
    info;
    range;
    startBytes;
    endBytes;
    eofIndex;
    abortController;
    reader;
    buffers;
    constructor(options = {}) {
        super(options);
    }
    async open(info, range) {
        this.info = info;
        this.range = range;
        if (!this.range.to) {
            this.range.to = -1;
        }
        this.range.from = Math.max(this.range.from, 0);
        if (this.eofIndex < 0) {
            this.eofIndex = range.to;
        }
        this.startBytes = 0;
        this.endBytes = -1;
        this.receivedLength = 0;
        this.buffers = [];
        if (this.range && !this.options.isLive) {
            this.startBytes = this.range.from ?? 0;
        }
        this.status = 1 /* IOLoaderStatus.CONNECTING */;
        if (!this.options.isLive && !this.options.disableSegment) {
            const params = {
                method: 'HEAD',
                headers: {},
                mode: 'cors',
                cache: 'default',
                referrerPolicy: 'no-referrer-when-downgrade'
            };
            if (this.info.headers) {
                common_util_object__WEBPACK_IMPORTED_MODULE_2__.each(this.info.headers, (value, key) => {
                    params.headers[key] = value;
                });
            }
            if (this.info.withCredentials) {
                params.credentials = 'include';
            }
            if (this.info.referrerPolicy) {
                params.referrerPolicy = this.info.referrerPolicy;
            }
            if (AbortController) {
                this.abortController = new AbortController();
                params.signal = this.abortController.signal;
            }
            try {
                const res = await fetch(this.info.url, params);
                if (res.ok && (res.status >= 200 && res.status <= 299)) {
                    const lengthHeader = res.headers.get('X-Content-Length') || res.headers.get('Content-Length');
                    if (lengthHeader != null) {
                        this.contentLength = parseInt(lengthHeader);
                        if (this.range.to < 0) {
                            this.eofIndex = this.contentLength + this.range.to;
                        }
                    }
                    this.endBytes = Math.min(this.startBytes + this.options.preload - 1, this.eofIndex);
                    this.status = 2 /* IOLoaderStatus.BUFFERING */;
                }
                else {
                    this.endBytes = -1;
                }
            }
            catch (error) {
                this.endBytes = -1;
            }
        }
        return 0;
    }
    async openReader() {
        const params = {
            method: 'GET',
            headers: {},
            mode: 'cors',
            cache: 'default',
            referrerPolicy: 'no-referrer-when-downgrade'
        };
        if (this.info.headers) {
            common_util_object__WEBPACK_IMPORTED_MODULE_2__.each(this.info.headers, (value, key) => {
                params.headers[key] = value;
            });
        }
        if (!this.options.isLive && !this.options.disableSegment) {
            params.headers['range'] = `bytes=${this.startBytes}-${this.endBytes > 0 ? this.endBytes : ''}`;
        }
        if (this.info.withCredentials) {
            params.credentials = 'include';
        }
        if (this.info.referrerPolicy) {
            params.referrerPolicy = this.info.referrerPolicy;
        }
        if (this.abortController) {
            this.abortController.abort();
        }
        if (typeof AbortController === 'function') {
            this.abortController = new AbortController();
            params.signal = this.abortController.signal;
        }
        try {
            const res = await fetch(this.info.url, params);
            if (res.ok && (res.status >= 200 && res.status <= 299)) {
                this.reader = res.body.getReader();
            }
            else {
                this.status = 3 /* IOLoaderStatus.ERROR */;
                common_util_logger__WEBPACK_IMPORTED_MODULE_3__.fatal(`FetchStreamLoader: Http code invalid, ${res.status} ${res.statusText}`, cheap__fileName__0, 192);
            }
        }
        catch (error) {
            if (this.retryCount < this.options.retryCount && (!this.options.isLive || !this.receivedLength)) {
                this.retryCount++;
                this.status = 1 /* IOLoaderStatus.CONNECTING */;
                await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_0__["default"](this.options.retryInterval);
                return this.openReader();
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_3__.fatal(`FetchStreamLoader: exception ${error.message}`, cheap__fileName__0, 205);
            }
        }
    }
    async readInterval(buffer, preLen = 0) {
        let pos = 0;
        while (this.buffers.length && pos < buffer.length) {
            const cache = this.buffers.shift();
            if (cache.length > buffer.length - pos) {
                buffer.set(cache.subarray(0, buffer.length - pos), pos);
                this.buffers.unshift(cache.subarray(buffer.length - pos));
                pos = buffer.length;
            }
            else {
                buffer.set(cache, pos);
                pos += cache.length;
            }
        }
        if (pos >= buffer.length) {
            return buffer.length + preLen;
        }
        if (this.status === 4 /* IOLoaderStatus.COMPLETE */) {
            return pos > 0 ? (pos + preLen) : (preLen > 0 ? preLen : -1048576 /* IOError.END */);
        }
        if (!this.reader) {
            await this.openReader();
        }
        const { value, done } = await this.reader.read();
        if (done) {
            if (this.contentLength !== null && (this.receivedLength + this.range.from) < this.endBytes + 1) {
                this.status = 3 /* IOLoaderStatus.ERROR */;
                common_util_logger__WEBPACK_IMPORTED_MODULE_3__.fatal('Fetch stream meet Early-EOF', cheap__fileName__0, 244);
            }
            else if (this.options.isLive || this.options.disableSegment || (this.receivedLength + this.range.from) >= this.eofIndex) {
                this.status = 4 /* IOLoaderStatus.COMPLETE */;
                this.startBytes = 0;
                return pos > 0 ? (pos + preLen) : (preLen > 0 ? preLen : -1048576 /* IOError.END */);
            }
            else {
                await this.reader.cancel();
                if (this.abortController) {
                    this.abortController.abort();
                }
                this.reader = null;
                this.startBytes = this.endBytes + 1;
                this.endBytes = Math.min(this.startBytes + this.options.preload - 1, this.eofIndex);
                return this.readInterval(buffer.subarray(pos), pos);
            }
        }
        else {
            this.receivedLength += value.length;
            if (value.length > buffer.length - pos) {
                buffer.set(value.subarray(0, buffer.length - pos), pos);
                this.buffers.push(value.subarray(buffer.length - pos));
                return buffer.length + preLen;
            }
            else {
                buffer.set(value, pos);
                pos += value.length;
                return pos + preLen;
            }
        }
    }
    async read(buffer) {
        return this.readInterval(buffer);
    }
    async seek(pos) {
        if (!this.contentLength) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_4__.OPERATE_NOT_SUPPORT;
        }
        await this.abort();
        this.receivedLength = Number(pos) - this.range.from;
        this.startBytes = Number(pos);
        if (!this.options.disableSegment) {
            this.endBytes = Math.min(this.startBytes + this.options.preload, this.eofIndex);
        }
        this.buffers.length = 0;
        if (this.status === 4 /* IOLoaderStatus.COMPLETE */) {
            this.status = 2 /* IOLoaderStatus.BUFFERING */;
        }
        return 0;
    }
    async size() {
        if (this.options.isLive) {
            return BigInt(0);
        }
        return BigInt(Math.floor(this.contentLength || 0));
    }
    async abort() {
        if (!this.reader) {
            return;
        }
        await this.reader.cancel();
        if (this.abortController) {
            this.abortController.abort();
        }
        this.reader = null;
    }
    async stop() {
        await this.abort();
        this.status = 0 /* IOLoaderStatus.IDLE */;
    }
}


/***/ }),

/***/ "./src/avnetwork/ioLoader/FileIOLoader.ts":
/*!************************************************!*\
  !*** ./src/avnetwork/ioLoader/FileIOLoader.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FileIOLoader)
/* harmony export */ });
/* harmony import */ var _IOLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IOLoader */ "./src/avnetwork/ioLoader/IOLoader.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/*
 * libmedia file loader
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


const hasArrayBuffer = common_util_is__WEBPACK_IMPORTED_MODULE_1__.func(Blob.prototype.arrayBuffer);
class FileIOLoader extends _IOLoader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    info;
    range;
    readPos;
    endPos;
    reader;
    readerResolve;
    async open(info, range) {
        this.info = info;
        this.range = range;
        this.readPos = 0;
        this.endPos = this.info.file.size;
        if (range.from > 0) {
            this.readPos = range.from;
        }
        if (range.to > 0) {
            this.endPos = range.to;
        }
        this.status = 2 /* IOLoaderStatus.BUFFERING */;
        return 0;
    }
    async readBufferByReader(len) {
        if (!this.reader) {
            this.reader = new FileReader();
            this.reader.onloadend = (event) => {
                if (this.readerResolve) {
                    this.readerResolve(event.target.result);
                }
            };
        }
        const blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;
        return new Promise((resolve) => {
            this.readerResolve = resolve;
            this.reader.readAsArrayBuffer(blobSlice.call(this.info.file, this.readPos, this.readPos + len));
        });
    }
    async read(buffer) {
        if (this.readPos >= this.endPos) {
            this.status = 4 /* IOLoaderStatus.COMPLETE */;
            return -1048576 /* IOError.END */;
        }
        const len = Math.min(buffer.length, this.endPos - this.readPos);
        if (hasArrayBuffer) {
            buffer.set(new Uint8Array(await (this.info.file.slice(this.readPos, this.readPos + len).arrayBuffer())), 0);
        }
        else {
            buffer.set(new Uint8Array(await this.readBufferByReader(len)), 0);
        }
        this.readPos += len;
        if (this.readPos >= this.endPos) {
            this.status = 4 /* IOLoaderStatus.COMPLETE */;
        }
        return len;
    }
    async seek(pos) {
        this.readPos = Number(pos);
        if (this.status === 4 /* IOLoaderStatus.COMPLETE */) {
            this.status = 2 /* IOLoaderStatus.BUFFERING */;
        }
        return 0;
    }
    async size() {
        return BigInt(Math.floor(this.info.file.size));
    }
    async stop() {
        this.status = 0 /* IOLoaderStatus.IDLE */;
    }
}


/***/ }),

/***/ "./src/avnetwork/ioLoader/IOLoader.ts":
/*!********************************************!*\
  !*** ./src/avnetwork/ioLoader/IOLoader.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOLoader)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/*
 * libmedia abstract loader
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const optionsDefault = {
    isLive: true,
    preload: 5242880,
    retryCount: 20,
    retryInterval: 1
};
class IOLoader {
    options;
    status;
    retryCount;
    retryTimeout;
    constructor(options = {}) {
        this.options = options;
        this.status = 0 /* IOLoaderStatus.IDLE */;
        this.retryCount = 0;
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend({}, optionsDefault);
        common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend(this.options, options);
    }
}


/***/ }),

/***/ "./src/avpipeline/AudioDecodePipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/AudioDecodePipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioDecodePipeline)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\cheap\std\collection\List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avcodec_wasmcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avcodec/wasmcodec/AudioDecoder */ "./src/avcodec/wasmcodec/AudioDecoder.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var avutil_struct_avcodecparameters__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avutil/struct/avcodecparameters */ "./src/avutil/struct/avcodecparameters.ts");
/* harmony import */ var avcodec_webcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avcodec/webcodec/AudioDecoder */ "./src/avcodec/webcodec/AudioDecoder.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var avutil_function_audioData2AVFrame__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! avutil/function/audioData2AVFrame */ "./src/avutil/function/audioData2AVFrame.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avutil_function_compileResource__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! avutil/function/compileResource */ "./src/avutil/function/compileResource.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");
/* harmony import */ var avutil_util_serialize__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! avutil/util/serialize */ "./src/avutil/util/serialize.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! avutil/util/codecparameters */ "./src/avutil/util/codecparameters.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
var cheap__fileName__0 = "src\\avpipeline\\AudioDecodePipeline.ts";





/*
 * libmedia AudioDecodePipeline
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */






















class AudioDecodePipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor() {
        super();
    }
    createWebcodecDecoder(task) {
        return new avcodec_webcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_12__["default"]({
            onError: (error) => {
                common_util_logger__WEBPACK_IMPORTED_MODULE_9__.error(`audio decode error, taskId: ${task.taskId}, error: ${error}`, cheap__fileName__0, 93);
                if (task.openReject) {
                    task.openReject(avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                    task.openReject = null;
                }
            },
            onReceiveFrame(audioData) {
                const avframe = (0,avutil_function_audioData2AVFrame__WEBPACK_IMPORTED_MODULE_16__.audioData2AVFrame)(audioData, task.avframePool.alloc());
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avframe + 104, (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avframe + 104), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_TIME_BASE_Q, task.timeBase));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 124, task.timeBase.den);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 120, task.timeBase.num);
                task.frameCaches.push(avframe);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](task.stats + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.stats + 56) + BigInt(1));
                if (task.lastDecodeTimestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](task.stats + 240, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_15__["default"])() - task.lastDecodeTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 240)));
                }
                task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_15__["default"])();
                audioData.close();
            }
        });
    }
    createWasmcodecDecoder(task, resource) {
        return new avcodec_wasmcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_8__["default"]({
            resource: resource,
            onError: (error) => {
                common_util_logger__WEBPACK_IMPORTED_MODULE_9__.error(`audio decode error, taskId: ${task.taskId}, error: ${error}`, cheap__fileName__0, 124);
                if (task.openReject) {
                    task.openReject(avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                    task.openReject = null;
                }
            },
            onReceiveFrame(frame) {
                task.frameCaches.push(frame);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](task.stats + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.stats + 56) + BigInt(1));
                if (task.lastDecodeTimestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](task.stats + 240, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_15__["default"])() - task.lastDecodeTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 240)));
                }
                task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_15__["default"])();
            },
            avframePool: task.avframePool
        });
    }
    async pullAVPacketInternal(task, leftIPCPort) {
        const data = await leftIPCPort.request('pull');
        if (common_util_is__WEBPACK_IMPORTED_MODULE_24__.number(data)) {
            return data;
        }
        else {
            const avpacket = task.avpacketPool.alloc();
            (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_21__.unserializeAVPacket)(data, avpacket);
            return avpacket;
        }
    }
    async createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__["default"](options.leftPort);
        const rightIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__["default"](options.rightPort);
        const frameCaches = [];
        const avframePool = new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_10__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__["default"]), options.avframeListMutex);
        const task = {
            ...options,
            resource: await (0,avutil_function_compileResource__WEBPACK_IMPORTED_MODULE_19__["default"])(options.resource),
            frameCaches,
            inputEnd: false,
            decoder: null,
            parameters: 0,
            lastDecodeTimestamp: 0,
            avframePool,
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_13__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__["default"]), options.avpacketListMutex),
            openReject: null
        };
        if (task.resource) {
            task.decoder = this.createWasmcodecDecoder(task, task.resource);
        }
        else {
            task.decoder = this.createWebcodecDecoder(task);
        }
        this.tasks.set(options.taskId, task);
        rightIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__.REQUEST, async (request) => {
            switch (request.method) {
                case 'pull': {
                    if (frameCaches.length) {
                        const frame = frameCaches.shift();
                        rightIPCPort.reply(request, frame);
                        break;
                    }
                    else if (!task.inputEnd) {
                        while (true) {
                            if (frameCaches.length) {
                                const frame = frameCaches.shift();
                                rightIPCPort.reply(request, frame);
                                break;
                            }
                            const avpacket = await this.pullAVPacketInternal(task, leftIPCPort);
                            if (avpacket === -1048576 /* IOError.END */) {
                                await task.decoder.flush();
                                task.inputEnd = true;
                                if (frameCaches.length) {
                                    const frame = frameCaches.shift();
                                    rightIPCPort.reply(request, frame);
                                    break;
                                }
                                else {
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_9__.info(`audio decoder ended, taskId: ${task.taskId}`, cheap__fileName__0, 218);
                                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                                    break;
                                }
                            }
                            else if (avpacket > 0) {
                                const ret = task.decoder.decode(avpacket, (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_TIME_BASE_Q));
                                task.avpacketPool.release(avpacket);
                                if (ret < 0) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](task.stats + 48, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 48) + 1);
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_9__.error(`audio decode error, taskId: ${options.taskId}, ret: ${ret}`, cheap__fileName__0, 231);
                                }
                                continue;
                            }
                            else {
                                common_util_logger__WEBPACK_IMPORTED_MODULE_9__.error(`audio decode pull avpacket error, taskId: ${options.taskId}, ret: ${avpacket}`, cheap__fileName__0, 236);
                                rightIPCPort.reply(request, avpacket);
                                break;
                            }
                        }
                        break;
                    }
                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                    break;
                }
            }
        });
        return 0;
    }
    async open(taskId, parameters, wasmDecoderOptions = {}) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.wasmDecoderOptions = wasmDecoderOptions;
            const codecpar = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_22__.avMallocz)(168);
            if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_20__["default"])(parameters)) {
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_23__.copyCodecParameters)(codecpar, parameters);
            }
            else {
                (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_21__.unserializeAVCodecParameters)(parameters, codecpar);
            }
            if (task.parameters) {
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_23__.freeCodecParameters)(task.parameters);
            }
            task.parameters = codecpar;
            return new Promise(async (resolve, reject) => {
                task.openReject = resolve;
                try {
                    await task.decoder.open(codecpar, task.wasmDecoderOptions);
                }
                catch (error) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_9__.error(`open audio decoder failed, error: ${error}`, cheap__fileName__0, 273);
                    resolve(avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                    return;
                }
                resolve(0);
            });
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_9__.fatal('task not found', cheap__fileName__0, 280);
    }
    async reopenDecoder(taskId, parameters, resource, wasmDecoderOptions) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (wasmDecoderOptions) {
                task.wasmDecoderOptions = wasmDecoderOptions;
            }
            const codecpar = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_22__.avMallocz)(168);
            if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_20__["default"])(parameters)) {
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_23__.copyCodecParameters)(codecpar, parameters);
            }
            else {
                (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_21__.unserializeAVCodecParameters)(parameters, codecpar);
            }
            if (task.parameters) {
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_23__.freeCodecParameters)(task.parameters);
            }
            task.parameters = codecpar;
            let decoder;
            if (resource) {
                resource = await (0,avutil_function_compileResource__WEBPACK_IMPORTED_MODULE_19__["default"])(resource);
                decoder = this.createWasmcodecDecoder(task, resource);
            }
            else {
                decoder = this.createWebcodecDecoder(task);
            }
            return new Promise(async (resolve, reject) => {
                task.openReject = resolve;
                try {
                    await decoder.open(codecpar);
                    if (resource) {
                        task.resource = resource;
                    }
                    task.decoder.close();
                    task.decoder = decoder;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_9__.debug(`reopen audio decoder, taskId: ${task.taskId}`, cheap__fileName__0, 323);
                }
                catch (error) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_9__.error(`reopen audio decoder failed, error: ${error}`, cheap__fileName__0, 326);
                    resolve(avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                    return;
                }
                resolve(0);
            });
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_9__.fatal('task not found', cheap__fileName__0, 333);
    }
    async resetTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.decoder) {
                await task.decoder.flush();
            }
            common_util_array__WEBPACK_IMPORTED_MODULE_14__.each(task.frameCaches, (frame) => {
                task.avframePool.release(frame);
            });
            task.frameCaches.length = 0;
            task.inputEnd = false;
            task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_15__["default"])();
            common_util_logger__WEBPACK_IMPORTED_MODULE_9__.info(`reset audio decoder, taskId: ${task.taskId}`, cheap__fileName__0, 349);
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_6__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.rightPort.close();
            task.leftPort.close();
            task.decoder.close();
            task.frameCaches.forEach((frame) => {
                task.avframePool.release(frame);
            });
            if (task.parameters) {
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_23__.freeCodecParameters)(task.parameters);
            }
            this.tasks.delete(taskId);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/AudioRenderPipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/AudioRenderPipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioRenderPipeline)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./..\cheap\std\collection\List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./..\cheap\thread\mutex.ts */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var _avutil_struct_avpcmbuffer_ts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./..\avutil\struct\avpcmbuffer.ts */ "./src/avutil/struct/avpcmbuffer.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var audioresample_Resampler__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! audioresample/Resampler */ "./src/audioresample/Resampler.ts");
/* harmony import */ var avutil_implement_AVPCMBufferPoolImpl__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/implement/AVPCMBufferPoolImpl */ "./src/avutil/implement/AVPCMBufferPoolImpl.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var audiostretchpitch_StretchPitcher__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! audiostretchpitch/StretchPitcher */ "./src/audiostretchpitch/StretchPitcher.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
/* harmony import */ var avutil_function_compileResource__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! avutil/function/compileResource */ "./src/avutil/function/compileResource.ts");
var cheap__fileName__7 = "src\\avpipeline\\AudioRenderPipeline.ts";









/*
 * libmedia AudioRenderPipeline
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

















class AudioRenderPipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_9__["default"] {
    avPCMBufferPool;
    avPCMBufferList;
    avPCMBufferListMutex;
    constructor() {
        super();
        this.avPCMBufferList = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_2__["default"])(_cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_1__["default"]);
        this.avPCMBufferListMutex = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_2__["default"])(_cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.Mutex);
        this.avPCMBufferPool = new avutil_implement_AVPCMBufferPoolImpl__WEBPACK_IMPORTED_MODULE_15__["default"](this.avPCMBufferList, this.avPCMBufferListMutex[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
    }
    async createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_11__["default"](options.leftPort);
        const rightIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_11__["default"](options.rightPort);
        const controlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_11__["default"](options.controlPort);
        const task = {
            ...options,
            leftIPCPort,
            rightIPCPort,
            controlIPCPort,
            resamplerResource: await (0,avutil_function_compileResource__WEBPACK_IMPORTED_MODULE_24__["default"])(options.resamplerResource),
            stretchpitcherResource: await (0,avutil_function_compileResource__WEBPACK_IMPORTED_MODULE_24__["default"])(options.stretchpitcherResource),
            resampler: null,
            stretchpitcher: new Map(),
            outPCMBuffer: null,
            waitPCMBuffer: 0,
            waitAVFrame: 0,
            waitPCMBufferPos: 0,
            frameEnded: false,
            stretchpitcherEnded: false,
            playRate: 1,
            playTempo: 1,
            playPitch: 1,
            useStretchpitcher: false,
            lastNotifyPTS: BigInt(0),
            currentPTS: avutil_constant__WEBPACK_IMPORTED_MODULE_20__.NOPTS_VALUE_BIGINT,
            firstPlayed: false,
            seeking: false,
            pausing: false,
            seekSync: null,
            receivePCMSync: null,
            paddingAVFrame: 0,
            fakePlayStartTimestamp: 0,
            fakePlaySamples: BigInt(0),
            fakePlayTimer: null,
            fakePlay: false,
            lastRenderTimestamp: 0,
            avframePool: new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_13__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_1__["default"]), options.avframeListMutex)
        };
        task.startPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(task.startPTS, task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q);
        for (let i = 0; i < options.playChannels; i++) {
            const stretchpitcher = new audiostretchpitch_StretchPitcher__WEBPACK_IMPORTED_MODULE_17__["default"]({
                resource: task.stretchpitcherResource
            });
            task.stretchpitcher.set(i, stretchpitcher);
            await stretchpitcher.open({
                sampleRate: options.playSampleRate,
                channels: 1
            });
            stretchpitcher.setTempo(task.playTempo);
            stretchpitcher.setPitch(task.playPitch);
            stretchpitcher.setRate(task.playRate);
        }
        const pullNewAudioFrame = async () => {
            let audioFrame;
            if (task.paddingAVFrame) {
                audioFrame = task.paddingAVFrame;
                task.paddingAVFrame = 0;
            }
            else {
                audioFrame = await task.leftIPCPort.request('pull');
            }
            if (audioFrame === -1048576 /* IOError.END */) {
                for (let i = 0; i < task.playChannels; i++) {
                    const stretchpitcher = task.stretchpitcher.get(i);
                    stretchpitcher.flush();
                }
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.info(`audio render ended, taskId: ${task.taskId}`, cheap__fileName__7, 204);
                return -1048576 /* IOError.END */;
            }
            else if (audioFrame < 0) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.error(`pull audio frame failed, taskId: ${task.taskId}`, cheap__fileName__7, 208);
                return audioFrame;
            }
            else {
                if (task.playRate !== 1
                    || task.playTempo !== 1
                    || task.playPitch !== 1
                    || task.enableJitterBuffer) {
                    task.useStretchpitcher = true;
                }
                else {
                    task.useStretchpitcher = false;
                }
                if (!task.firstPlayed) {
                    const start = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[17](audioFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q);
                    task.firstPlayed = true;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`got first audio frame, pts: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[17](audioFrame + 104)}(${start}ms), taskId: ${task.taskId}`, cheap__fileName__7, 230);
                }
                task.currentPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[17](audioFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[17](task.stats + 72, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[17](task.stats + 72) + BigInt(1));
                if (task.lastRenderTimestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](task.stats + 244, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])() - task.lastRenderTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](task.stats + 244)));
                }
                task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
                let releaseAudioFrame = true;
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 152) !== task.playSampleRate
                    || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 80) !== task.playFormat
                    || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 292) !== task.playChannels) {
                    if (task.resampler) {
                        const current = task.resampler.getInputPCMParameters();
                        if (current.format !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 80) || current.sampleRate !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 152)) {
                            task.resampler.close();
                            task.resampler = null;
                        }
                    }
                    if (!task.resampler) {
                        task.resampler = new audioresample_Resampler__WEBPACK_IMPORTED_MODULE_14__["default"]({
                            resource: task.resamplerResource
                        });
                        await task.resampler.open({
                            sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 152),
                            format: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 80),
                            channels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 292)
                        }, {
                            sampleRate: task.playSampleRate,
                            format: task.playFormat,
                            channels: task.playChannels
                        });
                    }
                    let pcmBuffer = this.avPCMBufferPool.alloc();
                    let ret = task.resampler.resample(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](audioFrame + 64), pcmBuffer, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 76));
                    if (ret < 0) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_12__.error(`resample error, ret: ${ret}, taskId: ${task.taskId}`, cheap__fileName__7, 278);
                        this.avPCMBufferPool.release(pcmBuffer);
                        return ret;
                    }
                    if (!task.useStretchpitcher) {
                        task.waitPCMBuffer = pcmBuffer;
                        task.waitPCMBufferPos = 0;
                    }
                    else {
                        for (let i = 0; i < task.playChannels; i++) {
                            const stretchpitcher = task.stretchpitcher.get(i);
                            stretchpitcher.sendSamples(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pcmBuffer) + (i * 4)), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](pcmBuffer + 8));
                        }
                        this.avPCMBufferPool.release(pcmBuffer);
                    }
                }
                else {
                    if (!task.useStretchpitcher) {
                        let pcmBuffer = this.avPCMBufferPool.alloc();
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pcmBuffer)) {
                            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pcmBuffer));
                            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avFreep)(pcmBuffer);
                        }
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](pcmBuffer + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 76));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](pcmBuffer + 12, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 76));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](pcmBuffer + 20, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 152));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](pcmBuffer + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 292));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[20](pcmBuffer, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](audioFrame + 64));
                        task.waitAVFrame = audioFrame;
                        task.waitPCMBuffer = pcmBuffer;
                        task.waitPCMBufferPos = 0;
                        releaseAudioFrame = false;
                    }
                    else {
                        for (let i = 0; i < task.playChannels; i++) {
                            const stretchpitcher = task.stretchpitcher.get(i);
                            stretchpitcher.sendSamples(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](audioFrame + 64) + (i * 4)), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 76));
                        }
                    }
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](task.stats + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 152));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](task.stats, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 292));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](task.stats + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 76));
                if (releaseAudioFrame) {
                    task.avframePool.release(audioFrame);
                }
            }
            return 0;
        };
        const receiveToPCMBuffer = async (pcmBuffer) => {
            let receive = 0;
            if (task.seeking) {
                await new Promise((resolve) => {
                    task.receivePCMSync = resolve;
                });
            }
            if (task.enableJitterBuffer) {
                let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](task.stats + 32) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](task.stats + 236) * 1000;
                if (buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](task.stats + 272)) {
                    this.setPlayRate(task.taskId, 1);
                }
            }
            if (task.frameEnded && task.useStretchpitcher) {
                let ret = 0;
                for (let i = 0; i < task.playChannels; i++) {
                    const stretchpitcher = task.stretchpitcher.get(i);
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pcmBuffer) + (i * 4))) {
                        ret = stretchpitcher.receiveSamples(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + (receive * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](pcmBuffer + 12) - receive);
                    }
                }
                if (receive + ret < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](pcmBuffer + 12)) {
                    task.stretchpitcherEnded = true;
                    for (let i = 0; i < task.playChannels; i++) {
                        //  0 
                        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_18__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + receive, 0, (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](pcmBuffer + 12) - receive) * 4);
                    }
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](pcmBuffer + 8, receive);
                return 0;
            }
            while (receive < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](pcmBuffer + 12)) {
                let len = 0;
                if (!task.useStretchpitcher) {
                    if (task.waitPCMBuffer) {
                        len = Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](task.waitPCMBuffer + 8) - task.waitPCMBufferPos, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](pcmBuffer + 12) - receive);
                        if (len) {
                            for (let i = 0; i < task.playChannels; i++) {
                                (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_18__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + receive * 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](task.waitPCMBuffer) + (i * 4)) + task.waitPCMBufferPos * 4, len * 4);
                            }
                            task.waitPCMBufferPos += len;
                        }
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](task.waitPCMBuffer + 8) === task.waitPCMBufferPos) {
                            if (task.waitAVFrame) {
                                // data  avframe  waitPCMBuffer  avframe 
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[20](task.waitPCMBuffer, 0);
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](task.waitPCMBuffer + 12, 0);
                                task.avframePool.release(task.waitAVFrame);
                                task.waitAVFrame = 0;
                            }
                            this.avPCMBufferPool.release(task.waitPCMBuffer);
                            task.waitPCMBuffer = 0;
                        }
                    }
                }
                else {
                    for (let i = 0; i < task.playChannels; i++) {
                        const stretchpitcher = task.stretchpitcher.get(i);
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pcmBuffer) + (i * 4))) {
                            len = stretchpitcher.receiveSamples(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + (receive * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](pcmBuffer + 12) - receive);
                        }
                    }
                }
                receive += len;
                if (receive < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](pcmBuffer + 12)) {
                    let ret = await pullNewAudioFrame();
                    if (ret === -1048576 /* IOError.END */) {
                        task.frameEnded = true;
                        if (task.useStretchpitcher) {
                            for (let i = 0; i < task.playChannels; i++) {
                                const stretchpitcher = task.stretchpitcher.get(i);
                                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pcmBuffer) + (i * 4))) {
                                    stretchpitcher.flush();
                                    ret = stretchpitcher.receiveSamples(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + (receive * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](pcmBuffer + 12) - receive);
                                }
                            }
                            if (receive + ret < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](pcmBuffer + 12)) {
                                task.stretchpitcherEnded = true;
                                for (let i = 0; i < task.playChannels; i++) {
                                    //  0 
                                    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_18__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pcmBuffer) + (i * 4)) + receive, 0, (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](pcmBuffer + 12) - receive) * 4);
                                }
                            }
                            receive += ret;
                        }
                        break;
                    }
                    else if (ret < 0) {
                        return ret;
                    }
                }
            }
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](pcmBuffer + 8, receive);
            const latency = (((task.useStretchpitcher ? task.stretchpitcher.get(0).getLatency() : 0)
                // 
                + (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](pcmBuffer + 12) * 3 >>> 1)) / task.playSampleRate * 1000) >>> 0;
            const currentPts = common_util_bigint__WEBPACK_IMPORTED_MODULE_23__.max(task.currentPTS - BigInt(Math.floor(latency)), BigInt(0));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[17](task.stats + 320, currentPts);
            if (task.currentPTS - task.lastNotifyPTS >= BigInt(1000)) {
                task.lastNotifyPTS = task.currentPTS;
                task.controlIPCPort.notify('syncPts', {
                    pts: currentPts
                });
            }
            if (task.seekSync) {
                task.seekSync();
                task.seekSync = null;
            }
            return 0;
        };
        rightIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_11__.REQUEST, async (request) => {
            switch (request.method) {
                case 'pull': {
                    if (task.fakePlay) {
                        task.fakePlay = false;
                        if (task.fakePlayTimer) {
                            clearTimeout(task.fakePlayTimer);
                            task.fakePlayTimer = null;
                        }
                        task.fakePlaySamples = BigInt(0);
                        task.fakePlayStartTimestamp = 0;
                    }
                    if (task.frameEnded && (task.stretchpitcherEnded || !task.useStretchpitcher)) {
                        rightIPCPort.reply(request, -1048576 /* IOError.END */);
                        return;
                    }
                    const pcmBuffer = request.params.buffer;
                    const ret = await receiveToPCMBuffer(pcmBuffer);
                    rightIPCPort.reply(request, ret);
                    break;
                }
                case 'pullBuffer': {
                    if (task.fakePlay) {
                        task.fakePlay = false;
                        if (task.fakePlayTimer) {
                            clearTimeout(task.fakePlayTimer);
                            task.fakePlayTimer = null;
                        }
                        task.fakePlaySamples = BigInt(0);
                        task.fakePlayStartTimestamp = 0;
                    }
                    if (task.frameEnded && (task.stretchpitcherEnded || !task.useStretchpitcher)) {
                        rightIPCPort.reply(request, -1048576 /* IOError.END */);
                        return;
                    }
                    const nbSamples = request.params.nbSamples;
                    if (!task.outPCMBuffer || task.outPCMBuffer.maxnbSamples !== nbSamples) {
                        if (task.outPCMBuffer) {
                            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avFreep)(task.outPCMBuffer.data);
                            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avFreep)(task.outPCMBuffer[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
                            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_7__["default"])(task.outPCMBuffer);
                        }
                        task.outPCMBuffer = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_2__["default"])(_avutil_struct_avpcmbuffer_ts__WEBPACK_IMPORTED_MODULE_8__["default"]);
                        task.outPCMBuffer.data = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avMalloc)(4 * task.playChannels);
                        const data = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avMallocz)(nbSamples * 4 * task.playChannels);
                        for (let i = 0; i < task.playChannels; i++) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[20](task.outPCMBuffer.data + (i * 4), data + nbSamples * 4 * i);
                        }
                        task.outPCMBuffer.maxnbSamples = nbSamples;
                    }
                    const ret = await receiveToPCMBuffer(task.outPCMBuffer[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
                    if (ret < 0) {
                        rightIPCPort.reply(request, ret);
                        return;
                    }
                    const pcm = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_18__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](task.outPCMBuffer.data), task.outPCMBuffer.nbSamples * 4 * task.playChannels).slice();
                    rightIPCPort.reply(request, pcm.buffer, null, [pcm.buffer]);
                    break;
                }
            }
        });
        this.tasks.set(options.taskId, task);
        return 0;
    }
    checkUseStretchpitcher(task) {
        const use = task.playRate !== 1
            || task.playTempo !== 1
            || task.playPitch !== 1
            || task.enableJitterBuffer;
        if (task.useStretchpitcher && !use) {
            for (let i = 0; i < task.playChannels; i++) {
                task.stretchpitcher.get(i).flush();
            }
        }
    }
    setPlayRate(taskId, rate) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.enableJitterBuffer) {
                let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](task.stats + 32) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](task.stats + 236) * 1000;
                if (buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](task.stats + 272)) {
                    rate = 1;
                }
            }
            task.playRate = rate;
            for (let i = 0; i < task.playChannels; i++) {
                task.stretchpitcher.get(i).setRate(rate);
            }
            this.checkUseStretchpitcher(task);
        }
    }
    async setPlayTempo(taskId, tempo) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.playTempo = tempo;
            for (let i = 0; i < task.playChannels; i++) {
                task.stretchpitcher.get(i).setTempo(tempo);
            }
            this.checkUseStretchpitcher(task);
        }
    }
    setPlayPitch(taskId, pitch) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.playPitch = pitch;
            for (let i = 0; i < task.playChannels; i++) {
                task.stretchpitcher.get(i).setPitch(pitch);
            }
            this.checkUseStretchpitcher(task);
        }
    }
    async beforeSeek(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (!task.fakePlay && !task.pausing) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`wait current pull front frame before seek, taskId: ${task.taskId}`, cheap__fileName__7, 616);
                await new Promise((resolve) => {
                    task.seekSync = resolve;
                });
            }
            else {
                if (task.fakePlayTimer) {
                    clearTimeout(task.fakePlayTimer);
                    task.fakePlayTimer = null;
                }
            }
            task.seeking = true;
            if (task.stretchpitcher.size) {
                for (const key of task.stretchpitcher.keys()) {
                    task.stretchpitcher.get(key).clear();
                }
            }
            if (task.waitPCMBuffer) {
                if (task.waitAVFrame) {
                    // data  avframe  waitPCMBuffer  avframe 
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[20](task.waitPCMBuffer, 0);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](task.waitPCMBuffer + 12, 0);
                    task.avframePool.release(task.waitAVFrame);
                    task.waitAVFrame = 0;
                }
                this.avPCMBufferPool.release(task.waitPCMBuffer);
                task.waitPCMBuffer = 0;
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`before seek end, taskId: ${task.taskId}`, cheap__fileName__7, 647);
        }
    }
    async syncSeekTime(taskId, timestamp, maxQueueLength) {
        const task = this.tasks.get(taskId);
        if (task) {
            let videoEnded = false;
            while (true) {
                let now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
                let videoPacketQueueLength = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](task.stats + 120);
                while (!videoEnded && maxQueueLength && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](task.stats + 120) > maxQueueLength) {
                    await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_22__["default"](0);
                    //  videoPacketQueueLength 200ms  video  sync 
                    // 
                    if ((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])() - now > 200 && videoPacketQueueLength === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](task.stats + 120)) {
                        videoEnded = true;
                    }
                    if (videoPacketQueueLength !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](task.stats + 120)) {
                        videoPacketQueueLength = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](task.stats + 120);
                        now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
                    }
                }
                let audioFrame = await task.leftIPCPort.request('pull');
                if (audioFrame < 0) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_12__.warn(`pull audio frame end after seek, taskId: ${taskId}`, cheap__fileName__7, 677);
                    task.frameEnded = true;
                    break;
                }
                if (timestamp < BigInt(0)) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_12__.info(`use the first audio frame because of the seek time${timestamp} < 0`, cheap__fileName__7, 683);
                    break;
                }
                const pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[17](audioFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q);
                if (pts - task.startPTS >= timestamp) {
                    task.paddingAVFrame = audioFrame;
                    task.frameEnded = false;
                    task.lastNotifyPTS = pts;
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[17](task.stats + 320, pts);
                    break;
                }
                else {
                    task.avframePool.release(audioFrame);
                }
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`sync seek time end, taskId: ${task.taskId}`, cheap__fileName__7, 708);
        }
    }
    async afterSeek(taskId, timestamp) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.seeking = false;
            if (task.receivePCMSync) {
                task.receivePCMSync();
                task.receivePCMSync = null;
            }
            if (!task.pausing) {
                if (task.fakePlay) {
                    task.fakePlayStartTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
                    task.fakePlaySamples = BigInt(0);
                    this.fakePlayNext(task);
                }
                task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`after seek end, taskId: ${task.taskId}`, cheap__fileName__7, 730);
        }
    }
    async restart(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.lastNotifyPTS = BigInt(0);
            task.frameEnded = false;
            task.firstPlayed = false;
            task.stretchpitcherEnded = false;
            if (task.stretchpitcher?.size) {
                for (let i = 0; i < task.playChannels; i++) {
                    task.stretchpitcher.get(i)?.clear();
                }
            }
            if (task.fakePlayTimer) {
                clearTimeout(task.fakePlayTimer);
            }
            task.fakePlaySamples = BigInt(0);
            task.fakePlayStartTimestamp = 0;
            task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.debug(`restart task, taskId: ${task.taskId}`, cheap__fileName__7, 753);
        }
    }
    async fakePlayNext(task) {
        const audioFrame = await task.leftIPCPort.request('pull');
        if (audioFrame < 0) {
            task.frameEnded = true;
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.info(`audio fake render ended, taskId: ${task.taskId}`, cheap__fileName__7, 764);
            task.controlIPCPort.notify('ended');
            return;
        }
        if (!task.fakePlay || task.pausing) {
            task.avframePool.release(audioFrame);
            return;
        }
        let next = (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 152) * 1000) >>> 0;
        next /= (task.playRate * task.playTempo);
        task.currentPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_19__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[17](audioFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q);
        const targetSamples = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])() - task.fakePlayStartTimestamp)) * BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 152) >> 0) / BigInt(1000);
        const diff = Number(targetSamples - task.fakePlaySamples);
        next -= (diff / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 152) * 1000) >>> 0;
        task.fakePlaySamples += BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](audioFrame + 76) >> 0);
        task.avframePool.release(audioFrame);
        if (task.currentPTS - task.lastNotifyPTS >= BigInt(1000)) {
            task.lastNotifyPTS = task.currentPTS;
            task.controlIPCPort.notify('syncPts', {
                pts: task.currentPTS
            });
        }
        task.fakePlayTimer = setTimeout(() => {
            task.fakePlayTimer = null;
            this.fakePlayNext(task);
        }, next);
    }
    async fakePlay(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.fakePlayStartTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
            task.fakePlay = true;
            task.fakePlaySamples = BigInt(0);
            this.fakePlayNext(task);
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.info(`start fake play, taskId: ${task.taskId}`, cheap__fileName__7, 809);
        }
    }
    async pause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.pausing = true;
            if (task.fakePlay) {
                if (task.fakePlayTimer) {
                    clearTimeout(task.fakePlayTimer);
                    task.fakePlayTimer = null;
                }
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.info(`task paused, taskId: ${task.taskId}`, cheap__fileName__7, 824);
        }
    }
    async unpause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.pausing = false;
            if (task.fakePlay) {
                task.fakePlayStartTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
                task.fakePlaySamples = BigInt(0);
                task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_21__["default"])();
                this.fakePlayNext(task);
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_12__.info(`task unpaused, taskId: ${task.taskId}`, cheap__fileName__7, 839);
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_10__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.resampler) {
                task.resampler.close();
            }
            if (task.stretchpitcher.size) {
                for (const key of task.stretchpitcher.keys()) {
                    task.stretchpitcher.get(key).close();
                }
                task.stretchpitcher.clear();
            }
            if (task.outPCMBuffer) {
                (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avFreep)(task.outPCMBuffer.data);
                (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avFreep)(task.outPCMBuffer[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
                (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_7__["default"])(task.outPCMBuffer);
            }
            if (task.waitPCMBuffer) {
                if (task.waitAVFrame) {
                    // data  avframe  waitPCMBuffer  avframe 
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[20](task.waitPCMBuffer, 0);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](task.waitPCMBuffer + 12, 0);
                    task.avframePool.release(task.waitAVFrame);
                }
                this.avPCMBufferPool.release(task.waitPCMBuffer);
                task.waitPCMBuffer = 0;
            }
            if (task.paddingAVFrame) {
                task.avframePool.release(task.paddingAVFrame);
            }
            task.leftIPCPort.destroy();
            task.rightIPCPort.destroy();
            this.tasks.delete(taskId);
        }
    }
    async clear() {
        await super.clear();
        this.avPCMBufferList.clear((buffer) => {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](buffer)) {
                (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](buffer));
                (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_16__.avFreep)(buffer);
            }
        }, 20);
        (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_7__["default"])(this.avPCMBufferList);
        (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_7__["default"])(this.avPCMBufferListMutex);
    }
}


/***/ }),

/***/ "./src/avpipeline/DemuxPipeline.ts":
/*!*****************************************!*\
  !*** ./src/avpipeline/DemuxPipeline.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DemuxPipeline)
/* harmony export */ });
/* unused harmony export STREAM_INDEX_ALL */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./..\cheap\std\collection\List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avformat/AVFormatContext */ "./src/avformat/AVFormatContext.ts");
/* harmony import */ var common_io_IOReader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/io/IOReader */ "./src/common/io/IOReader.ts");
/* harmony import */ var avformat_demux__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avformat/demux */ "./src/avformat/demux.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_std_buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! cheap/std/buffer/SafeUint8Array */ "./src/cheap/std/buffer/SafeUint8Array.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/timer/LoopTask */ "./src/common/timer/LoopTask.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_function_analyzeAVFormat__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! avutil/function/analyzeAVFormat */ "./src/avutil/function/analyzeAVFormat.ts");
/* harmony import */ var avutil_function_compileResource__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! avutil/function/compileResource */ "./src/avutil/function/compileResource.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var cheap_config__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! cheap/config */ "./src/cheap/config.ts");
/* harmony import */ var avutil_util_serialize__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! avutil/util/serialize */ "./src/avutil/util/serialize.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avformat_codecs_h264__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! avformat/codecs/h264 */ "./src/avformat/codecs/h264.ts");
/* harmony import */ var avformat_codecs_hevc__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! avformat/codecs/hevc */ "./src/avformat/codecs/hevc.ts");
/* harmony import */ var avformat_codecs_vvc__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! avformat/codecs/vvc */ "./src/avformat/codecs/vvc.ts");
var cheap__fileName__2 = "src\\avpipeline\\DemuxPipeline.ts";


































const STREAM_INDEX_ALL = -1;
class DemuxPipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_6__["default"] {
    constructor() {
        super();
    }
    createTask(options) {
        let leftIPCPort;
        let controlIPCPort;
        if (options.mainTaskId) {
            const mainTask = this.tasks.get(options.mainTaskId);
            leftIPCPort = mainTask.leftIPCPort;
            controlIPCPort = mainTask.controlIPCPort;
        }
        else {
            leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_8__["default"](options.leftPort);
            if (options.controlPort) {
                controlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_8__["default"](options.controlPort);
            }
        }
        const bufferLength = options.bufferLength || 1048576;
        const buf = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_12__.avMalloc)(bufferLength);
        if (!buf) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_7__.NO_MEMORY;
        }
        const buffer = new cheap_std_buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_13__["default"](buf, bufferLength);
        const ioReader = new common_io_IOReader__WEBPACK_IMPORTED_MODULE_10__["default"](bufferLength, true, buffer);
        if (!options.isLive) {
            ioReader.flags |= 1 /* IOFlags.SEEKABLE */;
        }
        if (options.flags) {
            ioReader.flags |= options.flags;
        }
        ioReader.onFlush = async (buffer) => {
            const params = {
                pointer: buffer.byteOffset,
                length: buffer.length
            };
            if (options.ioloaderOptions) {
                params.ioloaderOptions = options.ioloaderOptions;
            }
            try {
                const result = await leftIPCPort.request('read', params);
                if (common_util_is__WEBPACK_IMPORTED_MODULE_29__.number(result)) {
                    return result;
                }
                (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_22__.memcpyFromUint8Array)(params.pointer, result.length, result);
                return result.length;
            }
            catch (error) {
                return -1048574 /* IOError.INVALID_OPERATION */;
            }
        };
        ioReader.onSeek = async (pos) => {
            try {
                const params = {
                    pos
                };
                if (options.ioloaderOptions) {
                    params.ioloaderOptions = options.ioloaderOptions;
                }
                return leftIPCPort.request('seek', params);
            }
            catch (error) {
                return -1048574 /* IOError.INVALID_OPERATION */;
            }
        };
        ioReader.onSize = async () => {
            try {
                return leftIPCPort.request('size');
            }
            catch (error) {
                return BigInt(-1048574 /* IOError.INVALID_OPERATION */ >> 0);
            }
        };
        const formatContext = (0,avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_9__.createAVIFormatContext)();
        formatContext.ioReader = ioReader;
        formatContext.getDecoderResource = async (mediaType, codecId) => {
            if (!controlIPCPort) {
                return;
            }
            const wasm = await controlIPCPort.request('getDecoderResource', {
                codecId,
                mediaType
            });
            return (0,avutil_function_compileResource__WEBPACK_IMPORTED_MODULE_24__["default"])(wasm, mediaType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
        };
        this.tasks.set(options.taskId, {
            ...options,
            leftIPCPort,
            rightIPCPorts: new Map(),
            controlIPCPort,
            formatContext,
            ioReader,
            buffer: buf,
            cacheAVPackets: new Map(),
            cacheRequests: new Map(),
            streamIndexFlush: new Map(),
            realFormat: -1 /* AVFormat.UNKNOWN */,
            demuxEnded: false,
            loop: null,
            gopCounter: 0,
            lastKeyFramePts: BigInt(0),
            lastAudioDts: BigInt(0),
            lastVideoDts: BigInt(0),
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_15__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_1__["default"]), options.avpacketListMutex)
        });
        return 0;
    }
    async openStream(taskId, maxProbeDuration = 3000) {
        const task = this.tasks.get(taskId);
        if (task) {
            let ret = await task.leftIPCPort.request('open');
            if (ret < 0) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_14__.error(`open ioloader failed, ret: ${ret}`, cheap__fileName__2, 258);
                return ret;
            }
            let format;
            try {
                format = await (0,avutil_function_analyzeAVFormat__WEBPACK_IMPORTED_MODULE_23__["default"])(task.ioReader, task.format);
                task.format = format;
            }
            catch (error) {
                return avutil_error__WEBPACK_IMPORTED_MODULE_7__.DATA_INVALID;
            }
            let iformat;
            switch (format) {
                case 0 /* AVFormat.FLV */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IFlvFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IFlvFormat */ "./src/avformat/formats/IFlvFormat.ts"))).default);
                    }
                    break;
                case 1 /* AVFormat.MP4 */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IMovFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMovFormat */ "./src/avformat/formats/IMovFormat.ts"))).default);
                    }
                    break;
                case 2 /* AVFormat.MPEGTS */:
                    {
                        iformat = new ((await Promise.all(/*! import() */[__webpack_require__.e("src_avformat_bsf_aac_ADTS2RawFilter_ts-src_avformat_codecs_dts_ts-src_avformat_codecs_opus_ts-6c0f0d"), __webpack_require__.e("src_avformat_formats_IMpegtsFormat_ts")]).then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMpegtsFormat */ "./src/avformat/formats/IMpegtsFormat.ts"))).default);
                    }
                    break;
                case 3 /* AVFormat.MPEGPS */:
                    {
                        iformat = new ((await Promise.all(/*! import() */[__webpack_require__.e("src_avformat_bsf_aac_ADTS2RawFilter_ts-src_avformat_codecs_dts_ts-src_avformat_codecs_opus_ts-6c0f0d"), __webpack_require__.e("src_avformat_formats_IMpegpsFormat_ts")]).then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMpegpsFormat */ "./src/avformat/formats/IMpegpsFormat.ts"))).default);
                    }
                    break;
                case 5 /* AVFormat.IVF */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IIvfFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IIvfFormat */ "./src/avformat/formats/IIvfFormat.ts"))).default);
                    }
                    break;
                case 4 /* AVFormat.OGG */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IOggFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IOggFormat */ "./src/avformat/formats/IOggFormat.ts"))).default);
                    }
                    break;
                case 12 /* AVFormat.MP3 */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IMp3Format_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMp3Format */ "./src/avformat/formats/IMp3Format.ts"))).default);
                    }
                    break;
                case 6 /* AVFormat.MATROSKA */:
                case 7 /* AVFormat.WEBM */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IMatroskaFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMatroskaFormat */ "./src/avformat/formats/IMatroskaFormat.ts"))).default));
                    }
                    break;
                case 13 /* AVFormat.AAC */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IAacFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IAacFormat */ "./src/avformat/formats/IAacFormat.ts"))).default));
                    }
                    break;
                case 15 /* AVFormat.FLAC */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IFlacFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IFlacFormat */ "./src/avformat/formats/IFlacFormat.ts"))).default));
                    }
                    break;
                case 14 /* AVFormat.WAV */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IWavFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IWavFormat */ "./src/avformat/formats/IWavFormat.ts"))).default));
                    }
                    break;
                case 16 /* AVFormat.WEBVTT */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IWebVttFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IWebVttFormat */ "./src/avformat/formats/IWebVttFormat.ts"))).default));
                    }
                    break;
                case 17 /* AVFormat.SUBRIP */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_ISubRipFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/ISubRipFormat */ "./src/avformat/formats/ISubRipFormat.ts"))).default));
                    }
                    break;
                case 18 /* AVFormat.ASS */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IAssFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IAssFormat */ "./src/avformat/formats/IAssFormat.ts"))).default));
                    }
                    break;
                case 19 /* AVFormat.TTML */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_ITtmlFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/ITtmlFormat */ "./src/avformat/formats/ITtmlFormat.ts"))).default));
                    }
                    break;
                case 9 /* AVFormat.H264 */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IH264Format_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IH264Format */ "./src/avformat/formats/IH264Format.ts"))).default));
                    }
                    break;
                case 10 /* AVFormat.HEVC */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IHevcFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IHevcFormat */ "./src/avformat/formats/IHevcFormat.ts"))).default));
                    }
                    break;
                case 11 /* AVFormat.VVC */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IVvcFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IVvcFormat */ "./src/avformat/formats/IVvcFormat.ts"))).default));
                    }
                    break;
                default:
                    common_util_logger__WEBPACK_IMPORTED_MODULE_14__.error('format not support', cheap__fileName__2, 438);
                    return avutil_error__WEBPACK_IMPORTED_MODULE_7__.FORMAT_NOT_SUPPORT;
            }
            task.realFormat = format;
            task.formatContext.iformat = iformat;
            return avformat_demux__WEBPACK_IMPORTED_MODULE_11__.open(task.formatContext, {
                maxAnalyzeDuration: maxProbeDuration,
                fastOpen: task.isLive
            });
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.fatal('task not found', cheap__fileName__2, 453);
        }
    }
    async getFormat(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            return task.realFormat;
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.fatal('task not found', cheap__fileName__2, 463);
        }
    }
    async analyzeStreams(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.analyzeStreams(task.formatContext);
            const streams = [];
            for (let i = 0; i < task.formatContext.streams.length; i++) {
                const stream = task.formatContext.streams[i];
                streams.push({
                    index: stream.index,
                    id: stream.id,
                    codecpar: stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    nbFrames: stream.nbFrames,
                    metadata: stream.metadata,
                    duration: stream.duration,
                    startTime: stream.startTime,
                    disposition: stream.disposition,
                    timeBase: {
                        den: stream.timeBase.den,
                        num: stream.timeBase.num
                    }
                });
            }
            return {
                metadata: task.formatContext.metadata,
                format: task.realFormat,
                chapters: task.formatContext.chapters,
                streams
            };
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.fatal('task not found', cheap__fileName__2, 499);
        }
    }
    replyAVPacket(task, ipcPort, request, avpacket) {
        if ((0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_25__["default"])() && !cheap_config__WEBPACK_IMPORTED_MODULE_26__.USE_THREADS && (0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_28__["default"])(avpacket)) {
            const data = (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_27__.serializeAVPacket)(avpacket);
            const transfer = [data.data.buffer];
            if (data.sideData.length) {
                data.sideData.forEach((side) => {
                    transfer.push(side.data.buffer);
                });
            }
            ipcPort.reply(request, data, null, transfer);
            task.avpacketPool.release(avpacket);
            return;
        }
        ipcPort.reply(request, avpacket);
    }
    async connectStreamTask(taskId, streamIndex, port) {
        const task = this.tasks.get(taskId);
        if (task) {
            const ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_8__["default"](port);
            task.cacheAVPackets.set(streamIndex, []);
            ipcPort.streamIndex = streamIndex;
            ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_8__.REQUEST, async (request) => {
                switch (request.method) {
                    case 'pull': {
                        const cacheAVPackets = task.cacheAVPackets.get(ipcPort.streamIndex);
                        if (cacheAVPackets.length) {
                            const avpacket = cacheAVPackets.shift();
                            if (task.stats !== 0) {
                                if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](task.stats + 32) - 1);
                                }
                                else if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 120, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](task.stats + 120) - 1);
                                }
                            }
                            this.replyAVPacket(task, ipcPort, request, avpacket);
                        }
                        else {
                            if (task.demuxEnded) {
                                ipcPort.reply(request, -1048576 /* IOError.END */);
                            }
                            else {
                                task.cacheRequests.set(ipcPort.streamIndex, request);
                                if (task.loop && task.loop.isStarted()) {
                                    task.loop.resetInterval();
                                }
                            }
                        }
                        break;
                    }
                }
            });
            task.rightIPCPorts.set(streamIndex, ipcPort);
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.debug(`connect stream ${streamIndex}, taskId: ${task.taskId}`, cheap__fileName__2, 560);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.fatal('task not found', cheap__fileName__2, 563);
        }
    }
    async changeConnectStream(taskId, newStreamIndex, oldStreamIndex, force = true) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (newStreamIndex === oldStreamIndex) {
                return;
            }
            const cache = task.cacheAVPackets.get(oldStreamIndex);
            const ipcPort = task.rightIPCPorts.get(oldStreamIndex);
            const request = task.cacheRequests.get(oldStreamIndex);
            if (!cache) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_14__.warn(`oldStreamIndex ${oldStreamIndex} not found`, cheap__fileName__2, 581);
            }
            await task.loop.stopBeforeNextTick();
            if (force) {
                common_util_array__WEBPACK_IMPORTED_MODULE_17__.each(cache, (avpacket) => {
                    task.avpacketPool.release(avpacket);
                });
                cache.length = 0;
            }
            else {
                task.streamIndexFlush.set(newStreamIndex, true);
            }
            ipcPort.streamIndex = newStreamIndex;
            task.cacheAVPackets.set(newStreamIndex, cache);
            task.rightIPCPorts.set(newStreamIndex, ipcPort);
            task.cacheAVPackets.delete(oldStreamIndex);
            task.rightIPCPorts.delete(oldStreamIndex);
            if (request) {
                task.cacheRequests.set(newStreamIndex, request);
                task.cacheRequests.delete(oldStreamIndex);
            }
            if (!force) {
                task.loop.start();
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.debug(`changed connect stream, new ${newStreamIndex}, old: ${oldStreamIndex}, force: ${force}, taskId: ${task.taskId}`, cheap__fileName__2, 613);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.fatal('task not found', cheap__fileName__2, 616);
        }
    }
    async startDemux(taskId, isLive, minQueueLength) {
        const task = this.tasks.get(taskId);
        if (task) {
            // mpegts  20
            minQueueLength = Math.max(minQueueLength, task.format === 2 /* AVFormat.MPEGTS */ ? 20 : 10);
            if (task.loop) {
                task.loop.destroy();
            }
            task.loop = new common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_16__["default"](async () => {
                if (!isLive) {
                    let canDo = false;
                    task.cacheAVPackets.forEach((list, streamIndex) => {
                        const stream = task.formatContext.streams.find((stream) => {
                            return stream.index === streamIndex;
                        });
                        if (list.length < minQueueLength
                            && (stream.codecpar.codecType !== 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */
                                || task.cacheAVPackets.size === 1)) {
                            canDo = true;
                        }
                    });
                    if (!canDo) {
                        task.loop.emptyTask();
                        return;
                    }
                }
                const avpacket = task.avpacketPool.alloc();
                let ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.readAVPacket(task.formatContext, avpacket);
                if (!ret) {
                    const streamIndex = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 32);
                    if (task.stats !== 0) {
                        if (task.formatContext.streams[streamIndex].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                            && task.cacheAVPackets.has(streamIndex)) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](task.stats + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 24) + BigInt(1));
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](task.stats + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 16) + BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 28) >> 0));
                            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 24) > 1 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16) > task.lastAudioDts) {
                                const list = task.cacheAVPackets.get(streamIndex);
                                if (list && list.length) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 236, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 72)
                                        / (Number(BigInt.asIntN(32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](list[0] + 16))) / list.length)));
                                }
                                else {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 236, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 72)
                                        / Number(BigInt.asIntN(32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16) - task.lastAudioDts))));
                                }
                            }
                            task.lastAudioDts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16);
                        }
                        else if (task.formatContext.streams[streamIndex].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */
                            && task.cacheAVPackets.has(streamIndex)) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](task.stats + 112, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 112) + BigInt(1));
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](task.stats + 104, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 104) + BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 28) >> 0));
                            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](task.stats + 176, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 176) + BigInt(1));
                                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 176) > 1 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 8) > task.lastKeyFramePts) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 96, task.gopCounter);
                                    task.gopCounter = 1;
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 92, Number(BigInt.asIntN(32, (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_18__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 8) - task.lastKeyFramePts, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q))));
                                }
                                task.lastKeyFramePts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 8);
                            }
                            else {
                                task.gopCounter++;
                            }
                            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](task.stats + 112) > 1 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16) > task.lastVideoDts) {
                                const list = task.cacheAVPackets.get(streamIndex);
                                if (list && list.length) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 224, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 72)
                                        / (Number(BigInt.asIntN(32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](list[0] + 16))) / list.length)));
                                }
                                else {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 224, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 72)
                                        / Number(BigInt.asIntN(32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16) - task.lastVideoDts))));
                                }
                            }
                            task.lastVideoDts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 16);
                        }
                    }
                    if (task.streamIndexFlush.get(streamIndex)) {
                        const stream = task.formatContext.streams.find((stream) => {
                            return stream.index === streamIndex;
                        });
                        const ele = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_21__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */);
                        if (!ele && stream && stream.codecpar.extradataSize) {
                            const data = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_12__.avMalloc)(stream.codecpar.extradataSize);
                            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_22__.memcpy)(data, stream.codecpar.extradata, stream.codecpar.extradataSize);
                            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_21__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, data, stream.codecpar.extradataSize);
                        }
                        task.streamIndexFlush.set(streamIndex, false);
                    }
                    if (task.cacheRequests.has(streamIndex)) {
                        this.replyAVPacket(task, task.rightIPCPorts.get(streamIndex), task.cacheRequests.get(streamIndex), avpacket);
                        task.cacheRequests.delete(streamIndex);
                    }
                    else {
                        if (task.cacheAVPackets.has(streamIndex)) {
                            task.cacheAVPackets.get(streamIndex).push(avpacket);
                            if (task.stats !== 0) {
                                if (task.formatContext.streams[streamIndex].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](task.stats + 32) + 1);
                                }
                                else if (task.formatContext.streams[streamIndex].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 120, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](task.stats + 120) + 1);
                                }
                            }
                            if (task.formatContext.streams[streamIndex].codecpar.codecType === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */) {
                                if (task.cacheAVPackets.get(streamIndex).length > minQueueLength) {
                                    task.avpacketPool.release(task.cacheAVPackets.get(streamIndex).shift());
                                }
                            }
                        }
                        else {
                            if (task.rightIPCPorts.has(STREAM_INDEX_ALL)) {
                                if (task.cacheRequests.has(STREAM_INDEX_ALL)) {
                                    this.replyAVPacket(task, task.rightIPCPorts.get(STREAM_INDEX_ALL), task.cacheRequests.get(STREAM_INDEX_ALL), avpacket);
                                    task.cacheRequests.delete(STREAM_INDEX_ALL);
                                }
                                else {
                                    task.cacheAVPackets.get(STREAM_INDEX_ALL).push(avpacket);
                                }
                            }
                            else {
                                task.avpacketPool.release(avpacket);
                            }
                        }
                    }
                }
                else {
                    task.avpacketPool.release(avpacket);
                    if (ret !== -1048576 /* IOError.END */) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_14__.error(`demux error, ret: ${ret}, taskId: ${taskId}`, cheap__fileName__2, 776);
                    }
                    task.demuxEnded = true;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_14__.info(`demuxer ended, taskId: ${task.taskId}`, cheap__fileName__2, 781);
                    for (let streamIndex of task.cacheRequests.keys()) {
                        const cacheAVPackets = task.cacheAVPackets.get(streamIndex);
                        if (!cacheAVPackets.length) {
                            task.rightIPCPorts.get(streamIndex).reply(task.cacheRequests.get(streamIndex), -1048576 /* IOError.END */);
                            task.cacheRequests.delete(streamIndex);
                        }
                    }
                    task.loop.stop();
                }
            }, 0, 0, true, false);
            task.loop.start();
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.debug(`start demux loop, taskId: ${task.taskId}`, cheap__fileName__2, 796);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_14__.fatal('task not found', cheap__fileName__2, 799);
        }
    }
    async seek(taskId, timestamp, flags, streamIndex = -1) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.loop) {
                await task.loop.stopBeforeNextTick();
                let ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.seek(task.formatContext, streamIndex, timestamp, flags);
                if (ret >= BigInt(0)) {
                    task.cacheAVPackets.forEach((list) => {
                        common_util_array__WEBPACK_IMPORTED_MODULE_17__.each(list, (avpacket) => {
                            task.avpacketPool.release(avpacket);
                        });
                        list.length = 0;
                    });
                    if (task.stats !== 0) {
                        //  task  stream 
                        task.cacheAVPackets.forEach((list, streamIndex) => {
                            const stream = task.formatContext.streams.find((stream) => {
                                return stream.index === streamIndex;
                            });
                            if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 32, 0);
                            }
                            else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 120, 0);
                            }
                        });
                    }
                    const avpacket = task.avpacketPool.alloc();
                    while (true) {
                        ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.readAVPacket(task.formatContext, avpacket);
                        if (ret < 0 || task.cacheAVPackets.has(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 32))) {
                            break;
                        }
                    }
                    if (ret >= 0) {
                        task.demuxEnded = false;
                        const streamIndex = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 32);
                        task.cacheAVPackets.get(streamIndex).push(avpacket);
                        if (task.stats !== 0) {
                            if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](task.stats + 32) + 1);
                            }
                            else if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 120, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](task.stats + 120) + 1);
                            }
                        }
                        task.loop.start();
                        let duration = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 8);
                        if (task.formatContext.streams[streamIndex].startTime !== avutil_constant__WEBPACK_IMPORTED_MODULE_19__.NOPTS_VALUE_BIGINT) {
                            duration -= task.formatContext.streams[streamIndex].startTime;
                        }
                        else {
                            duration -= task.formatContext.streams[streamIndex].firstDTS;
                        }
                        return (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_18__.avRescaleQ)(common_util_bigint__WEBPACK_IMPORTED_MODULE_20__.max(duration, BigInt(0)), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q);
                    }
                    else {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_14__.warn(`got first packet failed after seek, taskId: ${task.taskId}`, cheap__fileName__2, 867);
                        task.avpacketPool.release(avpacket);
                        task.demuxEnded = true;
                        return timestamp;
                    }
                }
                return ret;
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_14__.info('seek before demux loop start', cheap__fileName__2, 878);
                let ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.seek(task.formatContext, -1, timestamp, flags);
                if (ret < 0) {
                    return ret;
                }
                return timestamp;
            }
        }
    }
    /**
     *  avpacket 
     *
     * @param taskId
     * @param max 
     */
    async croppingAVPacketQueue(taskId, max) {
        const task = this.tasks.get(taskId);
        if (task) {
            let croppingMax = max;
            const indexes = new Map();
            function hasSps(avpacket, codecId) {
                if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
                    return false;
                }
                let hasNewSps = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_21__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */) !== 0;
                if (!hasNewSps && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 80) === 2 /* h264.BitFormat.ANNEXB */) {
                    if (codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */) {
                        hasNewSps = !!avformat_codecs_h264__WEBPACK_IMPORTED_MODULE_30__.annexbExtradata2AvccExtradata((0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_21__.getAVPacketData)(avpacket));
                    }
                    else if (codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */) {
                        hasNewSps = !!avformat_codecs_hevc__WEBPACK_IMPORTED_MODULE_31__.annexbExtradata2AvccExtradata((0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_21__.getAVPacketData)(avpacket));
                    }
                    else if (codecId === 196 /* AVCodecID.AV_CODEC_ID_VVC */) {
                        hasNewSps = !!avformat_codecs_vvc__WEBPACK_IMPORTED_MODULE_32__.annexbExtradata2AvccExtradata((0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_21__.getAVPacketData)(avpacket));
                    }
                }
                return hasNewSps;
            }
            // 
            task.cacheAVPackets.forEach((list, streamIndex) => {
                const codecType = task.formatContext.streams[streamIndex].codecpar.codecType;
                const codecId = task.formatContext.streams[streamIndex].codecpar.codecId;
                if (codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    const lastDts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](list[list.length - 1] + 16);
                    let i = list.length - 2;
                    for (i = list.length - 2; i >= 0; i--) {
                        if ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](list[i] + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
                            if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_18__.avRescaleQ)(lastDts - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](list[i] + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__["default"])(list[i] + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q) >= max) {
                                croppingMax = common_util_bigint__WEBPACK_IMPORTED_MODULE_20__.max(croppingMax, (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_18__.avRescaleQ)(lastDts - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](list[i] + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__["default"])(list[i] + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q));
                                break;
                            }
                        }
                    }
                    if (codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */
                        || codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                        || codecId === 196 /* AVCodecID.AV_CODEC_ID_VVC */) {
                        if (i > 0 && !hasSps(list[i], codecId)) {
                            for (let j = i - 1; j > 0; j--) {
                                if ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](list[j] + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
                                    //  sps sps 
                                    if (hasSps(list[j], codecId)) {
                                        croppingMax = common_util_bigint__WEBPACK_IMPORTED_MODULE_20__.max(croppingMax, (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_18__.avRescaleQ)(lastDts - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](list[j] + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__["default"])(list[j] + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q));
                                        i = j;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (i > 0) {
                        indexes.set(streamIndex, i);
                    }
                }
            });
            // 
            task.cacheAVPackets.forEach((list, streamIndex) => {
                const codecType = task.formatContext.streams[streamIndex].codecpar.codecType;
                if (codecType !== 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    const lastDts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](list[list.length - 1] + 16);
                    let i = list.length - 2;
                    for (i = list.length - 2; i >= 0; i--) {
                        // 
                        if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_18__.avRescaleQ)(lastDts - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](list[i] + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__["default"])(list[i] + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_19__.AV_MILLI_TIME_BASE_Q) >= croppingMax) {
                            break;
                        }
                    }
                    if (i >= 0) {
                        indexes.set(streamIndex, i);
                    }
                }
            });
            // 
            if (indexes.size === task.cacheAVPackets.size) {
                indexes.forEach((index, streamIndex) => {
                    const list = task.cacheAVPackets.get(streamIndex);
                    list.splice(0, index).forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                    const codecType = task.formatContext.streams[streamIndex].codecpar.codecType;
                    if (task.stats !== 0) {
                        if (codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 32, list.length);
                        }
                        else if (codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 120, list.length);
                        }
                    }
                });
            }
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_7__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.loop) {
                await task.loop.stopBeforeNextTick();
                task.loop.destroy();
            }
            task.leftIPCPort.destroy();
            task.rightIPCPorts.forEach((ipcPort) => {
                ipcPort.destroy();
            });
            task.rightIPCPorts.clear();
            task.formatContext.destroy();
            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_12__.avFree)(task.buffer);
            task.cacheAVPackets.forEach((list) => {
                list.forEach((avpacket) => {
                    task.avpacketPool.release(avpacket);
                });
            });
            this.tasks.delete(taskId);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/IOPipeline.ts":
/*!**************************************!*\
  !*** ./src/avpipeline/IOPipeline.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOPipeline)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avnetwork_ioLoader_FetchIOLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avnetwork/ioLoader/FetchIOLoader */ "./src/avnetwork/ioLoader/FetchIOLoader.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avnetwork_ioLoader_FileIOLoader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avnetwork/ioLoader/FileIOLoader */ "./src/avnetwork/ioLoader/FileIOLoader.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avpipeline\\IOPipeline.ts";










class IOPipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super();
    }
    async createTask(options) {
        let ioLoader;
        switch (options.type) {
            case 0 /* IOType.Fetch */:
                ioLoader = new avnetwork_ioLoader_FetchIOLoader__WEBPACK_IMPORTED_MODULE_3__["default"](options.options);
                break;
            case 1 /* IOType.File */:
                ioLoader = new avnetwork_ioLoader_FileIOLoader__WEBPACK_IMPORTED_MODULE_7__["default"](options.options);
                break;
            case 2 /* IOType.HLS */:
                {
                    ioLoader = new (await __webpack_require__.e(/*! import() */ "src_avnetwork_ioLoader_HlsIOLoader_ts").then(__webpack_require__.bind(__webpack_require__, /*! avnetwork/ioLoader/HlsIOLoader */ "./src/avnetwork/ioLoader/HlsIOLoader.ts"))).default(options.options);
                }
                break;
            case 3 /* IOType.DASH */:
                {
                    ioLoader = new (await __webpack_require__.e(/*! import() */ "src_avnetwork_ioLoader_DashIOLoader_ts").then(__webpack_require__.bind(__webpack_require__, /*! avnetwork/ioLoader/DashIOLoader */ "./src/avnetwork/ioLoader/DashIOLoader.ts"))).default(options.options);
                }
                break;
        }
        if (!ioLoader) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_4__.INVALID_ARGUMENT;
        }
        const ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__["default"](options.rightPort);
        const task = {
            ...options,
            ioLoader,
            ipcPort
        };
        ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__.REQUEST, async (request) => {
            switch (request.method) {
                case 'open': {
                    try {
                        const ret = await ioLoader.open(options.info, options.range);
                        if (ret < 0) {
                            common_util_logger__WEBPACK_IMPORTED_MODULE_8__.error(`loader open error, ${ret}, taskId: ${options.taskId}`, cheap__fileName__0, 116);
                            ipcPort.reply(request, null, ret);
                            break;
                        }
                        ipcPort.reply(request, ret);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_8__.error(`loader open error, ${error}, taskId: ${options.taskId}`, cheap__fileName__0, 123);
                        ipcPort.reply(request, null, error);
                    }
                    break;
                }
                case 'read': {
                    const pointer = request.params.pointer;
                    const length = request.params.length;
                    const ioloaderOptions = request.params.ioloaderOptions;
                    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapSafeUint8Array)(pointer, length);
                    try {
                        const len = await ioLoader.read(buffer, ioloaderOptions);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](task.stats + 192, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.stats + 192) + BigInt(len >> 0));
                        ipcPort.reply(request, len);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_8__.error(`loader read error, ${error}, taskId: ${options.taskId}`, cheap__fileName__0, 144);
                        ipcPort.reply(request, avutil_error__WEBPACK_IMPORTED_MODULE_4__.DATA_INVALID);
                    }
                    break;
                }
                case 'seek': {
                    const pos = request.params.pos;
                    const ioloaderOptions = request.params.ioloaderOptions;
                    try {
                        const ret = await ioLoader.seek(pos, ioloaderOptions);
                        if (ret < 0) {
                            common_util_logger__WEBPACK_IMPORTED_MODULE_8__.error(`loader seek error, ${ret}, taskId: ${options.taskId}`, cheap__fileName__0, 160);
                            ipcPort.reply(request, null, ret);
                            break;
                        }
                        ipcPort.reply(request, ret);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_8__.error(`loader seek error, ${error}, taskId: ${options.taskId}`, cheap__fileName__0, 167);
                        ipcPort.reply(request, null, error);
                    }
                    break;
                }
                case 'size': {
                    ipcPort.reply(request, await ioLoader.size());
                    break;
                }
            }
        });
        this.tasks.set(options.taskId, task);
        return 0;
    }
    async open(id) {
        const task = this.tasks.get(id);
        if (task) {
            await task.ioLoader.open(task.info, task.range);
            return 0;
        }
    }
    async getDuration(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 2 /* IOType.HLS */ || task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getDuration();
                }
            }
            return 0;
        }
    }
    async hasAudio(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.hasAudio();
                }
            }
        }
        return false;
    }
    async hasVideo(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.hasVideo();
                }
            }
        }
        return false;
    }
    async hasSubtitle(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.hasSubtitle();
                }
            }
        }
        return false;
    }
    async getVideoList(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getVideoList();
                }
                else if (task.type === 2 /* IOType.HLS */) {
                    return task.ioLoader.getVideoList();
                }
            }
        }
        return {
            list: [],
            selectedIndex: 0
        };
    }
    async getAudioList(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getAudioList();
                }
            }
        }
        return {
            list: [],
            selectedIndex: 0
        };
    }
    async getSubtitleList(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getSubtitleList();
                }
            }
        }
        return {
            list: [],
            selectedIndex: 0
        };
    }
    async selectVideo(taskId, index) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    task.ioLoader.selectVideo(index);
                }
                else if (task.type === 2 /* IOType.HLS */) {
                    return task.ioLoader.selectVideo(index);
                }
            }
        }
    }
    async selectAudio(taskId, index) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    task.ioLoader.selectAudio(index);
                }
            }
        }
    }
    async selectSubtitle(taskId, index) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    task.ioLoader.selectSubtitle(index);
                }
            }
        }
    }
    async getMinBuffer(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getMinBuffer();
                }
            }
            {
                if (task.type === 2 /* IOType.HLS */) {
                    return task.ioLoader.getMinBuffer();
                }
            }
        }
        return 0;
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_4__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(id) {
        const task = this.tasks.get(id);
        if (task) {
            await task.ioLoader.stop();
            task.ipcPort.destroy();
            this.tasks.delete(id);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/Pipeline.ts":
/*!************************************!*\
  !*** ./src/avpipeline/Pipeline.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Pipeline)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/*
 * libmedia abstract Pipeline
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class Pipeline {
    tasks;
    constructor() {
        this.tasks = new Map();
    }
    async clear() {
        if (this.tasks.size) {
            for (const key of this.tasks.keys()) {
                await this.unregisterTask(key);
            }
        }
    }
    async setLogLevel(level) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.setLevel(level);
    }
    async getTaskCount() {
        return this.tasks.size;
    }
}


/***/ }),

/***/ "./src/avpipeline/VideoDecodePipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/VideoDecodePipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoDecodePipeline)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\cheap\std\collection\List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avcodec/wasmcodec/VideoDecoder */ "./src/avcodec/wasmcodec/VideoDecoder.ts");
/* harmony import */ var avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avcodec/webcodec/VideoDecoder */ "./src/avcodec/webcodec/VideoDecoder.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var avutil_struct_avcodecparameters__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/struct/avcodecparameters */ "./src/avutil/struct/avcodecparameters.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");
/* harmony import */ var avutil_function_compileResource__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! avutil/function/compileResource */ "./src/avutil/function/compileResource.ts");
/* harmony import */ var avutil_util_serialize__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! avutil/util/serialize */ "./src/avutil/util/serialize.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! avutil/util/codecparameters */ "./src/avutil/util/codecparameters.ts");
var cheap__fileName__0 = "src\\avpipeline\\VideoDecodePipeline.ts";





/*
 * libmedia VideoDecodePipeline
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */























class VideoDecodePipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor() {
        super();
    }
    createWebcodecDecoder(task, enableHardwareAcceleration = true) {
        return new avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__["default"]({
            onError: (error) => {
                if (task.hardwareRetryCount > 3 || !task.firstDecoded) {
                    if (task.targetDecoder === task.hardwareDecoder) {
                        task.targetDecoder = task.softwareDecoder;
                        task.hardwareDecoder.close();
                        task.hardwareDecoder = null;
                        task.decoderReady = this.openSoftwareDecoder(task);
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`video decode error width hardware(${task.hardwareRetryCount}), taskId: ${task.taskId}, error: ${error}, try to fallback to software decoder`, cheap__fileName__0, 126);
                    }
                }
                else {
                    task.hardwareRetryCount++;
                    try {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`retry open hardware decoder(${task.hardwareRetryCount}), taskId: ${task.taskId}`, cheap__fileName__0, 132);
                        task.decoderReady = task.hardwareDecoder.open(task.parameters);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`retry open hardware decoder failed, fallback to software decoder, taskId: ${task.taskId}`, cheap__fileName__0, 136);
                    }
                }
                task.needKeyFrame = true;
                task.leftIPCPort.request('requestKeyframe');
            },
            onReceiveFrame(frame) {
                task.firstDecoded = true;
                task.frameCaches.push(frame);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](task.stats + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.stats + 144) + BigInt(1));
                if (task.lastDecodeTimestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](task.stats + 248, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_19__["default"])() - task.lastDecodeTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 248)));
                }
                task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_19__["default"])();
            },
            enableHardwareAcceleration
        });
    }
    createWasmcodecDecoder(task, resource) {
        return new avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_8__["default"]({
            resource: resource,
            onError: (error) => {
                common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`video decode error, taskId: ${task.taskId}, error: ${error}`, cheap__fileName__0, 162);
                if (task.openReject) {
                    task.openReject(avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                    task.openReject = null;
                }
            },
            onReceiveFrame(frame) {
                task.firstDecoded = true;
                task.frameCaches.push(frame);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](task.stats + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](task.stats + 144) + BigInt(1));
                if (task.lastDecodeTimestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](task.stats + 248, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_19__["default"])() - task.lastDecodeTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 248)));
                }
                task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_19__["default"])();
            },
            avframePool: task.avframePool
        });
    }
    async pullAVPacketInternal(task, leftIPCPort) {
        const result = await leftIPCPort.request('pull');
        if (common_util_is__WEBPACK_IMPORTED_MODULE_12__.number(result)) {
            return result;
        }
        else {
            const avpacket = task.avpacketPool.alloc();
            (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_24__.unserializeAVPacket)(result, avpacket);
            return avpacket;
        }
    }
    async createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__["default"](options.leftPort);
        const rightIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__["default"](options.rightPort);
        const frameCaches = [];
        const avframePool = new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_11__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__["default"]), options.avframeListMutex);
        const task = {
            ...options,
            resource: await (0,avutil_function_compileResource__WEBPACK_IMPORTED_MODULE_23__["default"])(options.resource, true),
            leftIPCPort,
            rightIPCPort,
            softwareDecoder: null,
            hardwareDecoder: null,
            frameCaches,
            inputEnd: false,
            targetDecoder: null,
            needKeyFrame: true,
            parameters: 0,
            hardwareRetryCount: 0,
            lastDecodeTimestamp: 0,
            firstDecoded: false,
            decoderReady: null,
            softwareDecoderOpened: false,
            avframePool,
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_16__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__["default"]), options.avpacketListMutex)
        };
        task.softwareDecoder = task.resource
            ? this.createWasmcodecDecoder(task, task.resource)
            : (common_util_support__WEBPACK_IMPORTED_MODULE_21__["default"].videoDecoder ? this.createWebcodecDecoder(task, false) : null);
        if (!task.softwareDecoder) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error('software decoder not support', cheap__fileName__0, 234);
            return avutil_error__WEBPACK_IMPORTED_MODULE_6__.INVALID_OPERATE;
        }
        if (common_util_support__WEBPACK_IMPORTED_MODULE_21__["default"].videoDecoder && options.enableHardware) {
            task.hardwareDecoder = this.createWebcodecDecoder(task);
        }
        task.targetDecoder = task.hardwareDecoder || task.softwareDecoder;
        this.tasks.set(options.taskId, task);
        rightIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_7__.REQUEST, async (request) => {
            switch (request.method) {
                case 'pull': {
                    if (frameCaches.length) {
                        const frame = frameCaches.shift();
                        rightIPCPort.reply(request, frame, null, ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_22__["default"])(frame) || common_util_is__WEBPACK_IMPORTED_MODULE_12__.number(frame)) ? null : [frame]);
                        break;
                    }
                    else if (!task.inputEnd) {
                        while (true) {
                            if (frameCaches.length) {
                                const frame = frameCaches.shift();
                                rightIPCPort.reply(request, frame, null, ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_22__["default"])(frame) || common_util_is__WEBPACK_IMPORTED_MODULE_12__.number(frame)) ? null : [frame]);
                                break;
                            }
                            if (task.decoderReady) {
                                await task.decoderReady;
                                task.decoderReady = null;
                            }
                            const avpacket = await this.pullAVPacketInternal(task, leftIPCPort);
                            if (avpacket === -1048576 /* IOError.END */) {
                                if (task.targetDecoder === task.hardwareDecoder) {
                                    //  flush  2  flush 
                                    let ret = await Promise.race([
                                        new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_14__["default"](2),
                                        task.targetDecoder.flush()
                                    ]);
                                    if (common_util_is__WEBPACK_IMPORTED_MODULE_12__.number(ret)) {
                                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`video hardware decoder flush failed, ignore it, taskId: ${task.taskId}`, cheap__fileName__0, 277);
                                    }
                                }
                                else {
                                    await task.targetDecoder.flush();
                                }
                                task.inputEnd = true;
                                //  flush 
                                if (task.targetDecoder === task.hardwareDecoder) {
                                    await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_14__["default"](0);
                                }
                                if (frameCaches.length) {
                                    const frame = frameCaches.shift();
                                    rightIPCPort.reply(request, frame, null, task.targetDecoder === task.hardwareDecoder ? [frame] : null);
                                    break;
                                }
                                else {
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`video decoder ended, taskId: ${task.taskId}`, cheap__fileName__0, 294);
                                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                                    break;
                                }
                            }
                            else if (avpacket > 0) {
                                if (task.needKeyFrame) {
                                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                                        task.needKeyFrame = false;
                                    }
                                    else {
                                        task.avpacketPool.release(avpacket);
                                        continue;
                                    }
                                }
                                let ret = task.targetDecoder.decode(avpacket);
                                if (ret < 0) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](task.stats + 136, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.stats + 136) + 1);
                                    //  webcodecs 
                                    if ((task.targetDecoder instanceof avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__["default"]) && task.softwareDecoder) {
                                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`video decode error from hardware, taskId: ${task.taskId}, error: ${ret}, try to fallback to software decoder`, cheap__fileName__0, 321);
                                        if (task.targetDecoder === task.hardwareDecoder) {
                                            task.hardwareDecoder.close();
                                            task.hardwareDecoder = null;
                                        }
                                        else if (task.resource) {
                                            task.softwareDecoder.close();
                                            task.softwareDecoder = this.createWasmcodecDecoder(task, task.resource);
                                        }
                                        else {
                                            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`cannot fallback to wasm video decoder because of resource not found , taskId: ${options.taskId}`, cheap__fileName__0, 332);
                                            rightIPCPort.reply(request, avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                                            break;
                                        }
                                        try {
                                            await this.openSoftwareDecoder(task);
                                            task.targetDecoder = task.softwareDecoder;
                                        }
                                        catch (error) {
                                            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`video software decoder open error, taskId: ${options.taskId}`, cheap__fileName__0, 342);
                                            rightIPCPort.reply(request, avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                                            break;
                                        }
                                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                                            ret = task.targetDecoder.decode(avpacket);
                                            if (ret >= 0) {
                                                task.avpacketPool.release(avpacket);
                                                continue;
                                            }
                                            // webcodecs  wasm 
                                            if ((task.targetDecoder instanceof avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__["default"]) && task.resource) {
                                                common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`video decode error width webcodecs soft decoder, taskId: ${task.taskId}, error: ${ret}, try to fallback to wasm software decoder`, cheap__fileName__0, 356);
                                                task.softwareDecoder.close();
                                                task.softwareDecoder = this.createWasmcodecDecoder(task, task.resource);
                                                task.softwareDecoderOpened = false;
                                                try {
                                                    await this.openSoftwareDecoder(task);
                                                    task.targetDecoder = task.softwareDecoder;
                                                }
                                                catch (error) {
                                                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`video wasm software decoder open error, taskId: ${options.taskId}`, cheap__fileName__0, 366);
                                                    rightIPCPort.reply(request, avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                                                    break;
                                                }
                                                ret = task.targetDecoder.decode(avpacket);
                                                if (ret >= 0) {
                                                    task.avpacketPool.release(avpacket);
                                                    continue;
                                                }
                                            }
                                        }
                                        else {
                                            task.avpacketPool.release(avpacket);
                                            task.needKeyFrame = true;
                                            task.leftIPCPort.request('requestKeyframe');
                                            continue;
                                        }
                                    }
                                    task.avpacketPool.release(avpacket);
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`video decode error, taskId: ${options.taskId}, ret: ${ret}`, cheap__fileName__0, 385);
                                    rightIPCPort.reply(request, ret);
                                    break;
                                }
                                task.avpacketPool.release(avpacket);
                                // WebVideoDecoder  EncodedVideoChunk 
                                while (task.targetDecoder instanceof avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__["default"]
                                    && task.targetDecoder.getQueueLength() > 20) {
                                    await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_14__["default"](0);
                                }
                                continue;
                            }
                            else {
                                common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`video decode pull avpacket error, taskId: ${options.taskId}, ret: ${avpacket}`, cheap__fileName__0, 399);
                                rightIPCPort.reply(request, avpacket);
                                break;
                            }
                        }
                        break;
                    }
                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`video decoder ended, taskId: ${task.taskId}`, cheap__fileName__0, 406);
                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                    break;
                }
            }
        });
        return 0;
    }
    async openSoftwareDecoder(task) {
        if (task.softwareDecoder && !task.softwareDecoderOpened) {
            const parameters = task.parameters;
            let threadCount = 1;
            if ((0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_17__["default"])()) {
                let pixels = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 56) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 60);
                let framerate = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_18__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(parameters + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational));
                if (pixels >= 2073600 && pixels <= 2211840) {
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                        threadCount = 2;
                    }
                    if (framerate > 30) {
                        threadCount = 2;
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                            threadCount = 4;
                        }
                    }
                    else if (framerate > 60) {
                        threadCount = 4;
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                            threadCount = 6;
                        }
                    }
                }
                else if (pixels > 2211840 && pixels <= 8294400) {
                    threadCount = 4;
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                        threadCount = 6;
                    }
                }
                else if (pixels > 8294400) {
                    threadCount = 6;
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                        threadCount = 8;
                    }
                }
                threadCount = Math.min(threadCount, navigator.hardwareConcurrency);
            }
            try {
                await task.softwareDecoder.open(parameters, threadCount, task.wasmDecoderOptions);
            }
            catch (error) {
                if ((task.softwareDecoder instanceof avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__["default"]) && task.resource) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`webcodecs software decoder open failed, ${error}, try to fallback to wasm software decoder`, cheap__fileName__0, 477);
                    task.softwareDecoder.close();
                    task.softwareDecoder = this.createWasmcodecDecoder(task, task.resource);
                    await task.softwareDecoder.open(parameters, threadCount);
                    task.targetDecoder = task.softwareDecoder;
                }
                else {
                    throw error;
                }
            }
            task.softwareDecoderOpened = true;
        }
    }
    async reopenDecoder(taskId, parameters, resource, wasmDecoderOptions) {
        const task = this.tasks.get(taskId);
        if (task) {
            const codecpar = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_25__.avMallocz)(168);
            if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_22__["default"])(parameters)) {
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_26__.copyCodecParameters)(codecpar, parameters);
            }
            else {
                (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_24__.unserializeAVCodecParameters)(parameters, codecpar);
            }
            if (task.parameters) {
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_26__.freeCodecParameters)(task.parameters);
            }
            task.parameters = codecpar;
            if (wasmDecoderOptions) {
                task.wasmDecoderOptions = wasmDecoderOptions;
            }
            if (resource) {
                resource = await (0,avutil_function_compileResource__WEBPACK_IMPORTED_MODULE_23__["default"])(resource, true);
            }
            let softwareDecoder;
            if (task.preferWebCodecs && common_util_support__WEBPACK_IMPORTED_MODULE_21__["default"].videoDecoder && avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__["default"].isSupported(codecpar, false)) {
                softwareDecoder = this.createWebcodecDecoder(task, false);
            }
            else {
                softwareDecoder = resource
                    ? this.createWasmcodecDecoder(task, resource)
                    : (common_util_support__WEBPACK_IMPORTED_MODULE_21__["default"].videoDecoder ? this.createWebcodecDecoder(task, false) : null);
            }
            let hardwareDecoder = (common_util_support__WEBPACK_IMPORTED_MODULE_21__["default"].videoDecoder && task.enableHardware)
                ? this.createWebcodecDecoder(task, true)
                : null;
            return new Promise(async (resolve, reject) => {
                task.openReject = resolve;
                if (task.softwareDecoder) {
                    task.softwareDecoder.close();
                }
                if (task.hardwareDecoder) {
                    task.hardwareDecoder.close();
                }
                task.softwareDecoder = softwareDecoder;
                task.hardwareDecoder = hardwareDecoder;
                task.targetDecoder = task.hardwareDecoder || task.softwareDecoder;
                task.hardwareRetryCount = 0;
                if (task.hardwareDecoder) {
                    try {
                        await task.hardwareDecoder.open(codecpar);
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`reopen video hardware decoder, taskId: ${task.taskId}`, cheap__fileName__0, 552);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`cannot reopen hardware decoder, ${error}, taskId: ${task.taskId}`, cheap__fileName__0, 555);
                        task.hardwareDecoder.close();
                        task.hardwareDecoder = null;
                        task.targetDecoder = task.softwareDecoder;
                    }
                }
                if (resource) {
                    task.resource = resource;
                }
                if (task.targetDecoder === task.softwareDecoder) {
                    try {
                        await this.openSoftwareDecoder(task);
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`reopen video soft decoder, taskId: ${task.taskId}`, cheap__fileName__0, 570);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`reopen video software decoder failed, error: ${error}`, cheap__fileName__0, 573);
                        if (!task.hardwareDecoder) {
                            resolve(avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                            return;
                        }
                    }
                }
                resolve(0);
            });
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.fatal('task not found', cheap__fileName__0, 583);
    }
    async open(taskId, parameters, wasmDecoderOptions = {}) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.wasmDecoderOptions = wasmDecoderOptions;
            const codecpar = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_25__.avMallocz)(168);
            if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_22__["default"])(parameters)) {
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_26__.copyCodecParameters)(codecpar, parameters);
            }
            else {
                (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_24__.unserializeAVCodecParameters)(parameters, codecpar);
            }
            if (task.parameters) {
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_26__.freeCodecParameters)(task.parameters);
            }
            task.parameters = codecpar;
            if (task.preferWebCodecs
                && common_util_support__WEBPACK_IMPORTED_MODULE_21__["default"].videoDecoder
                && avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_9__["default"].isSupported(codecpar, false)
                && task.softwareDecoder instanceof avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_8__["default"]) {
                task.softwareDecoder.close();
                const softwareDecoder = this.createWebcodecDecoder(task, false);
                if (task.softwareDecoder === task.targetDecoder) {
                    task.targetDecoder = softwareDecoder;
                }
                task.softwareDecoder = softwareDecoder;
            }
            return new Promise(async (resolve, reject) => {
                task.openReject = resolve;
                if (task.hardwareDecoder) {
                    try {
                        await task.hardwareDecoder.open(codecpar);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`cannot open hardware decoder, ${error}`, cheap__fileName__0, 623);
                        task.hardwareDecoder.close();
                        task.hardwareDecoder = null;
                        task.targetDecoder = task.softwareDecoder;
                    }
                }
                if (task.targetDecoder === task.softwareDecoder) {
                    try {
                        await this.openSoftwareDecoder(task);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`open video software decoder failed, error: ${error}`, cheap__fileName__0, 635);
                        if (!task.hardwareDecoder) {
                            resolve(avutil_error__WEBPACK_IMPORTED_MODULE_6__.CODEC_NOT_SUPPORT);
                            return;
                        }
                    }
                }
                resolve(0);
            });
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.fatal('task not found', cheap__fileName__0, 645);
    }
    async setPlayRate(taskId, rate) {
        const task = this.tasks.get(taskId);
        if (task && task.softwareDecoder) {
            let discard = -16 /* AVDiscard.AVDISCARD_NONE */;
            let framerate = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_18__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(task.parameters + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational));
            if (framerate >= 120) {
                if (rate <= 1) {
                    discard = -16 /* AVDiscard.AVDISCARD_NONE */;
                }
                else if (rate < 1.5) {
                    discard = 8 /* AVDiscard.AVDISCARD_NONREF */;
                }
                else if (rate < 3) {
                    // 
                    discard = 8 /* AVDiscard.AVDISCARD_NONREF */;
                }
                else {
                    // 
                    discard = 32 /* AVDiscard.AVDISCARD_NONKEY */;
                }
            }
            else if (framerate >= 60) {
                if (rate < 1.5) {
                    discard = -16 /* AVDiscard.AVDISCARD_NONE */;
                }
                else if (rate < 3) {
                    discard = 8 /* AVDiscard.AVDISCARD_NONREF */;
                }
                else if (rate < 8) {
                    discard = 24 /* AVDiscard.AVDISCARD_NONINTRA */;
                }
                else {
                    discard = 32 /* AVDiscard.AVDISCARD_NONKEY */;
                }
            }
            else {
                discard = -16 /* AVDiscard.AVDISCARD_NONE */;
            }
            task.softwareDecoder.setSkipFrameDiscard(discard);
        }
    }
    async resetTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.targetDecoder === task.softwareDecoder) {
                await task.targetDecoder.flush();
            }
            // webcodec flush 
            else if (task.targetDecoder === task.hardwareDecoder) {
                task.hardwareDecoder.close();
                task.hardwareDecoder = this.createWebcodecDecoder(task);
                await task.hardwareDecoder.open(task.parameters);
                task.targetDecoder = task.hardwareDecoder;
            }
            common_util_array__WEBPACK_IMPORTED_MODULE_13__.each(task.frameCaches, (frame) => {
                if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_22__["default"])(frame)) {
                    task.avframePool.release(frame);
                }
                else {
                    frame.close();
                }
            });
            task.frameCaches.length = 0;
            task.needKeyFrame = true;
            task.inputEnd = false;
            task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_19__["default"])();
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`reset video decoder, taskId: ${task.taskId}`, cheap__fileName__0, 716);
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_6__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.rightPort.close();
            task.leftPort.close();
            if (task.softwareDecoder) {
                task.softwareDecoder.close();
            }
            if (task.hardwareDecoder) {
                task.hardwareDecoder.close();
            }
            task.frameCaches.forEach((frame) => {
                if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_22__["default"])(frame)) {
                    task.avframePool.release(frame);
                }
                else {
                    frame.close();
                }
            });
            if (task.parameters) {
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_26__.freeCodecParameters)(task.parameters);
            }
            this.tasks.delete(taskId);
        }
    }
    async getTasksInfo() {
        const info = [];
        this.tasks.forEach((task) => {
            info.push({
                codecId: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.parameters + 4),
                width: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.parameters + 56),
                height: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](task.parameters + 60),
                framerate: (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_18__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(task.parameters + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational)),
                hardware: task.targetDecoder === task.hardwareDecoder
            });
        });
        return info;
    }
}


/***/ }),

/***/ "./src/avpipeline/VideoRenderPipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/VideoRenderPipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoRenderPipeline)
/* harmony export */ });
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./..\cheap\std\collection\List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/timer/LoopTask */ "./src/common/timer/LoopTask.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
/* harmony import */ var avrender_image_WebGPURender__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! avrender/image/WebGPURender */ "./src/avrender/image/WebGPURender.ts");
/* harmony import */ var avrender_image_Canvas2dRender__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! avrender/image/Canvas2dRender */ "./src/avrender/image/Canvas2dRender.ts");
/* harmony import */ var avrender_image_WebGPUExternalRender__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! avrender/image/WebGPUExternalRender */ "./src/avrender/image/WebGPUExternalRender.ts");
/* harmony import */ var avrender_image_WebGLYUV8Render__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! avrender/image/WebGLYUV8Render */ "./src/avrender/image/WebGLYUV8Render.ts");
/* harmony import */ var avrender_image_WebGLRGB8Render__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! avrender/image/WebGLRGB8Render */ "./src/avrender/image/WebGLRGB8Render.ts");
/* harmony import */ var avrender_image_WebGLYUV16Render__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! avrender/image/WebGLYUV16Render */ "./src/avrender/image/WebGLYUV16Render.ts");
/* harmony import */ var avrender_image_WebGPUYUV8Render__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! avrender/image/WebGPUYUV8Render */ "./src/avrender/image/WebGPUYUV8Render.ts");
/* harmony import */ var avrender_image_WebGPURGB8Render__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! avrender/image/WebGPURGB8Render */ "./src/avrender/image/WebGPURGB8Render.ts");
/* harmony import */ var avrender_image_WebGPUYUV16Render__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! avrender/image/WebGPUYUV16Render */ "./src/avrender/image/WebGPUYUV16Render.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var common_function_nextTick__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! common/function/nextTick */ "./src/common/function/nextTick.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");
var cheap__fileName__2 = "src\\avpipeline\\VideoRenderPipeline.ts";




/*
 * libmedia VideoRenderPipeline
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



























const WebGPURenderList =  true ? [
    avrender_image_WebGPUYUV8Render__WEBPACK_IMPORTED_MODULE_24__["default"],
    avrender_image_WebGPURGB8Render__WEBPACK_IMPORTED_MODULE_25__["default"]
] : 0;
{
    WebGPURenderList.push(avrender_image_WebGPUYUV16Render__WEBPACK_IMPORTED_MODULE_26__["default"]);
}
const WebGLRenderList = [
    avrender_image_WebGLYUV8Render__WEBPACK_IMPORTED_MODULE_21__["default"],
    avrender_image_WebGLRGB8Render__WEBPACK_IMPORTED_MODULE_22__["default"]
];
{
    WebGLRenderList.push(avrender_image_WebGLYUV16Render__WEBPACK_IMPORTED_MODULE_23__["default"]);
}
var AdjustStatus;
(function (AdjustStatus) {
    AdjustStatus[AdjustStatus["None"] = 0] = "None";
    AdjustStatus[AdjustStatus["Accelerate"] = 1] = "Accelerate";
    AdjustStatus[AdjustStatus["Decelerate"] = 2] = "Decelerate";
})(AdjustStatus || (AdjustStatus = {}));
let disableWebGPU = false;
const HHRPrimaries = ['bt2020', 'bt2100', 'st2048', 'p3-dcl', 'hlg'];
function isHDR(primaries) {
    return common_util_array__WEBPACK_IMPORTED_MODULE_8__.has(HHRPrimaries, primaries);
}
class VideoRenderPipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_4__["default"] {
    constructor() {
        super();
    }
    async createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__["default"](options.leftPort);
        const controlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__["default"](options.controlPort);
        const task = {
            ...options,
            leftIPCPort,
            controlIPCPort,
            render: null,
            currentPTS: avutil_constant__WEBPACK_IMPORTED_MODULE_14__.NOPTS_VALUE_BIGINT,
            firstPTS: BigInt(0),
            startTimestamp: BigInt(0),
            playRate: BigInt(100),
            targetRate: BigInt(100),
            frontFrame: null,
            backFrame: null,
            renderFrame: null,
            renderFrameCount: BigInt(0),
            loop: null,
            renderRedyed: false,
            adjust: AdjustStatus.None,
            adjustDiff: BigInt(0),
            lastAdjustTimestamp: BigInt(0),
            firstRendered: false,
            canvasUpdated: false,
            renderCreating: false,
            renderRecreateCount: 0,
            pauseTimestamp: 0,
            pauseCurrentPts: BigInt(0),
            lastNotifyPTS: BigInt(0),
            skipRender: false,
            isSupport: () => false,
            frontBuffered: false,
            ended: false,
            seeking: false,
            seekSync: null,
            afterPullResolver: null,
            pausing: false,
            lastRenderTimestamp: 0,
            avframePool: new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_9__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_0__["default"]), options.avframeListMutex)
        };
        task.startPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)(task.startPTS, task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_14__.AV_MILLI_TIME_BASE_Q);
        controlIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__.NOTIFY, async (request) => {
            switch (request.method) {
                case 'syncPts': {
                    const targetPTS = request.params.pts;
                    const diff = Math.abs(Number(targetPTS - task.currentPTS));
                    if (diff > 100 && task.currentPTS > BigInt(0)) {
                        if (targetPTS > task.currentPTS) {
                            task.adjust = AdjustStatus.Accelerate;
                            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`video render sync pts accelerate, targetPTS: ${targetPTS}, currentPTS: ${task.currentPTS}, diff: ${diff}, taskId: ${task.taskId}`, cheap__fileName__2, 236);
                        }
                        else {
                            task.adjust = AdjustStatus.Decelerate;
                            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`video render sync pts decelerate, targetPTS: ${targetPTS}, currentPTS: ${task.currentPTS}, diff: ${diff} taskId: ${task.taskId}`, cheap__fileName__2, 240);
                        }
                        task.adjustDiff = BigInt(Math.floor(diff));
                    }
                    break;
                }
                case 'skipRender': {
                    task.skipRender = request.params.skipRender;
                    break;
                }
            }
        });
        this.tasks.set(options.taskId, task);
        return 0;
    }
    swap(task) {
        if (task.seeking) {
            return;
        }
        if (task.backFrame) {
            if (!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.backFrame)) {
                task.backFrame.close();
            }
            else {
                task.avframePool.release(task.backFrame);
            }
        }
        task.backFrame = null;
        if (task.frontBuffered) {
            task.backFrame = task.frontFrame;
            task.frontFrame = null;
        }
        else {
            return false;
        }
        if (task.ended) {
            return;
        }
        task.frontBuffered = false;
        const now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])();
        task.leftIPCPort.request('pull').then((frame) => {
            if (task.afterPullResolver) {
                task.afterPullResolver();
            }
            if (common_util_is__WEBPACK_IMPORTED_MODULE_7__.number(frame) && frame < 0) {
                task.ended = true;
                task.frontFrame = null;
                return;
            }
            const cost = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])() - now;
            //  1 
            if (cost > 1000) {
                task.startTimestamp += BigInt(Math.floor(cost));
            }
            task.frontFrame = frame;
            task.frontBuffered = true;
            if (task.seekSync) {
                task.seekSync();
                task.seekSync = null;
                return;
            }
            if (!task.backFrame) {
                this.swap(task);
            }
        });
        return true;
    }
    async createRender(task, frame, fallback = false) {
        if (task.renderCreating) {
            return;
        }
        task.renderCreating = true;
        task.renderRedyed = false;
        if (task.render) {
            task.render.destroy();
        }
        if (!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(frame)) {
            if ( true && task.enableWebGPU
                && common_util_support__WEBPACK_IMPORTED_MODULE_10__["default"].webgpu
                && !disableWebGPU
                && (
                // chrome116+ webgpu  VideoFrame 
                (common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].chrome || common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].newEdge) && common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].majorVersion, '116', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].majorVersion, '17.4', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_15__["default"].majorVersion, '129', true))
                && !isHDR(frame.colorSpace.primaries)) {
                // WebGPUExternalRender 
                task.render = new avrender_image_WebGPUExternalRender__WEBPACK_IMPORTED_MODULE_20__["default"](task.canvas, {
                    devicePixelRatio: task.devicePixelRatio,
                    renderMode: task.renderMode,
                    onRenderContextLost: () => {
                        task.canvasUpdated = false;
                        task.renderRedyed = false;
                        common_util_logger__WEBPACK_IMPORTED_MODULE_16__.warn('render context lost', cheap__fileName__2, 344);
                        task.controlIPCPort.notify('updateCanvas');
                    }
                });
                task.isSupport = avrender_image_WebGPUExternalRender__WEBPACK_IMPORTED_MODULE_20__["default"].isSupport;
            }
            else {
                // CanvasImageRender  hdr 
                task.render = new avrender_image_Canvas2dRender__WEBPACK_IMPORTED_MODULE_19__["default"](task.canvas, {
                    devicePixelRatio: task.devicePixelRatio,
                    renderMode: task.renderMode
                });
                task.isSupport = avrender_image_Canvas2dRender__WEBPACK_IMPORTED_MODULE_19__["default"].isSupport;
            }
        }
        else {
            //  webgpuwebgpu  webgl
            if ( true && task.enableWebGPU
                && common_util_support__WEBPACK_IMPORTED_MODULE_10__["default"].webgpu
                && !disableWebGPU) {
                common_util_array__WEBPACK_IMPORTED_MODULE_8__.each(WebGPURenderList, (RenderFactory) => {
                    if (RenderFactory.isSupport(frame)) {
                        task.render = new RenderFactory(task.canvas, {
                            devicePixelRatio: task.devicePixelRatio,
                            renderMode: task.renderMode,
                            onRenderContextLost: () => {
                                task.canvasUpdated = false;
                                task.renderRedyed = false;
                                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.warn('render context lost', cheap__fileName__2, 374);
                                task.controlIPCPort.notify('updateCanvas');
                            }
                        });
                        task.isSupport = RenderFactory.isSupport;
                        return false;
                    }
                });
            }
            else {
                common_util_array__WEBPACK_IMPORTED_MODULE_8__.each(WebGLRenderList, (RenderFactory) => {
                    if (RenderFactory.isSupport(frame)) {
                        task.render = new RenderFactory(task.canvas, {
                            devicePixelRatio: task.devicePixelRatio,
                            renderMode: task.renderMode,
                            onRenderContextLost: () => {
                                task.canvasUpdated = false;
                                task.renderRedyed = false;
                                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.warn('render context lost', cheap__fileName__2, 392);
                                task.controlIPCPort.notify('updateCanvas');
                            }
                        });
                        task.isSupport = RenderFactory.isSupport;
                        return false;
                    }
                });
            }
        }
        if (!task.render) {
            task.renderCreating = false;
            return;
        }
        try {
            await task.render.init();
            task.render.viewport(task.viewportWidth, task.viewportHeight);
            task.render.setRotate(task.renderRotate ?? 0);
            task.render.enableHorizontalFlip(task.flipHorizontal ?? false);
            task.render.enableVerticalFlip(task.flipVertical ?? false);
            task.render.render(frame);
            task.render.clear();
        }
        catch (error) {
            if (task.render instanceof avrender_image_WebGPURender__WEBPACK_IMPORTED_MODULE_18__["default"] && !fallback) {
                disableWebGPU = true;
                task.renderCreating = false;
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.warn('not support webgpu render, try to fallback to webgl render', cheap__fileName__2, 420);
                return this.createRender(task, frame, true);
            }
            else if (fallback) {
                task.renderCreating = false;
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.warn('canvas context lost after fallback, wait for recreate canvas', cheap__fileName__2, 425);
                if (task.renderRecreateCount < 3) {
                    task.renderRecreateCount++;
                    task.controlIPCPort.notify('updateCanvas');
                    return;
                }
                throw error;
            }
        }
        task.renderRedyed = true;
        task.renderCreating = false;
        task.renderRecreateCount = 0;
    }
    async play(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.fatal('task has already call play', cheap__fileName__2, 443);
            }
            task.backFrame = await task.leftIPCPort.request('pull');
            if (common_util_is__WEBPACK_IMPORTED_MODULE_7__.number(task.backFrame) && task.backFrame < 0) {
                task.backFrame = 0;
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.info(`video render ended, taskId: ${task.taskId}`, cheap__fileName__2, 450);
                task.controlIPCPort.notify('ended');
                return;
            }
            task.frontFrame = await task.leftIPCPort.request('pull');
            task.frontBuffered = true;
            task.ended = false;
            if (common_util_is__WEBPACK_IMPORTED_MODULE_7__.number(task.frontFrame) && task.frontFrame < 0) {
                task.ended = true;
                task.frontBuffered = false;
                task.frontFrame = 0;
            }
            await this.createRender(task, task.backFrame);
            task.firstPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)((!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_14__.AV_MILLI_TIME_BASE_Q);
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`got first video frame, pts: ${!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.backFrame)
                ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104)}(${task.firstPTS}ms), taskId: ${task.taskId}`, cheap__fileName__2, 474);
            //  pts  1000ms  0 
            if (task.firstPTS < BigInt(1000)) {
                task.firstPTS = BigInt(0);
            }
            task.currentPTS = task.firstPTS;
            task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - task.firstPTS * BigInt(100) / task.playRate;
            const inWorker = (0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_27__["default"])();
            const interval = (inWorker && common_util_support__WEBPACK_IMPORTED_MODULE_10__["default"].shareArrayBuffer) ? 0 : 10;
            task.loop = new common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_11__["default"](() => {
                if (!task.backFrame) {
                    if (!task.ended) {
                        task.loop.emptyTask();
                    }
                    else {
                        if (task.render && task.renderRedyed) {
                            task.render.clear();
                        }
                        task.loop.stop();
                        task.adjust = AdjustStatus.None;
                        common_util_logger__WEBPACK_IMPORTED_MODULE_16__.info(`video render ended, taskId: ${task.taskId}`, cheap__fileName__2, 502);
                        task.controlIPCPort.notify('ended');
                    }
                    return;
                }
                if (!task.isSupport(task.backFrame)) {
                    if (task.render) {
                        task.renderRedyed = false;
                        task.renderFrame = task.backFrame;
                        task.controlIPCPort.notify('updateCanvas');
                        return;
                    }
                    else {
                        this.createRender(task, task.backFrame);
                    }
                }
                const pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)((!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_14__.AV_MILLI_TIME_BASE_Q);
                if (pts < task.currentPTS) {
                    //  5s 
                    if (task.currentPTS - pts > BigInt(5000)) {
                        task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - (pts * BigInt(100) / task.targetRate);
                    }
                    else {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_16__.warn(`dropping frame with pts ${pts}, which is earlier then the last rendered frame(${task.currentPTS}), taskId: ${task.taskId}`, cheap__fileName__2, 532);
                        this.swap(task);
                        return;
                    }
                }
                //  5s 
                else if (pts - task.currentPTS > BigInt(5000)) {
                    task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - (pts * BigInt(100) / task.targetRate);
                }
                if (task.adjust === AdjustStatus.Accelerate) {
                    if (task.adjustDiff <= 0) {
                        task.adjust = AdjustStatus.None;
                        task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - (pts * BigInt(100) / task.targetRate);
                        task.lastAdjustTimestamp = BigInt(0);
                    }
                    else {
                        if (BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - task.lastAdjustTimestamp >= BigInt(200)) {
                            const sub = task.adjustDiff <= BigInt(100)
                                ? task.adjustDiff
                                : common_util_bigint__WEBPACK_IMPORTED_MODULE_17__.min(task.adjustDiff, BigInt(100)) * BigInt(100) / task.targetRate;
                            task.startTimestamp -= sub;
                            task.adjustDiff -= sub;
                            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`video render accelerate startTimestamp sub: ${sub}, taskId: ${task.taskId}`, cheap__fileName__2, 557);
                            task.lastAdjustTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])()));
                        }
                    }
                }
                else if (task.adjust === AdjustStatus.Decelerate) {
                    if (task.adjustDiff <= 0) {
                        task.adjust = AdjustStatus.None;
                        task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - (pts * BigInt(100) / task.targetRate);
                        task.lastAdjustTimestamp = BigInt(0);
                    }
                    else {
                        if (BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - task.lastAdjustTimestamp >= BigInt(300)) {
                            const add = task.adjustDiff < BigInt(50)
                                ? task.adjustDiff
                                : common_util_bigint__WEBPACK_IMPORTED_MODULE_17__.min(task.adjustDiff, BigInt(50)) * BigInt(100) / task.targetRate;
                            task.startTimestamp += add;
                            task.adjustDiff -= add;
                            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`video render decelerate startTimestamp add: ${add}, taskId: ${task.taskId}`, cheap__fileName__2, 578);
                            task.lastAdjustTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])()));
                        }
                    }
                }
                if (task.enableJitterBuffer) {
                    let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 120) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 224) * 1000;
                    if (buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 272)) {
                        this.setPlayRate(task.taskId, 1);
                    }
                }
                const diff = pts * BigInt(100) / task.playRate + task.startTimestamp - BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])()));
                if (diff <= 0) {
                    // 
                    if (task.renderRedyed
                        && !task.skipRender
                        && (inWorker || (-diff < BigInt(100)) || (task.renderFrameCount & BigInt(0x01)))) {
                        task.render.render(task.backFrame);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 328, pts);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 160, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.stats + 160) + BigInt(1));
                        if (task.lastRenderTimestamp) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 252, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])() - task.lastRenderTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 252)));
                        }
                        task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])();
                    }
                    else {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 168, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 168) + 1);
                    }
                    task.renderFrameCount++;
                    if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.backFrame)) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 84, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.backFrame + 68));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 88, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.backFrame + 72));
                    }
                    else {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 84, task.backFrame.displayWidth);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 88, task.backFrame.displayHeight);
                    }
                    if (!task.firstRendered) {
                        task.controlIPCPort.notify(task.canvasUpdated ? 'firstRenderedAfterUpdateCanvas' : 'firstRendered');
                        task.firstRendered = true;
                        task.canvasUpdated = false;
                    }
                    if (task.playRate !== task.targetRate) {
                        task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - (pts * BigInt(100) / task.targetRate);
                        task.playRate = task.targetRate;
                    }
                    task.currentPTS = pts;
                    if (pts - task.lastNotifyPTS >= BigInt(1000)) {
                        task.lastNotifyPTS = pts;
                        task.controlIPCPort.notify('syncPts', {
                            pts
                        });
                    }
                    this.swap(task);
                }
                else {
                    task.loop.emptyTask();
                }
            }, 0, interval);
            task.loop.start();
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.fatal('task not found', cheap__fileName__2, 650);
        }
    }
    async restart(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (!task.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.fatal('task has not played', cheap__fileName__2, 658);
            }
            if (task.loop.isStarted()) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.fatal('task has already run', cheap__fileName__2, 662);
            }
            if (task.backFrame) {
                if (!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.backFrame)) {
                    task.backFrame.close();
                }
                else {
                    task.avframePool.release(task.backFrame);
                }
            }
            if (task.frontFrame) {
                if (!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.frontFrame)) {
                    task.frontFrame.close();
                }
                else {
                    task.avframePool.release(task.frontFrame);
                }
            }
            task.backFrame = await task.leftIPCPort.request('pull');
            task.frontFrame = await task.leftIPCPort.request('pull');
            task.frontBuffered = true;
            task.ended = false;
            task.adjust = AdjustStatus.None;
            task.lastNotifyPTS = avutil_constant__WEBPACK_IMPORTED_MODULE_14__.NOPTS_VALUE_BIGINT;
            task.firstRendered = false;
            task.firstPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)((!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_14__.AV_MILLI_TIME_BASE_Q);
            task.currentPTS = task.firstPTS;
            //  pts  1000ms  0 
            if (task.firstPTS < BigInt(1000)) {
                task.firstPTS = BigInt(0);
            }
            task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - task.firstPTS * BigInt(100) / task.playRate;
            task.loop.start();
        }
    }
    async pause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (!task.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.fatal('task has not played', cheap__fileName__2, 713);
            }
            task.pauseTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])();
            task.pauseCurrentPts = task.currentPTS;
            task.loop.stop();
            task.pausing = true;
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.info(`task paused, taskId: ${task.taskId}`, cheap__fileName__2, 720);
        }
    }
    async unpause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.seeking) {
                return;
            }
            if (!task.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.fatal('task has not played', cheap__fileName__2, 731);
            }
            task.startTimestamp += BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])() - task.pauseTimestamp));
            task.startTimestamp -= task.currentPTS - task.pauseCurrentPts;
            if (!task.seeking) {
                task.loop.start();
            }
            task.pausing = false;
            task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])();
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.info(`task unpaused, taskId: ${task.taskId}`, cheap__fileName__2, 741);
        }
    }
    async updateCanvas(taskId, canvas) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.canvas = canvas;
            if (task.render) {
                task.render.destroy();
                task.render = null;
            }
            task.isSupport = () => false;
            task.canvasUpdated = true;
            task.firstRendered = false;
            task.renderRedyed = false;
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.fatal('task not found', cheap__fileName__2, 759);
        }
    }
    async setPlayRate(taskId, rate) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.enableJitterBuffer) {
                let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 120) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 224) * 1000;
                if (buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 272)) {
                    rate = 1;
                }
            }
            task.targetRate = BigInt(Math.floor(Math.floor(rate * 100)));
        }
    }
    async setRenderMode(taskId, mode) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.render) {
                task.renderMode = mode;
                task.render.setRenderMode(mode);
                (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_28__["default"])(() => {
                    if (task.pausing && task.backFrame && task.render) {
                        task.render.render(task.backFrame);
                    }
                });
            }
        }
    }
    async setRenderRotate(taskId, rotate) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.render) {
                task.renderRotate = rotate;
                task.render.setRotate(rotate);
                (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_28__["default"])(() => {
                    if (task.pausing && task.backFrame && task.render) {
                        task.render.render(task.backFrame);
                    }
                });
            }
        }
    }
    async enableHorizontalFlip(taskId, enable) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.render) {
                task.flipHorizontal = enable;
                task.render.enableHorizontalFlip(enable);
                (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_28__["default"])(() => {
                    if (task.pausing && task.backFrame && task.render) {
                        task.render.render(task.backFrame);
                    }
                });
            }
        }
    }
    async enableVerticalFlip(taskId, enable) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.render) {
                task.flipVertical = enable;
                task.render.enableVerticalFlip(enable);
                (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_28__["default"])(() => {
                    if (task.pausing && task.backFrame && task.render) {
                        task.render.render(task.backFrame);
                    }
                });
            }
        }
    }
    async resize(taskId, width, height) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.render) {
                task.render.viewport(width, height);
                (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_28__["default"])(() => {
                    if (task.pausing && task.backFrame && task.render) {
                        task.render.render(task.backFrame);
                    }
                });
            }
        }
    }
    async setSkipRender(taskId, skip) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.skipRender = skip;
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 252, 0);
            task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])();
        }
    }
    async beforeSeek(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            //  pull frontFrame
            if (!task.ended && !task.frontBuffered) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`wait current pull front frame before seek, taskId: ${task.taskId}`, cheap__fileName__2, 864);
                await new Promise((resolve) => {
                    task.seekSync = resolve;
                });
            }
            task.seeking = true;
            task.loop.stop();
            if (task.backFrame) {
                if (!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.backFrame)) {
                    task.backFrame.close();
                }
                else {
                    task.avframePool.release(task.backFrame);
                }
            }
            if (task.frontFrame) {
                if (!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.frontFrame)) {
                    task.frontFrame.close();
                }
                else {
                    task.avframePool.release(task.frontFrame);
                }
            }
            task.frontFrame = null;
            task.backFrame = null;
            task.currentPTS = avutil_constant__WEBPACK_IMPORTED_MODULE_14__.NOPTS_VALUE_BIGINT;
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`before seek end, taskId: ${task.taskId}`, cheap__fileName__2, 892);
        }
    }
    async syncSeekTime(taskId, timestamp, maxQueueLength) {
        const task = this.tasks.get(taskId);
        if (task) {
            while (true) {
                task.backFrame = await task.leftIPCPort.request('pull');
                if (common_util_is__WEBPACK_IMPORTED_MODULE_7__.number(task.backFrame) && task.backFrame < 0) {
                    task.ended = true;
                    task.seeking = false;
                    task.adjust = AdjustStatus.None;
                    task.backFrame = null;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_16__.warn(`pull video frame end after seek, taskId: ${taskId}`, cheap__fileName__2, 908);
                    task.controlIPCPort.notify('ended');
                    return;
                }
                if (timestamp < BigInt(0)) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_16__.info(`use the first video frame because of the seek time${timestamp} < 0`, cheap__fileName__2, 914);
                    break;
                }
                const pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)((!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_14__.AV_MILLI_TIME_BASE_Q);
                if (pts - task.startPTS >= timestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 328, pts);
                    break;
                }
                if (!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.backFrame)) {
                    task.backFrame.close();
                }
                else {
                    task.avframePool.release(task.backFrame);
                }
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`sync seek time end, taskId: ${task.taskId}`, cheap__fileName__2, 942);
        }
    }
    async afterSeek(taskId, timestamp) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.ended) {
                return;
            }
            task.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])())) - (timestamp + task.startPTS) * BigInt(100) / task.playRate;
            task.frontFrame = await task.leftIPCPort.request('pull');
            if (common_util_is__WEBPACK_IMPORTED_MODULE_7__.number(task.frontFrame) && task.frontFrame < 0) {
                task.frontFrame = null;
                task.frontBuffered = false;
                task.ended = true;
            }
            else {
                task.frontBuffered = true;
            }
            task.ended = false;
            task.adjust = AdjustStatus.None;
            task.lastRenderTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])();
            task.currentPTS = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)((!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_14__.AV_MILLI_TIME_BASE_Q);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 328, task.currentPTS);
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`got first video frame, pts: ${!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.backFrame)
                ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104)}(${task.currentPTS}ms), taskId: ${task.taskId}`, cheap__fileName__2, 977);
            task.seeking = false;
            if (!task.pausing) {
                task.loop.start();
            }
            else if (task.backFrame) {
                task.render.render(task.backFrame);
                // reset pause time
                task.pauseCurrentPts = task.currentPTS;
                task.pauseTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_12__["default"])();
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_16__.debug(`after seek end, taskId: ${task.taskId}`, cheap__fileName__2, 993);
        }
    }
    async renderNextFrame(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.backFrame) {
                const pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_13__.avRescaleQ)((!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.backFrame)) ? BigInt(Math.floor(task.backFrame.timestamp)) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.backFrame + 104), task.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_14__.AV_MILLI_TIME_BASE_Q);
                task.render.render(task.backFrame);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 328, pts);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 160, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.stats + 160) + BigInt(1));
                task.currentPTS = pts;
                this.swap(task);
            }
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_5__.INVALID_OPERATE;
        }
        return await this.createTask(options);
    }
    async unregisterTask(id) {
        const task = this.tasks.get(id);
        if (task) {
            const started = !!task.loop;
            if (task.loop) {
                await task.loop.stopBeforeNextTick();
                task.loop.destroy();
                task.loop = null;
            }
            if (started && !task.ended && !task.frontFrame) {
                await new Promise((resolve) => {
                    task.afterPullResolver = resolve;
                });
            }
            if (task.render) {
                task.render.destroy();
                task.render = null;
            }
            if (task.backFrame) {
                if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.backFrame) && task.backFrame > 0) {
                    task.avframePool.release(task.backFrame);
                }
                else {
                    task.backFrame.close();
                }
                task.backFrame = null;
            }
            if (task.frontFrame) {
                if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_29__["default"])(task.frontFrame) && task.frontFrame > 0) {
                    task.avframePool.release(task.frontFrame);
                }
                else {
                    task.frontFrame.close();
                }
                task.frontFrame = null;
            }
            task.leftIPCPort.destroy();
            task.controlIPCPort.destroy();
            this.tasks.delete(id);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/struct/stats.ts":
/*!****************************************!*\
  !*** ./src/avpipeline/struct/stats.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Stats)
/* harmony export */ });
/* unused harmony export JitterBuffer */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia stats struct defined
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class JitterBuffer {
    min;
    max;
}
(function (prototype) {
    var map = new Map();
    map.set("min", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("max", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(JitterBuffer.prototype);
class Stats {
    /**
     * 
     */
    channels;
    /**
     * 
     */
    sampleRate;
    /**
     * 
     */
    audioFrameSize;
    /**
     * 
     */
    audioPacketBytes;
    /**
     * 
     */
    audioPacketCount;
    /**
     * 
     */
    audioPacketQueueLength;
    /**
     * 
     */
    audioDropPacketCount;
    /**
     * 
     */
    audioDecodeErrorPacketCount;
    /**
     * 
     */
    audioEncodeErrorFrameCount;
    /**
     * 
     */
    audioFrameDecodeCount;
    /**
     * 
     */
    audioPacketEncodeCount;
    /**
     * 
     */
    audioFrameRenderCount;
    /**
     * 
     */
    audioFrameDropCount;
    /**
     * 
     */
    width;
    /**
     * 
     */
    height;
    /**
     * 
     */
    keyFrameInterval;
    /**
     *  gop 
     */
    gop;
    /**
     * 
     */
    videoPacketBytes;
    /**
     * 
     */
    videoPacketCount;
    /**
     * 
     */
    videoPacketQueueLength;
    /**
     * 
     */
    videoDropPacketCount;
    /**
     * 
     */
    videoDecodeErrorPacketCount;
    /**
     * 
     */
    videoEncodeErrorFrameCount;
    /**
     * 
     */
    videoFrameDecodeCount;
    /**
     * 
     */
    videoPacketEncodeCount;
    /**
     * 
     */
    videoFrameRenderCount;
    /**
     * 
     */
    videoFrameDropCount;
    /**
     * 
     */
    keyFrameCount;
    /**
     * buffer 
     */
    bufferDropBytes;
    /**
     * buffer 
     */
    bufferReceiveBytes;
    /**
     * buffer 
     *
     */
    bufferOutputBytes;
    /**
     * 
     */
    audioBitrate;
    /**
     * 
     */
    videoBitrate;
    /**
     * 
     */
    videoDecodeFramerate;
    /**
     * 
     */
    videoRenderFramerate;
    /**
     *  dts 
     */
    videoEncodeFramerate;
    /**
     * 
     */
    audioDecodeFramerate;
    /**
     * 
     */
    audioRenderFramerate;
    /**
     *  dts 
     */
    audioEncodeFramerate;
    /**
     * 
     */
    audioFrameDecodeIntervalMax;
    /**
     * 
     */
    audioFrameRenderIntervalMax;
    /**
     * 
     */
    videoFrameDecodeIntervalMax;
    /**
     * 
     */
    videoFrameRenderIntervalMax;
    /**
     * 
     */
    bandwidth;
    /**
     * 
     */
    jitter;
    /**
     * jitter buffer
     */
    jitterBuffer;
    /**
     * 
     */
    audioStutter;
    /**
     * 
     */
    videoStutter;
    /**
     *  codec string
     */
    audiocodec;
    /**
     *  codec string
     */
    videocodec;
    /**
     *  audio mux dts
     */
    firstAudioMuxDts;
    /**
     *  audio mux dts
     */
    lastAudioMuxDts;
    /**
     *  audio mux dts
     */
    firstVideoMuxDts;
    /**
     *  video mux dts
     */
    lastVideoMuxDts;
    /**
     * 
     */
    audioCurrentTime;
    /**
     * 
     */
    videoCurrentTime;
}
(function (prototype) {
    var map = new Map();
    map.set("channels", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("sampleRate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("audioFrameSize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("audioPacketBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("audioPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("audioPacketQueueLength", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    map.set("audioDropPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 40, 8: 0 });
    map.set("audioDecodeErrorPacketCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 48, 8: 0 });
    map.set("audioEncodeErrorFrameCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 52, 8: 0 });
    map.set("audioFrameDecodeCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 56, 8: 0 });
    map.set("audioPacketEncodeCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("audioFrameRenderCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("audioFrameDropCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    map.set("width", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 84, 8: 0 });
    map.set("height", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 88, 8: 0 });
    map.set("keyFrameInterval", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 92, 8: 0 });
    map.set("gop", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 96, 8: 0 });
    map.set("videoPacketBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 104, 8: 0 });
    map.set("videoPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 112, 8: 0 });
    map.set("videoPacketQueueLength", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 120, 8: 0 });
    map.set("videoDropPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 128, 8: 0 });
    map.set("videoDecodeErrorPacketCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 136, 8: 0 });
    map.set("videoEncodeErrorFrameCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 140, 8: 0 });
    map.set("videoFrameDecodeCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 144, 8: 0 });
    map.set("videoPacketEncodeCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 152, 8: 0 });
    map.set("videoFrameRenderCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 160, 8: 0 });
    map.set("videoFrameDropCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 168, 8: 0 });
    map.set("keyFrameCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 176, 8: 0 });
    map.set("bufferDropBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 184, 8: 0 });
    map.set("bufferReceiveBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 192, 8: 0 });
    map.set("bufferOutputBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 200, 8: 0 });
    map.set("audioBitrate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 208, 8: 0 });
    map.set("videoBitrate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 212, 8: 0 });
    map.set("videoDecodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 216, 8: 0 });
    map.set("videoRenderFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 220, 8: 0 });
    map.set("videoEncodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 224, 8: 0 });
    map.set("audioDecodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 228, 8: 0 });
    map.set("audioRenderFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 232, 8: 0 });
    map.set("audioEncodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 236, 8: 0 });
    map.set("audioFrameDecodeIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 240, 8: 0 });
    map.set("audioFrameRenderIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 244, 8: 0 });
    map.set("videoFrameDecodeIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 248, 8: 0 });
    map.set("videoFrameRenderIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 252, 8: 0 });
    map.set("bandwidth", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 256, 8: 0 });
    map.set("jitter", { 0: 19, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 264, 8: 0 });
    map.set("jitterBuffer", { 0: JitterBuffer, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 272, 8: 0 });
    map.set("audioStutter", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 280, 8: 0 });
    map.set("videoStutter", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 284, 8: 0 });
    map.set("firstAudioMuxDts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 288, 8: 0 });
    map.set("lastAudioMuxDts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 296, 8: 0 });
    map.set("firstVideoMuxDts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 304, 8: 0 });
    map.set("lastVideoMuxDts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 312, 8: 0 });
    map.set("audioCurrentTime", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 320, 8: 0 });
    map.set("videoCurrentTime", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 328, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 336);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(Stats.prototype);


/***/ }),

/***/ "./src/avplayer/AVPlayer.ts":
/*!**********************************!*\
  !*** ./src/avplayer/AVPlayer.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVPlayerSupportedCodecs: () => (/* binding */ AVPlayerSupportedCodecs),
/* harmony export */   "default": () => (/* binding */ AVPlayer)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _struct_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./struct.ts */ "./src/avplayer/struct.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _avutil_struct_avcodecparameters_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./..\avutil\struct\avcodecparameters.ts */ "./src/avutil/struct/avcodecparameters.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var avpipeline_IOPipeline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avpipeline/IOPipeline */ "./src/avpipeline/IOPipeline.ts");
/* harmony import */ var avpipeline_DemuxPipeline__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avpipeline/DemuxPipeline */ "./src/avpipeline/DemuxPipeline.ts");
/* harmony import */ var avpipeline_VideoDecodePipeline__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avpipeline/VideoDecodePipeline */ "./src/avpipeline/VideoDecodePipeline.ts");
/* harmony import */ var avpipeline_AudioDecodePipeline__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avpipeline/AudioDecodePipeline */ "./src/avpipeline/AudioDecodePipeline.ts");
/* harmony import */ var cheap_thread_thread__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! cheap/thread/thread */ "./src/cheap/thread/thread.ts");
/* harmony import */ var common_event_Emitter__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/event/Emitter */ "./src/common/event/Emitter.ts");
/* harmony import */ var common_function_generateUUID__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! common/function/generateUUID */ "./src/common/function/generateUUID.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! cheap/webassembly/compiler */ "./src/cheap/webassembly/compiler.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avpipeline_AudioRenderPipeline__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! avpipeline/AudioRenderPipeline */ "./src/avpipeline/AudioRenderPipeline.ts");
/* harmony import */ var avpipeline_VideoRenderPipeline__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! avpipeline/VideoRenderPipeline */ "./src/avpipeline/VideoRenderPipeline.ts");
/* harmony import */ var common_util_url__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! common/util/url */ "./src/common/util/url.ts");
/* harmony import */ var cheap_config__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! cheap/config */ "./src/cheap/config.ts");
/* harmony import */ var avrender_pcm_audioWorklet_base_registerProcessor__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! avrender/pcm/audioWorklet/base/registerProcessor */ "./src/avrender/pcm/audioWorklet/base/registerProcessor.ts");
/* harmony import */ var avrender_pcm_AudioSourceWorkletNode__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! avrender/pcm/AudioSourceWorkletNode */ "./src/avrender/pcm/AudioSourceWorkletNode.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var _Controller__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./Controller */ "./src/avplayer/Controller.ts");
/* harmony import */ var _eventType__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var _function_supportOffscreenCanvas__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./function/supportOffscreenCanvas */ "./src/avplayer/function/supportOffscreenCanvas.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var avrender_pcm_AudioSourceBufferNode__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! avrender/pcm/AudioSourceBufferNode */ "./src/avrender/pcm/AudioSourceBufferNode.ts");
/* harmony import */ var common_function_restrain__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! common/function/restrain */ "./src/common/function/restrain.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avpipeline_struct_stats__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! avpipeline/struct/stats */ "./src/avpipeline/struct/stats.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _function_createMessageChannel__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./function/createMessageChannel */ "./src/avplayer/function/createMessageChannel.ts");
/* harmony import */ var avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! avcodec/function/getVideoCodec */ "./src/avcodec/function/getVideoCodec.ts");
/* harmony import */ var avrender_track_function_getVideoMimeType__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! avrender/track/function/getVideoMimeType */ "./src/avrender/track/function/getVideoMimeType.ts");
/* harmony import */ var avrender_track_function_getAudioMimeType__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! avrender/track/function/getAudioMimeType */ "./src/avrender/track/function/getAudioMimeType.ts");
/* harmony import */ var _mse_MSEPipeline__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./mse/MSEPipeline */ "./src/avplayer/mse/MSEPipeline.ts");
/* harmony import */ var avcodec_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! avcodec/function/getHardwarePreference */ "./src/avcodec/function/getHardwarePreference.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var _StatsController__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./StatsController */ "./src/avplayer/StatsController.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
/* harmony import */ var _function_getMediaSource__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./function/getMediaSource */ "./src/avplayer/function/getMediaSource.ts");
/* harmony import */ var _JitterBufferController__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./JitterBufferController */ "./src/avplayer/JitterBufferController.ts");
/* harmony import */ var avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! avcodec/function/getAudioCodec */ "./src/avcodec/function/getAudioCodec.ts");
/* harmony import */ var avutil_stringEnum__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! avutil/stringEnum */ "./src/avutil/stringEnum.ts");
/* harmony import */ var avformat_dump__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! avformat/dump */ "./src/avformat/dump.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_function_isHdr__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! avutil/function/isHdr */ "./src/avutil/function/isHdr.ts");
/* harmony import */ var avutil_function_hasAlphaChannel__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! avutil/function/hasAlphaChannel */ "./src/avutil/function/hasAlphaChannel.ts");
/* harmony import */ var _subtitle_SubtitleRender__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./subtitle/SubtitleRender */ "./src/avplayer/subtitle/SubtitleRender.ts");
/* harmony import */ var avutil_function_compileResource__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! avutil/function/compileResource */ "./src/avutil/function/compileResource.ts");
/* harmony import */ var common_util_os__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! common/util/os */ "./src/common/util/os.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var avnetwork_ioLoader_FetchIOLoader__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! avnetwork/ioLoader/FetchIOLoader */ "./src/avnetwork/ioLoader/FetchIOLoader.ts");
/* harmony import */ var avnetwork_ioLoader_FileIOLoader__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! avnetwork/ioLoader/FileIOLoader */ "./src/avnetwork/ioLoader/FileIOLoader.ts");
/* harmony import */ var avnetwork_ioLoader_CustomIOLoader__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! avnetwork/ioLoader/CustomIOLoader */ "./src/avnetwork/ioLoader/CustomIOLoader.ts");
/* harmony import */ var avutil_util_serialize__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! avutil/util/serialize */ "./src/avutil/util/serialize.ts");
/* harmony import */ var _worker_IODemuxPipelineProxy__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./worker/IODemuxPipelineProxy */ "./src/avplayer/worker/IODemuxPipelineProxy.ts");
/* harmony import */ var _worker_AudioPipelineProxy__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./worker/AudioPipelineProxy */ "./src/avplayer/worker/AudioPipelineProxy.ts");
/* harmony import */ var _worker_VideoPipelineProxy__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./worker/VideoPipelineProxy */ "./src/avplayer/worker/VideoPipelineProxy.ts");
/* harmony import */ var _worker_MSEPipelineProxy__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./worker/MSEPipelineProxy */ "./src/avplayer/worker/MSEPipelineProxy.ts");
var cheap__fileName__5 = "src\\avplayer\\AVPlayer.ts";






































































const ObjectFitMap = {
    [1 /* RenderMode.FILL */]: 'cover',
    [0 /* RenderMode.FIT */]: 'contain'
};
const AVPlayerSupportedCodecs = [
    27 /* AVCodecID.AV_CODEC_ID_H264 */,
    173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
    196 /* AVCodecID.AV_CODEC_ID_VVC */,
    225 /* AVCodecID.AV_CODEC_ID_AV1 */,
    139 /* AVCodecID.AV_CODEC_ID_VP8 */,
    167 /* AVCodecID.AV_CODEC_ID_VP9 */,
    30 /* AVCodecID.AV_CODEC_ID_THEORA */,
    86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
    86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
    86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
    86051 /* AVCodecID.AV_CODEC_ID_SPEEX */,
    86021 /* AVCodecID.AV_CODEC_ID_VORBIS */,
    86019 /* AVCodecID.AV_CODEC_ID_AC3 */,
    86056 /* AVCodecID.AV_CODEC_ID_EAC3 */,
    86020 /* AVCodecID.AV_CODEC_ID_DTS */,
    94226 /* AVCodecID.AV_CODEC_ID_WEBVTT */,
    94225 /* AVCodecID.AV_CODEC_ID_SUBRIP */,
    94230 /* AVCodecID.AV_CODEC_ID_ASS */,
    94212 /* AVCodecID.AV_CODEC_ID_SSA */,
    94232 /* AVCodecID.AV_CODEC_ID_TTML */,
    94213 /* AVCodecID.AV_CODEC_ID_MOV_TEXT */,
    94210 /* AVCodecID.AV_CODEC_ID_TEXT */
];
const defaultAVPlayerOptions = {
    enableHardware: true,
    enableWebGPU: true,
    enableWorker: true,
    loop: false,
    jitterBufferMax: 10,
    jitterBufferMin: 4,
    lowLatency: false,
    preLoadTime: 4
};
class AVPlayer extends common_event_Emitter__WEBPACK_IMPORTED_MODULE_13__["default"] {
    static Util = {
        compile: cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_17__["default"],
        browser: common_util_browser__WEBPACK_IMPORTED_MODULE_34__["default"],
        os: common_util_os__WEBPACK_IMPORTED_MODULE_59__["default"]
    };
    static IOLoader = {
        CustomIOLoader: avnetwork_ioLoader_CustomIOLoader__WEBPACK_IMPORTED_MODULE_64__["default"],
        FetchIOLoader: avnetwork_ioLoader_FetchIOLoader__WEBPACK_IMPORTED_MODULE_62__["default"],
        FileIOLoader: avnetwork_ioLoader_FileIOLoader__WEBPACK_IMPORTED_MODULE_63__["default"]
    };
    static level = common_util_logger__WEBPACK_IMPORTED_MODULE_30__.INFO;
    static DemuxThreadReady;
    static AudioThreadReady;
    static VideoThreadReady;
    static MSEThreadReady;
    static IODemuxProxy;
    static AudioPipelineProxy;
    static MSEPipelineProxy;
    //  AVPlayer 
    static IOThread;
    static DemuxerThread;
    static AudioDecoderThread;
    static AudioRenderThread;
    static VideoRenderThread;
    static MSEThread;
    static audioContext;
    static Resource = new Map();
    //  player 
    // TODO  VideoDecoderThreadPool
    // 
    VideoDecoderThread;
    VideoRenderThread;
    VideoPipelineProxy;
    // AVPlayer 
    GlobalData;
    taskId;
    subTaskId;
    subtitleTaskId;
    ext;
    source;
    ioIPCPort;
    options;
    ioloader2DemuxerChannel;
    demuxer2VideoDecoderChannel;
    demuxer2AudioDecoderChannel;
    videoDecoder2VideoRenderChannel;
    audioDecoder2AudioRenderChannel;
    audioRender2AudioWorkletChannel;
    audioSourceNode;
    gainNode;
    formatContext;
    canvas;
    updateCanvas;
    video;
    audio;
    controller;
    volume;
    playRate;
    renderMode;
    renderRotate;
    flipHorizontal;
    flipVertical;
    useMSE;
    audioEnded;
    videoEnded;
    status;
    lastStatus;
    statsController;
    jitterBufferController;
    selectedVideoStream;
    selectedAudioStream;
    selectedSubtitleStream;
    lastSelectedInnerSubtitleStreamIndex;
    subtitleRender;
    externalSubtitleTasks;
    constructor(options) {
        super(true);
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_16__.extend({}, defaultAVPlayerOptions, options);
        this.taskId = (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_14__["default"])();
        this.status = 0 /* AVPlayerStatus.STOPPED */;
        this.volume = 1;
        this.playRate = 1;
        this.renderMode = 0 /* RenderMode.FIT */;
        this.renderRotate = 0;
        this.flipHorizontal = false;
        this.flipVertical = false;
        this.GlobalData = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_2__["default"])(_struct_ts__WEBPACK_IMPORTED_MODULE_1__.AVPlayerGlobalData);
        this.statsController = new _StatsController__WEBPACK_IMPORTED_MODULE_46__["default"](this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32, !(cheap_config__WEBPACK_IMPORTED_MODULE_23__.USE_THREADS || !common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].worker || !this.options.enableWorker), this);
        this.externalSubtitleTasks = [];
        this.lastSelectedInnerSubtitleStreamIndex = -1;
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_47__.init(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_47__.init(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28);
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`create player, taskId: ${this.taskId}`, cheap__fileName__5, 369);
    }
    /**
     * 
     */
    get currentTime() {
        if (this.useMSE) {
            return BigInt(Math.floor((((this.video || this.audio)?.currentTime || 0) * 1000)));
        }
        if (this.selectedAudioStream) {
            return this.GlobalData.stats.audioCurrentTime;
        }
        else if (this.selectedVideoStream) {
            return this.GlobalData.stats.videoCurrentTime;
        }
        return BigInt(0);
    }
    isCodecIdSupported(codecId) {
        if (codecId > 65536 /* AVCodecID.AV_CODEC_ID_FIRST_AUDIO */ && codecId <= 65572 /* AVCodecID.AV_CODEC_ID_PCM_SGA */) {
            return true;
        }
        return common_util_array__WEBPACK_IMPORTED_MODULE_54__.has(AVPlayerSupportedCodecs, codecId);
    }
    findBestStream(streams, mediaType) {
        if (this.options.findBestStream) {
            return this.options.findBestStream(streams, mediaType);
        }
        const ss = streams.filter((stream) => {
            return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar) === mediaType;
        });
        if (ss.length) {
            if (ss.length === 1) {
                return ss[0];
            }
            const defaultStream = ss.find((stream) => !!(stream.disposition & 1 /* AVDisposition.DEFAULT */));
            if (defaultStream && this.isCodecIdSupported(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](defaultStream.codecpar + 4))) {
                return defaultStream;
            }
            return ss.find((stream) => this.isCodecIdSupported(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 4))) || ss[0];
        }
    }
    async checkUseMSE() {
        {
            if (!common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].mse) {
                return false;
            }
            //  wasm
            if (!common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].wasmBaseSupported) {
                return true;
            }
            const videoStream = this.findBestStream(this.formatContext.streams, 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
            const audioStream = this.findBestStream(this.formatContext.streams, 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
            //  MediaSource  wasm 
            if (videoStream && !(0,_function_getMediaSource__WEBPACK_IMPORTED_MODULE_49__["default"])().isTypeSupported((0,avrender_track_function_getVideoMimeType__WEBPACK_IMPORTED_MODULE_41__["default"])(videoStream.codecpar))) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn(`can not support mse for codec: ${(0,avrender_track_function_getVideoMimeType__WEBPACK_IMPORTED_MODULE_41__["default"])(videoStream.codecpar)}, taskId: ${this.taskId}`, cheap__fileName__5, 430);
                return false;
            }
            if (audioStream && !(0,_function_getMediaSource__WEBPACK_IMPORTED_MODULE_49__["default"])().isTypeSupported((0,avrender_track_function_getAudioMimeType__WEBPACK_IMPORTED_MODULE_42__["default"])(audioStream.codecpar))) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn(`can not support mse for codec: ${(0,avrender_track_function_getAudioMimeType__WEBPACK_IMPORTED_MODULE_42__["default"])(audioStream.codecpar)}, taskId: ${this.taskId}`, cheap__fileName__5, 434);
                return false;
            }
            if (this.options.checkUseMES) {
                return this.options.checkUseMES(this.formatContext.streams);
            }
            if (videoStream) {
                //  canvas  hdr hdr  mse 
                // TODO  canvas  hdr 
                if ((0,avutil_function_isHdr__WEBPACK_IMPORTED_MODULE_55__["default"])(videoStream.codecpar)) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info('use mse because of hdr', cheap__fileName__5, 446);
                    return true;
                }
                // 1080p  mse
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar + 56) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar + 60) > 2073600) {
                    //  webcodec
                    if (!common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].videoDecoder) {
                        return true;
                    }
                    let extradata = null;
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](videoStream.codecpar + 12) !== 0) {
                        extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_38__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](videoStream.codecpar + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar + 16));
                    }
                    //  mse
                    const isWebcodecSupport = await VideoDecoder.isConfigSupported({
                        codec: (0,avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_40__["default"])(videoStream.codecpar),
                        codedWidth: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar + 56),
                        codedHeight: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar + 60),
                        description: extradata,
                        hardwareAcceleration: (0,avcodec_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_44__.getHardwarePreference)(true)
                    });
                    if (!isWebcodecSupport.supported) {
                        return true;
                    }
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar + 56) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar + 60) === 2073600) {
                    // safari 1080p@30fps  worker 
                    if (common_util_browser__WEBPACK_IMPORTED_MODULE_34__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_34__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_34__["default"].version, '16.1', true) && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_35__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_5__["default"])(videoStream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational)) > 30) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    createCanvas() {
        const canvas = document.createElement('canvas');
        canvas.id = 'avplayer-canvas-' + (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_14__["default"])();
        canvas.className = 'avplayer-canvas';
        canvas.width = this.options.container.offsetWidth * devicePixelRatio;
        canvas.height = this.options.container.offsetHeight * devicePixelRatio;
        canvas.style.cssText = `
      width: 100%;
      height: 100%;
    `;
        canvas.ondragstart = () => false;
        Object.defineProperty(canvas, 'currentTime', {
            enumerable: true,
            configurable: false,
            get: () => {
                return Number(this.currentTime) / 1000;
            },
            set: (time) => {
                this.seek(BigInt(Math.floor(Math.floor(time * 1000))));
            }
        });
        return canvas;
    }
    createVideo() {
        if (this.video) {
            this.options.container.removeChild(this.video);
        }
        const video = document.createElement('video');
        video.autoplay = true;
        video.className = 'avplayer-video';
        video.style.cssText = `
      width: 100%;
      height: 100%;
    `;
        this.options.container.appendChild(video);
        this.video = video;
    }
    createAudio() {
        if (this.audio) {
            this.options.container.removeChild(this.audio);
        }
        const audio = document.createElement('audio');
        audio.autoplay = true;
        audio.className = 'avplayer-audio';
        this.options.container.appendChild(audio);
        this.audio = audio;
    }
    handleTimeupdate(element) {
        let lastNotifyTime = 0;
        element.ontimeupdate = () => {
            const time = element.currentTime;
            if (Math.abs(time - lastNotifyTime) >= 1) {
                if (this.status === 6 /* AVPlayerStatus.PLAYED */) {
                    this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.TIME, [this.currentTime]);
                    AVPlayer.MSEThread.setCurrentTime(this.taskId, time);
                }
                lastNotifyTime = time;
            }
        };
        element.onended = () => {
            this.audioEnded = true;
            this.videoEnded = true;
            this.handleEnded();
        };
        element.onwaiting = () => {
            if (this.audio === element) {
                this.GlobalData.stats.audioStutter++;
            }
            else {
                this.GlobalData.stats.audioStutter++;
                this.GlobalData.stats.videoStutter++;
            }
        };
        element.oncanplay = () => {
            if (this.status === 6 /* AVPlayerStatus.PLAYED */) {
                element.play();
            }
        };
    }
    async handleEnded() {
        if (this.audioEnded && this.videoEnded) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`player ended, taskId: ${this.taskId}`, cheap__fileName__5, 575);
            if (this.options.loop && !this.options.isLive) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`loop play, taskId: ${this.taskId}`, cheap__fileName__5, 579);
                if ( true && this.isHls()) {
                    await AVPlayer.DemuxerThread.seek(this.taskId, BigInt(0), 16 /* AVSeekFlags.TIMESTAMP */);
                }
                else if ( true && this.isDash()) {
                    await AVPlayer.DemuxerThread.seek(this.taskId, BigInt(0), 16 /* AVSeekFlags.TIMESTAMP */);
                    if ( true && this.subTaskId) {
                        await AVPlayer.DemuxerThread.seek(this.subTaskId, BigInt(0), 16 /* AVSeekFlags.TIMESTAMP */);
                    }
                    if (( true) && this.subtitleTaskId) {
                        await AVPlayer.DemuxerThread.seek(this.subtitleTaskId, BigInt(0), 16 /* AVSeekFlags.TIMESTAMP */);
                    }
                }
                else {
                    await AVPlayer.DemuxerThread.seek(this.taskId, BigInt(0), 8 /* AVSeekFlags.FRAME */);
                }
                for (let i = 0; i < this.externalSubtitleTasks.length; i++) {
                    await AVPlayer.DemuxerThread.seek(this.externalSubtitleTasks[0].taskId, BigInt(0), 8 /* AVSeekFlags.FRAME */);
                }
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.TIME, [BigInt(0)]);
                if ( true && this.useMSE) {
                    if ((this.video || this.audio)?.src) {
                        URL.revokeObjectURL((this.video || this.audio).src);
                    }
                    await AVPlayer.MSEThread.restart(this.taskId);
                    const mediaSource = await AVPlayer.MSEThread.getMediaSource(this.taskId);
                    if (mediaSource) {
                        if (common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].workerMSE && mediaSource instanceof MediaSourceHandle) {
                            (this.video || this.audio).srcObject = mediaSource;
                        }
                        else {
                            (this.video || this.audio).src = URL.createObjectURL(mediaSource);
                        }
                        if (this.video) {
                            this.video.currentTime = 0;
                            this.video.playbackRate = this.playRate;
                        }
                        else if (this.audio) {
                            this.audio.currentTime = 0;
                            this.audio.playbackRate = this.playRate;
                        }
                        await Promise.all([
                            this.video?.play(),
                            this.audio?.play()
                        ]);
                    }
                }
                else {
                    if (this.audioDecoder2AudioRenderChannel) {
                        await AVPlayer.AudioDecoderThread.resetTask(this.taskId);
                        await AVPlayer.AudioRenderThread.restart(this.taskId);
                    }
                    if (this.audioSourceNode) {
                        await this.audioSourceNode.request('restart');
                        if (AVPlayer.audioContext.state === 'suspended') {
                            await AVPlayer.AudioRenderThread.fakePlay(this.taskId);
                        }
                        this.audioEnded = false;
                    }
                    if (this.videoDecoder2VideoRenderChannel) {
                        await this.VideoDecoderThread.resetTask(this.taskId);
                        await this.VideoRenderThread.restart(this.taskId);
                        this.videoEnded = false;
                    }
                }
                if (this.subtitleRender) {
                    this.subtitleRender.reset();
                    this.subtitleRender.start();
                }
            }
            else {
                if ((this.video || this.audio)?.src) {
                    URL.revokeObjectURL((this.video || this.audio).src);
                }
                if (this.video) {
                    this.options.container.removeChild(this.video);
                    this.video = null;
                }
                if (this.audio) {
                    this.options.container.removeChild(this.audio);
                    this.audio = null;
                }
                if (this.canvas) {
                    this.options.container.removeChild(this.canvas);
                    this.canvas = null;
                }
                await this.stop();
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.ENDED);
            }
        }
    }
    /**
     *  hls
     *
     * @returns
     */
    isHls() {
        return this.ext === 'm3u8' || this.ext === 'm3u';
    }
    /**
     *  dash
     *
     * @returns
     */
    isDash() {
        return this.ext === 'mpd';
    }
    async getResource(type, codecId, mediaType) {
        const key = codecId != null ? `${type}-${codecId}` : type;
        if (AVPlayer.Resource.has(key)) {
            return AVPlayer.Resource.get(key);
        }
        const wasmUrl = this.options.getWasm(type, codecId, mediaType);
        if (wasmUrl) {
            let resource;
            // safari 16  WebAssembly.Module  worker 
            //  buffer  worker 
            if (common_util_browser__WEBPACK_IMPORTED_MODULE_34__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_34__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_34__["default"].version, '16.3', false) && (common_util_is__WEBPACK_IMPORTED_MODULE_15__.string(wasmUrl) || common_util_is__WEBPACK_IMPORTED_MODULE_15__.arrayBuffer(wasmUrl))) {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_15__.string(wasmUrl)) {
                    const params = {
                        method: 'GET',
                        headers: {},
                        mode: 'cors',
                        cache: 'default',
                        referrerPolicy: 'no-referrer-when-downgrade'
                    };
                    const response = await fetch(wasmUrl, params);
                    resource = await response.arrayBuffer();
                }
                else {
                    resource = wasmUrl;
                }
            }
            else {
                resource = await (0,avutil_function_compileResource__WEBPACK_IMPORTED_MODULE_58__["default"])(wasmUrl, mediaType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
            }
            AVPlayer.Resource.set(key, resource);
            return resource;
        }
    }
    createSubtitleRender(subtitleStream, taskId) {
        this.subtitleRender = new _subtitle_SubtitleRender__WEBPACK_IMPORTED_MODULE_57__["default"]({
            dom: this.canvas || this.video || this.options.container,
            getCurrentTime: () => {
                return this.currentTime;
            },
            avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
            avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
            codecpar: subtitleStream.codecpar,
            container: this.options.container,
            videoWidth: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.selectedVideoStream?.codecpar + 56) ?? 0,
            videoHeight: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.selectedVideoStream?.codecpar + 60) ?? 0
        });
        this.subtitleRender.setDemuxTask(taskId);
        this.selectedSubtitleStream = subtitleStream;
        if (taskId === this.taskId) {
            this.lastSelectedInnerSubtitleStreamIndex = subtitleStream.index;
        }
        AVPlayer.DemuxerThread.connectStreamTask.transfer(this.subtitleRender.getDemuxerPort(taskId))
            .invoke(taskId, subtitleStream.index, this.subtitleRender.getDemuxerPort(taskId));
    }
    /**
     * 
     *
     * @param externalSubtitle
     * @returns
     */
    async loadExternalSubtitle(externalSubtitle) {
        if (this.status === 1 /* AVPlayerStatus.DESTROYING */ || this.status === 2 /* AVPlayerStatus.DESTROYED */) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal('player has already destroyed', cheap__fileName__5, 774);
        }
        if (!externalSubtitle.source) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal('external subtitle must has source', cheap__fileName__5, 778);
        }
        if (this.externalSubtitleTasks.some((task) => task.source === externalSubtitle.source)) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn('external subtitle has already loaded', cheap__fileName__5, 782);
            return;
        }
        const taskId = (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_14__["default"])();
        const ioloader2DemuxerChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_39__["default"])(this.options.enableWorker);
        const externalSubtitleTask = common_util_object__WEBPACK_IMPORTED_MODULE_16__.extend({
            taskId,
            streamId: -1,
            ioloader2DemuxerChannel
        }, externalSubtitle);
        let ext = '';
        let ret = 0;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_15__.string(externalSubtitle.source)) {
            ext = common_util_url__WEBPACK_IMPORTED_MODULE_22__.parse(externalSubtitle.source).file.split('.').pop();
            ret = await AVPlayer.IOThread.registerTask
                .transfer(ioloader2DemuxerChannel.port1)
                .invoke({
                type: 0 /* IOType.Fetch */,
                info: {
                    url: externalSubtitle.source
                },
                range: {
                    from: -1,
                    to: -1
                },
                taskId: taskId,
                options: {
                    isLive: this.options.isLive
                },
                rightPort: ioloader2DemuxerChannel.port1,
                stats: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32
            });
        }
        else {
            ext = externalSubtitle.source.name.split('.').pop();
            ret = await AVPlayer.IOThread.registerTask
                .transfer(ioloader2DemuxerChannel.port1)
                .invoke({
                type: 1 /* IOType.File */,
                info: {
                    file: externalSubtitle.source
                },
                range: {
                    from: -1,
                    to: -1
                },
                taskId: taskId,
                options: {
                    isLive: this.options.isLive
                },
                rightPort: ioloader2DemuxerChannel.port1,
                stats: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32
            });
        }
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`register io task failed, ret: ${ret}, taskId: ${this.taskId}`, cheap__fileName__5, 843);
        }
        await AVPlayer.DemuxerThread.registerTask.transfer(ioloader2DemuxerChannel.port2)
            .invoke({
            taskId: taskId,
            leftPort: ioloader2DemuxerChannel.port2,
            format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_52__.Ext2Format[ext],
            stats: 0,
            isLive: false,
            flags: 0,
            avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
            avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
        });
        ret = await AVPlayer.DemuxerThread.openStream(taskId);
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`open external subtitle failed, ret: ${ret}, taskId: ${taskId}`, cheap__fileName__5, 860);
        }
        let formatContext = await AVPlayer.DemuxerThread.analyzeStreams(taskId);
        if (common_util_is__WEBPACK_IMPORTED_MODULE_15__.number(formatContext) || !formatContext.streams.length) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`analyze stream failed, ret: ${formatContext}`, cheap__fileName__5, 864);
        }
        const stream = formatContext.streams[0];
        this.formatContext.streams.push(stream);
        externalSubtitleTask.streamId = stream.id;
        if (externalSubtitle.lang) {
            stream.metadata['language'] = externalSubtitle.lang;
        }
        if (externalSubtitle.title) {
            stream.metadata['title'] = externalSubtitle.title;
        }
        const handleStatus = this.status === 7 /* AVPlayerStatus.PAUSED */
            || this.status === 6 /* AVPlayerStatus.PLAYED */
            || this.status === 8 /* AVPlayerStatus.SEEKING */
            || this.status === 9 /* AVPlayerStatus.CHANGING */;
        if (handleStatus) {
            await AVPlayer.DemuxerThread.seek(taskId, this.currentTime, 8 /* AVSeekFlags.FRAME */);
        }
        if (handleStatus && !this.subtitleRender) {
            this.createSubtitleRender(stream, taskId);
            this.subtitleRender.start();
        }
        else if (this.subtitleRender) {
            await AVPlayer.DemuxerThread.connectStreamTask.transfer(this.subtitleRender.getDemuxerPort(taskId))
                .invoke(taskId, stream.index, this.subtitleRender.getDemuxerPort(taskId));
        }
        await AVPlayer.DemuxerThread.startDemux(taskId, false, 10);
        this.externalSubtitleTasks.push(externalSubtitleTask);
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.STREAM_UPDATE);
        return 0;
    }
    /**
     * 
     *
     * @param source  url  
     * @param externalSubtitles 
     */
    async load(source, externalSubtitles = []) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`call load, taskId: ${this.taskId}`, cheap__fileName__5, 914);
        this.status = 3 /* AVPlayerStatus.LOADING */;
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.LOADING);
        this.controller = new _Controller__WEBPACK_IMPORTED_MODULE_27__["default"](this, this.options.enableWorker);
        this.ioloader2DemuxerChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_39__["default"])(this.options.enableWorker);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_38__.memset)(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32, 0, 336);
        this.externalSubtitleTasks.length = 0;
        await AVPlayer.startDemuxPipeline(this.options.enableWorker);
        let ret = 0;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_15__.string(source)) {
            this.ext = common_util_url__WEBPACK_IMPORTED_MODULE_22__.parse(source).file.split('.').pop();
            //  url io 
            ret = await AVPlayer.IOThread.registerTask
                .transfer(this.ioloader2DemuxerChannel.port1)
                .invoke({
                type: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_52__.Ext2IOLoader[this.ext] ?? 0 /* IOType.Fetch */,
                info: {
                    url: source
                },
                range: {
                    from: -1,
                    to: -1
                },
                taskId: this.taskId,
                options: {
                    isLive: this.options.isLive
                },
                rightPort: this.ioloader2DemuxerChannel.port1,
                stats: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32
            });
        }
        else if (source instanceof File) {
            this.options.isLive = false;
            this.ext = source.name.split('.').pop();
            //  io 
            ret = await AVPlayer.IOThread.registerTask
                .transfer(this.ioloader2DemuxerChannel.port1)
                .invoke({
                type: 1 /* IOType.File */,
                info: {
                    file: source
                },
                range: {
                    from: -1,
                    to: -1
                },
                taskId: this.taskId,
                options: {
                    isLive: false
                },
                rightPort: this.ioloader2DemuxerChannel.port1,
                stats: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32
            });
        }
        else if (source instanceof avnetwork_ioLoader_CustomIOLoader__WEBPACK_IMPORTED_MODULE_64__["default"]) {
            this.ext = source.ext;
            this.ioIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_60__["default"](this.ioloader2DemuxerChannel.port1);
            this.ioIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_60__.REQUEST, async (request) => {
                switch (request.method) {
                    case 'open': {
                        try {
                            const ret = await source.open();
                            if (ret < 0) {
                                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.error(`custom loader open error, ${ret}, taskId: ${this.taskId}`, cheap__fileName__5, 982);
                                this.ioIPCPort.reply(request, null, ret);
                                break;
                            }
                            this.ioIPCPort.reply(request, ret);
                        }
                        catch (error) {
                            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.error(`loader open error, ${error}, taskId: ${this.taskId}`, cheap__fileName__5, 989);
                            this.ioIPCPort.reply(request, null, error);
                        }
                        break;
                    }
                    case 'read': {
                        const pointer = request.params.pointer;
                        const length = request.params.length;
                        const ioloaderOptions = request.params.ioloaderOptions;
                        const buffer = AVPlayer.IODemuxProxy ? new Uint8Array(length) : (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_38__.mapSafeUint8Array)(pointer, length);
                        try {
                            const len = await source.read(buffer, ioloaderOptions);
                            this.GlobalData.stats.bufferReceiveBytes += BigInt(len >> 0);
                            this.ioIPCPort.reply(request, AVPlayer.IODemuxProxy ? buffer : len, null, AVPlayer.IODemuxProxy ? [buffer.buffer] : null);
                        }
                        catch (error) {
                            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.error(`loader read error, ${error}, taskId: ${this.taskId}`, cheap__fileName__5, 1007);
                            this.ioIPCPort.reply(request, avutil_error__WEBPACK_IMPORTED_MODULE_61__.DATA_INVALID);
                        }
                        break;
                    }
                    case 'seek': {
                        const pos = request.params.pos;
                        const ioloaderOptions = request.params.ioloaderOptions;
                        try {
                            const ret = await source.seek(pos, ioloaderOptions);
                            if (ret < 0) {
                                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.error(`custom loader seek error, ${ret}, taskId: ${this.taskId}`, cheap__fileName__5, 1023);
                                this.ioIPCPort.reply(request, null, ret);
                                break;
                            }
                            this.ioIPCPort.reply(request, ret);
                        }
                        catch (error) {
                            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.error(`loader seek error, ${error}, taskId: ${this.taskId}`, cheap__fileName__5, 1030);
                            this.ioIPCPort.reply(request, null, error);
                        }
                        break;
                    }
                    case 'size': {
                        this.ioIPCPort.reply(request, await source.size());
                        break;
                    }
                }
            });
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal('invalid source', cheap__fileName__5, 1044);
        }
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`register io task failed, ret: ${ret}, taskId: ${this.taskId}`, cheap__fileName__5, 1048);
        }
        if ( true && this.isDash()) {
            await AVPlayer.IOThread.open(this.taskId);
            const hasAudio = await AVPlayer.IOThread.hasAudio(this.taskId);
            const hasVideo = await AVPlayer.IOThread.hasVideo(this.taskId);
            if (hasAudio && hasVideo) {
                // dash 
                this.subTaskId = (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_14__["default"])();
                await AVPlayer.DemuxerThread.registerTask
                    .transfer(this.ioloader2DemuxerChannel.port2, this.controller.getDemuxerControlPort())
                    .invoke({
                    taskId: this.taskId,
                    leftPort: this.ioloader2DemuxerChannel.port2,
                    controlPort: this.controller.getDemuxerControlPort(),
                    format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_52__.Ext2Format[this.ext],
                    stats: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32,
                    isLive: this.options.isLive,
                    flags: 2 /* IOFlags.SLICE */,
                    ioloaderOptions: {
                        mediaType: 'audio'
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
                });
                await AVPlayer.DemuxerThread.registerTask({
                    taskId: this.subTaskId,
                    mainTaskId: this.taskId,
                    flags: 2 /* IOFlags.SLICE */,
                    format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_52__.Ext2Format[this.ext],
                    stats: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32,
                    isLive: this.options.isLive,
                    ioloaderOptions: {
                        mediaType: 'video'
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
                });
            }
            else {
                // dash 
                await AVPlayer.DemuxerThread.registerTask
                    .transfer(this.ioloader2DemuxerChannel.port2, this.controller.getDemuxerControlPort())
                    .invoke({
                    taskId: this.taskId,
                    leftPort: this.ioloader2DemuxerChannel.port2,
                    controlPort: this.controller.getDemuxerControlPort(),
                    format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_52__.Ext2Format[this.ext],
                    stats: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32,
                    isLive: this.options.isLive,
                    flags: 2 /* IOFlags.SLICE */,
                    ioloaderOptions: {
                        mediaType: hasAudio ? 'audio' : 'video'
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
                });
            }
        }
        else {
            await AVPlayer.DemuxerThread.registerTask
                .transfer(this.ioloader2DemuxerChannel.port2, this.controller.getDemuxerControlPort())
                .invoke({
                taskId: this.taskId,
                leftPort: this.ioloader2DemuxerChannel.port2,
                controlPort: this.controller.getDemuxerControlPort(),
                format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_52__.Ext2Format[this.ext],
                stats: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32,
                isLive: this.options.isLive,
                flags: this.isHls() ? 2 /* IOFlags.SLICE */ : 0,
                avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
            });
        }
        if ( true && this.isDash() ||  true && this.isHls()) {
            const hasSubtitle = await AVPlayer.IOThread.hasSubtitle(this.taskId);
            if (hasSubtitle) {
                // dash  hls 
                this.subtitleTaskId = (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_14__["default"])();
                await AVPlayer.DemuxerThread.registerTask({
                    taskId: this.subtitleTaskId,
                    mainTaskId: this.taskId,
                    flags: 2 /* IOFlags.SLICE */,
                    format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_52__.Ext2Format[this.ext],
                    stats: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32,
                    isLive: this.options.isLive,
                    ioloaderOptions: {
                        mediaType: 'subtitle'
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
                });
            }
        }
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.PROGRESS, [0 /* AVPlayerProgress.OPEN_FILE */]);
        ret = await AVPlayer.DemuxerThread.openStream(this.taskId);
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`open stream failed, ret: ${ret}, taskId: ${this.taskId}`, cheap__fileName__5, 1149);
        }
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.PROGRESS, [1 /* AVPlayerProgress.ANALYZE_FILE */, this.ext]);
        let formatContext = await AVPlayer.DemuxerThread.analyzeStreams(this.taskId);
        if (common_util_is__WEBPACK_IMPORTED_MODULE_15__.number(formatContext) || !formatContext.streams.length) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`analyze stream failed, ret: ${formatContext}`, cheap__fileName__5, 1156);
        }
        if ( true && this.subTaskId) {
            ret = await AVPlayer.DemuxerThread.openStream(this.subTaskId);
            if (ret < 0) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`open stream failed, ret: ${ret}, taskId: ${this.subTaskId}`, cheap__fileName__5, 1162);
            }
            const subFormatContext = await AVPlayer.DemuxerThread.analyzeStreams(this.subTaskId);
            if (common_util_is__WEBPACK_IMPORTED_MODULE_15__.number(subFormatContext) || !subFormatContext.streams.length) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`analyze stream failed, ret: ${subFormatContext}`, cheap__fileName__5, 1166);
            }
            formatContext.streams = formatContext.streams.concat(subFormatContext.streams);
        }
        if (( true) && this.subtitleTaskId) {
            ret = await AVPlayer.DemuxerThread.openStream(this.subtitleTaskId);
            if (ret < 0) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`open subtitle stream failed, ret: ${ret}, taskId: ${this.subtitleTaskId}`, cheap__fileName__5, 1174);
            }
            const subFormatContext = await AVPlayer.DemuxerThread.analyzeStreams(this.subtitleTaskId);
            if (common_util_is__WEBPACK_IMPORTED_MODULE_15__.number(subFormatContext) || !subFormatContext.streams.length) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`analyze subtitle stream failed, ret: ${subFormatContext}`, cheap__fileName__5, 1178);
            }
            formatContext.streams = formatContext.streams.concat(subFormatContext.streams);
        }
        this.formatContext = formatContext;
        this.source = source;
        for (let i = 0; i < externalSubtitles.length; i++) {
            await this.loadExternalSubtitle(externalSubtitles[i]);
        }
        formatContext.streams.forEach((stream) => {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                this.GlobalData.stats.audiocodec = (0,avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_51__["default"])(stream.codecpar);
            }
            else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                this.GlobalData.stats.videocodec = (0,avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_40__["default"])(stream.codecpar);
            }
        });
        {
            // m3u8  dash  duration 
            if (this.isHls() || this.isDash()) {
                const duration = (await AVPlayer.IOThread.getDuration(this.taskId)) * 1000;
                if (duration > 0) {
                    for (let i = 0; i < this.formatContext.streams.length; i++) {
                        this.formatContext.streams[i].duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_35__.avRescaleQ)(BigInt(Math.floor(duration)), avutil_constant__WEBPACK_IMPORTED_MODULE_36__.AV_MILLI_TIME_BASE_Q, this.formatContext.streams[i].timeBase);
                    }
                }
            }
        }
        if (this.options.isLive && this.options.lowLatency) {
            const min = Math.max(this.source instanceof avnetwork_ioLoader_CustomIOLoader__WEBPACK_IMPORTED_MODULE_64__["default"]
                ? this.source.minBuffer
                : await AVPlayer.IOThread.getMinBuffer(this.taskId), this.options.jitterBufferMin);
            let max = this.options.jitterBufferMax;
            if (max <= min) {
                max = min + ((this.isHls() || this.isDash()) ? min : 1);
            }
            this.jitterBufferController = new _JitterBufferController__WEBPACK_IMPORTED_MODULE_50__["default"]({
                stats: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32,
                jitterBuffer: this.GlobalData.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 272,
                lowLatencyStart: !(this.isHls() || this.isDash()),
                useMse: this.useMSE,
                max,
                min,
                observer: {
                    onCroppingBuffer: (max) => {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.debug(`cropping buffer by jitter buffer, max: ${max}, taskId: ${this.taskId}`, cheap__fileName__5, 1235);
                        AVPlayer.DemuxerThread?.croppingAVPacketQueue(this.taskId, BigInt(max >> 0));
                    },
                    onSetPlayRate: (rate) => {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.debug(`set play rate by jitter buffer, rate: ${rate}, taskId: ${this.taskId}`, cheap__fileName__5, 1239);
                        if ( true && this.useMSE) {
                            AVPlayer.MSEThread.setPlayRate(this.taskId, rate);
                            if (this.video) {
                                this.video.playbackRate = rate;
                            }
                            else if (this.audio) {
                                this.audio.playbackRate = rate;
                            }
                        }
                        else {
                            if (this.audioDecoder2AudioRenderChannel) {
                                AVPlayer.AudioRenderThread.setPlayTempo(this.taskId, rate);
                            }
                            if (this.videoDecoder2VideoRenderChannel) {
                                this.VideoRenderThread.setPlayRate(this.taskId, rate);
                            }
                        }
                    }
                }
            });
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`\nAVPlayer version ${"v0.0.1-18-g41e9e9f"} Copyright (c) 2024-present the libmedia developers\n` + (0,avformat_dump__WEBPACK_IMPORTED_MODULE_53__["default"])([formatContext], [{
                from: common_util_is__WEBPACK_IMPORTED_MODULE_15__.string(source) ? source : source.name,
                tag: 'Input'
            }]), cheap__fileName__5, 1262);
        this.status = 4 /* AVPlayerStatus.LOADED */;
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.LOADED);
    }
    /**
     * 
     *
     * @param options
     * @returns
     */
    async play(options = {
        audio: true,
        video: true,
        subtitle: true
    }) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`call play, options: ${JSON.stringify(options)}, status: ${this.status} taskId: ${this.taskId}`, cheap__fileName__5, 1297);
        if (this.status === 6 /* AVPlayerStatus.PLAYED */) {
            return;
        }
        if (!options.audio && !options.video) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn(`video and audio must play one, ignore options, we will try to play video and audio, taskId: ${this.taskId}`, cheap__fileName__5, 1304);
            options.audio = true;
            options.video = true;
        }
        const promises = [];
        if (this.status === 7 /* AVPlayerStatus.PAUSED */) {
            // 
            if (this.selectedAudioStream && this.selectedVideoStream && (this.GlobalData.stats.videoCurrentTime - this.GlobalData.stats.audioCurrentTime > BigInt(400))) {
                await AVPlayer.AudioRenderThread.syncSeekTime(this.taskId, this.GlobalData.stats.videoCurrentTime);
            }
            if ( true && this.useMSE) {
                promises.push(AVPlayer.MSEThread.unpause(this.taskId));
                if (this.audio) {
                    this.audio.play();
                }
                else if (this.video) {
                    this.video.play();
                }
            }
            else {
                if (this.audioSourceNode) {
                    promises.push(this.audioSourceNode.request('unpause'));
                    promises.push(AVPlayer.AudioRenderThread.unpause(this.taskId));
                }
                if (this.videoDecoder2VideoRenderChannel) {
                    promises.push(this.VideoRenderThread.unpause(this.taskId));
                }
            }
            return Promise.all(promises).then(() => {
                this.status = 6 /* AVPlayerStatus.PLAYED */;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.PLAYED);
                if (this.jitterBufferController) {
                    this.jitterBufferController.start();
                }
                if (this.subtitleRender) {
                    this.subtitleRender.start();
                }
            });
        }
        this.status = 5 /* AVPlayerStatus.PLAYING */;
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.PLAYING);
        this.useMSE = await this.checkUseMSE();
        this.audioEnded = true;
        this.videoEnded = true;
        if ( true && this.useMSE) {
            await AVPlayer.startMSEPipeline(this.options.enableWorker);
            AVPlayer.MSEThread.setPlayRate(this.taskId, this.playRate);
            const videoStream = this.findBestStream(this.formatContext.streams, 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
            const audioStream = this.findBestStream(this.formatContext.streams, 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
            let hasVideo = false;
            //  mse 
            await AVPlayer.MSEThread.registerTask.transfer(this.controller.getMuxerControlPort())
                .invoke({
                taskId: this.taskId,
                stats: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32,
                controlPort: this.controller.getMuxerControlPort(),
                isLive: this.options.isLive,
                avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
                enableJitterBuffer: !!this.jitterBufferController
            });
            if (videoStream && options.video) {
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.PROGRESS, [3 /* AVPlayerProgress.LOAD_VIDEO_DECODER */, videoStream]);
                hasVideo = true;
                this.selectedVideoStream = videoStream;
                this.videoEnded = false;
                this.demuxer2VideoDecoderChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_39__["default"])(this.options.enableWorker);
                await AVPlayer.DemuxerThread.connectStreamTask
                    .transfer(this.demuxer2VideoDecoderChannel.port1)
                    .invoke(this.subTaskId || this.taskId, videoStream.index, this.demuxer2VideoDecoderChannel.port1);
                await AVPlayer.MSEThread.addStream.transfer(this.demuxer2VideoDecoderChannel.port2)
                    .invoke(this.taskId, videoStream.index, (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_65__.serializeAVCodecParameters)(videoStream.codecpar), videoStream.timeBase, videoStream.startTime, this.demuxer2VideoDecoderChannel.port2);
            }
            if (audioStream && options.audio) {
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.PROGRESS, [2 /* AVPlayerProgress.LOAD_AUDIO_DECODER */, audioStream]);
                this.selectedAudioStream = audioStream;
                this.audioEnded = false;
                this.demuxer2AudioDecoderChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_39__["default"])(this.options.enableWorker);
                await AVPlayer.DemuxerThread.connectStreamTask
                    .transfer(this.demuxer2AudioDecoderChannel.port1)
                    .invoke(this.taskId, audioStream.index, this.demuxer2AudioDecoderChannel.port1);
                await AVPlayer.MSEThread.addStream.transfer(this.demuxer2AudioDecoderChannel.port2)
                    .invoke(this.taskId, audioStream.index, (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_65__.serializeAVCodecParameters)(audioStream.codecpar), audioStream.timeBase, audioStream.startTime, this.demuxer2AudioDecoderChannel.port2);
            }
            if (hasVideo) {
                this.createVideo();
            }
            else {
                this.createAudio();
            }
            const mediaSource = await AVPlayer.MSEThread.getMediaSource(this.taskId);
            if (mediaSource) {
                if (common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].workerMSE && mediaSource instanceof MediaSourceHandle) {
                    (this.video || this.audio).srcObject = mediaSource;
                }
                else {
                    (this.video || this.audio).src = URL.createObjectURL(mediaSource);
                }
                this.handleTimeupdate(this.video || this.audio);
            }
        }
        else {
            let audioStartTime = BigInt(0);
            let videoStartTime = BigInt(0);
            const videoStream = this.findBestStream(this.formatContext.streams, 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
            const audioStream = this.findBestStream(this.formatContext.streams, 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
            if (videoStream && options.video) {
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.PROGRESS, [3 /* AVPlayerProgress.LOAD_VIDEO_DECODER */, videoStream]);
                this.selectedVideoStream = videoStream;
                await AVPlayer.startVideoRenderPipeline(this.options.enableWorker);
                await this.createVideoDecoderThread(this.options.enableWorker);
                videoStartTime = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_35__.avRescaleQ)(videoStream.startTime, videoStream.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_36__.AV_MILLI_TIME_BASE_Q);
                this.demuxer2VideoDecoderChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_39__["default"])(this.options.enableWorker);
                this.videoDecoder2VideoRenderChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_39__["default"])(this.options.enableWorker);
                let resource = await this.getResource('decoder', cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar));
                if (!resource) {
                    if (common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].videoDecoder) {
                        const isSupport = await VideoDecoder.isConfigSupported({
                            codec: (0,avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_40__["default"])(videoStream.codecpar)
                        });
                        if (!isSupport.supported) {
                            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`${(0,avformat_dump__WEBPACK_IMPORTED_MODULE_53__.dumpCodecName)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar + 4))} codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar + 4)} not support`, cheap__fileName__5, 1462);
                        }
                    }
                    else {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`${(0,avformat_dump__WEBPACK_IMPORTED_MODULE_53__.dumpCodecName)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar + 4))} codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar + 4)} not support`, cheap__fileName__5, 1466);
                    }
                }
                // 
                await this.VideoDecoderThread.registerTask
                    .transfer(this.demuxer2VideoDecoderChannel.port2, this.videoDecoder2VideoRenderChannel.port1)
                    .invoke({
                    taskId: this.taskId,
                    resource,
                    leftPort: this.demuxer2VideoDecoderChannel.port2,
                    rightPort: this.videoDecoder2VideoRenderChannel.port1,
                    stats: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32,
                    enableHardware: this.options.enableHardware,
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
                    avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 12,
                    avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28,
                    preferWebCodecs: !(0,avutil_function_isHdr__WEBPACK_IMPORTED_MODULE_55__["default"])(videoStream.codecpar) && !(0,avutil_function_hasAlphaChannel__WEBPACK_IMPORTED_MODULE_56__["default"])(videoStream.codecpar)
                });
                let ret = await this.VideoDecoderThread.open(this.taskId, (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_65__.serializeAVCodecParameters)(videoStream.codecpar));
                if (ret < 0) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`cannot open video ${(0,avformat_dump__WEBPACK_IMPORTED_MODULE_53__.dumpCodecName)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](videoStream.codecpar + 4))} decoder`, cheap__fileName__5, 1489);
                }
                await AVPlayer.DemuxerThread.connectStreamTask
                    .transfer(this.demuxer2VideoDecoderChannel.port1)
                    .invoke(this.subTaskId || this.taskId, videoStream.index, this.demuxer2VideoDecoderChannel.port1);
                this.VideoDecoderThread.setPlayRate(this.taskId, this.playRate);
            }
            if (audioStream && options.audio) {
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.PROGRESS, [2 /* AVPlayerProgress.LOAD_AUDIO_DECODER */, audioStream]);
                this.selectedAudioStream = audioStream;
                await AVPlayer.startAudioPipeline(this.options.enableWorker);
                if (AVPlayer.audioContext.state === 'suspended') {
                    await Promise.race([
                        AVPlayer.audioContext.resume(),
                        new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_45__["default"](0.1)
                    ]);
                }
                audioStartTime = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_35__.avRescaleQ)(audioStream.startTime, audioStream.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_36__.AV_MILLI_TIME_BASE_Q);
                this.demuxer2AudioDecoderChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_39__["default"])(this.options.enableWorker);
                this.audioDecoder2AudioRenderChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_39__["default"])(this.options.enableWorker);
                let resource = await this.getResource('decoder', cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](audioStream.codecpar + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](audioStream.codecpar));
                if (!resource) {
                    if (common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].audioDecoder) {
                        const isSupport = await AudioDecoder.isConfigSupported({
                            codec: (0,avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_51__["default"])(audioStream.codecpar),
                            sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](audioStream.codecpar + 136),
                            numberOfChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](audioStream.codecpar + 116)
                        });
                        if (!isSupport.supported) {
                            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`${(0,avformat_dump__WEBPACK_IMPORTED_MODULE_53__.dumpCodecName)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](audioStream.codecpar), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](audioStream.codecpar + 4))} codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](audioStream.codecpar + 4)} not support`, cheap__fileName__5, 1525);
                        }
                    }
                    else {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`${(0,avformat_dump__WEBPACK_IMPORTED_MODULE_53__.dumpCodecName)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](audioStream.codecpar), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](audioStream.codecpar + 4))} codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](audioStream.codecpar + 4)} not support`, cheap__fileName__5, 1529);
                    }
                }
                // 
                await AVPlayer.AudioDecoderThread.registerTask
                    .transfer(this.demuxer2AudioDecoderChannel.port2, this.audioDecoder2AudioRenderChannel.port1)
                    .invoke({
                    taskId: this.taskId,
                    resource,
                    leftPort: this.demuxer2AudioDecoderChannel.port2,
                    rightPort: this.audioDecoder2AudioRenderChannel.port1,
                    stats: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32,
                    timeBase: {
                        num: audioStream.timeBase.num,
                        den: audioStream.timeBase.den,
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24,
                    avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 12,
                    avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28
                });
                let ret = await AVPlayer.AudioDecoderThread.open(this.taskId, (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_65__.serializeAVCodecParameters)(audioStream.codecpar));
                if (ret < 0) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal(`cannot open audio ${(0,avformat_dump__WEBPACK_IMPORTED_MODULE_53__.dumpCodecName)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](audioStream.codecpar), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](audioStream.codecpar + 4))} decoder`, cheap__fileName__5, 1554);
                }
                await AVPlayer.DemuxerThread.connectStreamTask
                    .transfer(this.demuxer2AudioDecoderChannel.port1)
                    .invoke(this.taskId, audioStream.index, this.demuxer2AudioDecoderChannel.port1);
            }
            if (this.videoDecoder2VideoRenderChannel) {
                this.canvas = this.createCanvas();
                this.options.container.appendChild(this.canvas);
                const canvas = ((0,_function_supportOffscreenCanvas__WEBPACK_IMPORTED_MODULE_29__["default"])()
                    && (cheap_config__WEBPACK_IMPORTED_MODULE_23__.USE_THREADS
                        && true
                        || common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].worker
                            && this.options.enableWorker))
                    ? this.canvas.transferControlToOffscreen()
                    : this.canvas;
                const stream = this.formatContext.streams.find((stream) => {
                    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */;
                });
                // 
                await this.VideoRenderThread.registerTask
                    .transfer(this.videoDecoder2VideoRenderChannel.port2, this.controller.getVideoRenderControlPort(), canvas)
                    .invoke({
                    taskId: this.taskId,
                    leftPort: this.videoDecoder2VideoRenderChannel.port2,
                    controlPort: this.controller.getVideoRenderControlPort(),
                    canvas,
                    renderMode: this.renderMode,
                    renderRotate: this.renderRotate,
                    flipHorizontal: this.flipHorizontal,
                    flipVertical: this.flipVertical,
                    timeBase: {
                        num: stream.timeBase.num,
                        den: stream.timeBase.den,
                    },
                    viewportWidth: this.options.container.offsetWidth,
                    viewportHeight: this.options.container.offsetHeight,
                    devicePixelRatio: devicePixelRatio,
                    stats: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32,
                    enableWebGPU: this.options.enableWebGPU,
                    startPTS: stream.startTime,
                    avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 12,
                    avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28,
                    enableJitterBuffer: !!this.jitterBufferController && !this.audioDecoder2AudioRenderChannel
                });
                this.videoEnded = false;
                this.VideoRenderThread.setPlayRate(this.taskId, this.playRate);
                promises.push(this.VideoRenderThread.play(this.taskId));
            }
            if (this.audioDecoder2AudioRenderChannel) {
                const stream = this.formatContext.streams.find((stream) => {
                    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */;
                });
                this.audioRender2AudioWorkletChannel = new MessageChannel();
                const playChannels = Math.max(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 116), Math.min(AVPlayer.audioContext.destination.channelCount, 2));
                let resamplerResource = await this.getResource('resampler');
                let stretchpitcherResource = await this.getResource('stretchpitcher');
                if (!resamplerResource) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal('resampler not found', cheap__fileName__5, 1627);
                }
                if (!stretchpitcherResource) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_30__.fatal('stretch pitcher not found', cheap__fileName__5, 1630);
                }
                // 
                await AVPlayer.AudioRenderThread.registerTask
                    .transfer(this.audioDecoder2AudioRenderChannel.port2, this.audioRender2AudioWorkletChannel.port1, this.controller.getAudioRenderControlPort())
                    .invoke({
                    taskId: this.taskId,
                    leftPort: this.audioDecoder2AudioRenderChannel.port2,
                    rightPort: this.audioRender2AudioWorkletChannel.port1,
                    controlPort: this.controller.getAudioRenderControlPort(),
                    playFormat: 8 /* AVSampleFormat.AV_SAMPLE_FMT_FLTP */,
                    playSampleRate: AVPlayer.audioContext.sampleRate,
                    playChannels: playChannels,
                    resamplerResource,
                    stretchpitcherResource,
                    stats: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32,
                    timeBase: {
                        num: stream.timeBase.num,
                        den: stream.timeBase.den,
                    },
                    startPTS: stream.startTime,
                    avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 12,
                    avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28,
                    enableJitterBuffer: !!this.jitterBufferController
                });
                // 
                let AudioSource;
                if (common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].audioWorklet) {
                    AudioSource = avrender_pcm_AudioSourceWorkletNode__WEBPACK_IMPORTED_MODULE_25__["default"];
                }
                else {
                    AudioSource = avrender_pcm_AudioSourceBufferNode__WEBPACK_IMPORTED_MODULE_32__["default"];
                }
                this.audioSourceNode = new AudioSource(AVPlayer.audioContext, {
                    onEnded: () => {
                        this.onAudioEnded();
                    },
                    onFirstRendered: () => {
                        this.onFirstAudioRendered();
                    },
                    onStutter: () => {
                        this.onAudioStutter();
                    }
                }, {
                    numberOfInputs: 1,
                    numberOfOutputs: 1,
                    outputChannelCount: [playChannels],
                    isMainWorker: !!AVPlayer.AudioPipelineProxy
                });
                if (cheap_config__WEBPACK_IMPORTED_MODULE_23__.USE_THREADS
                    && true
                    && common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].audioWorklet
                    && (!common_util_browser__WEBPACK_IMPORTED_MODULE_34__["default"].safari || common_util_browser__WEBPACK_IMPORTED_MODULE_34__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_34__["default"].version, '16.1', true))) {
                    await this.audioSourceNode.request('init', {
                        memory: cheap_heap__WEBPACK_IMPORTED_MODULE_26__.Memory
                    });
                }
                AVPlayer.AudioRenderThread.setPlayTempo(this.taskId, this.playRate);
                this.gainNode = AVPlayer.audioContext.createGain();
                this.gainNode.connect(AVPlayer.audioContext.destination);
                this.audioSourceNode.connect(this.gainNode);
                this.setVolume(this.volume);
                this.audioEnded = false;
                promises.push(this.audioSourceNode.request('start', {
                    port: this.audioRender2AudioWorkletChannel.port2,
                    channels: playChannels
                }, [this.audioRender2AudioWorkletChannel.port2]));
            }
            if (this.audioDecoder2AudioRenderChannel) {
                this.controller.setTimeUpdateListenType(1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
            }
            else if (this.videoDecoder2VideoRenderChannel) {
                this.controller.setTimeUpdateListenType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
            }
            //  10 
            // 
            if (this.videoDecoder2VideoRenderChannel
                && this.audioDecoder2AudioRenderChannel
                && common_util_bigint__WEBPACK_IMPORTED_MODULE_48__.abs(videoStartTime - audioStartTime) > BigInt(10000)) {
                this.controller.setEnableAudioVideoSync(false);
            }
        }
        const subtitleStream = this.findBestStream(this.formatContext.streams, 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */);
        if (subtitleStream && options.subtitle && this.isCodecIdSupported(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](subtitleStream.codecpar + 4))) {
            const externalTask = this.externalSubtitleTasks.find((task) => {
                return task.streamId === subtitleStream.id;
            });
            this.createSubtitleRender(subtitleStream, externalTask ? externalTask.taskId : (this.subtitleTaskId || this.taskId));
        }
        if (this.subtitleRender && this.externalSubtitleTasks.length) {
            for (let i = 0; i < this.externalSubtitleTasks.length; i++) {
                const stream = this.formatContext.streams.find(((s) => s.id === this.externalSubtitleTasks[i].streamId));
                if (stream !== subtitleStream) {
                    await AVPlayer.DemuxerThread.connectStreamTask.transfer(this.subtitleRender.getDemuxerPort(this.externalSubtitleTasks[i].taskId))
                        .invoke(this.externalSubtitleTasks[i].taskId, stream.index, this.subtitleRender.getDemuxerPort(this.externalSubtitleTasks[i].taskId));
                }
            }
        }
        let minQueueLength = 10;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_15__.string(this.source) && !this.options.isLive) {
            this.formatContext.streams.forEach((stream) => {
                minQueueLength = Math.max(Math.ceil((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_35__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_5__["default"])(stream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational)) * this.options.preLoadTime), minQueueLength);
            });
        }
        promises.push(AVPlayer.DemuxerThread.startDemux(this.taskId, this.options.isLive, minQueueLength));
        if ( true && this.subTaskId) {
            promises.push(AVPlayer.DemuxerThread.startDemux(this.subTaskId, this.options.isLive, minQueueLength));
        }
        if (( true) && this.subtitleTaskId) {
            promises.push(AVPlayer.DemuxerThread.startDemux(this.subtitleTaskId, this.options.isLive, minQueueLength));
        }
        return Promise.all(promises).then(async () => {
            this.status = 6 /* AVPlayerStatus.PLAYED */;
            if ( true && this.useMSE) {
                await Promise.all([
                    this.video?.play(),
                    this.audio?.play()
                ]).catch((error) => {
                    if (this.video) {
                        this.video.muted = true;
                        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.RESUME);
                        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn('the audioContext was not started. It must be resumed after a user gesture', cheap__fileName__5, 1774);
                        return this.video.play();
                    }
                    else {
                        throw error;
                    }
                });
            }
            else {
                if (this.audioSourceNode && AVPlayer.audioContext.state === 'suspended') {
                    if (AVPlayer.audioContext.state === 'suspended') {
                        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.RESUME);
                        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn('the audioContext was not started. It must be resumed after a user gesture', cheap__fileName__5, 1786);
                    }
                    if (this.videoDecoder2VideoRenderChannel) {
                        AVPlayer.AudioRenderThread.fakePlay(this.taskId);
                        this.controller.setTimeUpdateListenType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
                    }
                    else {
                        //  mse 
                        throw new Error('the audioContext was not started. It must be resumed after a user gesture');
                    }
                }
            }
            this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.PLAYED);
            this.statsController.start();
            if (this.jitterBufferController) {
                this.jitterBufferController.start();
            }
            if (this.subtitleRender) {
                this.subtitleRender.start();
            }
        });
    }
    /**
     * 
     */
    async pause() {
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`call pause, taskId: ${this.taskId}`, cheap__fileName__5, 1814);
        if (!this.options.isLive) {
            const promises = [];
            if ( true && this.useMSE) {
                if (this.audio) {
                    this.audio.pause();
                }
                if (this.video) {
                    this.video.pause();
                }
                promises.push(AVPlayer.MSEThread.pause(this.taskId));
            }
            else {
                if (this.audioSourceNode) {
                    promises.push(this.audioSourceNode.request('pause'));
                    // stop fake play
                    promises.push(AVPlayer.AudioRenderThread.pause(this.taskId));
                }
                if (this.videoDecoder2VideoRenderChannel) {
                    promises.push(this.VideoRenderThread.pause(this.taskId));
                }
            }
            return Promise.all(promises).then(() => {
                if (this.status === 8 /* AVPlayerStatus.SEEKING */) {
                    this.lastStatus = 7 /* AVPlayerStatus.PAUSED */;
                }
                else {
                    this.status = 7 /* AVPlayerStatus.PAUSED */;
                }
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.PAUSED);
                if (this.jitterBufferController) {
                    this.jitterBufferController.stop();
                }
                if (this.subtitleRender) {
                    this.subtitleRender.pause();
                }
            });
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn(`pause can only used in vod, taskId: ${this.taskId}`, cheap__fileName__5, 1854);
        }
    }
    async doSeek(timestamp, streamIndex, options = {}) {
        if ( true && this.useMSE) {
            await AVPlayer.MSEThread.beforeSeek(this.taskId);
        }
        else {
            await Promise.all([
                AVPlayer.AudioRenderThread?.beforeSeek(this.taskId),
                this.VideoRenderThread?.beforeSeek(this.taskId)
            ]);
        }
        if (options.onBeforeSeek) {
            await options.onBeforeSeek();
        }
        let seekedTimestamp = -BigInt(1);
        if ( true && this.isHls()) {
            seekedTimestamp = await AVPlayer.DemuxerThread.seek(this.taskId, timestamp, 16 /* AVSeekFlags.TIMESTAMP */);
        }
        else if ( true && this.isDash()) {
            seekedTimestamp = await AVPlayer.DemuxerThread.seek(this.taskId, timestamp, 16 /* AVSeekFlags.TIMESTAMP */);
            if (this.subTaskId) {
                await AVPlayer.DemuxerThread.seek(this.subTaskId, timestamp, 16 /* AVSeekFlags.TIMESTAMP */);
            }
        }
        else {
            seekedTimestamp = await AVPlayer.DemuxerThread.seek(this.taskId, timestamp, 8 /* AVSeekFlags.FRAME */, streamIndex);
        }
        if (( true) && this.subtitleTaskId) {
            await AVPlayer.DemuxerThread.seek(this.subtitleTaskId, timestamp, 16 /* AVSeekFlags.TIMESTAMP */);
        }
        if (seekedTimestamp >= BigInt(0)) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.debug(`seeked to packet timestamp: ${seekedTimestamp}, taskId: ${this.taskId}`, cheap__fileName__5, 1896);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.error(`demuxer seek failed, code: ${seekedTimestamp}, taskId: ${this.taskId}`, cheap__fileName__5, 1899);
        }
        if ( true && this.useMSE) {
            if (seekedTimestamp >= BigInt(0)) {
                const time = await AVPlayer.MSEThread.afterSeek(this.taskId, seekedTimestamp > timestamp ? seekedTimestamp : timestamp);
                if (this.video) {
                    this.video.currentTime = time;
                }
                else if (this.audio) {
                    this.audio.currentTime = time;
                }
            }
            else {
                await AVPlayer.MSEThread.afterSeek(this.taskId, avutil_constant__WEBPACK_IMPORTED_MODULE_36__.NOPTS_VALUE_BIGINT);
            }
        }
        else {
            let maxQueueLength = 20;
            this.formatContext.streams.forEach((stream) => {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    maxQueueLength = Math.max(Math.ceil((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_35__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_5__["default"])(stream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational))), maxQueueLength);
                }
            });
            if (seekedTimestamp >= BigInt(0)) {
                await Promise.all([
                    AVPlayer.AudioDecoderThread?.resetTask(this.taskId),
                    this.VideoDecoderThread?.resetTask(this.taskId)
                ]);
                await Promise.all([
                    AVPlayer.AudioRenderThread?.syncSeekTime(this.taskId, seekedTimestamp > timestamp ? seekedTimestamp : timestamp, maxQueueLength),
                    this.VideoRenderThread?.syncSeekTime(this.taskId, seekedTimestamp > timestamp ? seekedTimestamp : timestamp, maxQueueLength)
                ]);
                await Promise.all([
                    AVPlayer.AudioRenderThread?.afterSeek(this.taskId, seekedTimestamp > timestamp ? seekedTimestamp : timestamp),
                    this.VideoRenderThread?.afterSeek(this.taskId, seekedTimestamp > timestamp ? seekedTimestamp : timestamp),
                ]);
            }
            else {
                await Promise.all([
                    AVPlayer.AudioRenderThread?.syncSeekTime(this.taskId, avutil_constant__WEBPACK_IMPORTED_MODULE_36__.NOPTS_VALUE_BIGINT, maxQueueLength),
                    this.VideoRenderThread?.syncSeekTime(this.taskId, avutil_constant__WEBPACK_IMPORTED_MODULE_36__.NOPTS_VALUE_BIGINT, maxQueueLength),
                ]);
                await Promise.all([
                    AVPlayer.AudioRenderThread?.afterSeek(this.taskId, avutil_constant__WEBPACK_IMPORTED_MODULE_36__.NOPTS_VALUE_BIGINT),
                    this.VideoRenderThread?.afterSeek(this.taskId, avutil_constant__WEBPACK_IMPORTED_MODULE_36__.NOPTS_VALUE_BIGINT),
                ]);
            }
            if (this.jitterBufferController) {
                this.jitterBufferController.reset();
            }
        }
        for (let i = 0; i < this.externalSubtitleTasks.length; i++) {
            await AVPlayer.DemuxerThread.seek(this.externalSubtitleTasks[i].taskId, this.currentTime, 8 /* AVSeekFlags.FRAME */);
        }
        if (this.subtitleRender) {
            this.subtitleRender.reset();
        }
    }
    /**
     * 
     *  seek 
     *
     * @param timestamp 
     */
    async seek(timestamp) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`call seek, timestamp: ${timestamp}, taskId: ${this.taskId}`, cheap__fileName__5, 1975);
        if (!this.formatContext.streams.length) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.error(`cannot found any stream to seek, taskId: ${this.taskId}`, cheap__fileName__5, 1978);
            return;
        }
        if (this.status === 8 /* AVPlayerStatus.SEEKING */) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn(`player is seeking now, taskId: ${this.taskId}`, cheap__fileName__5, 1983);
            return;
        }
        if (!this.options.isLive) {
            this.lastStatus = this.status;
            this.status = 8 /* AVPlayerStatus.SEEKING */;
            this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.SEEKING);
            let streamIndex = -1;
            if (this.selectedVideoStream) {
                streamIndex = this.selectedVideoStream.index;
            }
            else if (this.selectedAudioStream) {
                streamIndex = this.selectedAudioStream.index;
            }
            await this.doSeek(timestamp, streamIndex);
            this.status = this.lastStatus;
            this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.SEEKED);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn(`seek can only used in vod, taskId: ${this.taskId}`, cheap__fileName__5, 2008);
        }
    }
    /**
     * 
     *
     * @returns
     */
    getStreams() {
        return this.formatContext.streams.map((stream) => {
            return {
                ...stream,
                /**
                 * 
                 */
                mediaType: (0,avformat_dump__WEBPACK_IMPORTED_MODULE_53__.dumpKey)(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_52__.mediaType2AVMediaType, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar)),
                codecparProxy: (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_5__["default"])(stream.codecpar, _avutil_struct_avcodecparameters_ts__WEBPACK_IMPORTED_MODULE_6__["default"])
            };
        });
    }
    /**
     *  id
     *
     * @returns
     */
    getSelectedVideoStreamId() {
        if (this.selectedVideoStream) {
            return this.selectedVideoStream.id;
        }
        return -1;
    }
    /**
     *  id
     *
     * @returns
     */
    getSelectedAudioStreamId() {
        if (this.selectedAudioStream) {
            return this.selectedAudioStream.id;
        }
        return -1;
    }
    /**
     *  id
     *
     * @returns
     */
    getSelectedSubtitleStreamId() {
        if (this.selectedSubtitleStream) {
            return this.selectedSubtitleStream.id;
        }
        return -1;
    }
    /**
     * 
     *
     * @returns
     */
    getChapters() {
        return this.formatContext.chapters;
    }
    /**
     * 
     *
     * @returns
     */
    getDuration() {
        if (!this.options.isLive) {
            let max = BigInt(0);
            this.formatContext.streams.forEach((stream) => {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                    || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    const duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_35__.avRescaleQ)(stream.duration, {
                        den: stream.timeBase.den,
                        num: stream.timeBase.num
                    }, avutil_constant__WEBPACK_IMPORTED_MODULE_36__.AV_MILLI_TIME_BASE_Q);
                    if (duration > max) {
                        max = duration;
                    }
                }
            });
            return max;
        }
        return BigInt(0);
    }
    /**
     * 
     *
     * @returns
     */
    async stop() {
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`call stop, taskId: ${this.taskId}`, cheap__fileName__5, 2112);
        if (this.status === 0 /* AVPlayerStatus.STOPPED */) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn(`player has already stopped, taskId: ${this.taskId}`, cheap__fileName__5, 2115);
            return;
        }
        if (this.audioSourceNode) {
            await this.audioSourceNode.request('stop');
            this.audioSourceNode.disconnect();
            this.audioSourceNode = null;
        }
        if (this.VideoRenderThread) {
            await this.VideoRenderThread.unregisterTask(this.taskId);
        }
        if (AVPlayer.AudioRenderThread) {
            await AVPlayer.AudioRenderThread.unregisterTask(this.taskId);
        }
        if (this.VideoDecoderThread) {
            await this.VideoDecoderThread.unregisterTask(this.taskId);
        }
        if (AVPlayer.AudioDecoderThread) {
            await AVPlayer.AudioDecoderThread.unregisterTask(this.taskId);
        }
        if (AVPlayer.MSEThread) {
            await AVPlayer.MSEThread.unregisterTask(this.taskId);
        }
        if (AVPlayer.DemuxerThread) {
            await AVPlayer.DemuxerThread.unregisterTask(this.taskId);
            if ( true && this.subTaskId) {
                await AVPlayer.DemuxerThread.unregisterTask(this.subTaskId);
            }
            if (( true) && this.subtitleTaskId) {
                await AVPlayer.DemuxerThread.unregisterTask(this.subtitleTaskId);
            }
        }
        if (AVPlayer.IOThread) {
            await AVPlayer.IOThread.unregisterTask(this.taskId);
        }
        if (this.ioIPCPort) {
            await this.source.stop();
            this.ioIPCPort.destroy();
            this.ioIPCPort = null;
        }
        for (let i = 0; i < this.externalSubtitleTasks.length; i++) {
            await AVPlayer.DemuxerThread.unregisterTask(this.externalSubtitleTasks[i].taskId);
            await AVPlayer.IOThread.unregisterTask(this.externalSubtitleTasks[i].taskId);
        }
        if (this.subtitleRender) {
            this.subtitleRender.destroy();
            this.subtitleRender = null;
        }
        if (this.gainNode) {
            this.gainNode.disconnect();
            this.gainNode = null;
        }
        if (this.controller) {
            this.controller.destroy();
        }
        if ((this.video || this.audio)?.src) {
            URL.revokeObjectURL((this.video || this.audio).src);
        }
        if (this.video) {
            this.options.container.removeChild(this.video);
            this.video = null;
        }
        if (this.audio) {
            this.options.container.removeChild(this.audio);
            this.audio = null;
        }
        if (this.canvas) {
            this.options.container.removeChild(this.canvas);
            this.canvas = null;
        }
        this.ioloader2DemuxerChannel = null;
        this.demuxer2VideoDecoderChannel = null;
        this.demuxer2AudioDecoderChannel = null;
        this.videoDecoder2VideoRenderChannel = null;
        this.audioDecoder2AudioRenderChannel = null;
        this.audioRender2AudioWorkletChannel = null;
        this.selectedAudioStream = null;
        this.selectedVideoStream = null;
        this.selectedSubtitleStream = null;
        this.lastSelectedInnerSubtitleStreamIndex = -1;
        this.source = null;
        this.ext = '';
        this.statsController.stop();
        if (this.jitterBufferController) {
            this.jitterBufferController.stop();
            this.jitterBufferController = null;
        }
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.STOPPED);
        this.status = 0 /* AVPlayerStatus.STOPPED */;
    }
    /*
    * 
    *
    * @param rate
    */
    setPlaybackRate(rate) {
        if (!this.options.isLive) {
            this.playRate = (0,common_function_restrain__WEBPACK_IMPORTED_MODULE_33__["default"])(rate, 0.5, 2);
            if ( true && this.useMSE) {
                AVPlayer.MSEThread?.setPlayRate(this.taskId, this.playRate);
                if (this.video) {
                    this.video.playbackRate = this.playRate;
                }
                else if (this.audio) {
                    this.audio.playbackRate = this.playRate;
                }
            }
            else {
                AVPlayer.AudioRenderThread?.setPlayTempo(this.taskId, this.playRate);
                this.VideoRenderThread?.setPlayRate(this.taskId, this.playRate);
                this.VideoDecoderThread?.setPlayRate(this.taskId, this.playRate);
            }
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`player call setPlaybackRate, set ${this.playRate}, taskId: ${this.taskId}`, cheap__fileName__5, 2237);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn(`setPlaybackRate can only used in playback, taskId: ${this.taskId}`, cheap__fileName__5, 2240);
        }
    }
    /**
     * 
     *
     * @returns
     */
    getPlaybackRate() {
        return this.playRate;
    }
    /**
     * resume 
     */
    async resume() {
        if (AVPlayer.audioContext?.state === 'suspended') {
            await Promise.race([
                AVPlayer.audioContext.resume(),
                new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_45__["default"](0.1)
            ]);
            if (AVPlayer.audioContext.state === 'suspended') {
                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn('the audioContext was not allowed to start. It must be resumed after a user gesture', cheap__fileName__5, 2263);
            }
            else {
                if (this.audioSourceNode) {
                    this.controller.setTimeUpdateListenType(1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
                }
                if (this.video) {
                    this.video.muted = false;
                }
            }
        }
        if (this.video) {
            this.video.muted = false;
            if (!this.video.played) {
                await this.video.play();
            }
        }
        else if (this.audio) {
            this.audio.muted = false;
            if (!this.audio.played) {
                await this.audio.play();
            }
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`call resume, taskId: ${this.taskId}`, cheap__fileName__5, 2287);
    }
    /**
     * 
     *
     * @returns
     */
    getVolume() {
        return this.volume;
    }
    /**
     * 
     *
     * @param volume [0, 3]
     *
     */
    setVolume(volume, force = false) {
        this.volume = (0,common_function_restrain__WEBPACK_IMPORTED_MODULE_33__["default"])(volume, 0, 3);
        if (this.gainNode && AVPlayer.audioContext) {
            this.gainNode.gain.cancelScheduledValues(AVPlayer.audioContext.currentTime);
            if (common_util_browser__WEBPACK_IMPORTED_MODULE_34__["default"].firefox && !force) {
                this.gainNode.gain.setValueAtTime(this.volume, AVPlayer.audioContext.currentTime + 1);
            }
            else {
                if (this.gainNode.gain.value === 0 || this.volume === 0 || force) {
                    this.gainNode.gain.value = this.volume;
                }
                else {
                    this.gainNode.gain.exponentialRampToValueAtTime(this.volume, AVPlayer.audioContext.currentTime + 1);
                }
            }
        }
        else if (this.video) {
            this.video.volume = this.volume;
        }
        else if (this.audio) {
            this.audio.volume = this.volume;
        }
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.VOLUME_CHANGE, [this.volume]);
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`player call setVolume, set ${volume}, used ${this.volume}, taskId: ${this.taskId}`, cheap__fileName__5, 2331);
    }
    /**
     *
     * 
     *
     * @param mode
     * @returns
     */
    getRenderMode() {
        return this.renderMode;
    }
    /**
     * 
     *
     * - 0 
     * - 1 
     *
     * @param mode
     */
    setRenderMode(mode) {
        this.renderMode = mode;
        if ( true && this.useMSE && this.video) {
            this.video.style['object-fit'] = ObjectFitMap[this.renderMode];
        }
        else {
            this.VideoRenderThread?.setRenderMode(this.taskId, mode);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`player call setRenderMode, mode: ${mode}, taskId: ${this.taskId}`, cheap__fileName__5, 2361);
    }
    getVideoTransformContext() {
        let text = '';
        if (this.renderRotate !== 0) {
            text += `rotateZ(${this.renderRotate}deg)`;
        }
        if (this.flipHorizontal) {
            text += `${text.length ? ' ' : ''}scaleX(-1)`;
        }
        if (this.flipVertical) {
            text += `${text.length ? ' ' : ''}scaleY(-1)`;
        }
        return text;
    }
    /**
     * 
     *
     * @param angle
     */
    setRotate(angle) {
        this.renderRotate = angle;
        if ( true && this.useMSE && this.video) {
            this.video.style.transform = this.getVideoTransformContext();
        }
        else {
            this.VideoRenderThread?.setRenderRotate(this.taskId, angle);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`player call setRotate, angle: ${angle}, taskId: ${this.taskId}`, cheap__fileName__5, 2391);
    }
    enableHorizontalFlip(enable) {
        this.flipHorizontal = enable;
        if ( true && this.useMSE && this.video) {
            this.video.style.transform = this.getVideoTransformContext();
        }
        else {
            this.VideoRenderThread?.enableHorizontalFlip(this.taskId, enable);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`player call enableHorizontalFlip, enable: ${enable}, taskId: ${this.taskId}`, cheap__fileName__5, 2402);
    }
    enableVerticalFlip(enable) {
        this.flipVertical = enable;
        if ( true && this.useMSE && this.video) {
            this.video.style.transform = this.getVideoTransformContext();
        }
        else {
            this.VideoRenderThread?.enableVerticalFlip(this.taskId, enable);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`player call enableVerticalFlip, enable: ${enable}, taskId: ${this.taskId}`, cheap__fileName__5, 2413);
    }
    /**
     * 
     *
     * @param enable
     */
    setLoop(enable) {
        this.options.loop = enable;
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`call setLoop, enable: ${enable}, taskId: ${this.taskId}`, cheap__fileName__5, 2425);
    }
    /**
     *
     * 
     *
     * @param delay
     */
    setSubtitleDelay(delay) {
        if (this.subtitleRender && this.getSubtitleDelay() !== delay) {
            this.subtitleRender.setDelay(BigInt(delay >> 0));
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`set subtitle delay ${delay}`, cheap__fileName__5, 2438);
            this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.SUBTITLE_DELAY_CHANGE, [delay]);
        }
    }
    /**
     * 
     *
     * @returns
     */
    getSubtitleDelay() {
        if (this.subtitleRender) {
            return Number(BigInt.asIntN(32, this.subtitleRender.getDelay()));
        }
        return 0;
    }
    /**
     * 
     *
     * @param enable
     */
    setSubtitleEnable(enable) {
        if (this.subtitleRender && this.selectedSubtitleStream) {
            if (enable) {
                const externalTask = this.externalSubtitleTasks.find((task) => {
                    return task.streamId === this.selectedSubtitleStream.id;
                });
                if (externalTask) {
                    AVPlayer.DemuxerThread.seek(externalTask.taskId, this.currentTime, 8 /* AVSeekFlags.FRAME */);
                }
                this.subtitleRender.reset();
                this.subtitleRender.start();
            }
            else {
                this.subtitleRender.stop();
            }
        }
    }
    /**
     * 
     *
     * @param width
     * @param height
     */
    resize(width, height) {
        if (!this.useMSE) {
            this.VideoRenderThread?.resize(this.taskId, width, height);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`player call resize, width: ${width}, height: ${height}, taskId: ${this.taskId}`, cheap__fileName__5, 2489);
    }
    /**
     *  mse 
     *
     * @returns
     */
    isMSE() {
        return this.useMSE;
    }
    /**
     *  live 
     *
     * @returns
     */
    isLive() {
        return this.options.isLive;
    }
    /**
     *  dash 
     *
     * @returns
     */
    async getVideoList() {
        return AVPlayer.IOThread?.getVideoList(this.taskId);
    }
    /**
     *  dash 
     *
     * @returns
     */
    async getAudioList() {
        return AVPlayer.IOThread?.getAudioList(this.taskId);
    }
    /**
     *  dash 
     *
     * @returns
     */
    async getSubtitleList() {
        return AVPlayer.IOThread?.getSubtitleList(this.taskId);
    }
    /**
     *  status 
     *
     * @returns
     */
    getStatus() {
        return this.status;
    }
    /**
     * 
     *
     * @returns
     */
    hasAudio() {
        return !!this.selectedAudioStream;
    }
    /**
     * 
     *
     * @returns
     */
    hasVideo() {
        return !!this.selectedVideoStream;
    }
    /**
     * 
     *
     * @returns
     */
    hasSubtitle() {
        return !!this.selectedSubtitleStream;
    }
    /**
     * 
     *
     * @returns
     */
    getSource() {
        return this.source;
    }
    /**
     *  formatContext 
     *
     * @returns
     */
    getFormatContext() {
        return this.formatContext;
    }
    /**
     * 
     *
     * @returns
     */
    getExternalSubtitle() {
        return this.externalSubtitleTasks.map((task) => {
            return {
                source: task.source,
                lang: task.lang,
                title: task.title
            };
        });
    }
    /**
     *  AVPlayerOptions
     *
     * @returns
     */
    getOptions() {
        return this.options;
    }
    /**
     * load 
     *
     * @param is
     */
    setIsLive(is) {
        this.options.isLive = is;
    }
    /**
     *  audioContext  Node
     */
    getAudioOutputNode() {
        return this.gainNode;
    }
    /**
     * 
     *
     * @returns
     */
    isPictureInPicture() {
        if (this.useMSE) {
            return this.video && document.pictureInPictureElement === this.video;
        }
        else if (this.canvas && typeof documentPictureInPicture === 'object') {
            return documentPictureInPicture.window
                && documentPictureInPicture.window.document.body.querySelector('#' + this.canvas.id) === this.canvas;
        }
        return false;
    }
    /**
     * 
     *
     * @param id  iddash  getVideoList  index
     * @returns
     */
    async selectVideo(id) {
        if ( true && this.isHls() ||  true && this.isDash()) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`call IOThread selectVideo, index: ${id}, taskId: ${this.taskId}`, cheap__fileName__5, 2654);
            return AVPlayer.IOThread?.selectVideo(this.taskId, id);
        }
        else {
            const stream = this.formatContext.streams.find((stream) => stream.id === id);
            if (this.selectedVideoStream && stream && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */ && stream !== this.selectedVideoStream) {
                if (this.status === 9 /* AVPlayerStatus.CHANGING */) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn(`player is changing now, taskId: ${this.taskId}`, cheap__fileName__5, 2662);
                    return;
                }
                this.lastStatus = this.status;
                this.status = 9 /* AVPlayerStatus.CHANGING */;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.CHANGING, [0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */, stream.id, this.selectedVideoStream.id]);
                if (this.useMSE) {
                    await this.doSeek(this.currentTime, stream.index, {
                        onBeforeSeek: async () => {
                            await AVPlayer.DemuxerThread.changeConnectStream(this.taskId, stream.index, this.selectedVideoStream.index);
                            await AVPlayer.MSEThread.reAddStream(this.taskId, stream.index, (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_65__.serializeAVCodecParameters)(stream.codecpar), stream.timeBase, stream.startTime);
                        }
                    });
                }
                else {
                    await this.doSeek(this.currentTime, stream.index, {
                        onBeforeSeek: async () => {
                            await AVPlayer.DemuxerThread.changeConnectStream(this.taskId, stream.index, this.selectedVideoStream.index);
                            await this.VideoDecoderThread.reopenDecoder(this.taskId, (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_65__.serializeAVCodecParameters)(stream.codecpar), await this.getResource('decoder', cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 4), 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */));
                        }
                    });
                }
                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`changed selected video stream, from ${this.selectedVideoStream.id} to ${stream.id}, taskId: ${this.taskId}`, cheap__fileName__5, 2690);
                this.selectedVideoStream = stream;
                if (this.subtitleRender) {
                    this.subtitleRender.updateVideoResolution(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 56), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 60));
                }
                this.status = this.lastStatus;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.CHANGED, [0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */, stream.id, this.selectedVideoStream.id]);
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.error(`call selectVideo failed, id: ${id}, taskId: ${this.taskId}`, cheap__fileName__5, 2701);
            }
        }
    }
    /**
     * 
     *
     * @param id  iddash  getAudioList  index
     * @returns
     */
    async selectAudio(id) {
        if ( true && this.isHls() ||  true && this.isDash()) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`call IOThread selectAudio, index: ${id}, taskId: ${this.taskId}`, cheap__fileName__5, 2714);
            return AVPlayer.IOThread?.selectAudio(this.taskId, id);
        }
        else {
            const stream = this.formatContext.streams.find((stream) => stream.id === id);
            if (this.selectedAudioStream && stream && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */ && stream !== this.selectedAudioStream) {
                if (this.status === 9 /* AVPlayerStatus.CHANGING */) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn(`player is changing now, taskId: ${this.taskId}`, cheap__fileName__5, 2721);
                    return;
                }
                this.lastStatus = this.status;
                this.status = 9 /* AVPlayerStatus.CHANGING */;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.CHANGING, [1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */, stream.id, this.selectedAudioStream.id]);
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 4) !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.selectedAudioStream.codecpar + 4)
                    || this.useMSE
                        && (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 136) !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.selectedAudioStream.codecpar + 136)
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 116) !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](this.selectedAudioStream.codecpar + 116))) {
                    let seekStreamId = stream.index;
                    if (this.selectedVideoStream) {
                        seekStreamId = this.selectedVideoStream.index;
                    }
                    if (this.useMSE) {
                        await this.doSeek(this.currentTime, seekStreamId, {
                            onBeforeSeek: async () => {
                                await AVPlayer.DemuxerThread.changeConnectStream(this.taskId, stream.index, this.selectedAudioStream.index);
                                await AVPlayer.MSEThread.reAddStream(this.taskId, stream.index, (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_65__.serializeAVCodecParameters)(stream.codecpar), stream.timeBase, stream.startTime);
                            }
                        });
                    }
                    else {
                        await this.doSeek(this.currentTime, seekStreamId, {
                            onBeforeSeek: async () => {
                                await AVPlayer.DemuxerThread.changeConnectStream(this.taskId, stream.index, this.selectedAudioStream.index);
                                await AVPlayer.AudioDecoderThread.reopenDecoder(this.taskId, (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_65__.serializeAVCodecParameters)(stream.codecpar), await this.getResource('decoder', cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 4), 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */));
                            }
                        });
                    }
                }
                else {
                    await AVPlayer.DemuxerThread.changeConnectStream(this.taskId, stream.index, this.selectedAudioStream.index, false);
                }
                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`changed selected audio stream, from ${this.selectedAudioStream.id} to ${stream.id}, taskId: ${this.taskId}`, cheap__fileName__5, 2762);
                this.selectedAudioStream = stream;
                this.status = this.lastStatus;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.CHANGED, [1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */, stream.id, this.selectedAudioStream.id]);
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.error(`call selectAudio failed, id: ${id}, taskId: ${this.taskId}`, cheap__fileName__5, 2771);
            }
        }
    }
    /**
     * 
     *
     * @param id  iddash  getSubtitleList  index
     * @returns
     */
    async selectSubtitle(id) {
        if ( true && this.isHls() ||  true && this.isDash()) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`call IOThread selectSubtitle, index: ${id}, taskId: ${this.taskId}`, cheap__fileName__5, 2784);
            await AVPlayer.IOThread?.selectSubtitle(this.taskId, id);
            if (this.subtitleTaskId) {
                await AVPlayer.DemuxerThread.seek(this.subtitleTaskId, this.currentTime, 16 /* AVSeekFlags.TIMESTAMP */);
            }
            if (this.subtitleRender) {
                this.subtitleRender.reset();
                this.subtitleRender.start();
            }
        }
        else {
            const stream = this.formatContext.streams.find((stream) => stream.id === id);
            if (this.selectedSubtitleStream && stream && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar) === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */ && stream !== this.selectedSubtitleStream) {
                if (this.status === 9 /* AVPlayerStatus.CHANGING */) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn(`player is changing now, taskId: ${this.taskId}`, cheap__fileName__5, 2798);
                    return;
                }
                this.lastStatus = this.status;
                this.status = 9 /* AVPlayerStatus.CHANGING */;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.CHANGING, [3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */, stream.id, this.selectedSubtitleStream.id]);
                this.subtitleRender.reopenDecoder(stream.codecpar);
                const externalTask = this.externalSubtitleTasks.find((task) => {
                    return task.streamId === stream.id;
                });
                if (externalTask) {
                    this.subtitleRender.setDemuxTask(externalTask.taskId);
                    this.subtitleRender.reset();
                    await AVPlayer.DemuxerThread.seek(externalTask.taskId, this.currentTime, 8 /* AVSeekFlags.FRAME */, stream.index);
                }
                else {
                    this.subtitleRender.setDemuxTask(this.taskId);
                    if (this.lastSelectedInnerSubtitleStreamIndex === -1) {
                        await AVPlayer.DemuxerThread.connectStreamTask.transfer(this.subtitleRender.getDemuxerPort(this.taskId))
                            .invoke(this.taskId, stream.index, this.subtitleRender.getDemuxerPort(this.taskId));
                    }
                    else {
                        await AVPlayer.DemuxerThread.changeConnectStream(this.taskId, stream.index, this.lastSelectedInnerSubtitleStreamIndex, false);
                    }
                    const lastExternalTask = this.externalSubtitleTasks.find((task) => {
                        return task.streamId === this.selectedSubtitleStream.id;
                    });
                    if (lastExternalTask) {
                        this.subtitleRender.reset();
                    }
                    this.lastSelectedInnerSubtitleStreamIndex = stream.index;
                }
                if (this.subtitleRender) {
                    this.subtitleRender.start();
                }
                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`changed selected subtitle stream, from ${this.selectedSubtitleStream.id} to ${stream.id}, taskId: ${this.taskId}`, cheap__fileName__5, 2837);
                this.selectedSubtitleStream = stream;
                this.status = this.lastStatus;
                this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.CHANGED, [3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */, stream.id, this.selectedSubtitleStream.id]);
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_30__.error(`call selectSubtitle failed, id: ${id}, taskId: ${this.taskId}`, cheap__fileName__5, 2845);
            }
        }
    }
    /**
     *  mse 
     */
    async playNextFrame() {
        if (!this.useMSE && this.status === 7 /* AVPlayerStatus.PAUSED */ && this.selectedVideoStream) {
            await this.VideoRenderThread.renderNextFrame(this.taskId);
        }
    }
    /**
     * 
     */
    enterFullscreen() {
        const element = this.options.container;
        if (element.requestFullscreen) {
            element.requestFullscreen();
        }
        else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        }
        else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
        }
        else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`player call enterFullscreen, taskId: ${this.taskId}`, cheap__fileName__5, 2876);
    }
    /**
     * 
     */
    exitFullscreen() {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
        else if (document.mozExitFullScreen) {
            document.mozExitFullScreen();
        }
        else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`player call exitFullscreen, taskId: ${this.taskId}`, cheap__fileName__5, 2892);
    }
    /**
     * 
     *
     * @param type 
     * @param quality 
     */
    snapshot(type = 'png', quality = 1) {
        if ( true && this.useMSE && this.video) {
            const canvas = document.createElement('canvas');
            canvas.width = this.video.videoWidth;
            canvas.height = this.video.videoHeight;
            const context = canvas.getContext('2d');
            context.drawImage(this.video, 0, 0);
            return canvas.toDataURL(`image/${type}`, quality);
        }
        else if (this.canvas) {
            return this.canvas.toDataURL(`image/${type}`, quality);
        }
    }
    /**
     * 
     *
     * @returns
     */
    getStats() {
        return this.GlobalData.stats;
    }
    /**
     * 
     *
     * @returns
     */
    async destroy() {
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`call destroy, taskId: ${this.taskId}`, cheap__fileName__5, 2931);
        if (this.status === 2 /* AVPlayerStatus.DESTROYED */) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_30__.warn(`player has already destroyed, taskId: ${this.taskId}`, cheap__fileName__5, 2934);
            return;
        }
        await this.stop();
        if (this.VideoPipelineProxy) {
            await this.VideoDecoderThread.clear();
            await this.VideoRenderThread.clear();
            await this.VideoPipelineProxy.destroy();
            this.VideoDecoderThread = null;
            this.VideoPipelineProxy = null;
        }
        if (this.VideoDecoderThread) {
            await this.VideoDecoderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_12__.closeThread)(this.VideoDecoderThread);
            this.VideoDecoderThread = null;
        }
        this.VideoRenderThread = null;
        if (this.GlobalData) {
            this.GlobalData.avframeList.clear((avframe) => {
                (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_18__.unrefAVFrame)(avframe);
            }, 20);
            this.GlobalData.avpacketList.clear((avpacket) => {
                (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_19__.unrefAVPacket)(avpacket);
            }, 20);
            cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_47__.destroy(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24);
            cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_47__.destroy(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28);
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_7__["default"])(this.GlobalData);
            this.GlobalData = null;
        }
        this.status = 2 /* AVPlayerStatus.DESTROYED */;
    }
    /**
     * @internal
     */
    onVideoEnded() {
        this.videoEnded = true;
        this.handleEnded();
    }
    /**
     * @internal
     */
    onAudioEnded() {
        this.audioEnded = true;
        this.handleEnded();
    }
    /**
     * @internal
     */
    onCanvasUpdated() {
        this.updateCanvas = this.createCanvas();
        const canvas = ((0,_function_supportOffscreenCanvas__WEBPACK_IMPORTED_MODULE_29__["default"])()
            && (cheap_config__WEBPACK_IMPORTED_MODULE_23__.USE_THREADS
                && true
                || common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].worker
                    && this.options.enableWorker))
            ? this.updateCanvas.transferControlToOffscreen()
            : this.updateCanvas;
        this.VideoRenderThread.updateCanvas
            .transfer(canvas)
            .invoke(this.taskId, canvas);
    }
    /**
     * @internal
     */
    async onGetDecoderResource(mediaType, codecId) {
        return this.getResource('decoder', codecId, mediaType);
    }
    /**
     * @internal
     */
    onFirstVideoRendered() {
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`first video frame rendered, taskId: ${this.taskId}`, cheap__fileName__5, 3020);
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.FIRST_VIDEO_RENDERED);
    }
    /**
     * @internal
     */
    onFirstAudioRendered() {
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`first audio frame rendered, taskId: ${this.taskId}`, cheap__fileName__5, 3028);
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.FIRST_AUDIO_RENDERED);
    }
    /**
     * @internal
     */
    onAudioStutter() {
        if (this.status === 6 /* AVPlayerStatus.PLAYED */) {
            this.GlobalData.stats.audioStutter++;
        }
    }
    onVideoStutter() {
        if (this.status === 6 /* AVPlayerStatus.PLAYED */) {
            this.GlobalData.stats.videoStutter++;
        }
    }
    /**
     * @internal
     */
    onFirstVideoRenderedAfterUpdateCanvas() {
        if (this.updateCanvas) {
            if (this.canvas) {
                this.options.container.removeChild(this.canvas);
            }
            this.canvas = this.updateCanvas;
            this.options.container.appendChild(this.canvas);
            this.updateCanvas = null;
        }
    }
    /**
     * @internal
     */
    onTimeUpdate(pts) {
        this.fire(_eventType__WEBPACK_IMPORTED_MODULE_28__.TIME, [pts]);
    }
    /**
     * @internal
     */
    onMSESeek(time) {
        if (this.audio) {
            this.audio.currentTime = time;
        }
        else if (this.video) {
            this.video.currentTime = time;
        }
    }
    async createVideoDecoderThread(enableWorker = true) {
        if (this.VideoDecoderThread) {
            return;
        }
        if (cheap_config__WEBPACK_IMPORTED_MODULE_23__.USE_THREADS || !common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].worker || !enableWorker || !(0,_function_supportOffscreenCanvas__WEBPACK_IMPORTED_MODULE_29__["default"])()) {
            this.VideoDecoderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_12__.createThreadFromClass)(avpipeline_VideoDecodePipeline__WEBPACK_IMPORTED_MODULE_10__["default"], {
                name: 'VideoDecoderThread',
            }, /*require.resolve*/(/*! ./..\avpipeline\VideoDecodePipeline.ts */ "./src/avpipeline/VideoDecodePipeline.ts")).run();
            this.VideoDecoderThread.setLogLevel(AVPlayer.level);
            this.VideoRenderThread = AVPlayer.VideoRenderThread;
        }
        else {
            this.VideoPipelineProxy = new _worker_VideoPipelineProxy__WEBPACK_IMPORTED_MODULE_68__["default"]();
            await this.VideoPipelineProxy.run();
            this.VideoPipelineProxy.setLogLevel(AVPlayer.level);
            this.VideoDecoderThread = this.VideoPipelineProxy.VideoDecodePipeline;
            this.VideoRenderThread = this.VideoPipelineProxy.VideoRenderPipeline;
        }
    }
    static async startDemuxPipeline(enableWorker = true) {
        if (AVPlayer.DemuxThreadReady) {
            return AVPlayer.DemuxThreadReady;
        }
        return AVPlayer.DemuxThreadReady = new Promise(async (resolve) => {
            if (cheap_config__WEBPACK_IMPORTED_MODULE_23__.USE_THREADS || !common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].worker || !enableWorker) {
                AVPlayer.IOThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_12__.createThreadFromClass)(avpipeline_IOPipeline__WEBPACK_IMPORTED_MODULE_8__["default"], {
                    name: 'IOThread'
                }, /*require.resolve*/(/*! ./..\avpipeline\IOPipeline.ts */ "./src/avpipeline/IOPipeline.ts")).run();
                AVPlayer.IOThread.setLogLevel(AVPlayer.level);
                AVPlayer.DemuxerThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_12__.createThreadFromClass)(avpipeline_DemuxPipeline__WEBPACK_IMPORTED_MODULE_9__["default"], {
                    name: 'DemuxerThread'
                }, /*require.resolve*/(/*! ./..\avpipeline\DemuxPipeline.ts */ "./src/avpipeline/DemuxPipeline.ts")).run();
                AVPlayer.DemuxerThread.setLogLevel(AVPlayer.level);
            }
            else {
                AVPlayer.IODemuxProxy = new _worker_IODemuxPipelineProxy__WEBPACK_IMPORTED_MODULE_66__["default"]();
                await AVPlayer.IODemuxProxy.run();
                AVPlayer.IODemuxProxy.setLogLevel(AVPlayer.level);
                AVPlayer.IOThread = AVPlayer.IODemuxProxy.IOPipeline;
                AVPlayer.DemuxerThread = AVPlayer.IODemuxProxy.DemuxPipeline;
            }
            resolve();
        });
    }
    static async startAudioPipeline(enableWorker = true) {
        if (AVPlayer.AudioThreadReady) {
            return AVPlayer.AudioThreadReady;
        }
        return AVPlayer.AudioThreadReady = new Promise(async (resolve) => {
            if (!AVPlayer.audioContext) {
                AVPlayer.audioContext = new (AudioContext || webkitAudioContext)();
            }
            if (common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].audioWorklet) {
                await (0,avrender_pcm_audioWorklet_base_registerProcessor__WEBPACK_IMPORTED_MODULE_24__["default"])(AVPlayer.audioContext,  true && cheap_config__WEBPACK_IMPORTED_MODULE_23__.USE_THREADS && (!common_util_browser__WEBPACK_IMPORTED_MODULE_34__["default"].safari || common_util_browser__WEBPACK_IMPORTED_MODULE_34__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_34__["default"].version, '16.1', true))
                    ? /*require.resolve*/(/*! avrender/pcm/AudioSourceWorkletProcessor2 */ "./src/avrender/pcm/AudioSourceWorkletProcessor2.ts")
                    : /*require.resolve*/(/*! avrender/pcm/AudioSourceWorkletProcessor */ "./src/avrender/pcm/AudioSourceWorkletProcessor.ts"));
            }
            if (cheap_config__WEBPACK_IMPORTED_MODULE_23__.USE_THREADS || !common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].worker || !enableWorker) {
                AVPlayer.AudioDecoderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_12__.createThreadFromClass)(avpipeline_AudioDecodePipeline__WEBPACK_IMPORTED_MODULE_11__["default"], {
                    name: 'AudioDecoderThread',
                }, /*require.resolve*/(/*! ./..\avpipeline\AudioDecodePipeline.ts */ "./src/avpipeline/AudioDecodePipeline.ts")).run();
                AVPlayer.AudioDecoderThread.setLogLevel(AVPlayer.level);
                AVPlayer.AudioRenderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_12__.createThreadFromClass)(avpipeline_AudioRenderPipeline__WEBPACK_IMPORTED_MODULE_20__["default"], {
                    name: 'AudioRenderThread',
                }, /*require.resolve*/(/*! ./..\avpipeline\AudioRenderPipeline.ts */ "./src/avpipeline/AudioRenderPipeline.ts")).run();
                AVPlayer.AudioRenderThread.setLogLevel(AVPlayer.level);
            }
            else {
                AVPlayer.AudioPipelineProxy = new _worker_AudioPipelineProxy__WEBPACK_IMPORTED_MODULE_67__["default"]();
                await AVPlayer.AudioPipelineProxy.run();
                AVPlayer.AudioPipelineProxy.setLogLevel(AVPlayer.level);
                AVPlayer.AudioDecoderThread = AVPlayer.AudioPipelineProxy.AudioDecodePipeline;
                AVPlayer.AudioRenderThread = AVPlayer.AudioPipelineProxy.AudioRenderPipeline;
            }
            resolve();
        });
    }
    static async startVideoRenderPipeline(enableWorker = true) {
        if (AVPlayer.VideoThreadReady) {
            return AVPlayer.VideoThreadReady;
        }
        return AVPlayer.VideoThreadReady = new Promise(async (resolve) => {
            if (cheap_config__WEBPACK_IMPORTED_MODULE_23__.USE_THREADS || !common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].worker || !enableWorker || !(0,_function_supportOffscreenCanvas__WEBPACK_IMPORTED_MODULE_29__["default"])()) {
                AVPlayer.VideoRenderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_12__.createThreadFromClass)(avpipeline_VideoRenderPipeline__WEBPACK_IMPORTED_MODULE_21__["default"], {
                    name: 'VideoRenderThread',
                    disableWorker: !(0,_function_supportOffscreenCanvas__WEBPACK_IMPORTED_MODULE_29__["default"])()
                }, /*require.resolve*/(/*! ./..\avpipeline\VideoRenderPipeline.ts */ "./src/avpipeline/VideoRenderPipeline.ts")).run();
                AVPlayer.VideoRenderThread.setLogLevel(AVPlayer.level);
            }
            resolve();
        });
    }
    static async startMSEPipeline(enableWorker = true) {
        {
            if (AVPlayer.MSEThreadReady) {
                return AVPlayer.MSEThreadReady;
            }
            return AVPlayer.MSEThreadReady = new Promise(async (resolve) => {
                if (cheap_config__WEBPACK_IMPORTED_MODULE_23__.USE_THREADS || !common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].worker || !enableWorker || !common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].workerMSE) {
                    AVPlayer.MSEThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_12__.createThreadFromClass)(_mse_MSEPipeline__WEBPACK_IMPORTED_MODULE_43__["default"], {
                        name: 'MSEThread',
                        disableWorker: !common_util_support__WEBPACK_IMPORTED_MODULE_31__["default"].workerMSE
                    }, /*require.resolve*/(/*! ./mse\MSEPipeline.ts */ "./src/avplayer/mse/MSEPipeline.ts")).run();
                    AVPlayer.MSEThread.setLogLevel(AVPlayer.level);
                }
                else {
                    AVPlayer.MSEPipelineProxy = new _worker_MSEPipelineProxy__WEBPACK_IMPORTED_MODULE_69__["default"]();
                    await AVPlayer.MSEPipelineProxy.run();
                    AVPlayer.MSEPipelineProxy.setLogLevel(AVPlayer.level);
                    AVPlayer.MSEThread = AVPlayer.MSEPipelineProxy.MSEPipeline;
                }
                resolve();
            });
        }
    }
    /**
     * 
     */
    static async startPipelines(enableWorker = true) {
        await AVPlayer.startDemuxPipeline(enableWorker);
        await AVPlayer.startAudioPipeline(enableWorker);
        await AVPlayer.startVideoRenderPipeline(enableWorker);
        await AVPlayer.startMSEPipeline(enableWorker);
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info('AVPlayer pipelines started', cheap__fileName__5, 3218);
    }
    /**
     * 
     */
    static async stopPipelines() {
        if (AVPlayer.VideoRenderThread) {
            await AVPlayer.VideoRenderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_12__.closeThread)(AVPlayer.VideoRenderThread);
        }
        if (AVPlayer.AudioPipelineProxy) {
            await AVPlayer.AudioRenderThread.clear();
            await AVPlayer.AudioDecoderThread.clear();
            await AVPlayer.AudioPipelineProxy.destroy();
            AVPlayer.AudioRenderThread = null;
            AVPlayer.AudioDecoderThread = null;
        }
        if (AVPlayer.AudioRenderThread) {
            await AVPlayer.AudioRenderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_12__.closeThread)(AVPlayer.AudioRenderThread);
        }
        if (AVPlayer.AudioDecoderThread) {
            await AVPlayer.AudioDecoderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_12__.closeThread)(AVPlayer.AudioDecoderThread);
        }
        if (AVPlayer.IODemuxProxy) {
            await AVPlayer.DemuxerThread.clear();
            await AVPlayer.IOThread.clear();
            await AVPlayer.IODemuxProxy.destroy();
            AVPlayer.DemuxerThread = null;
            AVPlayer.IOThread = null;
        }
        if (AVPlayer.DemuxerThread) {
            await AVPlayer.DemuxerThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_12__.closeThread)(AVPlayer.DemuxerThread);
        }
        if (AVPlayer.IOThread) {
            await AVPlayer.IOThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_12__.closeThread)(AVPlayer.IOThread);
        }
        {
            if (AVPlayer.MSEPipelineProxy) {
                await AVPlayer.MSEThread.clear();
                AVPlayer.MSEPipelineProxy.destroy();
                AVPlayer.MSEThread = null;
            }
            if (AVPlayer.MSEThread) {
                await AVPlayer.MSEThread.clear();
                (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_12__.closeThread)(AVPlayer.MSEThread);
            }
        }
        AVPlayer.AudioPipelineProxy = null;
        AVPlayer.AudioDecoderThread = null;
        AVPlayer.IODemuxProxy = null;
        AVPlayer.DemuxerThread = null;
        AVPlayer.IOThread = null;
        AVPlayer.audioContext = null;
        AVPlayer.MSEThread = null;
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info('AVPlayer pipelines stopped', cheap__fileName__5, 3282);
    }
    /**
     * 
     *
     * @param level
     */
    static setLogLevel(level) {
        AVPlayer.level = level;
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.setLevel(level);
        if (AVPlayer.IOThread) {
            AVPlayer.IOThread.setLogLevel(level);
        }
        if (AVPlayer.DemuxerThread) {
            AVPlayer.DemuxerThread.setLogLevel(level);
        }
        if (AVPlayer.AudioDecoderThread) {
            AVPlayer.AudioDecoderThread.setLogLevel(level);
        }
        if (AVPlayer.AudioRenderThread) {
            AVPlayer.AudioRenderThread.setLogLevel(level);
        }
        if (AVPlayer.VideoRenderThread) {
            AVPlayer.VideoRenderThread.setLogLevel(level);
        }
        if (AVPlayer.MSEThread) {
            AVPlayer.MSEThread.setLogLevel(level);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_30__.info(`set log level: ${level}`, cheap__fileName__5, 3314);
    }
    on(event, listener, options = {}) {
        super.on(event, common_util_object__WEBPACK_IMPORTED_MODULE_16__.extend({
            fn: listener
        }, options));
        return this;
    }
    one(event, listener, options = {}) {
        super.on(event, common_util_object__WEBPACK_IMPORTED_MODULE_16__.extend({
            fn: listener,
            max: 1
        }, options));
        return this;
    }
}


/***/ }),

/***/ "./src/avplayer/Controller.ts":
/*!************************************!*\
  !*** ./src/avplayer/Controller.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Controller)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var _function_createMessageChannel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./function/createMessageChannel */ "./src/avplayer/function/createMessageChannel.ts");
/*
 * libmedia AVPlayer Controller
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class Controller {
    videoRenderControlChannel;
    audioRenderControlChannel;
    muxerControlChannel;
    demuxerControlChannel;
    videoRenderControlIPCPort;
    audioRenderControlIPCPort;
    muxerControlIPCPort;
    demuxerControlIPCPort;
    observer;
    visibilityHidden;
    onVisibilityChange;
    timeUpdateListenType;
    enableAudioVideoSync;
    constructor(observer, enableWorker) {
        this.observer = observer;
        this.videoRenderControlChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_1__["default"])(enableWorker);
        this.audioRenderControlChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_1__["default"])(enableWorker);
        this.muxerControlChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_1__["default"])(enableWorker);
        this.demuxerControlChannel = (0,_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_1__["default"])(enableWorker);
        this.videoRenderControlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](this.videoRenderControlChannel.port2);
        this.audioRenderControlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](this.audioRenderControlChannel.port2);
        this.muxerControlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](this.muxerControlChannel.port2);
        this.demuxerControlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](this.demuxerControlChannel.port2);
        this.enableAudioVideoSync = true;
        this.videoRenderControlIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.NOTIFY, (request) => {
            switch (request.method) {
                case 'ended':
                    this.observer.onVideoEnded();
                    break;
                case 'updateCanvas':
                    this.observer.onCanvasUpdated();
                    break;
                case 'firstRendered':
                    this.observer.onFirstVideoRendered();
                    break;
                case 'firstRenderedAfterUpdateCanvas':
                    this.observer.onFirstVideoRenderedAfterUpdateCanvas();
                    break;
                case 'syncPts':
                    if (this.timeUpdateListenType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                        this.observer.onTimeUpdate(request.params.pts);
                    }
                    break;
            }
        });
        this.audioRenderControlIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.NOTIFY, (request) => {
            switch (request.method) {
                case 'syncPts':
                    if (this.enableAudioVideoSync) {
                        this.videoRenderControlIPCPort.notify('syncPts', request.params);
                    }
                    if (this.timeUpdateListenType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                        this.observer.onTimeUpdate(request.params.pts);
                    }
                    break;
                case 'ended':
                    this.observer.onAudioEnded();
                    break;
            }
        });
        this.muxerControlIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.NOTIFY, (request) => {
            switch (request.method) {
                case 'seek':
                    this.observer.onMSESeek(request.params.time);
                    break;
            }
        });
        this.demuxerControlIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.REQUEST, async (request) => {
            switch (request.method) {
                case 'getDecoderResource':
                    this.demuxerControlIPCPort.reply(request, await this.observer.onGetDecoderResource(request.params.mediaType, request.params.codecId));
                    break;
            }
        });
        this.onVisibilityChange = (event) => {
            this.visibilityHidden = document.visibilityState === 'hidden' && !this.observer.isPictureInPicture();
            this.videoRenderControlIPCPort.notify('skipRender', {
                skipRender: this.visibilityHidden
            });
        };
        this.visibilityHidden = document.visibilityState === 'hidden' && !this.observer.isPictureInPicture();
        document.addEventListener('visibilitychange', this.onVisibilityChange);
    }
    getVideoRenderControlPort() {
        return this.videoRenderControlChannel.port1;
    }
    getAudioRenderControlPort() {
        return this.audioRenderControlChannel.port1;
    }
    getMuxerControlPort() {
        return this.muxerControlChannel.port1;
    }
    getDemuxerControlPort() {
        return this.demuxerControlChannel.port1;
    }
    setTimeUpdateListenType(type) {
        this.timeUpdateListenType = type;
    }
    setEnableAudioVideoSync(enable) {
        this.enableAudioVideoSync = enable;
    }
    destroy() {
        if (this.videoRenderControlIPCPort) {
            this.videoRenderControlIPCPort.destroy();
        }
        if (this.audioRenderControlIPCPort) {
            this.audioRenderControlIPCPort.destroy();
        }
        if (this.muxerControlIPCPort) {
            this.muxerControlIPCPort.destroy();
        }
        if (this.demuxerControlIPCPort) {
            this.demuxerControlIPCPort.destroy();
        }
        if (this.onVisibilityChange) {
            document.removeEventListener('visibilitychange', this.onVisibilityChange);
            this.onVisibilityChange = null;
        }
        this.videoRenderControlIPCPort = this.audioRenderControlIPCPort = this.muxerControlIPCPort = this.videoRenderControlChannel = this.audioRenderControlChannel = this.demuxerControlChannel = this.muxerControlChannel = null;
    }
}


/***/ }),

/***/ "./src/avplayer/JitterBufferController.ts":
/*!************************************************!*\
  !*** ./src/avplayer/JitterBufferController.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JitterBufferController)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_timer_Timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/timer/Timer */ "./src/common/timer/Timer.ts");
/* harmony import */ var common_timer_WorkerTimer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/timer/WorkerTimer */ "./src/common/timer/WorkerTimer.ts");




const QUEUE_MAX = 10;
const BUFFER_STEP = 200;
const RATE_STEP = 0.01;
class JitterBufferController {
    timer;
    interval;
    data;
    lastIncomingPacketCount;
    shutterCount;
    lastShutterCount;
    isFirst;
    max;
    min;
    targetPlaybackRate;
    currentPlaybackRate;
    playbackRateTimer;
    options;
    constructor(options) {
        this.options = options;
        this.interval = 1000;
        this.isFirst = true;
        this.data = [];
        this.lastIncomingPacketCount = BigInt(0);
        this.shutterCount = 0;
        this.lastShutterCount = 0;
        this.max = (options.max * 1000) >>> 0;
        this.min = (options.min * 1000) >>> 0;
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer, this.min);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, this.max);
        if (options.lowLatencyStart) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, this.min + BUFFER_STEP);
        }
        this.targetPlaybackRate = 1;
        this.currentPlaybackRate = 1;
        this.playbackRateTimer = new common_timer_Timer__WEBPACK_IMPORTED_MODULE_2__["default"](() => {
            if (this.currentPlaybackRate > this.targetPlaybackRate) {
                const rate = Math.max(this.targetPlaybackRate, this.currentPlaybackRate - RATE_STEP);
                this.options.observer.onSetPlayRate(rate);
                this.currentPlaybackRate = rate;
            }
            else if (this.currentPlaybackRate < this.targetPlaybackRate) {
                const rate = Math.min(this.targetPlaybackRate, this.currentPlaybackRate + RATE_STEP);
                this.options.observer.onSetPlayRate(rate);
                this.currentPlaybackRate = rate;
            }
            else {
                this.playbackRateTimer.stop();
            }
        }, 0, 200);
        this.timer = new common_timer_WorkerTimer__WEBPACK_IMPORTED_MODULE_3__["default"](this.onTimer.bind(this), 1000, this.interval);
    }
    start() {
        this.timer.start();
        this.isFirst = true;
        this.lastIncomingPacketCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.options.stats + 24) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.options.stats + 112);
        this.shutterCount = 0;
        this.lastShutterCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 284) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 280);
        this.computePlayRate();
    }
    stop() {
        this.timer.stop();
        this.data.length = 0;
        this.isFirst = true;
        if (this.playbackRateTimer.isStarted()) {
            this.playbackRateTimer.stop();
            this.targetPlaybackRate = this.currentPlaybackRate = 1;
            this.options.observer.onSetPlayRate(1);
        }
    }
    reset() {
        this.data.length = 0;
        this.isFirst = true;
        this.lastIncomingPacketCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.options.stats + 24) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.options.stats + 112);
        this.shutterCount = 0;
        this.lastShutterCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 284) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 280);
        this.targetPlaybackRate = this.currentPlaybackRate = 1;
    }
    setPlayRate(rate) {
        this.targetPlaybackRate = rate;
        if (this.options.useMse) {
            this.options.observer.onSetPlayRate(this.targetPlaybackRate);
            this.currentPlaybackRate = this.targetPlaybackRate;
        }
        else {
            if (this.currentPlaybackRate !== rate && !this.playbackRateTimer.isStarted()) {
                this.playbackRateTimer.start();
            }
        }
    }
    computePlayRate() {
        let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 236) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 32) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 236) * 1000)
            : (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 224) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 120) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 224) * 1000)
                : 0);
        if ((buffer < (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) >> 1)) && buffer < 2) {
            this.setPlayRate(0.8);
        }
        else if ((buffer < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) - BUFFER_STEP) && buffer < 2) {
            this.setPlayRate(0.95);
        }
        else if (buffer > cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4) + BUFFER_STEP) {
            this.setPlayRate(1.05);
        }
        else {
            this.setPlayRate(1);
        }
        if (buffer > (this.max << 1)) {
            this.options.observer.onCroppingBuffer(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4));
        }
    }
    process() {
        const average = this.data.reduce((prev, value, index) => {
            return prev + value * (index + 1);
        }, 0) / (QUEUE_MAX * (QUEUE_MAX + 1) / 2);
        const variance = this.data.reduce((pre, value) => {
            return pre + Math.pow(value - average, 2);
        }, 0) / this.data.length;
        const jitter = Math.sqrt(variance);
        const incomingFramerate = Math.round(average / (this.interval / 1000));
        const needFramerate = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 224) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 236);
        if ((incomingFramerate < (needFramerate >> 1)) || this.shutterCount > 3) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) * 2, this.max - BUFFER_STEP));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4) * 2, this.max));
        }
        else if (incomingFramerate >= needFramerate && jitter < 50) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer, Math.max(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) - BUFFER_STEP, this.min));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, Math.max(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4) - BUFFER_STEP, this.min + BUFFER_STEP));
        }
        else if (jitter > 100) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) + BUFFER_STEP, this.max - BUFFER_STEP));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4) + BUFFER_STEP, this.max));
        }
        else if (jitter < 20) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) === this.min) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, Math.max(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4) - BUFFER_STEP, this.min + BUFFER_STEP));
            }
            else {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer, Math.max(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) - BUFFER_STEP, this.min));
            }
        }
        else {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4) === this.max) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer) + BUFFER_STEP, this.max - BUFFER_STEP));
            }
            else {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.jitterBuffer + 4, Math.min(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.jitterBuffer + 4) + BUFFER_STEP, this.max));
            }
        }
        this.computePlayRate();
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[19](this.options.stats + 264, jitter);
    }
    onTimer() {
        const count = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.options.stats + 24) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.options.stats + 112);
        if (this.isFirst) {
            this.isFirst = false;
        }
        else {
            this.data.push(Number(BigInt.asIntN(32, count - this.lastIncomingPacketCount)));
        }
        this.lastIncomingPacketCount = count;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 284) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 280) > this.lastShutterCount) {
            this.shutterCount++;
        }
        else {
            this.shutterCount = 0;
        }
        this.lastShutterCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 284) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.stats + 280);
        if (this.data.length > QUEUE_MAX) {
            this.data.shift();
        }
        if (this.data.length === QUEUE_MAX) {
            this.process();
        }
    }
}


/***/ }),

/***/ "./src/avplayer/StatsController.ts":
/*!*****************************************!*\
  !*** ./src/avplayer/StatsController.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StatsController)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_timer_Timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/timer/Timer */ "./src/common/timer/Timer.ts");



class StatsController {
    stats;
    timer;
    videoFrameRenderCount;
    videoFrameDecodeCount;
    audioFrameRenderCount;
    audioFrameDecodeCount;
    videoPacketBytes;
    audioPacketBytes;
    bufferReceiveBytes;
    observer;
    isWorkerMain;
    constructor(stats, isWorkerMain, observer) {
        this.stats = stats;
        this.observer = observer;
        this.isWorkerMain = isWorkerMain;
        this.timer = new common_timer_Timer__WEBPACK_IMPORTED_MODULE_2__["default"](this.onTimer.bind(this), 1000, 1000);
    }
    reset() {
        this.videoFrameRenderCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 160);
        this.videoFrameDecodeCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 144);
        this.audioFrameRenderCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 72);
        this.audioFrameDecodeCount = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 56);
        this.videoPacketBytes = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 104);
        this.audioPacketBytes = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 16);
        this.bufferReceiveBytes = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 192);
    }
    start() {
        this.reset();
        this.timer.start();
    }
    stop() {
        this.timer.stop();
    }
    onTimer() {
        if (!this.isWorkerMain) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 240, 0);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 244, 0);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 248, 0);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 252, 0);
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 220, Number(BigInt.asIntN(32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 160) - this.videoFrameRenderCount)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 216, Number(BigInt.asIntN(32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 144) - this.videoFrameDecodeCount)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 232, Number(BigInt.asIntN(32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 72) - this.audioFrameRenderCount)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 228, Number(BigInt.asIntN(32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 56) - this.audioFrameDecodeCount)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 212, Number(BigInt.asIntN(32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 104) - this.videoPacketBytes)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 208, Number(BigInt.asIntN(32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 16) - this.audioPacketBytes)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.stats + 256, Number(BigInt.asIntN(32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](this.stats + 192) - this.bufferReceiveBytes)));
        if (document.visibilityState === 'visible'
            && (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.stats + 220) < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.stats + 224) * 0.5
                || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.stats + 252) > 6000 / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.stats + 224))) {
            this.observer.onVideoStutter();
        }
        this.reset();
    }
}


/***/ }),

/***/ "./src/avplayer/eventType.ts":
/*!***********************************!*\
  !*** ./src/avplayer/eventType.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CHANGED: () => (/* binding */ CHANGED),
/* harmony export */   CHANGING: () => (/* binding */ CHANGING),
/* harmony export */   ENDED: () => (/* binding */ ENDED),
/* harmony export */   FIRST_AUDIO_RENDERED: () => (/* binding */ FIRST_AUDIO_RENDERED),
/* harmony export */   FIRST_VIDEO_RENDERED: () => (/* binding */ FIRST_VIDEO_RENDERED),
/* harmony export */   LOADED: () => (/* binding */ LOADED),
/* harmony export */   LOADING: () => (/* binding */ LOADING),
/* harmony export */   PAUSED: () => (/* binding */ PAUSED),
/* harmony export */   PLAYED: () => (/* binding */ PLAYED),
/* harmony export */   PLAYING: () => (/* binding */ PLAYING),
/* harmony export */   PROGRESS: () => (/* binding */ PROGRESS),
/* harmony export */   RESUME: () => (/* binding */ RESUME),
/* harmony export */   SEEKED: () => (/* binding */ SEEKED),
/* harmony export */   SEEKING: () => (/* binding */ SEEKING),
/* harmony export */   STOPPED: () => (/* binding */ STOPPED),
/* harmony export */   STREAM_UPDATE: () => (/* binding */ STREAM_UPDATE),
/* harmony export */   SUBTITLE_DELAY_CHANGE: () => (/* binding */ SUBTITLE_DELAY_CHANGE),
/* harmony export */   TIME: () => (/* binding */ TIME),
/* harmony export */   VOLUME_CHANGE: () => (/* binding */ VOLUME_CHANGE)
/* harmony export */ });
/* unused harmony exports TIMEOUT, ERROR */
/*
 * libmedia AVPlayer eventType
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const LOADING = 'loading';
const LOADED = 'loaded';
const PLAYING = 'playing';
const PLAYED = 'played';
const PAUSED = 'paused';
const STOPPED = 'stopped';
const ENDED = 'ended';
const SEEKING = 'seeking';
const SEEKED = 'seeked';
const CHANGING = 'changing';
const CHANGED = 'changed';
const TIMEOUT = 'timeout';
const ERROR = 'error';
const TIME = 'time';
const RESUME = 'resume';
const FIRST_AUDIO_RENDERED = 'firstAudioRendered';
const FIRST_VIDEO_RENDERED = 'firstVideoRendered';
const STREAM_UPDATE = 'streamUpdate';
const PROGRESS = 'progress';
const VOLUME_CHANGE = 'volumeChange';
const SUBTITLE_DELAY_CHANGE = 'subtitle_delay_change';


/***/ }),

/***/ "./src/avplayer/function/createMessageChannel.ts":
/*!*******************************************************!*\
  !*** ./src/avplayer/function/createMessageChannel.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createMessageChannel)
/* harmony export */ });
/* harmony import */ var cheap_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/config */ "./src/cheap/config.ts");
/* harmony import */ var common_network_FakeMessageChannel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/FakeMessageChannel */ "./src/common/network/FakeMessageChannel.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/*
 * libmedia create MessageChannel
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function createMessageChannel(enableWorker) {
    if (cheap_config__WEBPACK_IMPORTED_MODULE_0__.USE_THREADS && true || common_util_support__WEBPACK_IMPORTED_MODULE_2__["default"].worker && enableWorker) {
        return new MessageChannel();
    }
    return new common_network_FakeMessageChannel__WEBPACK_IMPORTED_MODULE_1__["default"]();
}


/***/ }),

/***/ "./src/avplayer/function/getMediaSource.ts":
/*!*************************************************!*\
  !*** ./src/avplayer/function/getMediaSource.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getMediaSource)
/* harmony export */ });
/*
 * libmedia get MediaSource
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function getMediaSource() {
    if (typeof MediaSource === 'function') {
        return MediaSource;
    }
    else if (typeof ManagedMediaSource === 'function') {
        return ManagedMediaSource;
    }
    else {
        throw new Error('not support mse');
    }
}


/***/ }),

/***/ "./src/avplayer/function/supportOffscreenCanvas.ts":
/*!*********************************************************!*\
  !*** ./src/avplayer/function/supportOffscreenCanvas.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ supportOffscreenCanvas)
/* harmony export */ });
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var common_util_os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/os */ "./src/common/util/os.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/*
 * libmedia support OffscreenCanvas
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function supportOffscreenCanvas() {
    let result = common_util_support__WEBPACK_IMPORTED_MODULE_0__["default"].offscreenCanvas;
    // webgl with offscreencanvas only supported for Safari 17+ on Mac OS Sonoma
    if (common_util_os__WEBPACK_IMPORTED_MODULE_1__["default"].mac && common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].safari && (common_util_os__WEBPACK_IMPORTED_MODULE_1__["default"].version < '12' || common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].version < '17')) {
        result = false;
    }
    return result;
}


/***/ }),

/***/ "./src/avplayer/mse/MSEPipeline.ts":
/*!*****************************************!*\
  !*** ./src/avplayer/mse/MSEPipeline.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MSEPipeline)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./..\..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./..\..\cheap\std\collection\List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avformat/AVFormatContext */ "./src/avformat/AVFormatContext.ts");
/* harmony import */ var avpipeline_Pipeline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avpipeline/Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_io_IOWriterSync__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/io/IOWriterSync */ "./src/common/io/IOWriterSync.ts");
/* harmony import */ var avformat_mux__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avformat/mux */ "./src/avformat/mux.ts");
/* harmony import */ var avformat_formats_OMovFormat__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! avformat/formats/OMovFormat */ "./src/avformat/formats/OMovFormat.ts");
/* harmony import */ var avutil_struct_avcodecparameters__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/struct/avcodecparameters */ "./src/avutil/struct/avcodecparameters.ts");
/* harmony import */ var avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! avutil/util/codecparameters */ "./src/avutil/util/codecparameters.ts");
/* harmony import */ var common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! common/timer/LoopTask */ "./src/common/timer/LoopTask.ts");
/* harmony import */ var avrender_track_Track__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! avrender/track/Track */ "./src/avrender/track/Track.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var avrender_track_function_getAudioMimeType__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! avrender/track/function/getAudioMimeType */ "./src/avrender/track/function/getAudioMimeType.ts");
/* harmony import */ var avrender_track_function_getVideoMimeType__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! avrender/track/function/getVideoMimeType */ "./src/avrender/track/function/getVideoMimeType.ts");
/* harmony import */ var common_io_SeekableWriteBuffer__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! common/io/SeekableWriteBuffer */ "./src/common/io/SeekableWriteBuffer.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var avutil_util_common__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! avutil/util/common */ "./src/avutil/util/common.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
/* harmony import */ var avformat_function_mktag__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! avformat/function/mktag */ "./src/avformat/function/mktag.ts");
/* harmony import */ var _function_getMediaSource__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../function/getMediaSource */ "./src/avplayer/function/getMediaSource.ts");
/* harmony import */ var avutil_util_intread__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! avutil/util/intread */ "./src/avutil/util/intread.ts");
/* harmony import */ var avformat_codecs_h264__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! avformat/codecs/h264 */ "./src/avformat/codecs/h264.ts");
/* harmony import */ var avformat_codecs_hevc__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! avformat/codecs/hevc */ "./src/avformat/codecs/hevc.ts");
/* harmony import */ var avutil_util_serialize__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! avutil/util/serialize */ "./src/avutil/util/serialize.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
var cheap__fileName__19 = "src\\avplayer\\mse\\MSEPipeline.ts";







/*
 * libmedia MSEPipeline
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


































const BUFFER_MIN = 0.5;
const BUFFER_MAX = 1;
function checkExtradataChanged(old, oldSize, newer, newSize) {
    if (oldSize !== newSize) {
        return true;
    }
    let change = false;
    for (let i = 0; i < oldSize; i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[2](old + i) !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[2](newer + i)) {
            change = true;
            break;
        }
    }
    return change;
}
class MSEPipeline extends avpipeline_Pipeline__WEBPACK_IMPORTED_MODULE_8__["default"] {
    constructor() {
        super();
    }
    async syncToKeyframe(task) {
        let firstIsKeyframe = true;
        if (task.video) {
            // 
            while (true) {
                task.video.backPacket = await this.pullAVPacket(task.video, task);
                if (task.video.backPacket < 0) {
                    task.video.packetEnded = true;
                    task.video.backPacket = 0;
                    break;
                }
                //  pts  pts  packet
                if (task.audio
                    && !task.audio.packetEnded
                    && (!task.audio.backPacket
                        || (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.audio.backPacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.audio.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q)
                            < (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.video.backPacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.video.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q))) {
                    while (true) {
                        if (task.audio.backPacket > 0) {
                            task.avpacketPool.release(task.audio.backPacket);
                        }
                        task.audio.backPacket = await this.pullAVPacket(task.audio, task);
                        if (task.audio.backPacket < 0) {
                            task.audio.packetEnded = true;
                            task.audio.backPacket = 0;
                            break;
                        }
                        if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.audio.backPacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.audio.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q)
                            > (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.video.backPacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.video.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q)) {
                            break;
                        }
                    }
                }
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.video.backPacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                    break;
                }
                firstIsKeyframe = false;
                task.avpacketPool.release(task.video.backPacket);
            }
        }
        return firstIsKeyframe;
    }
    getSourceOpenHandler(task) {
        return async () => {
            await this.syncToKeyframe(task);
            const promises = [];
            if (task.audio) {
                task.audio.track.setSourceBuffer(this.createSourceBuffer(task.mediaSource, task.audio.oformatContext.streams[0].codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress]));
                if (!task.audio.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.open(task.audio.oformatContext, {
                        paddingZero: false
                    });
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.writeHeader(task.audio.oformatContext);
                }
                promises.push(this.startMux(task.audio, task));
            }
            if (task.video) {
                task.video.track.setSourceBuffer(this.createSourceBuffer(task.mediaSource, task.video.oformatContext.streams[0].codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress]));
                if (!task.video.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.open(task.video.oformatContext, {
                        paddingZero: false
                    });
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.writeHeader(task.video.oformatContext);
                }
                promises.push(this.startMux(task.video, task));
            }
            await Promise.all(promises);
            let startAudioLoop = false;
            let startVideoLoop = false;
            if (task.audio) {
                task.audio.backPacket = await this.pullAVPacket(task.audio, task);
                if (task.audio.backPacket > 0) {
                    startAudioLoop = true;
                    task.audio.frontPacket = await this.pullAVPacket(task.audio, task);
                    if (task.audio.frontPacket > 0) {
                        task.audio.frontBuffered = true;
                    }
                    else {
                        task.audio.frontPacket = 0;
                        task.audio.packetEnded = true;
                    }
                }
                else {
                    task.audio.packetEnded = true;
                }
                if (!task.audio.enableRawMpeg) {
                    task.audio.oformatContext.ioWriter.flush();
                }
                task.audio.track.addBuffer(task.audio.bufferQueue.flush());
            }
            if (task.video) {
                task.video.backPacket = await this.pullAVPacket(task.video, task);
                if (task.video.backPacket > 0) {
                    startVideoLoop = true;
                    task.video.frontPacket = await this.pullAVPacket(task.video, task);
                    if (task.video.frontPacket > 0) {
                        task.video.frontBuffered = true;
                    }
                    else {
                        task.video.frontPacket = 0;
                        task.video.packetEnded = true;
                    }
                }
                else {
                    task.video.packetEnded = true;
                }
                if (!task.video.enableRawMpeg) {
                    task.video.oformatContext.ioWriter.flush();
                }
                task.video.track.addBuffer(task.video.bufferQueue.flush());
            }
            if (task.audio) {
                if (startAudioLoop) {
                    this.createLoop(task.audio, task);
                    task.audio.loop.start();
                }
                else {
                    task.audio.track.end();
                }
            }
            if (task.video) {
                if (startVideoLoop) {
                    this.createLoop(task.video, task);
                    task.video.loop.start();
                }
                else {
                    task.video.track.end();
                }
            }
            // 
            await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_30__["default"](0.1);
            let min = 0;
            if (task.audio) {
                if (task.video) {
                    min = Math.max(task.audio.track.getBufferedStart(), task.video.track.getBufferedStart());
                }
                else {
                    min = task.audio.track.getBufferedStart();
                }
            }
            else if (task.video) {
                min = task.video.track.getBufferedStart();
            }
            // safari  0  seek  min buffer 
            if (common_util_browser__WEBPACK_IMPORTED_MODULE_28__["default"].safari || min > 0.1) {
                task.controlIPCPort.notify('seek', {
                    time: min
                });
            }
        };
    }
    getMimeType(codecpar) {
        let mimeType = '';
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
            mimeType = (0,avrender_track_function_getAudioMimeType__WEBPACK_IMPORTED_MODULE_23__["default"])(codecpar);
        }
        else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
            mimeType = (0,avrender_track_function_getVideoMimeType__WEBPACK_IMPORTED_MODULE_24__["default"])(codecpar);
        }
        if (!mimeType) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('invalid stream', cheap__fileName__19, 344);
        }
        return mimeType;
    }
    createSourceBuffer(mediaSource, codecpar) {
        return mediaSource.addSourceBuffer(this.getMimeType(codecpar));
    }
    // TODO avpacket extradata 
    mixExtradata(avpacket, resource, extradata, extradataSize) {
        const codecId = resource.oformatContext.streams[0].codecpar.codecId;
        if (codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */
            || codecId === 173 /* AVCodecID.AV_CODEC_ID_H265 */
            || codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */) {
        }
        const codecpar = resource.oformatContext.streams[0].codecpar;
        if (codecpar.extradata) {
            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_27__.avFree)(codecpar.extradata);
        }
        codecpar.extradata = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_27__.avMalloc)(extradataSize);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(codecpar.extradata, extradata, extradataSize);
        codecpar.extradataSize = extradataSize;
    }
    async pullAVPacketInternal(task, leftIPCPort) {
        const data = await leftIPCPort.request('pull');
        if (common_util_is__WEBPACK_IMPORTED_MODULE_39__.number(data)) {
            return data;
        }
        else {
            const avpacket = task.avpacketPool.alloc();
            (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_37__.unserializeAVPacket)(data, avpacket);
            return avpacket;
        }
    }
    async pullAVPacket(resource, task) {
        const pullQueue = resource.pullQueue;
        if (pullQueue.ended && !pullQueue.queue.length) {
            return -1048576 /* IOError.END */;
        }
        const avpacket = pullQueue.queue.length
            ? pullQueue.queue.shift()
            : (await this.pullAVPacketInternal(task, resource.pullIPC));
        if (avpacket < 0) {
            pullQueue.ended = true;
            return -1048576 /* IOError.END */;
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16) < pullQueue.lastDTS) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.warn(`got packet with dts ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16)}, which is earlier then the last packet(${pullQueue.lastDTS})`, cheap__fileName__19, 403);
        }
        //  pts  dtsdts  mse 
        if (resource.type === 'audio' && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16) > 0) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](avpacket + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16));
        }
        //  pts  m3u8  dash  mp4 flv 
        // TODO  pts  mse  duration 
        //  B  pts  dts B  pts  pts
        // 
        else if (resource.type === 'video' && !task.isLive) {
            if ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)
                && ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.video.codecpar + 4) === 27 /* AVCodecID.AV_CODEC_ID_H264 */
                    && avformat_codecs_h264__WEBPACK_IMPORTED_MODULE_35__.isIDR(avpacket, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](task.video.codecpar + 12) ? (avutil_util_intread__WEBPACK_IMPORTED_MODULE_34__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](task.video.codecpar + 12) + 4) & 4)
                        : 4))
                    || (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.video.codecpar + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                        && avformat_codecs_hevc__WEBPACK_IMPORTED_MODULE_36__.isIDR(avpacket, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](task.video.codecpar + 12) ? (avutil_util_intread__WEBPACK_IMPORTED_MODULE_34__.r8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](task.video.codecpar + 12) + 21) & 4)
                            : 4)))) {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8) < pullQueue.lastPTS) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_11__.warn(`got packet with pts ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8)}, which is earlier then the last packet(${pullQueue.lastPTS}), try to fix it!`, cheap__fileName__19, 436);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](avpacket + 8, pullQueue.lastPTS + (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16) - pullQueue.lastDTS));
                    const next = await this.pullAVPacketInternal(task, resource.pullIPC);
                    if (next < 0) {
                        pullQueue.ended = true;
                    }
                    else {
                        pullQueue.queue.push(next);
                        //  gop pts 
                        //  pts
                        let nextMinPts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](next + 8);
                        // I  P   pts
                        const max = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](next + 8);
                        while (true) {
                            const next2 = await this.pullAVPacketInternal(task, resource.pullIPC);
                            if (next2 < 0) {
                                pullQueue.ended = true;
                                break;
                            }
                            pullQueue.queue.push(next2);
                            //  pts  pts 
                            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](next2 + 8) > max) {
                                break;
                            }
                            nextMinPts = common_util_bigint__WEBPACK_IMPORTED_MODULE_31__.min(nextMinPts, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](next2 + 8));
                        }
                        if (nextMinPts < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8)) {
                            pullQueue.diff = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16) - pullQueue.lastDTS;
                        }
                    }
                }
                else {
                    pullQueue.diff = BigInt(0);
                }
            }
            else {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](avpacket + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8) + pullQueue.diff);
            }
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8) > pullQueue.lastPTS) {
            pullQueue.lastPTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8);
        }
        pullQueue.lastDTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16);
        //  sampleRate 
        //  samples count 
        //  avpacket 
        if (resource.type === 'audio' && pullQueue.useSampleRateTimeBase) {
            if (pullQueue.frameCount === avutil_constant__WEBPACK_IMPORTED_MODULE_20__.NOPTS_VALUE_BIGINT) {
                pullQueue.frameCount = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), resource.oformatContext.streams[0].timeBase);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](avpacket + 16, pullQueue.frameCount), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](avpacket + 8, pullQueue.frameCount);
            }
            else {
                pullQueue.frameCount = pullQueue.frameCount + BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](resource.codecpar + 144) >> 0);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](avpacket + 16, pullQueue.frameCount), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](avpacket + 8, pullQueue.frameCount);
            }
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(avpacket + 72, resource.oformatContext.streams[0].timeBase[cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress], 8);
        }
        return avpacket;
    }
    writeAVPacket(avpacket, resource, flush = false) {
        if (resource.enableRawMpeg) {
            if (!resource.timestampOffsetUpdated) {
                const offset = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q);
                resource.track.updateTimestampOffset(Number(BigInt.asIntN(32, offset)) / 1000);
                resource.timestampOffsetUpdated = true;
            }
            resource.bufferQueue.write((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 28)).slice());
        }
        else {
            avformat_mux__WEBPACK_IMPORTED_MODULE_13__.writeAVPacket(resource.oformatContext, avpacket);
            if (flush) {
                resource.oformatContext.ioWriter.flush();
            }
        }
    }
    swap(resource, task) {
        if (resource.backPacket) {
            task.avpacketPool.release(resource.backPacket);
        }
        resource.backPacket = 0;
        if (resource.frontBuffered) {
            resource.backPacket = resource.frontPacket;
            resource.frontPacket = 0;
        }
        else {
            return false;
        }
        resource.frontBuffered = false;
        const now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])();
        this.pullAVPacket(resource, task).then((packet) => {
            if (packet < 0) {
                resource.packetEnded = true;
                resource.frontPacket = 0;
                return;
            }
            const cost = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])() - now;
            //  5 
            if (cost > 5) {
                resource.startTimestamp += BigInt(Math.floor(cost));
            }
            resource.frontPacket = packet;
            resource.frontBuffered = true;
            if (resource.seekSync) {
                resource.seekSync();
                resource.seekSync = null;
            }
            if (!resource.backPacket) {
                this.swap(resource, task);
            }
        });
        return true;
    }
    createLoop(resource, task) {
        resource.loop = new common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_17__["default"](() => {
            const canPlayBufferTime = resource.track.getBufferedEnd() - (task.currentTime + ((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])() - task.currentTimeNTP) / 1000);
            if (canPlayBufferTime > BUFFER_MAX * (task.playRate > BigInt(100) ? (Number(task.playRate) / 100) : 1)) {
                resource.loop.emptyTask();
                return;
            }
            if (!resource.backPacket) {
                if (resource.packetEnded && !resource.frontPacket) {
                    resource.ended = true;
                    resource.loop.stop();
                    if (!resource.enableRawMpeg) {
                        avformat_mux__WEBPACK_IMPORTED_MODULE_13__.writeTrailer(resource.oformatContext);
                        avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(resource.oformatContext);
                    }
                    if (resource.bufferQueue.size) {
                        resource.track.addBuffer(resource.bufferQueue.flush());
                    }
                    resource.track.end();
                }
                else {
                    resource.loop.emptyTask();
                }
                return;
            }
            let avpacket = resource.backPacket;
            const dts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q);
            if (task.enableJitterBuffer) {
                let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 236) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 32) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 236) * 1000)
                    : (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 224) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 120) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 224) * 1000)
                        : 0);
                if (buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 272)) {
                    this.setPlayRate(task.taskId, 1);
                }
            }
            const diff = dts * BigInt(100) / task.playRate + resource.startTimestamp - BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])()));
            if (diff <= 0 || canPlayBufferTime < BUFFER_MIN * (task.playRate > BigInt(100) ? (Number(task.playRate) / 100) : 1)) {
                if (resource.track.isPaused()) {
                    resource.track.enqueue();
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](avpacket + 32, resource.oformatContext.streams[0].index);
                const extradata = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_26__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */);
                if (extradata && checkExtradataChanged(resource.oformatContext.streams[0].codecpar.extradata, resource.oformatContext.streams[0].codecpar.extradataSize, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](extradata), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](extradata + 4))) {
                    this.mixExtradata(avpacket, resource, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](extradata), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](extradata + 4));
                }
                this.writeAVPacket(avpacket, resource, true);
                resource.track.addBuffer(resource.bufferQueue.flush());
                const codecType = resource.oformatContext.streams[0].codecpar.codecType;
                if (codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](task.stats + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.stats + 144) + BigInt(1));
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](task.stats + 160, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.stats + 160) + BigInt(1));
                }
                else if (codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](task.stats + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.stats + 56) + BigInt(1));
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[17](task.stats + 72, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.stats + 72) + BigInt(1));
                }
                if (task.playRate !== task.targetRate) {
                    resource.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])())) - (dts * BigInt(100) / task.targetRate);
                    task.playRate = task.targetRate;
                }
                if (resource.packetEnded && !resource.frontPacket) {
                    resource.ended = true;
                    resource.loop.stop();
                    if (!resource.enableRawMpeg) {
                        avformat_mux__WEBPACK_IMPORTED_MODULE_13__.writeTrailer(resource.oformatContext);
                        avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(resource.oformatContext);
                    }
                    if (resource.bufferQueue.size) {
                        resource.track.addBuffer(resource.bufferQueue.flush());
                    }
                    resource.track.end();
                    return;
                }
                this.swap(resource, task);
            }
            else {
                resource.loop.emptyTask();
            }
        }, 0, 0);
    }
    async startMux(resource, task) {
        let startDTS = avutil_constant__WEBPACK_IMPORTED_MODULE_20__.NOPTS_VALUE_BIGINT;
        let startPTS = avutil_constant__WEBPACK_IMPORTED_MODULE_20__.NOPTS_VALUE_BIGINT;
        let lastDTS = BigInt(0);
        let avpacket;
        const timeBase = resource.oformatContext.streams[0].timeBase;
        if (resource.backPacket > 0) {
            startDTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](resource.backPacket + 16);
            startPTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](resource.backPacket + 8);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](resource.backPacket + 32, resource.oformatContext.streams[0].index);
            this.writeAVPacket(resource.backPacket, resource);
            task.avpacketPool.release(resource.backPacket);
            resource.backPacket = 0;
        }
        while (startDTS < BigInt(0) || (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)((lastDTS - startDTS), timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q) < task.cacheDuration) {
            avpacket = await this.pullAVPacket(resource, task);
            if (avpacket < 0) {
                resource.packetEnded = true;
                break;
            }
            lastDTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16);
            if (startDTS < BigInt(0)) {
                startDTS = lastDTS;
                startPTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8);
            }
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8) < startPTS) {
                startPTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8);
            }
            if (task.video && task.video.streamIndex === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 32)) {
                const extradata = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_26__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */);
                if (extradata && checkExtradataChanged(resource.oformatContext.streams[0].codecpar.extradata, resource.oformatContext.streams[0].codecpar.extradataSize, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](extradata), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](extradata + 4))) {
                    this.mixExtradata(avpacket, resource, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](extradata), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](extradata + 4));
                }
            }
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](avpacket + 32, resource.oformatContext.streams[0].index);
            this.writeAVPacket(avpacket, resource);
            task.avpacketPool.release(avpacket);
        }
        if (startPTS !== avutil_constant__WEBPACK_IMPORTED_MODULE_20__.NOPTS_VALUE_BIGINT && resource.startPTS <= BigInt(0)) {
            resource.startPTS = startPTS;
        }
        resource.pullQueue.diff = BigInt(0);
        task.currentTimeNTP = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])();
        task.currentTime = 0;
        resource.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])())) - (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)(lastDTS, timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q) * BigInt(100) / task.playRate;
    }
    resetResource(resource, task) {
        resource.bufferQueue.flush();
        const oformat = new avformat_formats_OMovFormat__WEBPACK_IMPORTED_MODULE_14__["default"]({
            fragmentMode: 1 /* FragmentMode.FRAME */,
            fragment: true,
            fastOpen: true,
            movMode: 0 /* MovMode.MP4 */,
            defaultBaseIsMoof: true
        });
        resource.oformatContext.oformat = oformat;
        const track = new avrender_track_Track__WEBPACK_IMPORTED_MODULE_18__["default"]();
        track.onQuotaExceededError = () => {
            resource.startTimestamp -= BigInt(100);
        };
        track.onEnded = () => {
            if ((!task.audio || task.audio.ended) && (!task.video || task.video.ended)) {
                task.mediaSource.endOfStream();
                common_util_logger__WEBPACK_IMPORTED_MODULE_11__.info(`muxer ended, taskId: ${task.taskId}`, cheap__fileName__19, 754);
            }
        };
        resource.track = track;
        resource.packetEnded = false;
        resource.ended = false;
        resource.startTimestamp = BigInt(0);
        resource.frontBuffered = false;
        resource.seekSync = null;
        if (resource.loop) {
            resource.loop.destroy();
            resource.loop = null;
        }
        if (resource.frontPacket) {
            task.avpacketPool.release(resource.frontPacket);
            resource.frontPacket = 0;
        }
        if (resource.backPacket) {
            task.avpacketPool.release(resource.backPacket);
            resource.backPacket = 0;
        }
        resource.pullQueue.ended = false;
        resource.pullQueue.index = 0;
        resource.pullQueue.frameCount = avutil_constant__WEBPACK_IMPORTED_MODULE_20__.NOPTS_VALUE_BIGINT;
        resource.pullQueue.lastPTS = BigInt(0);
        resource.pullQueue.lastDTS = BigInt(0);
        resource.pullQueue.diff = BigInt(0);
    }
    async addStream(taskId, streamIndex, parameters, timeBase, startPTS, pullIPCPort) {
        const task = this.tasks.get(taskId);
        if (task) {
            const codecpar = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_27__.avMallocz)(168);
            if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_38__["default"])(parameters)) {
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_16__.copyCodecParameters)(codecpar, parameters);
            }
            else {
                (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_37__.unserializeAVCodecParameters)(parameters, codecpar);
            }
            const ioWriter = new common_io_IOWriterSync__WEBPACK_IMPORTED_MODULE_12__["default"](1048576);
            const oformatContext = (0,avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_7__.createAVOFormatContext)();
            const oformat = new avformat_formats_OMovFormat__WEBPACK_IMPORTED_MODULE_14__["default"]({
                fragmentMode: 1 /* FragmentMode.FRAME */,
                fragment: true,
                fastOpen: true,
                movMode: 0 /* MovMode.MP4 */,
                defaultBaseIsMoof: true
            });
            const bufferQueue = new common_io_SeekableWriteBuffer__WEBPACK_IMPORTED_MODULE_25__["default"]();
            ioWriter.onFlush = (buffer) => {
                bufferQueue.write(buffer.slice());
                return 0;
            };
            ioWriter.onSeek = (pos) => {
                return bufferQueue.seek(pos) ? 0 : avutil_error__WEBPACK_IMPORTED_MODULE_9__.INVALID_OPERATE;
            };
            const stream = oformatContext.createStream();
            (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_16__.copyCodecParameters)(stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress], codecpar);
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 4) === 86017 /* AVCodecID.AV_CODEC_ID_MP3 */) {
                stream.codecpar.codecTag = (0,avformat_function_mktag__WEBPACK_IMPORTED_MODULE_32__["default"])('.mp3');
            }
            const useSampleRateTimeBase = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 144)
                && !task.isLive
                && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avQ2D)(timeBase) > (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avQ2D)({ num: 1, den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 136) });
            //  frameSize  sampleRate 
            //  mp4 ts  flv  pts 
            //  pts  mse 
            if (useSampleRateTimeBase) {
                stream.timeBase.den = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 136);
                stream.timeBase.num = 1;
            }
            else {
                stream.timeBase.den = timeBase.den;
                stream.timeBase.num = timeBase.num;
            }
            oformatContext.oformat = oformat;
            oformatContext.ioWriter = ioWriter;
            const track = new avrender_track_Track__WEBPACK_IMPORTED_MODULE_18__["default"]();
            const resource = {
                type: 'audio',
                codecpar,
                ioWriter,
                oformatContext,
                oformat,
                track,
                bufferQueue,
                streamIndex,
                pullIPC: new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_10__["default"](pullIPCPort),
                loop: null,
                frontPacket: 0,
                backPacket: 0,
                frontBuffered: false,
                startTimestamp: BigInt(0),
                packetEnded: false,
                ended: false,
                seekSync: null,
                startPTS,
                pullQueue: {
                    queue: [],
                    index: 0,
                    frameCount: avutil_constant__WEBPACK_IMPORTED_MODULE_20__.NOPTS_VALUE_BIGINT,
                    diff: BigInt(0),
                    lastPTS: BigInt(0),
                    lastDTS: BigInt(0),
                    ended: false,
                    useSampleRateTimeBase
                },
                enableRawMpeg: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 4) === 86017 /* AVCodecID.AV_CODEC_ID_MP3 */ && !common_util_browser__WEBPACK_IMPORTED_MODULE_28__["default"].firefox,
                timestampOffsetUpdated: false
            };
            track.onQuotaExceededError = () => {
                resource.startTimestamp -= BigInt(100);
            };
            track.onEnded = () => {
                if ((!task.audio || task.audio.ended) && (!task.video || task.video.ended)) {
                    task.mediaSource.endOfStream();
                    common_util_logger__WEBPACK_IMPORTED_MODULE_11__.info(`muxer ended, taskId: ${task.taskId}`, cheap__fileName__19, 895);
                }
            };
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                task.audio = resource;
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.stats + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 136));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.stats, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 116));
            }
            else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                resource.type = 'video';
                task.video = resource;
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.stats + 84, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 56));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.stats + 88, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 60));
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 84) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 88) > 8294400 && common_util_browser__WEBPACK_IMPORTED_MODULE_28__["default"].safari) {
                    task.cacheDuration = common_util_bigint__WEBPACK_IMPORTED_MODULE_31__.max(BigInt(3000), task.cacheDuration);
                }
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task not found', cheap__fileName__19, 916);
        }
    }
    async reAddStream(taskId, streamIndex, parameters, timeBase, startPTS) {
        const task = this.tasks.get(taskId);
        if (task) {
            const codecpar = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_27__.avMallocz)(168);
            if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_38__["default"])(parameters)) {
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_16__.copyCodecParameters)(codecpar, parameters);
            }
            else {
                (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_37__.unserializeAVCodecParameters)(parameters, codecpar);
            }
            const resource = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */ ? task.audio : task.video;
            if (resource) {
                resource.bufferQueue.flush();
                //  track abort
                await new Promise((resolve) => {
                    resource.track.removeAllBuffer(() => {
                        resolve();
                    });
                });
                resource.track.reset();
                const oformat = new avformat_formats_OMovFormat__WEBPACK_IMPORTED_MODULE_14__["default"]({
                    fragmentMode: 1 /* FragmentMode.FRAME */,
                    fragment: true,
                    fastOpen: true,
                    movMode: 0 /* MovMode.MP4 */,
                    defaultBaseIsMoof: true
                });
                resource.oformatContext.oformat = oformat;
                if (resource.codecpar) {
                    (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_16__.freeCodecParameters)(resource.codecpar);
                }
                resource.codecpar = codecpar;
                resource.streamIndex = streamIndex;
                resource.startPTS = startPTS;
                const stream = resource.oformatContext.streams[0];
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_16__.copyCodecParameters)(stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress], codecpar);
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 4) === 86017 /* AVCodecID.AV_CODEC_ID_MP3 */) {
                    stream.codecpar.codecTag = (0,avformat_function_mktag__WEBPACK_IMPORTED_MODULE_32__["default"])('.mp3');
                }
                const useSampleRateTimeBase = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                    && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 144)
                    && !task.isLive
                    && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avQ2D)(timeBase) > (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avQ2D)({ num: 1, den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 136) });
                //  frameSize  sampleRate 
                //  mp4 ts  flv  pts 
                //  pts  mse 
                if (useSampleRateTimeBase) {
                    stream.timeBase.den = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 136);
                    stream.timeBase.num = 1;
                }
                else {
                    stream.timeBase.den = timeBase.den;
                    stream.timeBase.num = timeBase.num;
                }
                resource.track.changeMimeType(this.getMimeType(stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress]));
                if (!resource.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.open(resource.oformatContext, {
                        paddingZero: false
                    });
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.writeHeader(resource.oformatContext);
                }
            }
            else {
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_16__.freeCodecParameters)(codecpar);
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task not found', cheap__fileName__19, 1004);
        }
    }
    async pause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (!task.audio?.loop && !task.video?.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task has not played', cheap__fileName__19, 1012);
            }
            task.pausing = true;
            task.pauseTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])();
            task.audio?.loop.stop();
            task.video?.loop.stop();
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task not found', cheap__fileName__19, 1020);
        }
    }
    async unpause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (!task.audio?.loop && !task.video?.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task has not played', cheap__fileName__19, 1028);
            }
            task.pausing = false;
            if (!task.seeking) {
                if (task.audio) {
                    task.audio.startTimestamp += BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])() - task.pauseTimestamp));
                    task.audio.loop.start();
                }
                if (task.video) {
                    task.video.startTimestamp += BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])() - task.pauseTimestamp));
                    task.video.loop.start();
                }
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task not found', cheap__fileName__19, 1045);
        }
    }
    async beforeSeek(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            //  pull frontFrame
            const promise = [];
            if (task.audio) {
                if (!task.audio.ended && !task.audio.frontBuffered) {
                    promise.push(new Promise((resolve) => {
                        task.audio.seekSync = resolve;
                    }));
                }
            }
            if (task.video) {
                if (!task.video.ended && !task.video.frontBuffered) {
                    promise.push(new Promise((resolve) => {
                        task.video.seekSync = resolve;
                    }));
                }
            }
            await Promise.all(promise);
            task.seeking = true;
            task.audio?.loop.stop();
            task.video?.loop.stop();
            if (task.audio) {
                if (!task.audio.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(task.audio.oformatContext);
                }
                task.audio.bufferQueue.flush();
                if (common_util_browser__WEBPACK_IMPORTED_MODULE_28__["default"].safari) {
                    await new Promise((resolve) => {
                        task.audio.track.removeAllBuffer(() => {
                            resolve();
                        });
                    });
                }
                task.audio.track.reset();
                task.audio.packetEnded = false;
                task.audio.timestampOffsetUpdated = false;
                if (task.audio.backPacket) {
                    task.avpacketPool.release(task.audio.backPacket);
                    task.audio.backPacket = 0;
                }
                if (task.audio.frontPacket) {
                    task.avpacketPool.release(task.audio.frontPacket);
                    task.audio.frontPacket = 0;
                }
                if (task.audio.pullQueue.queue.length) {
                    task.audio.pullQueue.queue.forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                }
                task.audio.pullQueue.queue.length = 0;
                task.audio.pullQueue.ended = false;
                task.audio.pullQueue.index = 0;
                task.audio.pullQueue.lastPTS = BigInt(0);
                task.audio.pullQueue.lastDTS = BigInt(0);
                task.audio.pullQueue.diff = BigInt(0);
                task.audio.pullQueue.frameCount = avutil_constant__WEBPACK_IMPORTED_MODULE_20__.NOPTS_VALUE_BIGINT;
            }
            if (task.video) {
                if (!task.video.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(task.video.oformatContext);
                }
                task.video.bufferQueue.flush();
                if (common_util_browser__WEBPACK_IMPORTED_MODULE_28__["default"].safari) {
                    await new Promise((resolve) => {
                        task.video.track.removeAllBuffer(() => {
                            resolve();
                        });
                    });
                }
                task.video.track.reset();
                task.video.packetEnded = false;
                task.video.timestampOffsetUpdated = false;
                if (task.video.backPacket) {
                    task.avpacketPool.release(task.video.backPacket);
                    task.video.backPacket = 0;
                }
                if (task.video.frontPacket) {
                    task.avpacketPool.release(task.video.frontPacket);
                    task.video.frontPacket = 0;
                }
                if (task.video.pullQueue.queue.length) {
                    task.video.pullQueue.queue.forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                }
                task.video.pullQueue.queue.length = 0;
                task.video.pullQueue.ended = false;
                task.video.pullQueue.index = 0;
                task.video.pullQueue.diff = BigInt(0);
                task.video.pullQueue.lastPTS = BigInt(0);
                task.video.pullQueue.lastDTS = BigInt(0);
            }
        }
    }
    async afterSeek(taskId, timestamp) {
        const task = this.tasks.get(taskId);
        if (task) {
            let audioRealTimestamp = timestamp;
            let videoRealTimestamp = timestamp;
            let firstIsKeyframe = await this.syncToKeyframe(task);
            if (task.audio && task.audio.backPacket > 0) {
                if (!firstIsKeyframe || timestamp < BigInt(0)) {
                    audioRealTimestamp = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.audio.backPacket + 8) - task.audio.startPTS, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.audio.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q);
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.audio.backPacket + 32, task.audio.oformatContext.streams[0].index);
                this.writeAVPacket(task.audio.backPacket, task.audio);
                task.avpacketPool.release(task.audio.backPacket);
                task.audio.backPacket = 0;
            }
            if (task.video && task.video.backPacket > 0) {
                if (!firstIsKeyframe || timestamp < BigInt(0)) {
                    videoRealTimestamp = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.video.backPacket + 8) - task.video.startPTS, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.video.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q);
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.video.backPacket + 32, task.video.oformatContext.streams[0].index);
                this.writeAVPacket(task.video.backPacket, task.video);
                task.avpacketPool.release(task.video.backPacket);
                task.video.backPacket = 0;
            }
            const realTimestamp = common_util_bigint__WEBPACK_IMPORTED_MODULE_31__.max(audioRealTimestamp, videoRealTimestamp);
            //  buffer
            while (true) {
                if (task.audio && !task.audio.packetEnded) {
                    task.audio.backPacket = await this.pullAVPacket(task.audio, task);
                    if (task.audio.backPacket < 0) {
                        task.audio.packetEnded = true;
                        task.audio.backPacket = 0;
                        if (!task.video || task.video.packetEnded) {
                            break;
                        }
                    }
                    if (audioRealTimestamp < BigInt(0)) {
                        audioRealTimestamp = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.audio.backPacket + 8) - task.audio.startPTS, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.audio.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q);
                    }
                    if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.audio.backPacket + 8) - task.audio.startPTS), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.audio.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q)
                        < realTimestamp + task.cacheDuration) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.audio.backPacket + 32, task.audio.oformatContext.streams[0].index);
                        this.writeAVPacket(task.audio.backPacket, task.audio);
                        if (!task.audio.enableRawMpeg) {
                            avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(task.audio.oformatContext);
                        }
                        task.audio.track.addBuffer(task.audio.bufferQueue.flush());
                        task.avpacketPool.release(task.audio.backPacket);
                        task.audio.backPacket = 0;
                    }
                    else {
                        break;
                    }
                }
                if (task.video && !task.video.packetEnded) {
                    task.video.backPacket = await this.pullAVPacket(task.video, task);
                    if (task.video.backPacket < 0) {
                        task.video.packetEnded = true;
                        task.video.backPacket = 0;
                        if (!task.audio || task.audio.packetEnded) {
                            break;
                        }
                    }
                    if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](task.video.backPacket + 8) - task.video.startPTS, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(task.video.backPacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q)
                        < realTimestamp + task.cacheDuration) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[15](task.video.backPacket + 32, task.video.oformatContext.streams[0].index);
                        this.writeAVPacket(task.video.backPacket, task.video);
                        if (!task.video.enableRawMpeg) {
                            avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(task.video.oformatContext);
                        }
                        task.video.track.addBuffer(task.video.bufferQueue.flush());
                        task.avpacketPool.release(task.video.backPacket);
                        task.video.backPacket = 0;
                    }
                    else {
                        break;
                    }
                }
            }
            const promises = [];
            if (task.audio) {
                if (!task.audio.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(task.audio.oformatContext);
                }
                promises.push(new Promise((resolve) => {
                    task.audio.track.addBuffer(task.audio.bufferQueue.flush(), () => {
                        resolve();
                    });
                }));
            }
            if (task.video) {
                if (!task.video.enableRawMpeg) {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_13__.flush(task.video.oformatContext);
                }
                promises.push(new Promise((resolve) => {
                    task.video.track.addBuffer(task.video.bufferQueue.flush(), () => {
                        resolve();
                    });
                }));
            }
            await Promise.all(promises);
            if (task.audio && !task.audio.packetEnded) {
                if (task.audio.backPacket <= 0) {
                    task.audio.backPacket = await this.pullAVPacket(task.audio, task);
                    if (task.audio.backPacket < 0) {
                        task.audio.packetEnded = true;
                        task.audio.backPacket = 0;
                    }
                }
                if (!task.audio.packetEnded) {
                    task.audio.frontPacket = await this.pullAVPacket(task.audio, task);
                    if (task.audio.frontPacket < 0) {
                        task.audio.frontPacket = 0;
                        task.audio.packetEnded = true;
                        task.audio.frontBuffered = false;
                    }
                    else {
                        task.audio.packetEnded = false;
                        task.audio.frontBuffered = true;
                    }
                    task.audio.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])())) - (audioRealTimestamp + task.cacheDuration + (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)(task.audio.startPTS, task.audio.oformatContext.streams[0].timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q)) * BigInt(100) / task.playRate;
                    if (task.pausing) {
                        task.pauseTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])();
                    }
                    else {
                        task.audio.loop.start();
                    }
                }
            }
            if (task.video && !task.video.packetEnded) {
                if (task.video.backPacket <= 0) {
                    task.video.backPacket = await this.pullAVPacket(task.video, task);
                    if (task.video.backPacket < 0) {
                        task.video.packetEnded = true;
                        task.video.backPacket = 0;
                    }
                }
                if (!task.video.packetEnded) {
                    task.video.frontPacket = await this.pullAVPacket(task.video, task);
                    if (task.video.frontPacket < 0) {
                        task.video.packetEnded = true;
                        task.video.frontBuffered = false;
                        task.video.frontPacket = 0;
                    }
                    else {
                        task.video.packetEnded = false;
                        task.video.frontBuffered = true;
                    }
                    task.video.startTimestamp = BigInt(Math.floor((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])())) - (videoRealTimestamp + task.cacheDuration + (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_21__.avRescaleQ)(task.video.startPTS, task.video.oformatContext.streams[0].timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_20__.AV_MILLI_TIME_BASE_Q)) * BigInt(100) / task.playRate;
                    if (task.pausing) {
                        task.pauseTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])();
                    }
                    else {
                        task.video.loop.start();
                    }
                }
            }
            if (!firstIsKeyframe) {
                await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_30__["default"](0.5);
            }
            let min = 0;
            let max = 0;
            if (task.audio) {
                if (task.video) {
                    min = Math.max(task.audio.track.getBufferedStart(), task.video.track.getBufferedStart());
                    max = Math.min(task.audio.track.getBufferedEnd(), task.video.track.getBufferedEnd());
                }
                else {
                    min = task.audio.track.getBufferedStart();
                    max = task.audio.track.getBufferedEnd();
                }
            }
            else if (task.video) {
                min = task.video.track.getBufferedStart();
                max = task.video.track.getBufferedEnd();
            }
            let seekTime = (0,avutil_util_common__WEBPACK_IMPORTED_MODULE_29__.milliSecond2Second)(realTimestamp);
            if (!(seekTime >= min && seekTime <= max)) {
                seekTime = Math.abs(seekTime - min) > Math.abs(seekTime - max) ? max : min;
            }
            task.currentTimeNTP = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])();
            task.currentTime = seekTime;
            task.seeking = false;
            return seekTime;
        }
        return 0;
    }
    async setPlayRate(taskId, rate) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.enableJitterBuffer) {
                let buffer = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 236) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 32) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 236) * 1000)
                    : (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 224) ? (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 120) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 224) * 1000)
                        : 0);
                if (buffer && buffer <= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 272)) {
                    rate = 1;
                }
            }
            task.targetRate = BigInt(Math.floor(Math.floor(rate * 100)));
            if (!task.enableJitterBuffer) {
                if (task.audio && task.audio.loop) {
                    task.audio.loop.resetInterval();
                }
                if (task.video && task.video.loop) {
                    task.video.loop.resetInterval();
                }
            }
        }
    }
    async restart(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.audio) {
                this.resetResource(task.audio, task);
            }
            if (task.video) {
                this.resetResource(task.video, task);
            }
            const mediaSource = new ((0,_function_getMediaSource__WEBPACK_IMPORTED_MODULE_33__["default"])())();
            mediaSource.onsourceopen = this.getSourceOpenHandler(task);
            task.mediaSource = mediaSource;
        }
    }
    async setCurrentTime(taskId, time) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.audio) {
                task.audio.track.removeBuffer(time);
            }
            if (task.video) {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 92) > 0) {
                    task.video.track.setMediaBufferMax(Math.max(task.video.track.getMediaBufferMax(), Math.ceil(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](task.stats + 92) / 1000 * 1.5), 10));
                    task.video.track.removeBuffer(time);
                }
            }
            task.currentTime = time;
            task.currentTimeNTP = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_22__["default"])();
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task not found', cheap__fileName__19, 1445);
        }
    }
    async getMediaSource(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.mediaSource.handle) {
                // @ts-ignore
                this.getMediaSource.transfer.push(task.mediaSource.handle);
                return task.mediaSource.handle;
            }
            else {
                return task.mediaSource;
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_11__.fatal('task not found', cheap__fileName__19, 1462);
        }
    }
    createTask(options) {
        const controlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_10__["default"](options.controlPort);
        const mediaSource = new MediaSource() || new ManagedMediaSource();
        const task = {
            ...options,
            mediaSource,
            audio: null,
            video: null,
            playRate: BigInt(100),
            targetRate: BigInt(100),
            pauseTimestamp: 0,
            seeking: false,
            pausing: false,
            controlIPCPort,
            currentTime: 0,
            currentTimeNTP: 0,
            cacheDuration: BigInt(Math.floor(BUFFER_MIN * 1000)),
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_19__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_6__["default"]), options.avpacketListMutex)
        };
        this.tasks.set(options.taskId, task);
        mediaSource.onsourceopen = this.getSourceOpenHandler(task);
        return 0;
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_9__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(id) {
        const task = this.tasks.get(id);
        if (task) {
            if (task.audio) {
                if (task.audio.loop) {
                    task.audio.oformatContext.destroy();
                    task.audio.loop.destroy();
                }
                if (task.audio.pullIPC) {
                    task.audio.pullIPC.destroy();
                }
                if (task.audio.pullQueue.queue.length) {
                    task.audio.pullQueue.queue.forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                    task.audio.pullQueue.queue.length = 0;
                }
                if (task.audio.codecpar) {
                    (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_16__.freeCodecParameters)(task.audio.codecpar);
                }
            }
            if (task.video) {
                if (task.video.loop) {
                    task.video.oformatContext.destroy();
                    task.video.loop.destroy();
                }
                if (task.video.pullIPC) {
                    task.video.pullIPC.destroy();
                }
                if (task.video.pullQueue.queue.length) {
                    task.video.pullQueue.queue.forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                    task.video.pullQueue.queue.length = 0;
                }
                if (task.video.codecpar) {
                    (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_16__.freeCodecParameters)(task.video.codecpar);
                }
            }
            if (task.controlIPCPort) {
                task.controlIPCPort.destroy();
            }
            this.tasks.delete(id);
        }
    }
}


/***/ }),

/***/ "./src/avplayer/struct.ts":
/*!********************************!*\
  !*** ./src/avplayer/struct.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVPlayerGlobalData: () => (/* binding */ AVPlayerGlobalData)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\cheap\std\collection\List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./..\cheap\thread\mutex.ts */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _avpipeline_struct_stats_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./..\avpipeline\struct\stats.ts */ "./src/avpipeline/struct/stats.ts");





class AVPlayerGlobalData {
    avpacketList;
    avframeList;
    avpacketListMutex;
    avframeListMutex;
    stats;
}
(function (prototype) {
    var map = new Map();
    map.set("avpacketList", { 0: _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__["default"], 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("avframeList", { 0: _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_2__["default"], 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("avpacketListMutex", { 0: _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("avframeListMutex", { 0: _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    map.set("stats", { 0: _avpipeline_struct_stats_ts__WEBPACK_IMPORTED_MODULE_4__["default"], 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 368);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVPlayerGlobalData.prototype);


/***/ }),

/***/ "./src/avplayer/subtitle/AssRender.ts":
/*!********************************************!*\
  !*** ./src/avplayer/subtitle/AssRender.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AssRender)
/* harmony export */ });
/* unused harmony export defaultStyle */
/* harmony import */ var assjs_src_renderer_animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! assjs/src/renderer/animation */ "./node_modules/assjs/src/renderer/animation.js");
/* harmony import */ var assjs_src_renderer_font_size__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! assjs/src/renderer/font-size */ "./node_modules/assjs/src/renderer/font-size.js");
/* harmony import */ var assjs_src_internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! assjs/src/internal */ "./node_modules/assjs/src/internal.js");
/* harmony import */ var assjs_src_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! assjs/src/utils */ "./node_modules/assjs/src/utils.js");
/* harmony import */ var common_function_generateUUID__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/function/generateUUID */ "./src/common/function/generateUUID.ts");
/* harmony import */ var ass_compiler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ass-compiler */ "./node_modules/ass-compiler/dist/esm/ass-compiler.js");
/* harmony import */ var ass_compiler_src_compiler_dialogues__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ass-compiler/src/compiler/dialogues */ "./node_modules/ass-compiler/src/compiler/dialogues.js");
/* harmony import */ var ass_compiler_src_compiler_styles__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ass-compiler/src/compiler/styles */ "./node_modules/ass-compiler/src/compiler/styles.js");
/* harmony import */ var assjs_src_renderer_renderer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! assjs/src/renderer/renderer */ "./node_modules/assjs/src/renderer/renderer.js");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/*
 * libmedia ass render
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */










const GLOBAL_CSS = '.ASS-box{font-family:Arial;overflow:hidden;pointer-events:none;position:absolute}.ASS-dialogue{font-size:0;position:absolute;z-index:0}.ASS-dialogue span{display:inline-block}.ASS-dialogue [data-text]{display:inline-block;color:var(--ass-fill-color);font-size:calc(var(--ass-scale)*var(--ass-real-fs)*1px);line-height:calc(var(--ass-scale)*var(--ass-tag-fs)*1px);letter-spacing:calc(var(--ass-scale)*var(--ass-tag-fsp)*1px)}.ASS-dialogue [data-wrap-style="0"],.ASS-dialogue [data-wrap-style="3"]{text-wrap:balance}.ASS-dialogue [data-wrap-style="1"]{word-break:break-word;white-space:normal}.ASS-dialogue [data-wrap-style="2"]{word-break:normal;white-space:nowrap}.ASS-dialogue [data-border-style="1"]{position:relative}.ASS-dialogue [data-border-style="1"]::after,.ASS-dialogue [data-border-style="1"]::before{content:attr(data-text);position:absolute;top:0;left:0;z-index:-1;filter:blur(calc(var(--ass-tag-blur)*1px))}.ASS-dialogue [data-border-style="1"]::before{color:var(--ass-shadow-color);transform:translate(calc(var(--ass-scale-stroke)*var(--ass-tag-xshad)*1px),calc(var(--ass-scale-stroke)*var(--ass-tag-yshad)*1px));-webkit-text-stroke:var(--ass-border-width) var(--ass-shadow-color);text-shadow:var(--ass-shadow-delta);opacity:var(--ass-shadow-opacity)}.ASS-dialogue [data-border-style="1"]::after{color:transparent;-webkit-text-stroke:var(--ass-border-width) var(--ass-border-color);text-shadow:var(--ass-border-delta);opacity:var(--ass-border-opacity)}.ASS-dialogue [data-border-style="3"]{padding:calc(var(--ass-scale-stroke)*var(--ass-tag-xbord)*1px) calc(var(--ass-scale-stroke)*var(--ass-tag-ybord)*1px);position:relative;filter:blur(calc(var(--ass-tag-blur)*1px))}.ASS-dialogue [data-border-style="3"]::after,.ASS-dialogue [data-border-style="3"]::before{content:"";width:100%;height:100%;position:absolute;z-index:-1}.ASS-dialogue [data-border-style="3"]::before{background-color:var(--ass-shadow-color);left:calc(var(--ass-scale-stroke)*var(--ass-tag-xshad)*1px);top:calc(var(--ass-scale-stroke)*var(--ass-tag-yshad)*1px)}.ASS-dialogue [data-border-style="3"]::after{background-color:var(--ass-border-color);left:0;top:0}@container style(--ass-tag-xbord: 0) and style(--ass-tag-ybord: 0){.ASS-dialogue [data-border-style="3"]::after{background-color:transparent}}@container style(--ass-tag-xshad: 0) and style(--ass-tag-yshad: 0){.ASS-dialogue [data-border-style="3"]::before{background-color:transparent}}.ASS-dialogue [data-rotate]{transform:perspective(312.5px) rotateY(calc(var(--ass-tag-fry)*1deg)) rotateX(calc(var(--ass-tag-frx)*1deg)) rotateZ(calc(var(--ass-tag-frz)*-1deg))}.ASS-dialogue [data-text][data-rotate]{transform-style:preserve-3d;word-break:normal;white-space:nowrap}.ASS-dialogue [data-scale],.ASS-dialogue [data-skew]{display:inline-block;transform:scale(var(--ass-tag-fscx),var(--ass-tag-fscy)) skew(calc(var(--ass-tag-fax)*1rad),calc(var(--ass-tag-fay)*1rad));transform-origin:var(--ass-align-h) var(--ass-align-v)}.ASS-fix-font-size{font-size:2048px;font-family:Arial;line-height:normal;width:0;height:0;position:absolute;visibility:hidden;overflow:hidden}.ASS-clip-area,.ASS-fix-font-size span{position:absolute}.ASS-clip-area{width:100%;height:100%;top:0;left:0}.ASS-scroll-area{position:absolute;width:100%;overflow:hidden}';
function addGlobalStyle(container) {
    const rootNode = container.getRootNode() || document;
    let isDocument = rootNode instanceof Document;
    if (!isDocument && typeof documentPictureInPicture === 'object' && documentPictureInPicture.window) {
        isDocument = rootNode === documentPictureInPicture.window.document;
    }
    const styleRoot = isDocument ? rootNode.head : rootNode;
    let $style = styleRoot.querySelector('#ASS-global-style');
    if (!$style) {
        $style = document.createElement('style');
        $style.type = 'text/css';
        $style.id = 'ASS-global-style';
        $style.append(document.createTextNode(GLOBAL_CSS));
        styleRoot.append($style);
    }
    if (!document.head.querySelector('#ASS-global-style')) {
        $style = document.createElement('style');
        $style.type = 'text/css';
        $style.id = 'ASS-global-style';
        $style.append(document.createTextNode(GLOBAL_CSS));
        document.head.append($style);
    }
}
const defaultStyle = {
    Name: 'Default',
    Fontname: 'Arial',
    Fontsize: '16',
    PrimaryColour: '&Hffffff',
    SecondaryColour: '&Hffffff',
    OutlineColour: '&H0',
    BackColour: '&H0',
    Bold: '0',
    Italic: '0',
    Underline: '0',
    StrikeOut: '0',
    ScaleX: '100',
    ScaleY: '100',
    Spacing: '0',
    Angle: '0',
    BorderStyle: '1',
    Outline: '1',
    Shadow: '0',
    Alignment: '2',
    MarginL: '10',
    MarginR: '10',
    MarginV: '10',
    Encoding: '0',
};
class AssRender {
    store;
    resampling_ = 'video_height';
    resize_;
    options;
    constructor(dom, options = { container: dom.parentNode }) {
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend({}, options);
        this.store = {
            video: dom,
            box: document.createElement('div'),
            svg: (0,assjs_src_utils__WEBPACK_IMPORTED_MODULE_3__.createSVGEl)('svg'),
            defs: (0,assjs_src_utils__WEBPACK_IMPORTED_MODULE_3__.createSVGEl)('defs'),
            observer: null,
            scale: 1,
            width: 0,
            height: 0,
            scriptRes: {
                width: options.videoWidth || dom.clientWidth,
                height: options.videoHeight || dom.clientHeight
            },
            layoutRes: {
                width: options.videoWidth || dom.clientWidth,
                height: options.videoHeight || dom.clientHeight
            },
            resampledRes: {
                width: 0,
                height: 0
            },
            sbas: true,
            styles: null,
            space: [],
            actives: [],
            delay: 0,
            index: 0,
            dialogues: []
        };
        if (options.videoWidth == null) {
            // @ts-ignore
            dom.videoWidth = options.videoWidth;
        }
        if (options.videoHeight == null) {
            // @ts-ignore
            dom.videoHeight = options.videoHeight;
        }
        if (!options.container) {
            throw new Error('Missing container.');
        }
        this.resize_ = (0,assjs_src_internal__WEBPACK_IMPORTED_MODULE_2__.createResize)(this, this.store);
        this.updateHeader(options.header);
        options.container.append(assjs_src_renderer_font_size__WEBPACK_IMPORTED_MODULE_1__.$fixFontSize);
        const { svg, defs, scriptRes, box } = this.store;
        svg.setAttributeNS(null, 'viewBox', `0 0 ${scriptRes.width} ${scriptRes.height}`);
        svg.append(defs);
        options.container.append(svg);
        box.className = 'ASS-box';
        options.container.append(box);
        addGlobalStyle(options.container);
        this.resampling_ = options.resampling || 'video_height';
        const observer = new ResizeObserver(this.resize.bind(this));
        observer.observe(dom);
        this.store.observer = observer;
        return this;
    }
    framing(dialogue) {
        const dia = (0,assjs_src_renderer_renderer__WEBPACK_IMPORTED_MODULE_8__.renderer)(dialogue, this.store);
        (0,assjs_src_utils__WEBPACK_IMPORTED_MODULE_3__.batchAnimate)(dia, 'play');
        dia.__dialogue = dialogue;
        this.store.actives.push(dia);
    }
    updateHeader(header) {
        if (header) {
            const { info, width, height, styles } = (0,ass_compiler__WEBPACK_IMPORTED_MODULE_5__.compile)(header, {
                defaultStyle
            });
            this.store.sbas = /yes/i.test(info.ScaledBorderAndShadow);
            this.store.layoutRes = {
                width: +info.LayoutResX || this.options.videoWidth || this.store.video.clientWidth,
                height: +info.LayoutResY || this.options.videoHeight || this.store.video.clientHeight,
            };
            this.store.scriptRes = {
                width: width || this.store.layoutRes.width,
                height: height || this.store.layoutRes.height,
            };
            this.store.styles = styles;
        }
        else {
            this.store.styles = (0,ass_compiler_src_compiler_styles__WEBPACK_IMPORTED_MODULE_7__.compileStyles)({
                info: {
                    WrapStyle: ''
                },
                style: [],
                defaultStyle
            });
            this.store.scriptRes = {
                width: 384,
                height: 288
            };
        }
        this.resize_();
        this.options.header = header;
    }
    updateVideoResolution(videoWidth, videoHeight) {
        if (this.options.header) {
            const { info, width, height } = (0,ass_compiler__WEBPACK_IMPORTED_MODULE_5__.compile)(this.options.header, {
                defaultStyle
            });
            this.store.layoutRes = {
                width: +info.LayoutResX || videoWidth || this.store.video.clientWidth,
                height: +info.LayoutResY || videoHeight || this.store.video.clientHeight,
            };
            this.store.scriptRes = {
                width: width || this.store.layoutRes.width,
                height: height || this.store.layoutRes.height,
            };
        }
        else {
            this.store.layoutRes = {
                width: videoWidth,
                height: videoHeight
            };
        }
    }
    render(event) {
        if (event.type === 1 /* AssEventType.Dialogue */) {
            // @ts-ignore
            event.Start = Number(event.Start) / 1000;
            // @ts-ignore
            event.End = Number(event.End) / 1000;
            const dialogue = (0,ass_compiler_src_compiler_dialogues__WEBPACK_IMPORTED_MODULE_6__.compileDialogues)({
                styles: this.store.styles,
                dialogues: [event]
            })[0];
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(dialogue, {
                d: `ASS-${(0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_4__["default"])()}`,
                align: {
                    h: (dialogue.alignment + 2) % 3,
                    v: Math.trunc((dialogue.alignment - 1) / 3)
                }
            });
            (0,assjs_src_renderer_animation__WEBPACK_IMPORTED_MODULE_0__.setKeyframes)(dialogue, this.store);
            this.framing(dialogue);
        }
    }
    clear(pts) {
        const now = Number(BigInt.asIntN(32, pts)) / 1000;
        for (let i = this.store.actives.length - 1; i >= 0; i -= 1) {
            const dia = this.store.actives[i];
            const { end } = dia;
            if (end < now) {
                dia.$div.remove();
                this.store.actives.splice(i, 1);
            }
        }
    }
    clearAll() {
        for (let i = this.store.actives.length - 1; i >= 0; i -= 1) {
            const dia = this.store.actives[i];
            dia.$div.remove();
        }
        this.store.actives.length = 0;
        this.store.space.length = 0;
    }
    resize() {
        const actions = this.store.actives.slice();
        this.resize_();
        for (let i = 0; i < actions.length; i++) {
            this.framing(actions[i].__dialogue);
        }
    }
    destroy() {
        const { video, box, svg, observer } = this.store;
        (0,assjs_src_internal__WEBPACK_IMPORTED_MODULE_2__.clear)(this.store);
        assjs_src_renderer_font_size__WEBPACK_IMPORTED_MODULE_1__.$fixFontSize.remove();
        svg.remove();
        box.remove();
        observer.unobserve(video);
        this.store.styles = {};
        return this;
    }
    show() {
        this.store.box.style.visibility = 'visible';
        return this;
    }
    hide() {
        this.store.box.style.visibility = 'hidden';
        return this;
    }
    get resampling() {
        return this.resampling_;
    }
    set resampling(r) {
        if (r === this.resampling_) {
            return;
        }
        if (/^(video|script)_(width|height)$/.test(r)) {
            this.resampling_ = r;
            this.resize();
        }
    }
}


/***/ }),

/***/ "./src/avplayer/subtitle/SubtitleRender.ts":
/*!*************************************************!*\
  !*** ./src/avplayer/subtitle/SubtitleRender.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SubtitleRender)
/* harmony export */ });
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./..\..\cheap\std\collection\List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./..\..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var avcodec_subtitle_SubtitleDecoder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avcodec/subtitle/SubtitleDecoder */ "./src/avcodec/subtitle/SubtitleDecoder.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/timer/LoopTask */ "./src/common/timer/LoopTask.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _AssRender__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./AssRender */ "./src/avplayer/subtitle/AssRender.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avformat_formats_ass_iass__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avformat/formats/ass/iass */ "./src/avformat/formats/ass/iass.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
var cheap__fileName__6 = "src\\avplayer\\subtitle\\SubtitleRender.ts";





/*
 * libmedia subtitle render
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */













const WebVttReplace = [
    {
        reg: /<i>/g,
        value: '{\\i1}'
    },
    {
        reg: /<\/i>/g,
        value: '{\\i0}'
    },
    {
        reg: /<b>/g,
        value: '{\\b1}'
    },
    {
        reg: /<\/b>/g,
        value: '{\\b0}'
    },
    {
        reg: /<u>/g,
        value: '{\\u1}'
    },
    {
        reg: /<\/u>/g,
        value: '{\\u0}'
    },
    {
        reg: /{/g,
        value: '\\{'
    },
    {
        reg: /}/g,
        value: '\\}'
    },
    {
        reg: /&gt;/g,
        value: '>'
    },
    {
        reg: /&lt;/g,
        value: '<'
    },
    {
        reg: /&lrm;/g,
        value: ''
    },
    {
        reg: /&rlm;/g,
        value: ''
    },
    {
        reg: /&amp;/g,
        value: '&'
    },
    {
        reg: /&nbsp;/g,
        value: '\\h'
    },
    {
        reg: /(<br\s*\/?>)|\n>/g,
        value: '\\N'
    }
];
class SubtitleRender {
    decoder;
    loop;
    demuxer2SubtitleRenderChannels;
    leftPorts;
    currentPort;
    render;
    queue;
    ended;
    options;
    pulling;
    formats;
    avpacketPool;
    delay;
    enable;
    constructor(options) {
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_16__.extend({}, options);
        this.ended = false;
        this.pulling = false;
        this.queue = [];
        this.delay = BigInt(0);
        this.demuxer2SubtitleRenderChannels = new Map();
        this.leftPorts = new Map();
        if (options.avpacketList) {
            this.avpacketPool = new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_13__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_0__["default"]), options.avpacketListMutex);
        }
        this.createDecoder();
        this.render = new _AssRender__WEBPACK_IMPORTED_MODULE_9__["default"](this.options.dom, {
            header: this.getAssHeader(this.options.codecpar),
            container: this.options.container,
            videoWidth: this.options.videoWidth,
            videoHeight: this.options.videoHeight
        });
        this.loop = new common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_7__["default"](() => {
            if (!this.queue.length && this.ended) {
                this.loop.stop();
            }
            if (this.queue.length < 6 && !this.ended) {
                this.pull();
            }
            const currentTime = this.options.getCurrentTime() - this.delay;
            this.render.clear(currentTime);
            while (this.queue.length) {
                const event = this.queue[0];
                if (event.Start > currentTime) {
                    break;
                }
                if (event.End > currentTime) {
                    this.render.render(event);
                }
                this.queue.shift();
            }
        }, 0, 50, false);
    }
    getAssHeader(codecpar) {
        let header = '';
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 4) === 94230 /* AVCodecID.AV_CODEC_ID_ASS */ && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 16)) {
            header = common_util_text__WEBPACK_IMPORTED_MODULE_10__.decode((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_11__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](codecpar + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](codecpar + 16)));
            const lines = header.split(/\r?\n/);
            let hasEvent = false;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '[Events]') {
                    hasEvent = true;
                }
                if (/^Format:/.test(line) && hasEvent) {
                    this.formats = avformat_formats_ass_iass__WEBPACK_IMPORTED_MODULE_12__.parseEventFormat(line.trim());
                }
            }
        }
        return header;
    }
    createDecoder() {
        if (this.decoder) {
            this.decoder.close();
        }
        this.decoder = new avcodec_subtitle_SubtitleDecoder__WEBPACK_IMPORTED_MODULE_5__["default"]({
            onReceiveSubtitle: (subtitle) => {
                for (let i = 0; i < subtitle.rects.length; i++) {
                    const rect = subtitle.rects[i];
                    if (rect.type === 3 /* AVSubtitleType.SUBTITLE_ASS */) {
                        const event = avformat_formats_ass_iass__WEBPACK_IMPORTED_MODULE_12__.parseEvent(this.formats, rect.text);
                        if (event.Start == null) {
                            event.Start = subtitle.pts;
                        }
                        if (event.End == null) {
                            event.End = subtitle.pts + subtitle.duration;
                        }
                        this.queue.push(event);
                    }
                    else if (rect.type === 2 /* AVSubtitleType.SUBTITLE_WEBVTT */) {
                        this.queue.push(this.webvtt2AssEvent(rect.text, subtitle.pts, subtitle.pts + subtitle.duration));
                    }
                    else {
                        this.queue.push(this.text2AssEvent(rect.text, subtitle.pts, subtitle.pts + subtitle.duration));
                    }
                }
            }
        });
        this.decoder.open(this.options.codecpar);
    }
    text2AssEvent(text, start, end) {
        return {
            type: 1 /* AssEventType.Dialogue */,
            ReadOrder: 0,
            Layer: 0,
            Start: start,
            End: end,
            Style: 'Default',
            Name: '',
            MarginL: 0,
            MarginR: 0,
            MarginV: 0,
            Text: {
                raw: text,
                combined: text,
                parsed: [
                    {
                        tags: [],
                        text: text,
                        drawing: []
                    }
                ]
            }
        };
    }
    webvtt2AssEvent(text, start, end) {
        for (let i = 0; i < WebVttReplace.length; i++) {
            text = text.replace(WebVttReplace[i].reg, WebVttReplace[i].value);
        }
        return this.text2AssEvent(text, start, end);
    }
    async pull() {
        if (this.pulling && !this.ended) {
            return;
        }
        this.pulling = true;
        const currentPort = this.currentPort;
        const avpacket = await this.leftPorts.get(this.currentPort).request('pull');
        if (avpacket === -1048576 /* IOError.END */) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_8__.debug('SubtitleRender end', cheap__fileName__6, 290);
            this.decoder.flush();
            this.ended = true;
        }
        else if (avpacket < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_8__.debug(`SubtitleRender pull avpacket error, ret: ${avpacket}`, cheap__fileName__6, 295);
            this.ended = true;
        }
        else if (this.loop && currentPort === this.currentPort) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](avpacket + 8, (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_14__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_MILLI_TIME_BASE_Q));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](avpacket + 48, (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_14__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 48), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_MILLI_TIME_BASE_Q));
            const ret = this.decoder.decode(avpacket);
            if (this.avpacketPool) {
                this.avpacketPool.release(avpacket);
            }
            else {
                (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_17__.destroyAVPacket)(avpacket);
            }
            if (ret < 0) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_8__.debug(`SubtitleRender decode avpacket error, ret: ${avpacket}`, cheap__fileName__6, 309);
                this.ended = true;
            }
        }
        else {
            if (this.avpacketPool) {
                this.avpacketPool.release(avpacket);
            }
            else {
                (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_17__.destroyAVPacket)(avpacket);
            }
        }
        this.pulling = false;
    }
    getDemuxerPort(taskId) {
        if (this.demuxer2SubtitleRenderChannels.has(taskId)) {
            return this.demuxer2SubtitleRenderChannels.get(taskId).port1;
        }
        const messageChannel = new MessageChannel();
        const ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__["default"](messageChannel.port2);
        this.demuxer2SubtitleRenderChannels.set(taskId, messageChannel);
        this.leftPorts.set(taskId, ipcPort);
        return messageChannel.port1;
    }
    start() {
        if (!this.loop.isStarted()) {
            this.loop.start();
        }
        this.ended = false;
    }
    stop() {
        this.loop.stop();
        this.render.clearAll();
    }
    pause() {
        this.loop.stop();
    }
    reset() {
        this.queue.length = 0;
        this.render.clearAll();
    }
    reopenDecoder(codecpar) {
        this.options.codecpar = codecpar;
        this.createDecoder();
        this.render.updateHeader(this.getAssHeader(codecpar));
    }
    updateVideoResolution(videoWidth, videoHeight) {
        if (videoWidth !== this.options.videoWidth || videoHeight !== this.options.videoHeight) {
            this.render.updateVideoResolution(videoWidth, videoHeight);
            this.options.videoWidth = videoWidth;
            this.options.videoHeight = videoHeight;
        }
    }
    setDemuxTask(taskId) {
        if (this.currentPort !== taskId) {
            this.pulling = false;
        }
        this.currentPort = taskId;
    }
    destroy() {
        this.loop.destroy();
        this.loop = null;
        this.leftPorts.clear();
        this.demuxer2SubtitleRenderChannels.clear();
        this.queue.length = 0;
        this.render.destroy();
        this.render = null;
        this.decoder.close();
        this.decoder = null;
    }
    setDelay(d) {
        this.delay = d;
    }
    getDelay() {
        return this.delay;
    }
}


/***/ }),

/***/ "./src/avplayer/worker/AudioPipeline.ts":
/*!**********************************************!*\
  !*** ./src/avplayer/worker/AudioPipeline.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioPipeline)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _struct_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./..\struct.ts */ "./src/avplayer/struct.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avpipeline_AudioDecodePipeline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avpipeline/AudioDecodePipeline */ "./src/avpipeline/AudioDecodePipeline.ts");
/* harmony import */ var avpipeline_AudioRenderPipeline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avpipeline/AudioRenderPipeline */ "./src/avpipeline/AudioRenderPipeline.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_timer_Timer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/timer/Timer */ "./src/common/timer/Timer.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
var cheap__fileName__12 = "src\\avplayer\\worker\\AudioPipeline.ts";




/*
 * libmedia AudioPipeline
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */










class AudioPipeline {
    decoder;
    render;
    globalDataMap;
    controlPort;
    timer;
    constructor() {
        this.decoder = new avpipeline_AudioDecodePipeline__WEBPACK_IMPORTED_MODULE_6__["default"]();
        this.render = new avpipeline_AudioRenderPipeline__WEBPACK_IMPORTED_MODULE_7__["default"]();
        this.globalDataMap = new Map();
    }
    createGlobalData(taskId) {
        const data = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_2__["default"])(_struct_ts__WEBPACK_IMPORTED_MODULE_1__.AVPlayerGlobalData);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_10__.init(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_10__.init(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28);
        this.globalDataMap.set(taskId, data);
        return data;
    }
    releaseGlobalData(data) {
        data.avframeList.clear((avframe) => {
            (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_8__.unrefAVFrame)(avframe);
        }, 20);
        data.avpacketList.clear((avpacket) => {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.unrefAVPacket)(avpacket);
        }, 20);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_10__.destroy(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_10__.destroy(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28);
        (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_3__["default"])(data);
    }
    async init(controlPort) {
        this.controlPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_11__["default"](controlPort);
        let secondCounter = 0;
        this.timer = new common_timer_Timer__WEBPACK_IMPORTED_MODULE_12__["default"](() => {
            secondCounter++;
            const result = [];
            this.globalDataMap.forEach((globalData, key) => {
                const stats = globalData.stats;
                result.push({
                    taskId: key,
                    stats: {
                        audioFrameDecodeCount: stats.audioFrameDecodeCount,
                        audioFrameDecodeIntervalMax: stats.audioFrameDecodeIntervalMax,
                        audioDecodeErrorPacketCount: stats.audioDecodeErrorPacketCount,
                        audioFrameRenderCount: stats.audioFrameRenderCount,
                        audioFrameRenderIntervalMax: stats.audioFrameRenderIntervalMax,
                        sampleRate: stats.sampleRate,
                        channels: stats.channels,
                        audioFrameSize: stats.audioFrameSize,
                        audioCurrentTime: stats.audioCurrentTime
                    }
                });
                if (secondCounter === 2) {
                    stats.audioFrameDecodeIntervalMax = 0;
                    stats.audioFrameRenderIntervalMax = 0;
                }
            });
            this.controlPort.notify('stats', {
                data: result
            });
            if (secondCounter === 2) {
                secondCounter = 0;
            }
        }, 0, 500);
        this.controlPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_11__.NOTIFY, (request) => {
            switch (request.method) {
                case 'stats': {
                    const data = request.params.data;
                    for (let i = 0; i < data.length; i++) {
                        const stats = this.globalDataMap.get(data[i].taskId).stats;
                        if (stats) {
                            common_util_object__WEBPACK_IMPORTED_MODULE_13__.each(data[i].stats, (value, key) => {
                                stats[key] = value;
                            });
                            stats.jitterBuffer.min = data[i].jitterBuffer.min;
                            stats.jitterBuffer.max = data[i].jitterBuffer.max;
                        }
                    }
                }
            }
        });
        this.timer.start();
    }
    async invoke(type, method, args) {
        const me = this;
        function transformResult(method, args, result) {
            if (method === 'unregisterTask') {
                const globalData = me.globalDataMap.get(args[0]);
                if (globalData) {
                    me.releaseGlobalData(globalData);
                    me.globalDataMap.delete(args[0]);
                }
            }
            else if (method === 'clear') {
                me.globalDataMap.forEach((globalData) => {
                    me.releaseGlobalData(globalData);
                });
                me.globalDataMap.clear();
            }
            else if (method === 'syncSeekTime') {
                const globalData = me.globalDataMap.get(args[0]);
                if (globalData) {
                    return globalData.stats.audioCurrentTime;
                }
            }
            return result;
        }
        if (type === 'decoder') {
            if (method === 'registerTask') {
                const globalData = this.globalDataMap.get(args[0].taskId) || this.createGlobalData(args[0].taskId);
                args[0].stats = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32;
                args[0].avpacketList = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress];
                args[0].avpacketListMutex = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24;
                args[0].avframeList = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 12;
                args[0].avframeListMutex = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28;
            }
            if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.func(this.decoder[method])) {
                return this.decoder[method](...args)
                    .then((result) => {
                    result = transformResult(method, args, result);
                    return result;
                });
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`method ${method} not found`, cheap__fileName__12, 179);
            }
        }
        else {
            if (method === 'registerTask') {
                const globalData = this.globalDataMap.get(args[0].taskId) || this.createGlobalData(args[0].taskId);
                args[0].stats = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32;
                args[0].avframeList = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 12;
                args[0].avframeListMutex = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28;
            }
            if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.func(this.render[method])) {
                return this.render[method](...args)
                    .then((result) => {
                    result = transformResult(method, args, result);
                    return result;
                });
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`method ${method} not found`, cheap__fileName__12, 197);
            }
        }
    }
    async setLogLevel(level) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.setLevel(level);
    }
}


/***/ }),

/***/ "./src/avplayer/worker/AudioPipelineProxy.ts":
/*!***************************************************!*\
  !*** ./src/avplayer/worker/AudioPipelineProxy.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioPipelineProxy)
/* harmony export */ });
/* harmony import */ var _avpipeline_struct_stats_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./..\..\avpipeline\struct\stats.ts */ "./src/avpipeline/struct/stats.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_thread_thread__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/thread/thread */ "./src/cheap/thread/thread.ts");
/* harmony import */ var _AudioPipeline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AudioPipeline */ "./src/avplayer/worker/AudioPipeline.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");


/*
 * libmedia AudioPipelineProxy
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class AudioPipelineProxy {
    thread;
    controlMessageChannel;
    controlPort;
    statsMap;
    constructor() {
        this.statsMap = new Map();
    }
    async run() {
        this.thread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_2__.createThreadFromClass)(_AudioPipeline__WEBPACK_IMPORTED_MODULE_3__["default"], {
            name: 'AudioPipeline',
            dispatchToWorker: true
        }, /*require.resolve*/(/*! ./AudioPipeline.ts */ "./src/avplayer/worker/AudioPipeline.ts")).run();
        this.controlMessageChannel = new MessageChannel();
        this.controlPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__["default"](this.controlMessageChannel.port1);
        this.controlPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__.NOTIFY, (request) => {
            switch (request.method) {
                case 'stats': {
                    const data = request.params.data;
                    const syncStats = [];
                    for (let i = 0; i < data.length; i++) {
                        const stats = this.statsMap.get(data[i].taskId);
                        if (stats) {
                            common_util_object__WEBPACK_IMPORTED_MODULE_5__.each(data[i].stats, (value, key) => {
                                stats[key] = value;
                            });
                            syncStats.push({
                                taskId: data[i].taskId,
                                stats: {
                                    audioPacketQueueLength: stats.audioPacketQueueLength,
                                    audioEncodeFramerate: stats.audioEncodeFramerate,
                                    videoPacketQueueLength: stats.videoPacketQueueLength
                                },
                                jitterBuffer: {
                                    min: stats.jitterBuffer.min,
                                    max: stats.jitterBuffer.max
                                }
                            });
                        }
                    }
                    this.controlPort.notify('stats', {
                        data: {
                            stats: syncStats
                        }
                    });
                }
            }
        });
        await this.thread.init.transfer(this.controlMessageChannel.port2).invoke(this.controlMessageChannel.port2);
    }
    async destroy() {
        await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_2__.joinThread)(this.thread);
        this.thread = null;
    }
    setLogLevel(level) {
        this.thread.setLogLevel(level);
    }
    transformResult(method, args, result) {
        if (method === 'unregisterTask') {
            this.statsMap.delete(args[0]);
        }
        else if (method === 'clear') {
            this.statsMap.clear();
        }
        else if (method === 'registerTask') {
            this.statsMap.set(args[0].taskId, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__["default"])(args[0].stats, _avpipeline_struct_stats_ts__WEBPACK_IMPORTED_MODULE_0__["default"]));
        }
        else if (method === 'syncSeekTime') {
            const stats = this.statsMap.get(args[0]);
            if (stats) {
                stats.audioCurrentTime = result;
                return;
            }
        }
        return result;
    }
    get AudioDecodePipeline() {
        const me = this;
        return new Proxy({}, {
            get(target, propertyKey, receiver) {
                if (target[propertyKey]) {
                    return target[propertyKey];
                }
                const call = async function (...args) {
                    return me.thread.invoke('decoder', propertyKey, args)
                        .then((result) => {
                        result = me.transformResult(propertyKey, args, result);
                        return result;
                    });
                };
                call.transfer = function (...transfer) {
                    return {
                        invoke: async function (...args) {
                            return me.thread.invoke.transfer(...transfer).invoke('decoder', propertyKey, args)
                                .then((result) => {
                                result = me.transformResult(propertyKey, args, result);
                                return result;
                            });
                        }
                    };
                };
                target[propertyKey] = call;
                return target[propertyKey];
            }
        });
    }
    get AudioRenderPipeline() {
        const me = this;
        return new Proxy({}, {
            get(target, propertyKey, receiver) {
                if (target[propertyKey]) {
                    return target[propertyKey];
                }
                const call = async function (...args) {
                    return me.thread.invoke('render', propertyKey, args)
                        .then((result) => {
                        result = me.transformResult(propertyKey, args, result);
                        return result;
                    });
                };
                call.transfer = function (...transfer) {
                    return {
                        invoke: async function (...args) {
                            return me.thread.invoke.transfer(...transfer).invoke('render', propertyKey, args)
                                .then((result) => {
                                result = me.transformResult(propertyKey, args, result);
                                return result;
                            });
                        }
                    };
                };
                target[propertyKey] = call;
                return target[propertyKey];
            }
        });
    }
}


/***/ }),

/***/ "./src/avplayer/worker/IODemuxPipeline.ts":
/*!************************************************!*\
  !*** ./src/avplayer/worker/IODemuxPipeline.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IODemuxPipeline)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _struct_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./..\struct.ts */ "./src/avplayer/struct.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var avpipeline_IOPipeline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avpipeline/IOPipeline */ "./src/avpipeline/IOPipeline.ts");
/* harmony import */ var avpipeline_DemuxPipeline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avpipeline/DemuxPipeline */ "./src/avpipeline/DemuxPipeline.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_util_serialize__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/serialize */ "./src/avutil/util/serialize.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_timer_Timer__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/timer/Timer */ "./src/common/timer/Timer.ts");
var cheap__fileName__8 = "src\\avplayer\\worker\\IODemuxPipeline.ts";




/*
 * libmedia IODemuxPipeline
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */










class IODemuxPipeline {
    ioThread;
    demuxPipeline;
    globalDataMap;
    controlPort;
    timer;
    constructor() {
        this.ioThread = new avpipeline_IOPipeline__WEBPACK_IMPORTED_MODULE_4__["default"]();
        this.demuxPipeline = new avpipeline_DemuxPipeline__WEBPACK_IMPORTED_MODULE_5__["default"]();
        this.globalDataMap = new Map();
    }
    createGlobalData(taskId) {
        const data = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_2__["default"])(_struct_ts__WEBPACK_IMPORTED_MODULE_1__.AVPlayerGlobalData);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_11__.init(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_11__.init(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28);
        this.globalDataMap.set(taskId, data);
        return data;
    }
    releaseGlobalData(data) {
        data.avframeList.clear((avframe) => {
            (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_9__.unrefAVFrame)(avframe);
        }, 20);
        data.avpacketList.clear((avpacket) => {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_10__.unrefAVPacket)(avpacket);
        }, 20);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_11__.destroy(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_11__.destroy(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28);
        (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_3__["default"])(data);
    }
    async init(controlPort) {
        this.controlPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_12__["default"](controlPort);
        this.timer = new common_timer_Timer__WEBPACK_IMPORTED_MODULE_13__["default"](() => {
            const result = [];
            this.globalDataMap.forEach((globalData, key) => {
                const stats = globalData.stats;
                result.push({
                    taskId: key,
                    stats: {
                        bufferReceiveBytes: stats.bufferReceiveBytes,
                        audioPacketQueueLength: stats.audioPacketQueueLength,
                        videoPacketQueueLength: stats.videoPacketQueueLength,
                        audioPacketCount: stats.audioPacketCount,
                        audioPacketBytes: stats.audioPacketBytes,
                        audioEncodeFramerate: stats.audioEncodeFramerate,
                        videoPacketCount: stats.videoPacketCount,
                        videoPacketBytes: stats.videoPacketBytes,
                        keyFrameCount: stats.keyFrameCount,
                        gop: stats.gop,
                        keyFrameInterval: stats.keyFrameInterval,
                        videoEncodeFramerate: stats.videoEncodeFramerate
                    }
                });
            });
            this.controlPort.notify('stats', {
                data: result
            });
        }, 0, 500);
        this.timer.start();
    }
    async invoke(type, method, args) {
        const me = this;
        function transformResult(method, args, result) {
            if (method === 'unregisterTask') {
                const globalData = me.globalDataMap.get(args[0]);
                if (globalData) {
                    me.releaseGlobalData(globalData);
                    me.globalDataMap.delete(args[0]);
                }
            }
            else if (method === 'clear') {
                me.globalDataMap.forEach((globalData) => {
                    me.releaseGlobalData(globalData);
                });
                me.globalDataMap.clear();
            }
            else if (method === 'analyzeStreams' && !common_util_is__WEBPACK_IMPORTED_MODULE_6__.number(result)) {
                result.streams.forEach((stream) => {
                    stream.codecpar = (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_8__.serializeAVCodecParameters)(stream.codecpar);
                });
            }
        }
        if (type === 'io') {
            if (method === 'registerTask') {
                const globalData = this.globalDataMap.get(args[0].taskId) || this.createGlobalData(args[0].taskId);
                args[0].stats = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32;
            }
            if (common_util_is__WEBPACK_IMPORTED_MODULE_6__.func(this.ioThread[method])) {
                return this.ioThread[method](...args)
                    .then((result) => {
                    transformResult(method, args, result);
                    return result;
                });
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal(`method ${method} not found`, cheap__fileName__8, 150);
            }
        }
        else {
            if (method === 'registerTask') {
                const globalData = this.globalDataMap.get(args[0].taskId) || this.createGlobalData(args[0].taskId);
                args[0].stats = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32;
                args[0].avpacketList = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress];
                args[0].avpacketListMutex = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24;
            }
            if (common_util_is__WEBPACK_IMPORTED_MODULE_6__.func(this.demuxPipeline[method])) {
                return this.demuxPipeline[method](...args)
                    .then((result) => {
                    transformResult(method, args, result);
                    return result;
                });
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal(`method ${method} not found`, cheap__fileName__8, 168);
            }
        }
    }
    async setLogLevel(level) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.setLevel(level);
    }
}


/***/ }),

/***/ "./src/avplayer/worker/IODemuxPipelineProxy.ts":
/*!*****************************************************!*\
  !*** ./src/avplayer/worker/IODemuxPipelineProxy.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IODemuxPipelineProxy)
/* harmony export */ });
/* harmony import */ var _avpipeline_struct_stats_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./..\..\avpipeline\struct\stats.ts */ "./src/avpipeline/struct/stats.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_thread_thread__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/thread/thread */ "./src/cheap/thread/thread.ts");
/* harmony import */ var _IODemuxPipeline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./IODemuxPipeline */ "./src/avplayer/worker/IODemuxPipeline.ts");
/* harmony import */ var avutil_util_serialize__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/util/serialize */ "./src/avutil/util/serialize.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");
/* harmony import */ var avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/util/codecparameters */ "./src/avutil/util/codecparameters.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");


/*
 * libmedia IODemuxPipelineProxy
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */








class IODemuxPipelineProxy {
    thread;
    codecparMap;
    controlMessageChannel;
    controlPort;
    statsMap;
    constructor() {
        this.codecparMap = new Map();
        this.statsMap = new Map();
    }
    async run() {
        this.thread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_2__.createThreadFromClass)(_IODemuxPipeline__WEBPACK_IMPORTED_MODULE_3__["default"], {
            name: 'IODemuxPipeline',
            dispatchToWorker: true
        }, /*require.resolve*/(/*! ./IODemuxPipeline.ts */ "./src/avplayer/worker/IODemuxPipeline.ts")).run();
        this.controlMessageChannel = new MessageChannel();
        this.controlPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_8__["default"](this.controlMessageChannel.port1);
        this.controlPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_8__.NOTIFY, (request) => {
            switch (request.method) {
                case 'stats': {
                    const data = request.params.data;
                    for (let i = 0; i < data.length; i++) {
                        const stats = this.statsMap.get(data[i].taskId);
                        if (stats) {
                            common_util_object__WEBPACK_IMPORTED_MODULE_9__.each(data[i].stats, (value, key) => {
                                stats[key] = value;
                            });
                        }
                    }
                }
            }
        });
        await this.thread.init.transfer(this.controlMessageChannel.port2).invoke(this.controlMessageChannel.port2);
    }
    setLogLevel(level) {
        this.thread.setLogLevel(level);
    }
    async destroy() {
        await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_2__.joinThread)(this.thread);
        this.thread = null;
    }
    get IOPipeline() {
        const me = this;
        return new Proxy({}, {
            get(target, propertyKey, receiver) {
                if (target[propertyKey]) {
                    return target[propertyKey];
                }
                const call = async function (...args) {
                    return me.thread.invoke('io', propertyKey, args);
                };
                call.transfer = function (...transfer) {
                    return {
                        invoke: async function (...args) {
                            return me.thread.invoke.transfer(...transfer).invoke('io', propertyKey, args);
                        }
                    };
                };
                target[propertyKey] = call;
                return target[propertyKey];
            }
        });
    }
    get DemuxPipeline() {
        const me = this;
        function transformResult(method, args, result) {
            if (method === 'analyzeStreams' && !common_util_is__WEBPACK_IMPORTED_MODULE_5__.number(result)) {
                const codecpar = [];
                result.streams.forEach((stream) => {
                    if (!(0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_6__["default"])(stream.codecpar)) {
                        stream.codecpar = (0,avutil_util_serialize__WEBPACK_IMPORTED_MODULE_4__.unserializeAVCodecParameters)(stream.codecpar);
                        codecpar.push(stream.codecpar);
                    }
                    me.codecparMap.set(args[0], codecpar);
                });
            }
            else if (method === 'unregisterTask') {
                const codecpar = me.codecparMap.get(args[0]);
                if (codecpar) {
                    codecpar.forEach((par) => {
                        (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_7__.freeCodecParameters)(par);
                    });
                    me.codecparMap.delete(args[0]);
                }
                me.statsMap.delete(args[0]);
            }
            else if (method === 'clear') {
                me.codecparMap.forEach((codecpar) => {
                    codecpar.forEach((par) => {
                        (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_7__.freeCodecParameters)(par);
                    });
                });
                me.codecparMap.clear();
                me.statsMap.clear();
            }
            else if (method === 'registerTask') {
                me.statsMap.set(args[0].taskId, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__["default"])(args[0].stats, _avpipeline_struct_stats_ts__WEBPACK_IMPORTED_MODULE_0__["default"]));
            }
        }
        return new Proxy({}, {
            get(target, propertyKey, receiver) {
                if (target[propertyKey]) {
                    return target[propertyKey];
                }
                const call = async function (...args) {
                    return me.thread.invoke('demux', propertyKey, args)
                        .then((result) => {
                        transformResult(propertyKey, args, result);
                        return result;
                    });
                };
                call.transfer = function (...transfer) {
                    return {
                        invoke: async function (...args) {
                            return me.thread.invoke.transfer(...transfer).invoke('demux', propertyKey, args)
                                .then((result) => {
                                transformResult(propertyKey, args, result);
                                return result;
                            });
                        }
                    };
                };
                target[propertyKey] = call;
                return target[propertyKey];
            }
        });
    }
}


/***/ }),

/***/ "./src/avplayer/worker/MSEPipeline.ts":
/*!********************************************!*\
  !*** ./src/avplayer/worker/MSEPipeline.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MSEPipelineWorker)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _struct_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./..\struct.ts */ "./src/avplayer/struct.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_timer_Timer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/timer/Timer */ "./src/common/timer/Timer.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var _mse_MSEPipeline__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../mse/MSEPipeline */ "./src/avplayer/mse/MSEPipeline.ts");
var cheap__fileName__10 = "src\\avplayer\\worker\\MSEPipeline.ts";




/*
 * libmedia MSEPipelineWorker
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */









class MSEPipelineWorker {
    mse;
    globalDataMap;
    controlPort;
    timer;
    constructor() {
        this.mse = new _mse_MSEPipeline__WEBPACK_IMPORTED_MODULE_12__["default"]();
        this.globalDataMap = new Map();
    }
    createGlobalData(taskId) {
        const data = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_2__["default"])(_struct_ts__WEBPACK_IMPORTED_MODULE_1__.AVPlayerGlobalData);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_8__.init(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_8__.init(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28);
        this.globalDataMap.set(taskId, data);
        return data;
    }
    releaseGlobalData(data) {
        data.avframeList.clear((avframe) => {
            (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_6__.unrefAVFrame)(avframe);
        }, 20);
        data.avpacketList.clear((avpacket) => {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_7__.unrefAVPacket)(avpacket);
        }, 20);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_8__.destroy(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_8__.destroy(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28);
        (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_3__["default"])(data);
    }
    async init(controlPort) {
        this.controlPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_9__["default"](controlPort);
        this.timer = new common_timer_Timer__WEBPACK_IMPORTED_MODULE_10__["default"](() => {
            const result = [];
            this.globalDataMap.forEach((globalData, key) => {
                const stats = globalData.stats;
                result.push({
                    taskId: key,
                    stats: {
                        audioFrameDecodeCount: stats.audioFrameDecodeCount,
                        audioFrameRenderCount: stats.audioFrameRenderCount,
                        sampleRate: stats.sampleRate,
                        channels: stats.channels,
                        videoFrameDecodeCount: stats.videoFrameDecodeCount,
                        videoFrameRenderCount: stats.videoFrameRenderCount,
                        width: stats.width,
                        height: stats.height
                    }
                });
            });
            this.controlPort.notify('stats', {
                data: result
            });
        }, 0, 500);
        this.controlPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_9__.NOTIFY, (request) => {
            switch (request.method) {
                case 'stats': {
                    const data = request.params.data;
                    for (let i = 0; i < data.length; i++) {
                        const stats = this.globalDataMap.get(data[i].taskId).stats;
                        if (stats) {
                            common_util_object__WEBPACK_IMPORTED_MODULE_11__.each(data[i].stats, (value, key) => {
                                stats[key] = value;
                            });
                            stats.jitterBuffer.min = data[i].jitterBuffer.min;
                            stats.jitterBuffer.max = data[i].jitterBuffer.max;
                        }
                    }
                }
            }
        });
        this.timer.start();
    }
    async invoke(method, args) {
        const me = this;
        function transformResult(method, args, result) {
            if (method === 'unregisterTask') {
                const globalData = me.globalDataMap.get(args[0]);
                if (globalData) {
                    me.releaseGlobalData(globalData);
                    me.globalDataMap.delete(args[0]);
                }
            }
            else if (method === 'clear') {
                me.globalDataMap.forEach((globalData) => {
                    me.releaseGlobalData(globalData);
                });
                me.globalDataMap.clear();
            }
            return result;
        }
        if (method === 'registerTask') {
            const globalData = this.globalDataMap.get(args[0].taskId) || this.createGlobalData(args[0].taskId);
            args[0].stats = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32;
            args[0].avpacketList = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress];
            args[0].avpacketListMutex = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24;
        }
        if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.func(this.mse[method])) {
            if (!this.mse[method].transfer) {
                this.mse[method].transfer = [];
            }
            return this.mse[method](...args)
                .then((result) => {
                if (this.mse[method].transfer.length) {
                    this.invoke.transfer = this.mse[method].transfer;
                }
                result = transformResult(method, args, result);
                return result;
            });
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`method ${method} not found`, cheap__fileName__10, 162);
        }
    }
    async setLogLevel(level) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.setLevel(level);
    }
}


/***/ }),

/***/ "./src/avplayer/worker/MSEPipelineProxy.ts":
/*!*************************************************!*\
  !*** ./src/avplayer/worker/MSEPipelineProxy.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MSEPipelineProxy)
/* harmony export */ });
/* harmony import */ var _avpipeline_struct_stats_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./..\..\avpipeline\struct\stats.ts */ "./src/avpipeline/struct/stats.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_thread_thread__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/thread/thread */ "./src/cheap/thread/thread.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var _MSEPipeline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MSEPipeline */ "./src/avplayer/worker/MSEPipeline.ts");


/*
 * libmedia MSEPipelineProxy
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class MSEPipelineProxy {
    thread;
    controlMessageChannel;
    controlPort;
    statsMap;
    constructor() {
        this.statsMap = new Map();
    }
    async run() {
        this.thread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_2__.createThreadFromClass)(_MSEPipeline__WEBPACK_IMPORTED_MODULE_5__["default"], {
            name: 'MSEPipeline',
            dispatchToWorker: true
        }, /*require.resolve*/(/*! ./MSEPipeline.ts */ "./src/avplayer/worker/MSEPipeline.ts")).run();
        this.controlMessageChannel = new MessageChannel();
        this.controlPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_3__["default"](this.controlMessageChannel.port1);
        this.controlPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_3__.NOTIFY, (request) => {
            switch (request.method) {
                case 'stats': {
                    const data = request.params.data;
                    const syncStats = [];
                    for (let i = 0; i < data.length; i++) {
                        const stats = this.statsMap.get(data[i].taskId);
                        if (stats) {
                            common_util_object__WEBPACK_IMPORTED_MODULE_4__.each(data[i].stats, (value, key) => {
                                stats[key] = value;
                            });
                            syncStats.push({
                                taskId: data[i].taskId,
                                stats: {
                                    videoEncodeFramerate: stats.videoEncodeFramerate,
                                    videoPacketQueueLength: stats.videoPacketQueueLength,
                                    audioPacketQueueLength: stats.audioPacketQueueLength,
                                    audioEncodeFramerate: stats.audioEncodeFramerate,
                                },
                                jitterBuffer: {
                                    min: stats.jitterBuffer.min,
                                    max: stats.jitterBuffer.max
                                }
                            });
                        }
                    }
                    this.controlPort.notify('stats', {
                        data: {
                            stats: syncStats
                        }
                    });
                }
            }
        });
        await this.thread.init.transfer(this.controlMessageChannel.port2).invoke(this.controlMessageChannel.port2);
    }
    setLogLevel(level) {
        this.thread.setLogLevel(level);
    }
    async destroy() {
        await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_2__.joinThread)(this.thread);
        this.thread = null;
    }
    transformResult(method, args, result) {
        if (method === 'unregisterTask') {
            this.statsMap.delete(args[0]);
        }
        else if (method === 'clear') {
            this.statsMap.clear();
        }
        else if (method === 'registerTask') {
            this.statsMap.set(args[0].taskId, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__["default"])(args[0].stats, _avpipeline_struct_stats_ts__WEBPACK_IMPORTED_MODULE_0__["default"]));
        }
        return result;
    }
    get MSEPipeline() {
        const me = this;
        return new Proxy({}, {
            get(target, propertyKey, receiver) {
                if (target[propertyKey]) {
                    return target[propertyKey];
                }
                const call = async function (...args) {
                    return me.thread.invoke(propertyKey, args)
                        .then((result) => {
                        result = me.transformResult(propertyKey, args, result);
                        return result;
                    });
                };
                call.transfer = function (...transfer) {
                    return {
                        invoke: async function (...args) {
                            return me.thread.invoke.transfer(...transfer).invoke(propertyKey, args)
                                .then((result) => {
                                result = me.transformResult(propertyKey, args, result);
                                return result;
                            });
                        }
                    };
                };
                target[propertyKey] = call;
                return target[propertyKey];
            }
        });
    }
}


/***/ }),

/***/ "./src/avplayer/worker/VideoPipeline.ts":
/*!**********************************************!*\
  !*** ./src/avplayer/worker/VideoPipeline.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoPipeline)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _struct_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./..\struct.ts */ "./src/avplayer/struct.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avpipeline_VideoDecodePipeline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avpipeline/VideoDecodePipeline */ "./src/avpipeline/VideoDecodePipeline.ts");
/* harmony import */ var avpipeline_VideoRenderPipeline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avpipeline/VideoRenderPipeline */ "./src/avpipeline/VideoRenderPipeline.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_timer_Timer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/timer/Timer */ "./src/common/timer/Timer.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
var cheap__fileName__12 = "src\\avplayer\\worker\\VideoPipeline.ts";




/*
 * libmedia VideoPipeline
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */










class VideoPipeline {
    decoder;
    render;
    globalDataMap;
    controlPort;
    timer;
    constructor() {
        this.decoder = new avpipeline_VideoDecodePipeline__WEBPACK_IMPORTED_MODULE_6__["default"]();
        this.render = new avpipeline_VideoRenderPipeline__WEBPACK_IMPORTED_MODULE_7__["default"]();
        this.globalDataMap = new Map();
    }
    createGlobalData(taskId) {
        const data = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_2__["default"])(_struct_ts__WEBPACK_IMPORTED_MODULE_1__.AVPlayerGlobalData);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_10__.init(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_10__.init(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28);
        this.globalDataMap.set(taskId, data);
        return data;
    }
    releaseGlobalData(data) {
        data.avframeList.clear((avframe) => {
            (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_8__.unrefAVFrame)(avframe);
        }, 20);
        data.avpacketList.clear((avpacket) => {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.unrefAVPacket)(avpacket);
        }, 20);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_10__.destroy(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24);
        cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_10__.destroy(data[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28);
        (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_3__["default"])(data);
    }
    async init(controlPort) {
        this.controlPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_11__["default"](controlPort);
        let secondCounter = 0;
        this.timer = new common_timer_Timer__WEBPACK_IMPORTED_MODULE_12__["default"](() => {
            secondCounter++;
            const result = [];
            this.globalDataMap.forEach((globalData, key) => {
                const stats = globalData.stats;
                result.push({
                    taskId: key,
                    stats: {
                        videoFrameDecodeCount: stats.videoFrameDecodeCount,
                        videoFrameDecodeIntervalMax: stats.videoFrameDecodeIntervalMax,
                        videoDecodeErrorPacketCount: stats.videoDecodeErrorPacketCount,
                        videoCurrentTime: stats.videoCurrentTime,
                        videoFrameRenderCount: stats.videoFrameRenderCount,
                        videoFrameRenderIntervalMax: stats.videoFrameRenderIntervalMax,
                        videoFrameDropCount: stats.videoFrameDropCount,
                        width: stats.width,
                        height: stats.height
                    }
                });
                if (secondCounter === 2) {
                    stats.videoFrameDecodeIntervalMax = 0;
                    stats.videoFrameRenderIntervalMax = 0;
                }
            });
            this.controlPort.notify('stats', {
                data: result
            });
            if (secondCounter === 2) {
                secondCounter = 0;
            }
        }, 0, 500);
        this.controlPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_11__.NOTIFY, (request) => {
            switch (request.method) {
                case 'stats': {
                    const data = request.params.data;
                    for (let i = 0; i < data.length; i++) {
                        const stats = this.globalDataMap.get(data[i].taskId).stats;
                        if (stats) {
                            common_util_object__WEBPACK_IMPORTED_MODULE_13__.each(data[i].stats, (value, key) => {
                                stats[key] = value;
                            });
                            stats.jitterBuffer.min = data[i].jitterBuffer.min;
                            stats.jitterBuffer.max = data[i].jitterBuffer.max;
                        }
                    }
                }
            }
        });
        this.timer.start();
    }
    async invoke(type, method, args) {
        const me = this;
        function transformResult(method, args, result) {
            if (method === 'unregisterTask') {
                const globalData = me.globalDataMap.get(args[0]);
                if (globalData) {
                    me.releaseGlobalData(globalData);
                    me.globalDataMap.delete(args[0]);
                }
            }
            else if (method === 'clear') {
                me.globalDataMap.forEach((globalData) => {
                    me.releaseGlobalData(globalData);
                });
                me.globalDataMap.clear();
            }
            else if (method === 'syncSeekTime') {
                const globalData = me.globalDataMap.get(args[0]);
                if (globalData) {
                    return globalData.stats.videoCurrentTime;
                }
            }
            return result;
        }
        if (type === 'decoder') {
            if (method === 'registerTask') {
                const globalData = this.globalDataMap.get(args[0].taskId) || this.createGlobalData(args[0].taskId);
                args[0].stats = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32;
                args[0].avpacketList = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress];
                args[0].avpacketListMutex = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 24;
                args[0].avframeList = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 12;
                args[0].avframeListMutex = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28;
            }
            if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.func(this.decoder[method])) {
                return this.decoder[method](...args)
                    .then((result) => {
                    result = transformResult(method, args, result);
                    return result;
                });
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`method ${method} not found`, cheap__fileName__12, 179);
            }
        }
        else {
            if (method === 'registerTask') {
                const globalData = this.globalDataMap.get(args[0].taskId) || this.createGlobalData(args[0].taskId);
                args[0].stats = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 32;
                args[0].avframeList = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 12;
                args[0].avframeListMutex = globalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + 28;
            }
            if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.func(this.render[method])) {
                return this.render[method](...args)
                    .then((result) => {
                    result = transformResult(method, args, result);
                    return result;
                });
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`method ${method} not found`, cheap__fileName__12, 197);
            }
        }
    }
    async setLogLevel(level) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.setLevel(level);
    }
}


/***/ }),

/***/ "./src/avplayer/worker/VideoPipelineProxy.ts":
/*!***************************************************!*\
  !*** ./src/avplayer/worker/VideoPipelineProxy.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoPipelineProxy)
/* harmony export */ });
/* harmony import */ var _avpipeline_struct_stats_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./..\..\avpipeline\struct\stats.ts */ "./src/avpipeline/struct/stats.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_thread_thread__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/thread/thread */ "./src/cheap/thread/thread.ts");
/* harmony import */ var _VideoPipeline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VideoPipeline */ "./src/avplayer/worker/VideoPipeline.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");


/*
 * libmedia VideoPipelineProxy
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class VideoPipelineProxy {
    thread;
    controlMessageChannel;
    controlPort;
    statsMap;
    constructor() {
        this.statsMap = new Map();
    }
    async run() {
        this.thread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_2__.createThreadFromClass)(_VideoPipeline__WEBPACK_IMPORTED_MODULE_3__["default"], {
            name: 'VideoPipeline',
            dispatchToWorker: true
        }, /*require.resolve*/(/*! ./VideoPipeline.ts */ "./src/avplayer/worker/VideoPipeline.ts")).run();
        this.controlMessageChannel = new MessageChannel();
        this.controlPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__["default"](this.controlMessageChannel.port1);
        this.controlPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__.NOTIFY, (request) => {
            switch (request.method) {
                case 'stats': {
                    const data = request.params.data;
                    const syncStats = [];
                    for (let i = 0; i < data.length; i++) {
                        const stats = this.statsMap.get(data[i].taskId);
                        if (stats) {
                            common_util_object__WEBPACK_IMPORTED_MODULE_5__.each(data[i].stats, (value, key) => {
                                stats[key] = value;
                            });
                            syncStats.push({
                                taskId: data[i].taskId,
                                stats: {
                                    videoEncodeFramerate: stats.videoEncodeFramerate,
                                    videoPacketQueueLength: stats.videoPacketQueueLength
                                },
                                jitterBuffer: {
                                    min: stats.jitterBuffer.min,
                                    max: stats.jitterBuffer.max
                                }
                            });
                        }
                    }
                    this.controlPort.notify('stats', {
                        data: {
                            stats: syncStats
                        }
                    });
                }
            }
        });
        await this.thread.init.transfer(this.controlMessageChannel.port2).invoke(this.controlMessageChannel.port2);
    }
    setLogLevel(level) {
        this.thread.setLogLevel(level);
    }
    async destroy() {
        await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_2__.joinThread)(this.thread);
        this.thread = null;
    }
    transformResult(method, args, result) {
        if (method === 'unregisterTask') {
            this.statsMap.delete(args[0]);
        }
        else if (method === 'clear') {
            this.statsMap.clear();
        }
        else if (method === 'registerTask') {
            this.statsMap.set(args[0].taskId, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__["default"])(args[0].stats, _avpipeline_struct_stats_ts__WEBPACK_IMPORTED_MODULE_0__["default"]));
        }
        else if (method === 'syncSeekTime') {
            const stats = this.statsMap.get(args[0]);
            if (stats) {
                stats.videoCurrentTime = result;
                return;
            }
        }
        return result;
    }
    get VideoDecodePipeline() {
        const me = this;
        return new Proxy({}, {
            get(target, propertyKey, receiver) {
                if (target[propertyKey]) {
                    return target[propertyKey];
                }
                const call = async function (...args) {
                    return me.thread.invoke('decoder', propertyKey, args)
                        .then((result) => {
                        result = me.transformResult(propertyKey, args, result);
                        return result;
                    });
                };
                call.transfer = function (...transfer) {
                    return {
                        invoke: async function (...args) {
                            return me.thread.invoke.transfer(...transfer).invoke('decoder', propertyKey, args)
                                .then((result) => {
                                result = me.transformResult(propertyKey, args, result);
                                return result;
                            });
                        }
                    };
                };
                target[propertyKey] = call;
                return target[propertyKey];
            }
        });
    }
    get VideoRenderPipeline() {
        const me = this;
        return new Proxy({}, {
            get(target, propertyKey, receiver) {
                if (target[propertyKey]) {
                    return target[propertyKey];
                }
                const call = async function (...args) {
                    return me.thread.invoke('render', propertyKey, args)
                        .then((result) => {
                        result = me.transformResult(propertyKey, args, result);
                        return result;
                    });
                };
                call.transfer = function (...transfer) {
                    return {
                        invoke: async function (...args) {
                            return me.thread.invoke.transfer(...transfer).invoke('render', propertyKey, args)
                                .then((result) => {
                                result = me.transformResult(propertyKey, args, result);
                                return result;
                            });
                        }
                    };
                };
                target[propertyKey] = call;
                return target[propertyKey];
            }
        });
    }
}


/***/ }),

/***/ "./src/avrender/image/Canvas2dRender.ts":
/*!**********************************************!*\
  !*** ./src/avrender/image/Canvas2dRender.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CanvasImageRender)
/* harmony export */ });
/* harmony import */ var _ImageRender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageRender */ "./src/avrender/image/ImageRender.ts");
/*
 * libmedia Canvas2dRender
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class CanvasImageRender extends _ImageRender__WEBPACK_IMPORTED_MODULE_0__["default"] {
    context;
    paddingLeft;
    paddingTop;
    flipX;
    flipY;
    constructor(canvas, options) {
        super(canvas, options);
        this.paddingLeft = 0;
        this.paddingTop = 0;
        this.flipX = 1;
        this.flipY = 1;
    }
    async init() {
        this.context = this.canvas.getContext('2d');
    }
    clear() {
        const w = this.canvas.width >> 1;
        const h = this.canvas.height >> 1;
        if (this.rotate) {
            this.context.translate(w, h);
            this.context.rotate(-this.rotate * Math.PI / 180);
            this.context.translate(-w, -h);
        }
        this.context.clearRect(0, 0, this.canvasWidth * this.options.devicePixelRatio, this.canvasHeight * this.options.devicePixelRatio);
        if (this.rotate) {
            this.context.translate(w, h);
            this.context.rotate(this.rotate * Math.PI / 180);
            this.context.translate(-w, -h);
        }
    }
    checkFrame(frame) {
        if (frame.codedWidth !== this.textureWidth
            || frame.codedHeight !== this.videoHeight
            || frame.codedWidth !== this.videoWidth) {
            this.videoWidth = frame.codedWidth;
            this.videoHeight = frame.codedHeight;
            this.textureWidth = frame.codedWidth;
            this.layout();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        this.context.drawImage(frame, this.paddingLeft, this.paddingTop, this.canvasWidth * this.options.devicePixelRatio - 2 * this.paddingLeft, this.canvasHeight * this.options.devicePixelRatio - 2 * this.paddingTop);
    }
    layout() {
        let videoWidth = this.videoWidth;
        let videoHeight = this.videoHeight;
        let canvasWidth = this.canvasWidth;
        let canvasHeight = this.canvasHeight;
        let basePaddingLeft = 0;
        let basePaddingTop = 0;
        if (this.rotate === 90 || this.rotate === 270) {
            basePaddingTop = Math.floor((canvasHeight - canvasWidth) / 2);
            basePaddingLeft = Math.floor((canvasWidth - canvasHeight) / 2);
            canvasWidth = this.canvasHeight;
            canvasHeight = this.canvasWidth;
        }
        const scaleX = videoWidth / canvasWidth;
        const scaleY = videoHeight / canvasHeight;
        let isPaddingTop;
        if (scaleX > 1) {
            if (scaleX < scaleY) {
                isPaddingTop = false;
            }
            else {
                isPaddingTop = true;
            }
        }
        else {
            if (scaleX > scaleY) {
                isPaddingTop = true;
            }
            else {
                isPaddingTop = false;
            }
        }
        if (this.renderMode === 1 /* RenderMode.FILL */) {
            isPaddingTop = !isPaddingTop;
        }
        if (isPaddingTop) {
            const paddingTop = (canvasHeight - videoHeight * canvasWidth / videoWidth) / canvasHeight;
            this.paddingTop = (Math.floor(paddingTop / 2 * canvasHeight) + basePaddingTop) * this.options.devicePixelRatio;
            this.paddingLeft = basePaddingLeft * this.options.devicePixelRatio;
        }
        else {
            const paddingLeft = (canvasWidth - videoWidth * canvasHeight / videoHeight) / canvasWidth;
            this.paddingLeft = (Math.floor(paddingLeft / 2 * canvasWidth) + basePaddingLeft) * this.options.devicePixelRatio;
            this.paddingTop = basePaddingTop * this.options.devicePixelRatio;
        }
        if (this.context) {
            let flipX = 1;
            let flipY = 1;
            if (this.flipHorizontal) {
                flipX = -1;
            }
            if (this.flipVertical) {
                flipY = -1;
            }
            const w = this.canvas.width >> 1;
            const h = this.canvas.height >> 1;
            this.context.translate(w, h);
            if (flipX !== this.flipX) {
                this.context.scale(-1, 1);
            }
            if (flipY !== this.flipY) {
                this.context.scale(1, -1);
            }
            this.context.translate(-w, -h);
            this.flipX = flipX;
            this.flipY = flipY;
        }
    }
    setRotate(angle) {
        angle = angle % 360;
        if (angle === this.rotate) {
            return;
        }
        const w = this.canvas.width >> 1;
        const h = this.canvas.height >> 1;
        if (this.rotate) {
            this.context.translate(w, h);
            this.context.rotate(-this.rotate * Math.PI / 180);
            this.context.translate(-w, -h);
        }
        this.clear();
        this.rotate = angle;
        if (this.context) {
            this.context.translate(w, h);
            this.context.rotate(this.rotate * Math.PI / 180);
            this.context.translate(-w, -h);
        }
        this.layout();
    }
    destroy() {
        this.context = null;
        super.destroy();
    }
    static isSupport(frame) {
        // VideoFrame
        return frame instanceof VideoFrame || frame instanceof ImageBitmap;
    }
}


/***/ }),

/***/ "./src/avrender/image/ImageRender.ts":
/*!*******************************************!*\
  !*** ./src/avrender/image/ImageRender.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageRender)
/* harmony export */ });
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/*
 * libmedia ImageRender
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class ImageRender {
    canvas;
    options;
    textureWidth;
    videoWidth;
    videoHeight;
    canvasWidth;
    canvasHeight;
    rotate;
    renderMode;
    format;
    lost;
    destroyed;
    srcColorSpace;
    dstColorSpace;
    flipHorizontal;
    flipVertical;
    constructor(canvas, options) {
        this.canvas = canvas;
        this.options = options;
        this.canvasWidth = canvas.width;
        this.canvasHeight = canvas.height;
        this.videoWidth = 0;
        this.videoHeight = 0;
        this.textureWidth = 0;
        this.rotate = 0;
        this.renderMode = options.renderMode;
        this.flipHorizontal = false;
        this.flipVertical = false;
        this.lost = false;
        this.destroyed = false;
        if (options.dstColorSpace) {
            this.dstColorSpace = options.dstColorSpace;
        }
        else {
            this.dstColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_0__["default"](1 /* AVColorSpace.AVCOL_SPC_BT709 */, 1 /* AVColorPrimaries.AVCOL_PRI_BT709 */, 1 /* AVColorTransferCharacteristic.AVCOL_TRC_BT709 */, 1 /* AVColorRange.AVCOL_RANGE_MPEG */);
        }
    }
    getRotateMatrix(angle) {
        angle = Math.PI * angle / 180;
        const s = Math.sin(angle);
        const c = Math.cos(angle);
        return [
            c, -s, 0, 0,
            s, c, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ];
    }
    setRenderMode(mode) {
        if (this.renderMode !== mode) {
            this.renderMode = mode;
            this.layout();
            this.clear();
        }
    }
    enableHorizontalFlip(enable) {
        if (this.flipHorizontal !== enable) {
            this.flipHorizontal = enable;
            this.layout();
            this.clear();
        }
    }
    enableVerticalFlip(enable) {
        if (this.flipVertical !== enable) {
            this.flipVertical = enable;
            this.layout();
            this.clear();
        }
    }
    viewport(width, height) {
        if (this.canvasWidth !== width || this.canvasHeight !== height) {
            const devicePixelRatio = this.options.devicePixelRatio;
            this.canvasWidth = width;
            this.canvasHeight = height;
            this.canvas.width = width * devicePixelRatio;
            this.canvas.height = height * devicePixelRatio;
            if (this.videoWidth && this.videoHeight) {
                this.layout();
            }
        }
    }
    getVideoWidth() {
        return this.videoWidth;
    }
    getVideoHeight() {
        return this.videoHeight;
    }
    destroy() {
        this.canvas = null;
        this.destroyed = true;
    }
    setDstColorSpace(space) {
        this.dstColorSpace = space;
    }
    static isSupport(frame) {
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLRGB8Render.ts":
/*!***********************************************!*\
  !*** ./src/avrender/image/WebGLRGB8Render.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLRGB8Render)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var _WebGLRGBRender__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WebGLRGBRender */ "./src/avrender/image/WebGLRGBRender.ts");
/* harmony import */ var _webgl_program_RGB8Program__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./webgl/program/RGB8Program */ "./src/avrender/image/webgl/program/RGB8Program.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");








class WebGLRGB8Render extends _WebGLRGBRender__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(canvas, options) {
        super(canvas, options);
    }
    generateFragmentSource(format, descriptor) {
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_3__["default"])(this.srcColorSpace, this.dstColorSpace, {
            bitDepth: 8,
            type: 0 /* GLType.kWebGL */,
            outputRGB: true
        });
        const map = ['r', 'g', 'b', 'a'];
        let r = `texture2D(rgb_Sampler, v_color.xy).${map[descriptor.comp[0].offset]}`;
        let g = `texture2D(rgb_Sampler, v_color.xy).${map[descriptor.comp[1].offset]}`;
        let b = `texture2D(rgb_Sampler, v_color.xy).${map[descriptor.comp[2].offset]}`;
        let alpha = '1.0';
        if ((descriptor.flags & 128 /* PixelFormatFlags.ALPHA */) && descriptor.nbComponents === 4) {
            alpha = `texture2D(rgb_Sampler, v_color.xy).${map[descriptor.comp[3].offset]}`;
        }
        this.fragmentSource = `
      precision highp float;
      varying vec4 v_color;
      uniform sampler2D rgb_Sampler;
      void main () {
        float r = ${r};
        float g = ${g};
        float b = ${b};
        float alpha = ${alpha};
        vec4 color = vec4(r, g, b, alpha);
        ${steps.reduce((pre, current) => pre + current, '')}
        gl_FragColor = color;
      }
    `;
    }
    checkFrame(frame) {
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68) !== this.videoWidth) {
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_4__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 220), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 212), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 216), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 208));
            this.generateFragmentSource(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80), descriptor);
            this.program = new _webgl_program_RGB8Program__WEBPACK_IMPORTED_MODULE_6__["default"](this.fragmentSource);
            this.useProgram();
            if (descriptor.nbComponents === 4) {
                this.rgbTexture.setFormat(this.gl.RGBA);
                this.rgbTexture.setInternalformat(this.gl.RGBA);
            }
            this.rgbTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72));
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32);
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80);
            this.layout();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        this.rgbTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame), this.rgbTexture.width * this.rgbTexture.height));
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
    static isSupport(frame) {
        if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_7__["default"])(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                return (info.flags & 32 /* PixelFormatFlags.RGB */) && ((info.comp[0].depth + 7) >>> 3) === 1;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLRGBRender.ts":
/*!**********************************************!*\
  !*** ./src/avrender/image/WebGLRGBRender.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLRGBRender)
/* harmony export */ });
/* harmony import */ var _WebGLRender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLRender */ "./src/avrender/image/WebGLRender.ts");
/* harmony import */ var _webgl_texture_RGBTexture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl/texture/RGBTexture */ "./src/avrender/image/webgl/texture/RGBTexture.ts");
/*
 * libmedia WebGLRGBRender
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class WebGLRGBRender extends _WebGLRender__WEBPACK_IMPORTED_MODULE_0__["default"] {
    rgbTexture;
    constructor(canvas, options) {
        super(canvas, options);
    }
    useProgram() {
        super.useProgram();
        this.rgbTexture = new _webgl_texture_RGBTexture__WEBPACK_IMPORTED_MODULE_1__["default"](this.gl);
        this.rgbTexture.bind(0);
        this.rgbTexture.init();
        this.program.bindRGBTexture(0);
    }
    destroy() {
        if (this.rgbTexture) {
            this.rgbTexture.destroy();
            this.rgbTexture = null;
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLRender.ts":
/*!*******************************************!*\
  !*** ./src/avrender/image/WebGLRender.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLRender)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _ImageRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageRender */ "./src/avrender/image/ImageRender.ts");
/* harmony import */ var _function_flipVertex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./function/flipVertex */ "./src/avrender/image/function/flipVertex.ts");
var cheap__fileName__0 = "src\\avrender\\image\\WebGLRender.ts";
/*
 * libmedia WebGLRender
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



class WebGLRender extends _ImageRender__WEBPACK_IMPORTED_MODULE_1__["default"] {
    gl;
    // 
    VAO;
    program;
    vertex;
    webglContextLostTimer;
    onWebglContextLost;
    onWebglContextRestored;
    fragmentSource;
    vertexSource;
    constructor(canvas, options) {
        super(canvas, options);
    }
    async init() {
        this.gl = this.canvas.getContext('webgl2', {
            alpha: false,
            antialias: false,
            preserveDrawingBuffer: this.options.preserveDrawingBuffer
        });
        if (!this.gl) {
            this.gl = this.canvas.getContext('webgl', {
                alpha: false,
                antialias: false,
                preserveDrawingBuffer: this.options.preserveDrawingBuffer
            });
        }
        if (!this.gl) {
            this.gl = this.canvas.getContext('experimental-webgl', {
                alpha: false,
                antialias: false,
                preserveDrawingBuffer: this.options.preserveDrawingBuffer
            });
        }
        if (!this.gl) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('can not support webgl, got WebGLRenderingContext failed', cheap__fileName__0, 96);
        }
        this.VAO = this.gl.createBuffer();
        if (!this.VAO) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('create vao buffer failed', cheap__fileName__0, 101);
        }
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VAO);
        this.gl.enable(this.gl.BLEND);
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
        this.gl.clearDepth(1.0);
        this.viewport(this.canvasWidth || this.canvas.width, this.canvasHeight || this.canvas.height);
        this.onWebglContextLost = (event) => {
            if (this.destroyed) {
                return;
            }
            this.webglContextLostTimer = setTimeout(() => {
                this.lost = true;
                this.webglContextLostTimer = null;
                common_util_logger__WEBPACK_IMPORTED_MODULE_0__.error('webgl context lost', cheap__fileName__0, 118);
                if (this.options.onRenderContextLost) {
                    this.options.onRenderContextLost();
                }
            }, 3000);
        };
        this.onWebglContextRestored = (event) => {
            if (this.webglContextLostTimer) {
                clearTimeout(this.webglContextLostTimer);
                this.webglContextLostTimer = null;
            }
        };
        this.canvas.addEventListener('webglcontextlost', this.onWebglContextLost);
        this.canvas.addEventListener('webglcontextrestored', this.onWebglContextRestored);
    }
    viewport(width, height) {
        this.gl.viewport(0, 0, width * this.options.devicePixelRatio, height * this.options.devicePixelRatio);
        super.viewport(width, height);
    }
    useProgram() {
        this.program.link(this.gl);
        this.program.bind();
        this.program.setRotateMatrix(this.getRotateMatrix(this.rotate));
    }
    clear() {
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    }
    layout() {
        let videoWidth = this.videoWidth;
        let videoHeight = this.videoHeight;
        let canvasWidth = this.canvasWidth;
        let canvasHeight = this.canvasHeight;
        if (this.rotate === 90 || this.rotate === 270) {
            /*
             * videoWidth = this.videoHeight
             * videoHeight = this.videoWidth
             */
            canvasWidth = this.canvasHeight;
            canvasHeight = this.canvasWidth;
        }
        const scaleX = videoWidth / canvasWidth;
        const scaleY = videoHeight / canvasHeight;
        let isPaddingTop;
        if (scaleX > 1) {
            if (scaleX < scaleY) {
                isPaddingTop = false;
            }
            else {
                isPaddingTop = true;
            }
        }
        else {
            if (scaleX > scaleY) {
                isPaddingTop = true;
            }
            else {
                isPaddingTop = false;
            }
        }
        if (this.renderMode === 1 /* RenderMode.FILL */) {
            isPaddingTop = !isPaddingTop;
        }
        let texturePadding = 0;
        if (this.textureWidth !== this.videoWidth) {
            texturePadding = (this.textureWidth - this.videoWidth) / this.textureWidth;
        }
        if (isPaddingTop) {
            const paddingTop = (canvasHeight - videoHeight * canvasWidth / videoWidth) / canvasHeight;
            this.vertex = [
                -1, 1 - paddingTop, 0, 0, 0, 0, 0,
                -1, -1 + paddingTop, 0, 0, 1, 0, 0,
                1, 1 - paddingTop, 0, 1 - texturePadding, 0, 0, 0,
                1, -1 + paddingTop, 0, 1 - texturePadding, 1, 0, 0
            ];
        }
        else {
            const paddingLeft = (canvasWidth - videoWidth * canvasHeight / videoHeight) / canvasWidth;
            this.vertex = [
                -1 + paddingLeft, 1, 0, 0, 0, 0, 0,
                -1 + paddingLeft, -1, 0, 0, 1, 0, 0,
                1 - paddingLeft, 1, 0, 1 - texturePadding, 0, 0, 0,
                1 - paddingLeft, -1, 0, 1 - texturePadding, 1, 0, 0
            ];
        }
        (0,_function_flipVertex__WEBPACK_IMPORTED_MODULE_2__["default"])(this.vertex, this.flipHorizontal, this.flipVertical);
        if (this.gl) {
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.vertex), this.gl.STATIC_DRAW);
        }
    }
    setRotate(angle) {
        angle = angle % 360;
        if (angle === this.rotate) {
            return;
        }
        this.rotate = angle;
        if (this.gl) {
            this.program.setRotateMatrix(this.getRotateMatrix(this.rotate));
        }
        this.layout();
        this.clear();
    }
    destroy() {
        if (this.program) {
            this.program.stop();
        }
        this.gl = null;
        this.VAO = null;
        this.vertex = null;
        if (this.onWebglContextLost) {
            this.canvas.removeEventListener('webglcontextlost', this.onWebglContextLost);
            this.onWebglContextLost = null;
        }
        if (this.onWebglContextRestored) {
            this.canvas.removeEventListener('webglcontextrestored', this.onWebglContextRestored);
            this.onWebglContextRestored = null;
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLYUV16Render.ts":
/*!************************************************!*\
  !*** ./src/avrender/image/WebGLYUV16Render.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLYUV16Render)
/* harmony export */ });
/* harmony import */ var _struct_HdrMetadata_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./struct\HdrMetadata.ts */ "./src/avrender/image/struct/HdrMetadata.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var _WebGLYUVRender__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WebGLYUVRender */ "./src/avrender/image/WebGLYUVRender.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");
/* harmony import */ var _colorTransform_options__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./colorTransform/options */ "./src/avrender/image/colorTransform/options.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var _webgl_program_YUV16Program__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./webgl/program/YUV16Program */ "./src/avrender/image/webgl/program/YUV16Program.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");













class WebGLYUV16Render extends _WebGLYUVRender__WEBPACK_IMPORTED_MODULE_6__["default"] {
    hdrMetadata;
    ext;
    constructor(canvas, options) {
        super(canvas, options);
        this.hdrMetadata = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_1__["default"])(_struct_HdrMetadata_ts__WEBPACK_IMPORTED_MODULE_0__["default"]);
        this.hdrMetadata.multiplier = 1.0;
    }
    async init() {
        await super.init();
        this.ext = this.gl.getExtension('EXT_texture_norm16');
        if (!this.ext) {
            throw Error('not support');
        }
    }
    generateFragmentSource(format, descriptor, colorTransformOptions) {
        colorTransformOptions.outputRGB = true;
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_7__["default"])(this.srcColorSpace, this.dstColorSpace, colorTransformOptions);
        let y = 'texture2D(y_Sampler, v_color.xy).x';
        let u = 'texture2D(u_Sampler, v_color.xy).x';
        let v = 'texture2D(v_Sampler, v_color.xy).x';
        let alpha = '1.0';
        if (format === 23 /* AVPixelFormat.AV_PIX_FMT_NV12 */
            || format === 189 /* AVPixelFormat.AV_PIX_FMT_NV24 */) {
            u = 'texture2D(u_Sampler, v_color.xy).x';
            v = 'texture2D(u_Sampler, v_color.xy).y';
        }
        else if (format === 24 /* AVPixelFormat.AV_PIX_FMT_NV21 */
            || format === 190 /* AVPixelFormat.AV_PIX_FMT_NV42 */) {
            u = 'texture2D(u_Sampler, v_color.xy).y';
            v = 'texture2D(u_Sampler, v_color.xy).x';
        }
        if ((descriptor.flags & 128 /* PixelFormatFlags.ALPHA */) && descriptor.nbComponents === 4) {
            alpha = 'texture2D(a_Sampler, v_color.xy).x';
        }
        this.fragmentSource = `
      precision highp float;

      varying vec4 v_color;
      uniform sampler2D y_Sampler;
      uniform sampler2D u_Sampler;
      uniform sampler2D v_Sampler;
      
      uniform float v_max;

      uniform float offset;
      uniform float multiplier;
      uniform float pq_tonemap_a;
      uniform float pq_tonemap_b;
      uniform float hlg_ootf_gamma_minus_one;
      uniform float hlg_dst_max_luminance_relative;
      uniform float nits_to_sdr_relative_factor;
      uniform float sdr_relative_to_nits_factor;

      ${(descriptor.flags & 1 /* PixelFormatFlags.BIG_ENDIAN */) ? `
        float swap(float x) {
          int value = int(x * 65535.0);
          int low = value & 0xff;
          int high = (value >> 8) & 0xff;
          value = (low << 8) | high;
          return float(value) / v_max;
        }
      ` : ''}
      
      void main () {
      
        float y = ${y};
        float u = ${u};
        float v = ${v};
        float alpha = ${alpha};
        
        ${(descriptor.flags & 1 /* PixelFormatFlags.BIG_ENDIAN */) ? `
          y = swap(y);
          u = swap(u);
          v = swap(v);
        ` : `
          y = y * 65535.0 / v_max;
          u = u * 65535.0 / v_max;
          v = v * 65535.0 / v_max;
        `}
        
        vec4 color = vec4(y, u, v, alpha);

        if (color.a > 0.0) {
          color.r /= color.a;
          color.g /= color.a;
          color.b /= color.a;
        }
        color.r -= offset;
        color.g -= offset;
        color.b -= offset;

        color.r *= multiplier;
        color.g *= multiplier;
        color.b *= multiplier;
        
        ${steps.reduce((pre, current) => pre + current, '')}

        color.r *= color.a;
        color.g *= color.a;
        color.b *= color.a;

        gl_FragColor = color;
      }
    `;
    }
    checkFrame(frame) {
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        const bytesPerPixel = (descriptor.comp[0].depth + 7) >>> 3;
        if ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32) / bytesPerPixel) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 68) !== this.videoWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80) !== this.format) {
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_9__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 220), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 212), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 216), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 208));
            const colorTransformOptions = {
                type: 0 /* GLType.kWebGL */,
                bitDepth: descriptor.comp[0].depth,
                toneMapPQAndHlgToDst: true,
                metadata: this.hdrMetadata,
                dstSdrMaxLuminanceNits: _colorTransform_options__WEBPACK_IMPORTED_MODULE_8__.DefaultSDRWhiteLevel,
                dstMaxLuminanceRelative: 1.0
            };
            const sideData = (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_10__.getAVFrameSideData)(frame, 14 /* AVFrameSideDataType.AV_FRAME_DATA_CONTENT_LIGHT_LEVEL */);
            if (sideData) {
                const lightMetadata = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](sideData + 4);
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[8](lightMetadata) > 0) {
                    colorTransformOptions.maxContentLightLevel = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[8](lightMetadata);
                }
            }
            this.generateFragmentSource(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80), descriptor, colorTransformOptions);
            this.program = new _webgl_program_YUV16Program__WEBPACK_IMPORTED_MODULE_11__["default"](this.fragmentSource);
            this.useProgram();
            this.program.setMetaData(this.hdrMetadata);
            this.yTexture.setFormat(this.gl.RED);
            this.yTexture.setInternalformat(this.ext.R16_EXT);
            this.yTexture.setDataType(this.gl.UNSIGNED_SHORT);
            this.uTexture.setFormat(this.gl.RED);
            this.uTexture.setInternalformat(this.ext.R16_EXT);
            this.uTexture.setDataType(this.gl.UNSIGNED_SHORT);
            this.vTexture.setFormat(this.gl.RED);
            this.vTexture.setInternalformat(this.ext.R16_EXT);
            this.vTexture.setDataType(this.gl.UNSIGNED_SHORT);
            this.aTexture.setFormat(this.gl.RED);
            this.aTexture.setInternalformat(this.ext.R16_EXT);
            this.aTexture.setDataType(this.gl.UNSIGNED_SHORT);
            this.yTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72));
            this.uTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32 + 4) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80)].log2ChromaH);
            if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
                this.vTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32 + 8) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80)].log2ChromaH);
            }
            if (descriptor.nbComponents === 4) {
                this.aTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32 + 12) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72));
            }
            this.program.setMax((1 << descriptor.comp[0].depth) - 1);
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 32) >>> 1;
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80);
            this.layout();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        this.yTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.mapUint16Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](frame), this.yTexture.width * this.yTexture.height));
        this.uTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.mapUint16Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](frame + 4), this.uTexture.width * this.uTexture.height));
        if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
            this.vTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.mapUint16Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](frame + 8), this.vTexture.width * this.vTexture.height));
        }
        if (descriptor.nbComponents === 4) {
            this.aTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.mapUint16Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](frame + 12), this.aTexture.width * this.aTexture.height));
        }
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
    destroy() {
        if (this.hdrMetadata) {
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_3__["default"])(this.hdrMetadata);
            this.hdrMetadata = null;
        }
        super.destroy();
    }
    static isSupport(frame) {
        if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_12__["default"])(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_5__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                if (info.flags & 32 /* PixelFormatFlags.RGB */) {
                    return false;
                }
                return (info.flags & 16 /* PixelFormatFlags.PLANER */) && ((info.comp[0].depth + 7) >>> 3) === 2;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLYUV8Render.ts":
/*!***********************************************!*\
  !*** ./src/avrender/image/WebGLYUV8Render.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLYUV8Render)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var _WebGLYUVRender__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WebGLYUVRender */ "./src/avrender/image/WebGLYUVRender.ts");
/* harmony import */ var _webgl_program_YUV8Program__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./webgl/program/YUV8Program */ "./src/avrender/image/webgl/program/YUV8Program.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");








class WebGLYUV8Render extends _WebGLYUVRender__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(canvas, options) {
        super(canvas, options);
    }
    generateFragmentSource(format, descriptor) {
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_5__["default"])(this.srcColorSpace, this.dstColorSpace, {
            bitDepth: 8,
            type: 0 /* GLType.kWebGL */,
            outputRGB: true
        });
        let y = 'texture2D(y_Sampler, v_color.xy).x';
        let u = 'texture2D(u_Sampler, v_color.xy).x';
        let v = 'texture2D(v_Sampler, v_color.xy).x';
        let alpha = '1.0';
        if (format === 23 /* AVPixelFormat.AV_PIX_FMT_NV12 */
            || format === 189 /* AVPixelFormat.AV_PIX_FMT_NV24 */) {
            u = 'texture2D(u_Sampler, v_color.xy).x';
            v = 'texture2D(u_Sampler, v_color.xy).y';
        }
        else if (format === 24 /* AVPixelFormat.AV_PIX_FMT_NV21 */
            || format === 190 /* AVPixelFormat.AV_PIX_FMT_NV42 */) {
            u = 'texture2D(u_Sampler, v_color.xy).y';
            v = 'texture2D(u_Sampler, v_color.xy).x';
        }
        if ((descriptor.flags & 128 /* PixelFormatFlags.ALPHA */) && descriptor.nbComponents === 4) {
            alpha = 'texture2D(a_Sampler, v_color.xy).x';
        }
        this.fragmentSource = `
      precision highp float;
      varying vec4 v_color;
      uniform sampler2D y_Sampler;
      uniform sampler2D u_Sampler;
      uniform sampler2D v_Sampler;
      uniform sampler2D a_Sampler;
      void main () {
        float y = ${y};
        float u = ${u};
        float v = ${v};
        float alpha = ${alpha};
        vec4 color = vec4(y, u, v, alpha);
        ${steps.reduce((pre, current) => pre + current, '')}
        gl_FragColor = color;
      }
    `;
    }
    checkFrame(frame) {
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68) !== this.videoWidth) {
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_6__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 220), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 212), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 216), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 208));
            this.generateFragmentSource(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80), descriptor);
            this.program = new _webgl_program_YUV8Program__WEBPACK_IMPORTED_MODULE_4__["default"](this.fragmentSource);
            this.useProgram();
            this.yTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72));
            this.uTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32 + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)].log2ChromaH);
            if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
                this.vTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32 + 8), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)].log2ChromaH);
            }
            if (descriptor.nbComponents === 4) {
                this.aTexture.setSize(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32 + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72));
            }
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32);
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80);
            this.layout();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        this.yTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame), this.yTexture.width * this.yTexture.height));
        this.uTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame + 4), this.uTexture.width * this.uTexture.height));
        if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
            this.vTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame + 8), this.vTexture.width * this.vTexture.height));
        }
        if (descriptor.nbComponents === 4) {
            this.aTexture.fill((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame + 12), this.aTexture.width * this.aTexture.height));
        }
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
    static isSupport(frame) {
        if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_7__["default"])(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                if (info.flags & 32 /* PixelFormatFlags.RGB */) {
                    return false;
                }
                return (info.flags & 16 /* PixelFormatFlags.PLANER */) && ((info.comp[0].depth + 7) >>> 3) === 1;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGLYUVRender.ts":
/*!**********************************************!*\
  !*** ./src/avrender/image/WebGLYUVRender.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLYUVRender)
/* harmony export */ });
/* harmony import */ var _webgl_texture_YUVTexture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl/texture/YUVTexture */ "./src/avrender/image/webgl/texture/YUVTexture.ts");
/* harmony import */ var _WebGLRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGLRender */ "./src/avrender/image/WebGLRender.ts");
/*
 * libmedia WebGLYUVRender
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class WebGLYUVRender extends _WebGLRender__WEBPACK_IMPORTED_MODULE_1__["default"] {
    yTexture;
    uTexture;
    vTexture;
    aTexture;
    constructor(canvas, options) {
        super(canvas, options);
    }
    useProgram() {
        super.useProgram();
        this.yTexture = new _webgl_texture_YUVTexture__WEBPACK_IMPORTED_MODULE_0__["default"](this.gl);
        this.yTexture.bind(0);
        this.yTexture.init();
        this.program.bindYTexture(0);
        this.uTexture = new _webgl_texture_YUVTexture__WEBPACK_IMPORTED_MODULE_0__["default"](this.gl);
        this.uTexture.bind(1);
        this.uTexture.init();
        this.program.bindUTexture(1);
        this.vTexture = new _webgl_texture_YUVTexture__WEBPACK_IMPORTED_MODULE_0__["default"](this.gl);
        this.vTexture.bind(2);
        this.vTexture.init();
        this.program.bindVTexture(2);
        this.aTexture = new _webgl_texture_YUVTexture__WEBPACK_IMPORTED_MODULE_0__["default"](this.gl);
        this.aTexture.bind(3);
        this.aTexture.init();
        this.program.bindATexture(3);
    }
    destroy() {
        if (this.yTexture) {
            this.yTexture.destroy();
            this.yTexture = null;
        }
        if (this.uTexture) {
            this.uTexture.destroy();
            this.uTexture = null;
        }
        if (this.vTexture) {
            this.vTexture.destroy();
            this.vTexture = null;
        }
        if (this.aTexture) {
            this.aTexture.destroy();
            this.aTexture = null;
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPUExternalRender.ts":
/*!****************************************************!*\
  !*** ./src/avrender/image/WebGPUExternalRender.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPUExternalRender)
/* harmony export */ });
/* harmony import */ var _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgpu/wgsl/vertex.wgsl */ "./src/avrender/image/webgpu/wgsl/vertex.wgsl");
/* harmony import */ var _webgpu_wgsl_fragment_external_wgsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgpu/wgsl/fragment/external.wgsl */ "./src/avrender/image/webgpu/wgsl/fragment/external.wgsl");
/* harmony import */ var _WebGPURender__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebGPURender */ "./src/avrender/image/WebGPURender.ts");
/*
 * libmedia WebGPUExternalRender
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



class WebGPUExternalRender extends _WebGPURender__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(canvas, options) {
        super(canvas, options);
        this.vertexSource = _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_0__["default"];
        this.fragmentSource = _webgpu_wgsl_fragment_external_wgsl__WEBPACK_IMPORTED_MODULE_1__["default"];
    }
    checkFrame(frame) {
        if (frame.codedWidth !== this.textureWidth
            || frame.codedHeight !== this.videoHeight
            || frame.codedWidth !== this.videoWidth) {
            this.videoWidth = frame.codedWidth;
            this.videoHeight = frame.codedHeight;
            this.textureWidth = frame.codedWidth;
            this.layout();
            this.generatePipeline();
        }
    }
    generateBindGroup() {
        this.bindGroupLayout = this.device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX,
                    buffer: {
                        type: 'uniform'
                    }
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    externalTexture: {}
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: {
                        type: 'filtering'
                    }
                }
            ]
        });
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        const bindGroup = this.device.createBindGroup({
            layout: this.renderPipeline.getBindGroupLayout(0),
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this.rotateMatrixBuffer,
                        size: Float32Array.BYTES_PER_ELEMENT * 16
                    }
                },
                {
                    binding: 1,
                    resource: this.device.importExternalTexture({
                        source: frame
                    })
                },
                {
                    binding: 2,
                    resource: this.sampler
                }
            ]
        });
        const commandEncoder = this.device.createCommandEncoder();
        const renderPassDescriptor = {
            colorAttachments: [
                {
                    view: this.context.getCurrentTexture().createView(),
                    clearValue: {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 1
                    },
                    loadOp: 'clear',
                    storeOp: 'store'
                }
            ],
        };
        const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor);
        renderPass.setPipeline(this.renderPipeline);
        renderPass.setBindGroup(0, bindGroup);
        renderPass.setVertexBuffer(0, this.vbo);
        renderPass.draw(4, 4, 0, 0);
        renderPass.end();
        this.device.queue.submit([commandEncoder.finish()]);
    }
    destroy() {
        super.destroy();
    }
    static isSupport(frame) {
        // VideoFrame
        return frame instanceof VideoFrame;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPURGB8Render.ts":
/*!************************************************!*\
  !*** ./src/avrender/image/WebGPURGB8Render.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPURGB8Render)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");
/* harmony import */ var _WebGPURGBRender__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WebGPURGBRender */ "./src/avrender/image/WebGPURGBRender.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");







class WebGPURGB8Render extends _WebGPURGBRender__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(canvas, options) {
        super(canvas, options);
    }
    generateFragmentSource(format, descriptor) {
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_4__["default"])(this.srcColorSpace, this.dstColorSpace, {
            bitDepth: 8,
            type: 1 /* GLType.kWebGPU */,
            outputRGB: true
        });
        const map = ['r', 'g', 'b', 'a'];
        let r = `textureSample(rgbTexture, in_texcoord.xy).${map[descriptor.comp[0].offset]}`;
        let g = `textureSample(rgbTexture, in_texcoord.xy).${map[descriptor.comp[1].offset]}`;
        let b = `textureSample(rgbTexture, in_texcoord.xy).${map[descriptor.comp[2].offset]}`;
        let alpha = '1.0';
        if ((descriptor.flags & 128 /* PixelFormatFlags.ALPHA */) && descriptor.nbComponents === 4) {
            alpha = `textureSample(rgbTexture, in_texcoord.xy).${map[descriptor.comp[3].offset]}`;
        }
        this.fragmentSource = `
      @group(0) @binding(1) var s: sampler;
      @group(0) @binding(2) var rgbTexture: texture_2d<f32>;
      
      @fragment
      fn main(@location(0) in_texcoord: vec4<f32>) -> @location(0) vec4<f32> {
        let r = ${r};
        let g = ${g};
        let b = ${b};
        let alpha = ${alpha};
        var color = vec4(r, g, b, alpha);
        ${steps.reduce((pre, current) => pre + current, '')}
        return color;
      }
    `;
    }
    checkFrame(frame) {
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_1__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68) !== this.videoWidth) {
            if (this.rgbTexture) {
                this.rgbTexture.destroy();
            }
            this.rgbTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72)],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                format: 'r8unorm'
            });
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_3__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 220), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 212), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 216), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 208));
            this.generateFragmentSource(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80), descriptor);
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32);
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80);
            this.layout();
            this.generatePipeline();
            this.generateRenderBundleEncoder();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        this.device.queue.writeTexture({
            texture: this.rgbTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame), this.rgbTexture.width * this.rgbTexture.height), {
            offset: 0,
            bytesPerRow: this.rgbTexture.width,
            rowsPerImage: this.rgbTexture.height
        }, {
            width: this.rgbTexture.width,
            height: this.rgbTexture.height,
            depthOrArrayLayers: 1
        });
        const commandEncoder = this.device.createCommandEncoder();
        const renderPass = commandEncoder.beginRenderPass({
            colorAttachments: [{
                    view: this.context.getCurrentTexture().createView(),
                    clearValue: {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 1
                    },
                    loadOp: 'clear',
                    storeOp: 'store'
                }]
        });
        renderPass.executeBundles([this.renderBundle]);
        renderPass.end();
        this.device.queue.submit([
            commandEncoder.finish()
        ]);
    }
    static isSupport(frame) {
        if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_6__["default"])(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_1__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                return (info.flags & 32 /* PixelFormatFlags.RGB */) && ((info.comp[0].depth + 7) >>> 3) === 1;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPURGBRender.ts":
/*!***********************************************!*\
  !*** ./src/avrender/image/WebGPURGBRender.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPURGBRender)
/* harmony export */ });
/* harmony import */ var _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgpu/wgsl/vertex.wgsl */ "./src/avrender/image/webgpu/wgsl/vertex.wgsl");
/* harmony import */ var _WebGPURender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGPURender */ "./src/avrender/image/WebGPURender.ts");
/*
 * libmedia WebGPURGBRender
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class WebGPURGBRender extends _WebGPURender__WEBPACK_IMPORTED_MODULE_1__["default"] {
    rgbTexture;
    constructor(canvas, options) {
        super(canvas, options);
        this.vertexSource = _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_0__["default"];
    }
    generateBindGroup() {
        if (!this.rgbTexture) {
            return;
        }
        const bindGroupLayoutEntry = [
            {
                binding: 0,
                visibility: GPUShaderStage.VERTEX,
                buffer: {
                    type: 'uniform'
                }
            },
            {
                binding: 1,
                visibility: GPUShaderStage.FRAGMENT,
                sampler: {
                    type: 'filtering'
                }
            },
            {
                binding: 2,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            }
        ];
        this.bindGroupLayout = this.device.createBindGroupLayout({
            entries: bindGroupLayoutEntry
        });
        const bindGroupEntry = [
            {
                binding: 0,
                resource: {
                    buffer: this.rotateMatrixBuffer,
                    size: Float32Array.BYTES_PER_ELEMENT * 16
                }
            },
            {
                binding: 1,
                resource: this.sampler
            },
            {
                binding: 2,
                resource: this.rgbTexture.createView()
            }
        ];
        this.bindGroup = this.device.createBindGroup({
            layout: this.bindGroupLayout,
            entries: bindGroupEntry
        });
    }
    destroy() {
        if (this.rgbTexture) {
            this.rgbTexture.destroy();
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPURender.ts":
/*!********************************************!*\
  !*** ./src/avrender/image/WebGPURender.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPURender)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _ImageRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageRender */ "./src/avrender/image/ImageRender.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var _function_flipVertex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./function/flipVertex */ "./src/avrender/image/function/flipVertex.ts");
var cheap__fileName__0 = "src\\avrender\\image\\WebGPURender.ts";
/*
 * libmedia WebGPURender
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class WebGPURender extends _ImageRender__WEBPACK_IMPORTED_MODULE_1__["default"] {
    adapter;
    device;
    context;
    vsModule;
    fsModule;
    rotateMatrixBuffer;
    renderPipeline;
    rotateMatrix;
    vbo;
    sampler;
    vertex;
    fragmentSource;
    vertexSource;
    renderBundleEncoder;
    renderBundle;
    bindGroupLayout;
    bindGroup;
    pipelineLayout;
    constructor(canvas, options) {
        super(canvas, options);
    }
    async init(requiredFeatures) {
        this.adapter = await navigator.gpu.requestAdapter({
            powerPreference: this.options.powerPreference ?? 'high-performance'
        });
        if (!this.adapter) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('not support webgpu render', cheap__fileName__0, 86);
        }
        const canRequiredFeatures = [];
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(requiredFeatures, (feature) => {
            if (this.adapter.features.has(feature)) {
                canRequiredFeatures.push(feature);
            }
        });
        this.device = await this.adapter.requestDevice({
            requiredFeatures: canRequiredFeatures.length ? canRequiredFeatures : undefined
        });
        this.device.lost.then(() => {
            if (this.destroyed) {
                return;
            }
            this.lost = true;
            common_util_logger__WEBPACK_IMPORTED_MODULE_0__.error('gpu device lost', cheap__fileName__0, 105);
            if (this.options?.onRenderContextLost) {
                this.options.onRenderContextLost();
            }
        });
        this.context = this.canvas.getContext('webgpu');
        if (!this.context) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('can not support webgpu, got GPUCanvasContext failed', cheap__fileName__0, 114);
        }
        this.context.configure({
            device: this.device,
            format: navigator.gpu.getPreferredCanvasFormat(),
            alphaMode: 'premultiplied'
        });
        this.sampler = this.device.createSampler({
            magFilter: 'linear',
            minFilter: 'linear'
        });
        this.vbo = this.device.createBuffer({
            size: Float32Array.BYTES_PER_ELEMENT * 28,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
        });
        this.rotateMatrixBuffer = this.device.createBuffer({
            size: Float32Array.BYTES_PER_ELEMENT * 16,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.setRotateMatrix(this.getRotateMatrix(0));
    }
    generatePipeline() {
        this.generateBindGroup();
        this.pipelineLayout = this.device.createPipelineLayout({
            bindGroupLayouts: [this.bindGroupLayout]
        });
        this.vsModule = this.device.createShaderModule({
            code: this.vertexSource
        });
        this.fsModule = this.device.createShaderModule({
            code: this.fragmentSource
        });
        this.renderPipeline = this.device.createRenderPipeline({
            layout: this.pipelineLayout,
            vertex: {
                module: this.vsModule,
                entryPoint: 'main',
                buffers: [
                    {
                        arrayStride: 28,
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: 'float32x3'
                            },
                            {
                                shaderLocation: 1,
                                offset: 12,
                                format: 'float32x4'
                            }
                        ]
                    }
                ]
            },
            fragment: {
                module: this.fsModule,
                entryPoint: 'main',
                targets: [{
                        format: navigator.gpu.getPreferredCanvasFormat()
                    }]
            },
            primitive: {
                topology: 'triangle-strip'
            }
        });
    }
    generateRenderBundleEncoder() {
        if (!this.renderPipeline) {
            return;
        }
        this.renderBundleEncoder = this.device.createRenderBundleEncoder({
            colorFormats: [navigator.gpu.getPreferredCanvasFormat()]
        });
        this.renderBundleEncoder.setPipeline(this.renderPipeline);
        this.renderBundleEncoder.setBindGroup(0, this.bindGroup);
        this.renderBundleEncoder.setVertexBuffer(0, this.vbo);
        this.renderBundleEncoder.draw(4, 4, 0, 0);
        this.renderBundle = this.renderBundleEncoder.finish();
    }
    setRotateMatrix(rotateMatrix) {
        this.rotateMatrix = rotateMatrix;
        const buffer = new Float32Array(this.rotateMatrix);
        this.device.queue.writeBuffer(this.rotateMatrixBuffer, 0, 
        //  ArrayBuffer
        buffer.buffer, 
        // 
        buffer.byteOffset, 
        // 
        buffer.byteLength);
    }
    setVertices() {
        const buffer = new Float32Array(this.vertex);
        this.device.queue.writeBuffer(this.vbo, 0, 
        //  ArrayBuffer
        buffer.buffer, 
        // 
        buffer.byteOffset, 
        // 
        buffer.byteLength);
    }
    clear() {
        this.context.getCurrentTexture().destroy();
    }
    layout() {
        let videoWidth = this.videoWidth;
        let videoHeight = this.videoHeight;
        let canvasWidth = this.canvasWidth;
        let canvasHeight = this.canvasHeight;
        if (this.rotate === 90 || this.rotate === 270) {
            /*
             * videoWidth = this.videoHeight
             * videoHeight = this.videoWidth
             */
            canvasWidth = this.canvasHeight;
            canvasHeight = this.canvasWidth;
        }
        const scaleX = videoWidth / canvasWidth;
        const scaleY = videoHeight / canvasHeight;
        let isPaddingTop;
        if (scaleX > 1) {
            if (scaleX < scaleY) {
                isPaddingTop = false;
            }
            else {
                isPaddingTop = true;
            }
        }
        else {
            if (scaleX > scaleY) {
                isPaddingTop = true;
            }
            else {
                isPaddingTop = false;
            }
        }
        if (this.renderMode === 1 /* RenderMode.FILL */) {
            isPaddingTop = !isPaddingTop;
        }
        let texturePadding = 0;
        if (this.textureWidth !== this.videoWidth) {
            texturePadding = (this.textureWidth - this.videoWidth) / this.textureWidth;
        }
        if (isPaddingTop) {
            const paddingTop = (canvasHeight - videoHeight * canvasWidth / videoWidth) / canvasHeight;
            this.vertex = [
                -1, 1 - paddingTop, 0, 0, 0, 0, 0,
                -1, -1 + paddingTop, 0, 0, 1, 0, 0,
                1, 1 - paddingTop, 0, 1 - texturePadding, 0, 0, 0,
                1, -1 + paddingTop, 0, 1 - texturePadding, 1, 0, 0
            ];
        }
        else {
            const paddingLeft = (canvasWidth - videoWidth * canvasHeight / videoHeight) / canvasWidth;
            this.vertex = [
                -1 + paddingLeft, 1, 0, 0, 0, 0, 0,
                -1 + paddingLeft, -1, 0, 0, 1, 0, 0,
                1 - paddingLeft, 1, 0, 1 - texturePadding, 0, 0, 0,
                1 - paddingLeft, -1, 0, 1 - texturePadding, 1, 0, 0
            ];
        }
        (0,_function_flipVertex__WEBPACK_IMPORTED_MODULE_3__["default"])(this.vertex, this.flipHorizontal, this.flipVertical);
        this.setVertices();
    }
    viewport(width, height) {
        super.viewport(width, height);
    }
    setRotate(angle) {
        angle = angle % 360;
        if (angle === this.rotate) {
            return;
        }
        this.rotate = angle;
        this.setRotateMatrix(this.getRotateMatrix(angle));
        this.layout();
        this.clear();
    }
    destroy() {
        this.sampler = null;
        if (this.vbo) {
            this.vbo.destroy();
        }
        if (this.rotateMatrixBuffer) {
            this.rotateMatrixBuffer.destroy();
        }
        this.bindGroupLayout = null;
        this.bindGroup = null;
        this.pipelineLayout = null;
        this.renderBundle = null;
        this.renderBundleEncoder = null;
        this.fsModule = null;
        this.vsModule = null;
        this.renderPipeline = null;
        this.rotateMatrix = null;
        this.vertex = null;
        this.context = null;
        this.options = null;
        this.destroyed = true;
        if (this.device) {
            this.device.destroy();
            this.device = null;
        }
        if (this.adapter) {
            this.adapter = null;
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPUYUV16Render.ts":
/*!*************************************************!*\
  !*** ./src/avrender/image/WebGPUYUV16Render.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPUYUV16Render)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _struct_HdrMetadata_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./struct/HdrMetadata */ "./src/avrender/image/struct/HdrMetadata.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var _WebGPUYUVRender__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WebGPUYUVRender */ "./src/avrender/image/WebGPUYUVRender.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var _webgpu_wgsl_compute_uint2FloatLE_wgsl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./webgpu/wgsl/compute/uint2FloatLE.wgsl */ "./src/avrender/image/webgpu/wgsl/compute/uint2FloatLE.wgsl");
/* harmony import */ var _webgpu_wgsl_compute_uint2FloatBE_wgsl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./webgpu/wgsl/compute/uint2FloatBE.wgsl */ "./src/avrender/image/webgpu/wgsl/compute/uint2FloatBE.wgsl");
/* harmony import */ var _colorTransform_options__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./colorTransform/options */ "./src/avrender/image/colorTransform/options.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");
















class WebGPUYUV16Render extends _WebGPUYUVRender__WEBPACK_IMPORTED_MODULE_5__["default"] {
    metaYBuffer;
    metaUBuffer;
    metaVBuffer;
    metaABuffer;
    computeBindGroupLayout;
    computeBindGroupY;
    computeBindGroupU;
    computeBindGroupV;
    computeBindGroupA;
    computePipelineLayout;
    computePipeline;
    inputYTexture;
    inputUTexture;
    inputVTexture;
    inputATexture;
    computeModule;
    uint2Float;
    hdrMetadata;
    hdrMetadataBuffer;
    constructor(canvas, options) {
        super(canvas, options);
        this.hdrMetadata = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_2__["default"])(_struct_HdrMetadata_ts__WEBPACK_IMPORTED_MODULE_1__["default"]);
        this.hdrMetadata.multiplier = 1.0;
    }
    generateFragmentSource(format, descriptor, colorTransformOptions) {
        colorTransformOptions.outputRGB = true;
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_12__["default"])(this.srcColorSpace, this.dstColorSpace, colorTransformOptions);
        let y = 'textureSample(yTexture, s, in_texcoord.xy).x;';
        let u = 'textureSample(uTexture, s, in_texcoord.xy).x';
        let v = 'textureSample(vTexture, s, in_texcoord.xy).x';
        let alpha = '1.0';
        if (format === 23 /* AVPixelFormat.AV_PIX_FMT_NV12 */
            || format === 189 /* AVPixelFormat.AV_PIX_FMT_NV24 */) {
            u = 'textureSample(uTexture, s, in_texcoord.xy).x';
            v = 'textureSample(uTexture, s, in_texcoord.xy).y';
        }
        else if (format === 24 /* AVPixelFormat.AV_PIX_FMT_NV21 */
            || format === 190 /* AVPixelFormat.AV_PIX_FMT_NV42 */) {
            u = 'textureSample(uTexture, s, in_texcoord.xy).y';
            v = 'textureSample(uTexture, s, in_texcoord.xy).x';
        }
        if ((descriptor.flags & 128 /* PixelFormatFlags.ALPHA */) && descriptor.nbComponents === 4) {
            alpha = 'textureSample(aTexture, s, in_texcoord.xy).x';
        }
        this.fragmentSource = `
      struct HdrMetadata {
        offset: f32,
        multiplier: f32,
        pqTonemapA: f32,
        pqTonemapB: f32,
        hlgOOTFGammaMinusOne: f32,
        hlgDstMaxLuminanceRelative: f32,
        nitsToSdrRelativeFactor: f32,
        sdrRelativeToNitsFactor: f32
      };

      @group(0) @binding(1) var s: sampler;
      @group(0) @binding(2) var<uniform> hdrMetadata: HdrMetadata;
      @group(0) @binding(3) var yTexture: texture_2d<f32>;
      @group(0) @binding(4) var uTexture: texture_2d<f32>;

      ${this.vTexture ? '@group(0) @binding(5) var vTexture: texture_2d<f32>;' : ''}
      ${this.aTexture ? '@group(0) @binding(6) var aTexture: texture_2d<f32>;' : ''}

      @fragment
      fn main(@location(0) in_texcoord: vec4<f32>) -> @location(0) vec4<f32> {

        let offset = hdrMetadata.offset;
        let multiplier = hdrMetadata.multiplier;
        let pq_tonemap_a = hdrMetadata.pqTonemapA;
        let pq_tonemap_b = hdrMetadata.pqTonemapB;
        let hlg_ootf_gamma_minus_one = hdrMetadata.hlgOOTFGammaMinusOne;
        let hlg_dst_max_luminance_relative = hdrMetadata.hlgDstMaxLuminanceRelative;
        let nits_to_sdr_relative_factor = hdrMetadata.nitsToSdrRelativeFactor;
        let sdr_relative_to_nits_factor = hdrMetadata.sdrRelativeToNitsFactor;

        let y = ${y}
        let u = ${u};
        let v = ${v};
        let alpha = ${alpha};
        var color = vec4(y, u, v, alpha);

        if (color.a > 0) {
          color.r /= color.a;
          color.g /= color.a;
          color.b /= color.a;
        }
        color.r -= offset;
        color.g -= offset;
        color.b -= offset;

        color.r *= multiplier;
        color.g *= multiplier;
        color.b *= multiplier;
        
        ${steps.reduce((pre, current) => pre + current, '')}

        color.r *= color.a;
        color.g *= color.a;
        color.b *= color.a;

        return color;
      }
    `;
    }
    async init() {
        await super.init(['float32-filterable']);
        this.metaYBuffer = this.device.createBuffer({
            size: Uint32Array.BYTES_PER_ELEMENT * 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.metaUBuffer = this.device.createBuffer({
            size: Uint32Array.BYTES_PER_ELEMENT * 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.metaVBuffer = this.device.createBuffer({
            size: Uint32Array.BYTES_PER_ELEMENT * 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.metaABuffer = this.device.createBuffer({
            size: Uint32Array.BYTES_PER_ELEMENT * 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.hdrMetadataBuffer = this.device.createBuffer({
            size: (47) & ~15,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
    }
    generateComputeBindGroup() {
        this.computeBindGroupLayout = this.device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: 'uniform'
                    }
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.COMPUTE,
                    texture: {
                        sampleType: 'uint'
                    }
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.COMPUTE,
                    storageTexture: {
                        format: 'r32float'
                    }
                }
            ]
        });
        this.computeBindGroupY = this.device.createBindGroup({
            layout: this.computeBindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this.metaYBuffer,
                        size: Uint32Array.BYTES_PER_ELEMENT * 4
                    }
                },
                {
                    binding: 1,
                    resource: this.inputYTexture.createView()
                },
                {
                    binding: 2,
                    resource: this.yTexture.createView()
                }
            ]
        });
        this.computeBindGroupU = this.device.createBindGroup({
            layout: this.computeBindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this.metaUBuffer,
                        size: Uint32Array.BYTES_PER_ELEMENT * 4
                    }
                },
                {
                    binding: 1,
                    resource: this.inputUTexture.createView()
                },
                {
                    binding: 2,
                    resource: this.uTexture.createView()
                }
            ]
        });
        if (this.vTexture) {
            this.computeBindGroupV = this.device.createBindGroup({
                layout: this.computeBindGroupLayout,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: this.metaVBuffer,
                            size: Uint32Array.BYTES_PER_ELEMENT * 4
                        }
                    },
                    {
                        binding: 1,
                        resource: this.inputVTexture.createView()
                    },
                    {
                        binding: 2,
                        resource: this.vTexture.createView()
                    }
                ]
            });
        }
        if (this.aTexture) {
            this.computeBindGroupA = this.device.createBindGroup({
                layout: this.computeBindGroupLayout,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: this.metaABuffer,
                            size: Uint32Array.BYTES_PER_ELEMENT * 4
                        }
                    },
                    {
                        binding: 1,
                        resource: this.inputATexture.createView()
                    },
                    {
                        binding: 2,
                        resource: this.aTexture.createView()
                    }
                ]
            });
        }
    }
    generateComputePipeline() {
        this.generateComputeBindGroup();
        this.computePipelineLayout = this.device.createPipelineLayout({
            bindGroupLayouts: [this.computeBindGroupLayout]
        });
        this.computeModule = this.device.createShaderModule({
            code: this.uint2Float
        });
        this.computePipeline = this.device.createComputePipeline({
            layout: this.computePipelineLayout,
            compute: {
                module: this.computeModule,
                entryPoint: 'main'
            }
        });
    }
    generateBindGroup() {
        if (!this.yTexture) {
            return;
        }
        const bindGroupLayoutEntry = [
            {
                binding: 0,
                visibility: GPUShaderStage.VERTEX,
                buffer: {
                    type: 'uniform'
                }
            },
            {
                binding: 1,
                visibility: GPUShaderStage.FRAGMENT,
                sampler: {
                    type: 'filtering'
                }
            },
            {
                binding: 2,
                visibility: GPUShaderStage.FRAGMENT,
                buffer: {
                    type: 'uniform'
                }
            },
            {
                binding: 3,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            },
            {
                binding: 4,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            },
        ];
        if (this.vTexture) {
            bindGroupLayoutEntry.push({
                binding: 5,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            });
        }
        if (this.aTexture) {
            bindGroupLayoutEntry.push({
                binding: 6,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            });
        }
        this.bindGroupLayout = this.device.createBindGroupLayout({
            entries: bindGroupLayoutEntry
        });
        const bindGroupEntry = [
            {
                binding: 0,
                resource: {
                    buffer: this.rotateMatrixBuffer,
                    size: Float32Array.BYTES_PER_ELEMENT * 16
                }
            },
            {
                binding: 1,
                resource: this.sampler
            },
            {
                binding: 2,
                resource: {
                    buffer: this.hdrMetadataBuffer,
                    size: this.hdrMetadataBuffer.size
                }
            },
            {
                binding: 3,
                resource: this.yTexture.createView()
            },
            {
                binding: 4,
                resource: this.uTexture.createView()
            }
        ];
        if (this.vTexture) {
            bindGroupEntry.push({
                binding: 5,
                resource: this.vTexture.createView()
            });
        }
        if (this.aTexture) {
            bindGroupEntry.push({
                binding: 6,
                resource: this.aTexture.createView()
            });
        }
        this.bindGroup = this.device.createBindGroup({
            layout: this.bindGroupLayout,
            entries: bindGroupEntry
        });
    }
    checkFrame(frame) {
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_6__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        if ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 32) >>> 1) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 68) !== this.videoWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 80) !== this.format) {
            if (this.yTexture) {
                this.yTexture.destroy();
            }
            if (this.uTexture) {
                this.uTexture.destroy();
            }
            if (this.vTexture) {
                this.vTexture.destroy();
            }
            if (this.aTexture) {
                this.aTexture.destroy();
            }
            if (this.inputYTexture) {
                this.inputYTexture.destroy();
            }
            if (this.inputUTexture) {
                this.inputUTexture.destroy();
            }
            if (this.inputVTexture) {
                this.inputVTexture.destroy();
            }
            if (this.inputATexture) {
                this.inputATexture.destroy();
            }
            this.yTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 32) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 72)],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING,
                format: 'r32float'
            });
            this.uTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 32 + 4) >>> 1, (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 72) >>> descriptor.log2ChromaH)],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING,
                format: 'r32float'
            });
            if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
                this.vTexture = this.device.createTexture({
                    size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 32 + 8) >>> 1, (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 72) >>> descriptor.log2ChromaH)],
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING,
                    format: 'r32float'
                });
            }
            if (descriptor.nbComponents === 4) {
                this.aTexture = this.device.createTexture({
                    size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 32 + 12) >>> 1, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 72)],
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING,
                    format: 'r32float'
                });
            }
            this.inputYTexture = this.device.createTexture({
                size: [this.yTexture.width, this.yTexture.height],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                format: 'r16uint'
            });
            this.inputUTexture = this.device.createTexture({
                size: [this.uTexture.width, this.uTexture.height],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                format: 'r16uint'
            });
            if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
                this.inputVTexture = this.device.createTexture({
                    size: [this.vTexture.width, this.vTexture.height],
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                    format: 'r16uint'
                });
            }
            if (descriptor.nbComponents === 4) {
                this.inputATexture = this.device.createTexture({
                    size: [this.aTexture.width, this.aTexture.height],
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                    format: 'r16uint'
                });
            }
            const yBuffer = new Uint32Array([(1 << descriptor.comp[0].depth) - 1, this.inputYTexture.width, this.inputYTexture.height]);
            this.device.queue.writeBuffer(this.metaYBuffer, 0, yBuffer.buffer, yBuffer.byteOffset, yBuffer.byteLength);
            const uBuffer = new Uint32Array([(1 << descriptor.comp[1].depth) - 1, this.inputUTexture.width, this.inputUTexture.height]);
            this.device.queue.writeBuffer(this.metaUBuffer, 0, uBuffer.buffer, uBuffer.byteOffset, uBuffer.byteLength);
            if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
                const vBuffer = new Uint32Array([(1 << descriptor.comp[2].depth) - 1, this.inputVTexture.width, this.inputVTexture.height]);
                this.device.queue.writeBuffer(this.metaVBuffer, 0, vBuffer.buffer, vBuffer.byteOffset, vBuffer.byteLength);
            }
            if (descriptor.nbComponents === 4) {
                const aBuffer = new Uint32Array([(1 << descriptor.comp[3].depth) - 1, this.inputATexture.width, this.inputATexture.height]);
                this.device.queue.writeBuffer(this.metaABuffer, 0, aBuffer.buffer, aBuffer.byteOffset, aBuffer.byteLength);
            }
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_8__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 220), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 212), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 216), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 208));
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 32) >>> 1;
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 80);
            const colorTransformOptions = {
                type: 1 /* GLType.kWebGPU */,
                bitDepth: descriptor.comp[0].depth,
                toneMapPQAndHlgToDst: true,
                metadata: this.hdrMetadata,
                dstSdrMaxLuminanceNits: _colorTransform_options__WEBPACK_IMPORTED_MODULE_11__.DefaultSDRWhiteLevel,
                dstMaxLuminanceRelative: 1.0
            };
            const sideData = (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_13__.getAVFrameSideData)(frame, 14 /* AVFrameSideDataType.AV_FRAME_DATA_CONTENT_LIGHT_LEVEL */);
            if (sideData) {
                const lightMetadata = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](sideData + 4);
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[8](lightMetadata) > 0) {
                    colorTransformOptions.maxContentLightLevel = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[8](lightMetadata);
                }
            }
            this.generateFragmentSource(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 80), descriptor, colorTransformOptions);
            this.uint2Float = (descriptor.flags & 1 /* PixelFormatFlags.BIG_ENDIAN */) ? _webgpu_wgsl_compute_uint2FloatBE_wgsl__WEBPACK_IMPORTED_MODULE_10__["default"] : _webgpu_wgsl_compute_uint2FloatLE_wgsl__WEBPACK_IMPORTED_MODULE_9__["default"];
            this.layout();
            this.generatePipeline();
            this.generateRenderBundleEncoder();
            this.generateComputePipeline();
            const hdrBuffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.mapUint8Array)(this.hdrMetadata[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress], 32).slice();
            this.device.queue.writeBuffer(this.hdrMetadataBuffer, 0, hdrBuffer.buffer, hdrBuffer.byteOffset, hdrBuffer.byteLength);
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        const commandEncoder = this.device.createCommandEncoder();
        const computePass = commandEncoder.beginComputePass({});
        computePass.setPipeline(this.computePipeline);
        computePass.setBindGroup(0, this.computeBindGroupY);
        this.device.queue.writeTexture({
            texture: this.inputYTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](frame), (this.inputYTexture.width * this.inputYTexture.height) << 1), {
            offset: 0,
            bytesPerRow: this.inputYTexture.width << 1,
            rowsPerImage: this.inputYTexture.height
        }, {
            width: this.inputYTexture.width,
            height: this.inputYTexture.height,
            depthOrArrayLayers: 1
        });
        computePass.dispatchWorkgroups((this.inputYTexture.width + 7) >>> 3, (this.inputYTexture.height + 7) >>> 3);
        computePass.setBindGroup(0, this.computeBindGroupU);
        this.device.queue.writeTexture({
            texture: this.inputUTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](frame + 4), (this.inputUTexture.width * this.inputUTexture.height) << 1), {
            offset: 0,
            bytesPerRow: this.inputUTexture.width << 1,
            rowsPerImage: this.inputUTexture.height
        }, {
            width: this.inputUTexture.width,
            height: this.inputUTexture.height,
            depthOrArrayLayers: 1
        });
        computePass.dispatchWorkgroups((this.inputUTexture.width + 7) >>> 3, (this.inputUTexture.height + 7) >>> 3);
        if (this.inputVTexture) {
            computePass.setBindGroup(0, this.computeBindGroupV);
            this.device.queue.writeTexture({
                texture: this.inputVTexture
            }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](frame + 8), (this.inputVTexture.width * this.inputVTexture.height) << 1), {
                offset: 0,
                bytesPerRow: this.inputVTexture.width << 1,
                rowsPerImage: this.inputVTexture.height
            }, {
                width: this.inputVTexture.width,
                height: this.inputVTexture.height,
                depthOrArrayLayers: 1
            });
            computePass.dispatchWorkgroups((this.inputVTexture.width + 7) >>> 3, (this.inputVTexture.height + 7) >>> 3);
        }
        if (this.inputATexture) {
            computePass.setBindGroup(0, this.computeBindGroupA);
            this.device.queue.writeTexture({
                texture: this.inputATexture
            }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](frame + 12), (this.inputATexture.width * this.inputATexture.height) << 1), {
                offset: 0,
                bytesPerRow: this.inputATexture.width << 1,
                rowsPerImage: this.inputATexture.height
            }, {
                width: this.inputATexture.width,
                height: this.inputATexture.height,
                depthOrArrayLayers: 1
            });
            computePass.dispatchWorkgroups((this.inputATexture.width + 7) >>> 3, (this.inputATexture.height + 7) >>> 3);
        }
        computePass.end();
        const renderPass = commandEncoder.beginRenderPass({
            colorAttachments: [{
                    view: this.context.getCurrentTexture().createView(),
                    clearValue: {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 1
                    },
                    loadOp: 'clear',
                    storeOp: 'store'
                }]
        });
        renderPass.executeBundles([this.renderBundle]);
        renderPass.end();
        this.device.queue.submit([
            commandEncoder.finish()
        ]);
    }
    destroy() {
        if (this.inputYTexture) {
            this.inputYTexture.destroy();
            this.inputYTexture = null;
        }
        if (this.inputUTexture) {
            this.inputUTexture.destroy();
            this.inputUTexture = null;
        }
        if (this.inputVTexture) {
            this.inputVTexture.destroy();
            this.inputVTexture = null;
        }
        if (this.metaYBuffer) {
            this.metaYBuffer.destroy();
            this.metaYBuffer = null;
        }
        if (this.metaUBuffer) {
            this.metaUBuffer.destroy();
            this.metaUBuffer = null;
        }
        if (this.metaVBuffer) {
            this.metaVBuffer.destroy();
            this.metaVBuffer = null;
        }
        if (this.hdrMetadata) {
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_4__["default"])(this.hdrMetadata);
            this.hdrMetadata = null;
        }
        this.computeModule = null;
        this.computeBindGroupY = null;
        this.computeBindGroupU = null;
        this.computeBindGroupV = null;
        this.computeBindGroupLayout = null;
        this.computePipelineLayout = null;
        this.computePipeline = null;
        super.destroy();
    }
    static isSupport(frame) {
        if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_14__["default"])(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_6__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                if (info.flags & 32 /* PixelFormatFlags.RGB */) {
                    return false;
                }
                return (info.flags & 16 /* PixelFormatFlags.PLANER */) && ((info.comp[0].depth + 7) >>> 3) === 2;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPUYUV8Render.ts":
/*!************************************************!*\
  !*** ./src/avrender/image/WebGPUYUV8Render.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPUYUV8Render)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _WebGPUYUVRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGPUYUVRender */ "./src/avrender/image/WebGPUYUVRender.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var _colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./colorTransform/generateSteps */ "./src/avrender/image/colorTransform/generateSteps.ts");
/* harmony import */ var cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/function/isPointer */ "./src/cheap/std/function/isPointer.ts");







class WebGPUYUV8Render extends _WebGPUYUVRender__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(canvas, options) {
        super(canvas, options);
    }
    generateFragmentSource(format, descriptor) {
        const steps = (0,_colorTransform_generateSteps__WEBPACK_IMPORTED_MODULE_5__["default"])(this.srcColorSpace, this.dstColorSpace, {
            bitDepth: 8,
            type: 1 /* GLType.kWebGPU */,
            outputRGB: true
        });
        let y = 'textureSample(yTexture, s, in_texcoord.xy).x';
        let u = 'textureSample(uTexture, s, in_texcoord.xy).x';
        let v = 'textureSample(vTexture, s, in_texcoord.xy).x';
        let alpha = '1.0';
        if (format === 23 /* AVPixelFormat.AV_PIX_FMT_NV12 */
            || format === 189 /* AVPixelFormat.AV_PIX_FMT_NV24 */) {
            u = 'textureSample(uTexture, s, in_texcoord.xy).x';
            v = 'textureSample(uTexture, s, in_texcoord.xy).y';
        }
        else if (format === 24 /* AVPixelFormat.AV_PIX_FMT_NV21 */
            || format === 190 /* AVPixelFormat.AV_PIX_FMT_NV42 */) {
            u = 'textureSample(uTexture, s, in_texcoord.xy).y';
            v = 'textureSample(uTexture, s, in_texcoord.xy).x';
        }
        if ((descriptor.flags & 128 /* PixelFormatFlags.ALPHA */) && descriptor.nbComponents === 4) {
            alpha = 'textureSample(aTexture, s, in_texcoord.xy).x';
        }
        this.fragmentSource = `
      @group(0) @binding(1) var s: sampler;
      @group(0) @binding(2) var yTexture: texture_2d<f32>;
      @group(0) @binding(3) var uTexture: texture_2d<f32>;
      ${this.vTexture ? '@group(0) @binding(4) var vTexture: texture_2d<f32>;' : ''}
      ${this.aTexture ? '@group(0) @binding(5) var aTexture: texture_2d<f32>;' : ''}
      
      @fragment
      fn main(@location(0) in_texcoord: vec4<f32>) -> @location(0) vec4<f32> {
        let y = ${y};
        let u = ${u};
        let v = ${v};
        let alpha = ${alpha};
        var color = vec4(y, u, v, alpha);
        ${steps.reduce((pre, current) => pre + current, '')}
        return color;
      }
    `;
    }
    checkFrame(frame) {
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
        if (!descriptor) {
            return;
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32) !== this.textureWidth
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) !== this.videoHeight
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68) !== this.videoWidth) {
            if (this.yTexture) {
                this.yTexture.destroy();
            }
            if (this.uTexture) {
                this.uTexture.destroy();
            }
            if (this.vTexture) {
                this.vTexture.destroy();
            }
            if (this.aTexture) {
                this.aTexture.destroy();
            }
            this.yTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72)],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                format: 'r8unorm'
            });
            this.uTexture = this.device.createTexture({
                size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32 + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)].log2ChromaH],
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                format: 'r8unorm'
            });
            if (descriptor.comp[1].plane !== descriptor.comp[2].plane) {
                this.vTexture = this.device.createTexture({
                    size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32 + 8), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72) >>> avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)].log2ChromaH],
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                    format: 'r8unorm'
                });
            }
            if (descriptor.nbComponents === 4) {
                this.aTexture = this.device.createTexture({
                    size: [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32 + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72)],
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                    format: 'r8unorm'
                });
            }
            this.srcColorSpace = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_4__["default"](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 220), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 212), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 216), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 208));
            this.generateFragmentSource(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80), descriptor);
            this.videoWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 68);
            this.videoHeight = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 72);
            this.textureWidth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 32);
            this.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80);
            this.layout();
            this.generatePipeline();
            this.generateRenderBundleEncoder();
        }
    }
    render(frame) {
        if (this.lost) {
            return;
        }
        this.checkFrame(frame);
        this.device.queue.writeTexture({
            texture: this.yTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame), this.yTexture.width * this.yTexture.height), {
            offset: 0,
            bytesPerRow: this.yTexture.width,
            rowsPerImage: this.yTexture.height
        }, {
            width: this.yTexture.width,
            height: this.yTexture.height,
            depthOrArrayLayers: 1
        });
        this.device.queue.writeTexture({
            texture: this.uTexture
        }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame + 4), this.uTexture.width * this.uTexture.height), {
            offset: 0,
            bytesPerRow: this.uTexture.width,
            rowsPerImage: this.uTexture.height
        }, {
            width: this.uTexture.width,
            height: this.uTexture.height,
            depthOrArrayLayers: 1
        });
        if (this.vTexture) {
            this.device.queue.writeTexture({
                texture: this.vTexture
            }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame + 8), this.vTexture.width * this.vTexture.height), {
                offset: 0,
                bytesPerRow: this.vTexture.width,
                rowsPerImage: this.vTexture.height
            }, {
                width: this.vTexture.width,
                height: this.vTexture.height,
                depthOrArrayLayers: 1
            });
        }
        if (this.aTexture) {
            this.device.queue.writeTexture({
                texture: this.aTexture
            }, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](frame + 12), this.aTexture.width * this.aTexture.height), {
                offset: 0,
                bytesPerRow: this.aTexture.width,
                rowsPerImage: this.aTexture.height
            }, {
                width: this.aTexture.width,
                height: this.aTexture.height,
                depthOrArrayLayers: 1
            });
        }
        const commandEncoder = this.device.createCommandEncoder();
        const renderPass = commandEncoder.beginRenderPass({
            colorAttachments: [{
                    view: this.context.getCurrentTexture().createView(),
                    clearValue: {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 1
                    },
                    loadOp: 'clear',
                    storeOp: 'store'
                }]
        });
        renderPass.executeBundles([this.renderBundle]);
        renderPass.end();
        this.device.queue.submit([
            commandEncoder.finish()
        ]);
    }
    static isSupport(frame) {
        if ((0,cheap_std_function_isPointer__WEBPACK_IMPORTED_MODULE_6__["default"])(frame)) {
            const info = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](frame + 80)];
            if (info) {
                if (info.flags & 32 /* PixelFormatFlags.RGB */) {
                    return false;
                }
                return (info.flags & 16 /* PixelFormatFlags.PLANER */) && ((info.comp[0].depth + 7) >>> 3) === 1;
            }
        }
        return false;
    }
}


/***/ }),

/***/ "./src/avrender/image/WebGPUYUVRender.ts":
/*!***********************************************!*\
  !*** ./src/avrender/image/WebGPUYUVRender.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGPUYUVRender)
/* harmony export */ });
/* harmony import */ var _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgpu/wgsl/vertex.wgsl */ "./src/avrender/image/webgpu/wgsl/vertex.wgsl");
/* harmony import */ var _WebGPURender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGPURender */ "./src/avrender/image/WebGPURender.ts");
/*
 * libmedia WebGPUYUVRender
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class WebGPUYUVRender extends _WebGPURender__WEBPACK_IMPORTED_MODULE_1__["default"] {
    yTexture;
    uTexture;
    vTexture;
    aTexture;
    constructor(canvas, options) {
        super(canvas, options);
        this.vertexSource = _webgpu_wgsl_vertex_wgsl__WEBPACK_IMPORTED_MODULE_0__["default"];
    }
    generateBindGroup() {
        if (!this.yTexture) {
            return;
        }
        const bindGroupLayoutEntry = [
            {
                binding: 0,
                visibility: GPUShaderStage.VERTEX,
                buffer: {
                    type: 'uniform'
                }
            },
            {
                binding: 1,
                visibility: GPUShaderStage.FRAGMENT,
                sampler: {
                    type: 'filtering'
                }
            },
            {
                binding: 2,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            },
            {
                binding: 3,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            },
        ];
        if (this.vTexture) {
            bindGroupLayoutEntry.push({
                binding: 4,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            });
        }
        if (this.aTexture) {
            bindGroupLayoutEntry.push({
                binding: 5,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType: 'float'
                }
            });
        }
        this.bindGroupLayout = this.device.createBindGroupLayout({
            entries: bindGroupLayoutEntry
        });
        const bindGroupEntry = [
            {
                binding: 0,
                resource: {
                    buffer: this.rotateMatrixBuffer,
                    size: Float32Array.BYTES_PER_ELEMENT * 16
                }
            },
            {
                binding: 1,
                resource: this.sampler
            },
            {
                binding: 2,
                resource: this.yTexture.createView()
            },
            {
                binding: 3,
                resource: this.uTexture.createView()
            }
        ];
        if (this.vTexture) {
            bindGroupEntry.push({
                binding: 4,
                resource: this.vTexture.createView()
            });
        }
        if (this.aTexture) {
            bindGroupEntry.push({
                binding: 5,
                resource: this.aTexture.createView()
            });
        }
        this.bindGroup = this.device.createBindGroup({
            layout: this.bindGroupLayout,
            entries: bindGroupEntry
        });
    }
    destroy() {
        if (this.yTexture) {
            this.yTexture.destroy();
        }
        if (this.uTexture) {
            this.uTexture.destroy();
        }
        if (this.vTexture) {
            this.vTexture.destroy();
        }
        if (this.aTexture) {
            this.aTexture.destroy();
        }
        super.destroy();
    }
}


/***/ }),

/***/ "./src/avrender/image/colorSpace/ColorSpace.ts":
/*!*****************************************************!*\
  !*** ./src/avrender/image/colorSpace/ColorSpace.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ColorSpace)
/* harmony export */ });
/* harmony import */ var common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/math/Matrix4 */ "./src/common/math/Matrix4.ts");
/* harmony import */ var common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/math/Vector3 */ "./src/common/math/Vector3.ts");
/* harmony import */ var _transferFns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transferFns */ "./src/avrender/image/colorSpace/transferFns.ts");
/* harmony import */ var _primaries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./primaries */ "./src/avrender/image/colorSpace/primaries.ts");
/*
 * libmedia ColorSpace
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class ColorSpace {
    matrixId;
    primaryId;
    transferId;
    rangeId;
    constructor(matrixId, primaryId, transferId, rangeId) {
        this.matrixId = matrixId;
        this.primaryId = primaryId;
        this.transferId = transferId;
        this.rangeId = rangeId;
    }
    getMatrixId() {
        return this.matrixId;
    }
    getPrimaryId() {
        return this.primaryId;
    }
    getTransferId() {
        return this.transferId;
    }
    getRangeId() {
        return this.rangeId;
    }
    isWide() {
        if (this.primaryId === 9 /* AVColorPrimaries.AVCOL_PRI_BT2020 */
            || this.primaryId === 11 /* AVColorPrimaries.AVCOL_PRI_SMPTE431 */
            || this.primaryId === 12 /* AVColorPrimaries.AVCOL_PRI_SMPTE432 */) {
            return true;
        }
        return false;
    }
    isHDR() {
        return this.transferId === 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */
            || this.transferId === 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */;
    }
    isToneMappedByDefault() {
        if (
        // HLG
        this.transferId === 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */
            // PQ
            || this.transferId === 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */) {
            return true;
        }
        return false;
    }
    isAffectedBySDRWhiteLevel() {
        if (
        // HLG
        this.transferId === 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */
            // PQ
            || this.transferId === 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */) {
            return true;
        }
        return false;
    }
    fullRangeEncodedValues() {
        return this.transferId === 12 /* AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG */
            || this.transferId === 11 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4 */;
    }
    getTransferMatrix(bitDepth) {
        const chroma05 = (1 << (bitDepth - 1)) / ((1 << bitDepth) - 1);
        let Kr = 0;
        let Kb = 0;
        switch (this.matrixId) {
            case 0 /* AVColorSpace.AVCOL_SPC_RGB */:
                return new common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]();
            case 1 /* AVColorSpace.AVCOL_SPC_BT709 */:
            case 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */:
                Kr = 0.2126;
                Kb = 0.0722;
                break;
            case 4 /* AVColorSpace.AVCOL_SPC_FCC */:
                Kr = 0.30;
                Kb = 0.11;
                break;
            case 5 /* AVColorSpace.AVCOL_SPC_BT470BG */:
            case 6 /* AVColorSpace.AVCOL_SPC_SMPTE170M */:
                Kr = 0.299;
                Kb = 0.114;
                break;
            case 7 /* AVColorSpace.AVCOL_SPC_SMPTE240M */:
                Kr = 0.212;
                Kb = 0.087;
                break;
            case 8 /* AVColorSpace.AVCOL_SPC_YCOCG */: {
                return common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
                    // Y
                    0.25, 0.5, 0.25, 0.0,
                    // Cg
                    -0.25, 0.5, -0.25, chroma05,
                    // Co
                    0.5, 0.0, -0.5, chroma05,
                    0.0, 0.0, 0.0, 1.0
                ]);
            }
            // BT2020_CL is a special case.
            // Basically we return a matrix that transforms RYB values
            // to YUV values. (Note that the green component have been replaced
            // with the luminance.)
            case 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */: {
                Kr = 0.2627;
                Kb = 0.0593;
                return common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
                    // R
                    1.0, 0.0, 0.0, 0.0,
                    // Y
                    Kr, 1.0 - Kr - Kb, Kb, 0.0,
                    // B
                    0.0, 0.0, 1.0, 0.0,
                    0.0, 0.0, 0.0, 1.0
                ]);
            }
            case 9 /* AVColorSpace.AVCOL_SPC_BT2020_NCL */:
                Kr = 0.2627;
                Kb = 0.0593;
                break;
            case 11 /* AVColorSpace.AVCOL_SPC_SMPTE2085 */:
                return common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
                    // Y
                    0.0, 1.0, 0.0, 0.0,
                    // DX or DZ
                    0.0, -0.5,
                    0.493283,
                    0.5,
                    // DZ or DX
                    0.5, -0.991902 / 2.0, 0.0, 0.5,
                    0.0, 0.0, 0.0, 1.0,
                ]);
        }
        let Kg = 1.0 - Kr - Kb;
        let um = 0.5 / (1.0 - Kb);
        let vm = 0.5 / (1.0 - Kr);
        return common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
            // Y
            Kr, Kg, Kb, 0.0,
            // U
            um * -Kr, um * -Kg, um * (1.0 - Kb), 0.5,
            // V
            vm * (1.0 - Kr), vm * -Kg, vm * -Kb, 0.5,
            0.0, 0.0, 0.0, 1.0,
        ]);
    }
    getRangeAdjustMatrix(bitDepth) {
        switch (this.rangeId) {
            case 2 /* AVColorRange.AVCOL_RANGE_JPEG */:
                return new common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]();
            case 1 /* AVColorRange.AVCOL_RANGE_MPEG */:
                break;
        }
        // See ITU-T H.273 (2016), Section 8.3. The following is derived from
        // Equations 20-31.
        const shift = bitDepth - 8;
        const ay = 219 << shift;
        const c = (1 << bitDepth) - 1;
        const scaleY = c / ay;
        switch (this.matrixId) {
            case 0 /* AVColorSpace.AVCOL_SPC_RGB */:
            case 8 /* AVColorSpace.AVCOL_SPC_YCOCG */:
                return new common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]().setScale(new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([scaleY, scaleY, scaleY]))
                    .postTranslate(new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([-16.0 / 219.0, -16.0 / 219.0, -16.0 / 219.0]));
            case 1 /* AVColorSpace.AVCOL_SPC_BT709 */:
            case 4 /* AVColorSpace.AVCOL_SPC_FCC */:
            case 5 /* AVColorSpace.AVCOL_SPC_BT470BG */:
            case 6 /* AVColorSpace.AVCOL_SPC_SMPTE170M */:
            case 7 /* AVColorSpace.AVCOL_SPC_SMPTE240M */:
            case 9 /* AVColorSpace.AVCOL_SPC_BT2020_NCL */:
            case 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */:
            case 11 /* AVColorSpace.AVCOL_SPC_SMPTE2085 */:
            case 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */: {
                const aUV = 224 << shift;
                const scaleUV = c / aUV;
                const translateUV = (aUV - c) / (2.0 * aUV);
                return new common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]().setScale(new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([scaleY, scaleUV, scaleUV]))
                    .postTranslate(new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([-16.0 / 219.0, translateUV, translateUV]));
            }
        }
        return new common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]();
    }
    getTransferFunction_() {
        switch (this.transferId) {
            case 8 /* AVColorTransferCharacteristic.AVCOL_TRC_LINEAR */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFnLinear;
            case 4 /* AVColorTransferCharacteristic.AVCOL_TRC_GAMMA22 */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFn470SystemM;
            case 5 /* AVColorTransferCharacteristic.AVCOL_TRC_GAMMA28 */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFn470SystemBG;
            case 7 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE240M */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFnSMPTEST240;
            case 1 /* AVColorTransferCharacteristic.AVCOL_TRC_BT709 */:
            case 6 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE170M */:
            case 14 /* AVColorTransferCharacteristic.AVCOL_TRC_BT2020_10 */:
            case 15 /* AVColorTransferCharacteristic.AVCOL_TRC_BT2020_12 */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFnSRGB;
            case 17 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTEST428_1 */:
                return _transferFns__WEBPACK_IMPORTED_MODULE_2__.TransferFnSMPETST428_1;
            case 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */:
            case 12 /* AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG */:
            case 9 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG */:
            case 10 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG_SQRT */:
            case 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */:
            case 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */:
                return null;
        }
    }
    getTransferFunction(sdrWhiteLevel) {
        switch (this.transferId) {
            default:
                return this.getTransferFunction_();
        }
    }
    getInverseTransferFunction(sdrWhiteLevel) {
        const fn = this.getTransferFunction(sdrWhiteLevel);
        if (fn) {
            const fnInv = {
                a: 0,
                b: 0,
                c: 0,
                d: 0,
                e: 0,
                f: 0,
                g: 0
            };
            if (fn.a > 0 && fn.g > 0) {
                const aToG = Math.pow(fn.a, fn.g);
                fnInv.a = 1.0 / aToG;
                fnInv.b = -fn.e / aToG;
                fnInv.g = 1.0 / fn.g;
            }
            fnInv.d = fn.c * fn.d + fn.f;
            fnInv.e = -fn.b / fn.a;
            if (fn.c != 0) {
                fnInv.c = 1.0 / fn.c;
                fnInv.f = -fn.f / fn.c;
            }
            return fnInv;
        }
    }
    hasExtendedSkTransferFn() {
        return this.matrixId === 0 /* AVColorSpace.AVCOL_SPC_RGB */;
    }
    isValid() {
        return this.matrixId !== 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */
            && this.primaryId !== 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */
            && this.transferId !== 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */
            && this.rangeId !== 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */;
    }
    getColorSpacePrimaries() {
        const pri = _primaries__WEBPACK_IMPORTED_MODULE_3__.Invalid;
        switch (this.primaryId) {
            case 1 /* AVColorPrimaries.AVCOL_PRI_BT709 */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.Rec709;
            case 4 /* AVColorPrimaries.AVCOL_PRI_BT470M */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.Rec470SystemM;
            case 5 /* AVColorPrimaries.AVCOL_PRI_BT470BG */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.Rec470SystemBG;
            case 7 /* AVColorPrimaries.AVCOL_PRI_SMPTE240M */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.SMPTE_ST_240;
            case 8 /* AVColorPrimaries.AVCOL_PRI_FILM */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.GenericFilm;
            case 9 /* AVColorPrimaries.AVCOL_PRI_BT2020 */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.Rec2020;
            case 10 /* AVColorPrimaries.AVCOL_PRI_SMPTEST428_1 */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.SMPTE_ST_428_1;
            case 11 /* AVColorPrimaries.AVCOL_PRI_SMPTE431 */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.SMPTE_RP_431_2;
            case 12 /* AVColorPrimaries.AVCOL_PRI_SMPTE432 */:
                return _primaries__WEBPACK_IMPORTED_MODULE_3__.SMPTE_EG_432_1;
        }
        return pri;
    }
    getPrimaryMatrix() {
        const pri = this.getColorSpacePrimaries();
        const toXYZD50 = _primaries__WEBPACK_IMPORTED_MODULE_3__.primariesToXYZD50(pri);
        return common_math_Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
            toXYZD50.rc(0, 0), toXYZD50.rc(0, 1), toXYZD50.rc(0, 2), 0,
            toXYZD50.rc(1, 0), toXYZD50.rc(1, 1), toXYZD50.rc(1, 2), 0,
            toXYZD50.rc(2, 0), toXYZD50.rc(2, 1), toXYZD50.rc(2, 2), 0,
            0, 0, 0, 1
        ]);
    }
}


/***/ }),

/***/ "./src/avrender/image/colorSpace/primaries.ts":
/*!****************************************************!*\
  !*** ./src/avrender/image/colorSpace/primaries.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GenericFilm: () => (/* binding */ GenericFilm),
/* harmony export */   Invalid: () => (/* binding */ Invalid),
/* harmony export */   Rec2020: () => (/* binding */ Rec2020),
/* harmony export */   Rec470SystemBG: () => (/* binding */ Rec470SystemBG),
/* harmony export */   Rec470SystemM: () => (/* binding */ Rec470SystemM),
/* harmony export */   Rec709: () => (/* binding */ Rec709),
/* harmony export */   SMPTE_EG_432_1: () => (/* binding */ SMPTE_EG_432_1),
/* harmony export */   SMPTE_RP_431_2: () => (/* binding */ SMPTE_RP_431_2),
/* harmony export */   SMPTE_ST_240: () => (/* binding */ SMPTE_ST_240),
/* harmony export */   SMPTE_ST_428_1: () => (/* binding */ SMPTE_ST_428_1),
/* harmony export */   primariesToXYZD50: () => (/* binding */ primariesToXYZD50)
/* harmony export */ });
/* unused harmony exports Rec601, ITU_T_H273_VALUE22, SRGB, P3, A98RGB, ProPhotoRGB, XYZD50, XYZD65, AppleGenericRGB, WideGamutColorSpin */
/* harmony import */ var common_math_Matrix3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/math/Matrix3 */ "./src/common/math/Matrix3.ts");
/* harmony import */ var common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/math/Vector3 */ "./src/common/math/Vector3.ts");
/* harmony import */ var common_math_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/math/matrix */ "./src/common/math/matrix.ts");
/* harmony import */ var common_math_vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/math/vector */ "./src/common/math/vector.ts");
/*
 * libmedia primary defined
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




// Rec. ITU-R BT.709-6, value 1.
const Rec709 = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06, 0.3127, 0.329];
// Rec. ITU-R BT.470-6 System M (historical), value 4.
const Rec470SystemM = [0.67, 0.33, 0.21, 0.71, 0.14, 0.08, 0.31, 0.316];
// Rec. ITU-R BT.470-6 System B, G (historical), value 5.
const Rec470SystemBG = [0.64, 0.33, 0.29, 0.60, 0.15, 0.06, 0.3127, 0.3290];
// Rec. ITU-R BT.601-7 525, value 6.
const Rec601 = [0.630, 0.340, 0.310, 0.595, 0.155, 0.070, 0.3127, 0.3290];
// SMPTE ST 240, value 7 (functionally the same as value 6).
const SMPTE_ST_240 = Rec601;
// Generic film (colour filters using Illuminant C), value 8.
const GenericFilm = [0.681, 0.319, 0.243, 0.692, 0.145, 0.049, 0.310, 0.316];
// Rec. ITU-R BT.2020-2, value 9.
const Rec2020 = [0.708, 0.292, 0.170, 0.797, 0.131, 0.046, 0.3127, 0.3290];
// SMPTE ST 428-1, value 10.
const SMPTE_ST_428_1 = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.3333333333333333, 0.3333333333333333];
// SMPTE RP 431-2, value 11.
const SMPTE_RP_431_2 = [0.680, 0.320, 0.265, 0.690, 0.150, 0.060, 0.314, 0.351];
// SMPTE EG 432-1, value 12.
const SMPTE_EG_432_1 = [0.680, 0.320, 0.265, 0.690, 0.150, 0.060, 0.3127, 0.3290];
// No corresponding industry specification identified, value 22.
// This is sometimes referred to as EBU 3213-E, but that document doesn't
// specify these values.
const ITU_T_H273_VALUE22 = [0.630, 0.340, 0.295, 0.605, 0.155, 0.077, 0.3127, 0.3290];
// CSS Color Level 4 predefined and xyz color spaces.
// 'srgb'
const SRGB = Rec709;
// 'display-p3' (and also 'p3' as a color gamut).
const P3 = SMPTE_EG_432_1;
// 'a98-rgb'
const A98RGB = [0.64, 0.33, 0.21, 0.71, 0.15, 0.06, 0.3127, 0.3290];
// 'prophoto-rgb'
const ProPhotoRGB = [0.7347, 0.2653, 0.1596, 0.8404, 0.0366, 0.0001, 0.34567, 0.35850];
// 'rec2020' (as both a predefined color space and color gamut).
// The value kRec2020 is already defined above.
// 'xyzd50'
const XYZD50 = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.34567, 0.35850];
// 'xyz' and 'xyzd65'
const XYZD65 = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.3127, 0.3290];
// //////////////////////////////////////////////////////////////////////////////
// Additional helper color primaries.
// Invalid primaries, initialized to zero.
const Invalid = [0, 0, 0, 0, 0, 0, 0, 0];
// The GenericRGB space on macOS.
const AppleGenericRGB = [0.63002, 0.34000, 0.29505, 0.60498, 0.15501, 0.07701, 0.3127, 0.3290];
// Primaries where the colors are rotated and the gamut is huge. Good for
// testing.
const WideGamutColorSpin = [0.01, 0.98, 0.01, 0.01, 0.98, 0.01, 0.3127, 0.3290];
function adaptToXYZ50(wx, wy) {
    const wXYZ = new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([wx / wy, 1, (1 - wx - wy) / wy]);
    const wXYZD50 = new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([0.96422, 1.0, 0.82521]);
    const xyzToLms = common_math_Matrix3__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
        0.8951, 0.2664, -0.1614,
        -0.7502, 1.7135, 0.0367,
        0.0389, -0.0685, 1.0296
    ]);
    const lmsToXyz = common_math_Matrix3__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
        0.9869929, -0.1470543, 0.1599627,
        0.4323053, 0.5183603, 0.0492912,
        -0.0085287, 0.0400428, 0.9684867
    ]);
    const srcCone = (0,common_math_vector__WEBPACK_IMPORTED_MODULE_3__.mvMul)(xyzToLms, wXYZ);
    const dstCone = (0,common_math_vector__WEBPACK_IMPORTED_MODULE_3__.mvMul)(xyzToLms, wXYZD50);
    let toXYZD50 = new common_math_Matrix3__WEBPACK_IMPORTED_MODULE_0__["default"]([
        dstCone.x / srcCone.x, 0, 0,
        0, dstCone.y / srcCone.y, 0,
        0, 0, dstCone.z / srcCone.z
    ]);
    toXYZD50 = (0,common_math_matrix__WEBPACK_IMPORTED_MODULE_2__.concat3x3)(toXYZD50, xyzToLms);
    toXYZD50 = (0,common_math_matrix__WEBPACK_IMPORTED_MODULE_2__.concat3x3)(lmsToXyz, toXYZD50);
    return toXYZD50;
}
function primariesToXYZD50(pri) {
    const matrix3 = common_math_Matrix3__WEBPACK_IMPORTED_MODULE_0__["default"].RowMajor([
        pri[0], pri[2], pri[4],
        pri[1], pri[3], pri[5],
        1 - pri[0] - pri[1], 1 - pri[2] - pri[3], 1 - pri[4] - pri[5]
    ]);
    const matrix3Inv = matrix3.copy().invert();
    const wXYZ = new common_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([pri[6] / pri[7], 1, (1 - pri[6] - pri[7]) / pri[7]]);
    const XYZ = (0,common_math_vector__WEBPACK_IMPORTED_MODULE_3__.mvMul)(matrix3Inv, wXYZ);
    let toXYZ = new common_math_Matrix3__WEBPACK_IMPORTED_MODULE_0__["default"]([
        XYZ.x, 0, 0,
        0, XYZ.y, 0,
        0, 0, XYZ.z
    ]);
    toXYZ = (0,common_math_matrix__WEBPACK_IMPORTED_MODULE_2__.concat3x3)(matrix3, toXYZ);
    const dxToD50 = adaptToXYZ50(pri[6], pri[7]);
    return (0,common_math_matrix__WEBPACK_IMPORTED_MODULE_2__.concat3x3)(dxToD50, toXYZ);
}


/***/ }),

/***/ "./src/avrender/image/colorSpace/transferFns.ts":
/*!******************************************************!*\
  !*** ./src/avrender/image/colorSpace/transferFns.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TransferFn470SystemBG: () => (/* binding */ TransferFn470SystemBG),
/* harmony export */   TransferFn470SystemM: () => (/* binding */ TransferFn470SystemM),
/* harmony export */   TransferFnLinear: () => (/* binding */ TransferFnLinear),
/* harmony export */   TransferFnSMPETST428_1: () => (/* binding */ TransferFnSMPETST428_1),
/* harmony export */   TransferFnSMPTEST240: () => (/* binding */ TransferFnSMPTEST240),
/* harmony export */   TransferFnSRGB: () => (/* binding */ TransferFnSRGB)
/* harmony export */ });
/* unused harmony exports TransferFnRec709, TransferFn2Dot2, TransferFnRec2020, TransferFnPQ, TransferFnHLG */
/*
 * libmedia transfer defined
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const TransferFnRec709 = {
    g: 2.222222222222, a: 0.909672415686, b: 0.090327584314, c: 0.222222222222, d: 0.081242858299, e: 0.0, f: 0.0
};
const TransferFn470SystemM = {
    g: 2.2, a: 1.0, b: 0.0, c: 0.0, d: 0.0, e: 0.0, f: 0.0
};
const TransferFn470SystemBG = {
    g: 2.8, a: 1.0, b: 0.0, c: 0.0, d: 0.0, e: 0.0, f: 0.0
};
const TransferFnSMPTEST240 = {
    g: 2.222222222222, a: 0.899626676224, b: 0.100373323776, c: 0.25, d: 0.091286342118, e: 0.0, f: 0.0
};
const TransferFnLinear = {
    g: 1.0, a: 1.0, b: 0.0, c: 0.0, d: 0.0, e: 0.0, f: 0.0
};
const TransferFnSRGB = {
    g: 2.4, a: 0.9478672985781991, b: 0.05213270142180095, c: 0.07739938080495357, d: 0.04045, e: 0.0, f: 0.0
};
// eslint-disable-next-line camelcase
const TransferFnSMPETST428_1 = {
    g: 2.6, a: 1.034080527699, b: 0.0, c: 0.0, d: 0.0, e: 0.0, f: 0.0
};
const TransferFn2Dot2 = {
    g: 2.2, a: 1.0, b: 0.0, c: 0.0, d: 0.0, e: 0.0, f: 0.0
};
const TransferFnRec2020 = {
    g: 2.22222, a: 0.909672, b: 0.0903276, c: 0.222222, d: 0.0812429, e: 0.0, f: 0.0
};
const TransferFnPQ = {
    g: -2.0, a: -107 / 128.0, b: 1.0, c: 0.012683313515655966, d: 18.8515625, e: -2392 / 128, f: 6.277394636015326
};
const TransferFnHLG = {
    g: -3.0, a: 2.0, b: 2.0, c: 5.591816309728916, d: 0.28466892, e: 0.55991073, f: 0.0
};


/***/ }),

/***/ "./src/avrender/image/colorTransform/colorTransformHLGOOTF.ts":
/*!********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/colorTransformHLGOOTF.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeHLGToneMapConstants: () => (/* binding */ computeHLGToneMapConstants),
/* harmony export */   "default": () => (/* binding */ colorTransformHLGOOTF)
/* harmony export */ });
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./options */ "./src/avrender/image/colorTransform/options.ts");
/*
 * libmedia hlg ootf
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

// The luminance vector in rec2020 linear space.
const kLr = 0.2627;
const kLg = 0.6780;
const kLb = 0.0593;
function computeHLGToneMapConstants(options) {
    options.metadata.hlgDstMaxLuminanceRelative = options.dstMaxLuminanceRelative;
    const dstMaxLuminanceNits = options.dstSdrMaxLuminanceNits * options.dstMaxLuminanceRelative;
    options.metadata.hlgOOTFGammaMinusOne = 1.2 + 0.42 * Math.log10(dstMaxLuminanceNits / _options__WEBPACK_IMPORTED_MODULE_0__.HLGRefMaxLumNits) / Math.log10(10.0) - 1.0;
}
function colorTransformHLGOOTF(options) {
    if (options.type === 0 /* GLType.kWebGL */) {
        return `
      {
        vec4 luma_vec = vec4(${kLr}, ${kLg}, ${kLb}, 0.0);
        float L = dot(color, luma_vec);
        if (L > 0.0) {
          color.r *= pow(L, hlg_ootf_gamma_minus_one);
          color.g *= pow(L, hlg_ootf_gamma_minus_one);
          color.b *= pow(L, hlg_ootf_gamma_minus_one);
          color.r *= hlg_dst_max_luminance_relative;
          color.g *= hlg_dst_max_luminance_relative;
          color.b *= hlg_dst_max_luminance_relative;
        }
      }
    `;
    }
    else if (options.type === 1 /* GLType.kWebGPU */) {
        return `
      {
        let luma_vec: vec4<f32> = vec4(${kLr}, ${kLg}, ${kLb}, 0.0);
        let L: f32 = dot(color, luma_vec);
        if (L > 0.0) {
          color.r *= pow(L, hlg_ootf_gamma_minus_one);
          color.g *= pow(L, hlg_ootf_gamma_minus_one);
          color.b *= pow(L, hlg_ootf_gamma_minus_one);
          color.r *= hlg_dst_max_luminance_relative;
          color.g *= hlg_dst_max_luminance_relative;
          color.b *= hlg_dst_max_luminance_relative;
        }
      }
    `;
    }
    return '';
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/colorTransformMatrix.ts":
/*!*******************************************************************!*\
  !*** ./src/avrender/image/colorTransform/colorTransformMatrix.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ colorTransformMatrix)
/* harmony export */ });
/*
 * libmedia color transform matrix
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function colorTransformMatrix(matrix, options) {
    let mat4String = '';
    let vec4String = '';
    if (options.type === 0 /* GLType.kWebGL */) {
        mat4String = 'mat4';
        vec4String = 'vec4';
    }
    else if (options.type === 1 /* GLType.kWebGPU */) {
        mat4String = 'mat4x4';
        vec4String = 'vec4';
    }
    if (!mat4String || !vec4String) {
        return '';
    }
    let source = `
      color = ${mat4String}(
        ${matrix.rc(0, 0)}, ${matrix.rc(1, 0)}, ${matrix.rc(2, 0)}, 0,
        ${matrix.rc(0, 1)}, ${matrix.rc(1, 1)}, ${matrix.rc(2, 1)}, 0,
        ${matrix.rc(0, 2)}, ${matrix.rc(1, 2)}, ${matrix.rc(2, 2)}, 0,
        0, 0, 0, 1
      ) * color;
    `;
    if (matrix.rc(0, 3) !== 0 || matrix.rc(1, 3) !== 0 || matrix.rc(2, 3) !== 0) {
        source += `
        color += ${vec4String}(${matrix.rc(0, 3)}, ${matrix.rc(1, 3)}, ${matrix.rc(2, 3)}, 0);
      `;
    }
    return source;
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/colorTransformSdrToDstNitsRelative.ts":
/*!*********************************************************************************!*\
  !*** ./src/avrender/image/colorTransform/colorTransformSdrToDstNitsRelative.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeSdrRelativeToNitsFactor: () => (/* binding */ computeSdrRelativeToNitsFactor),
/* harmony export */   "default": () => (/* binding */ colorTransformSdrToDstNitsRelative)
/* harmony export */ });
/*
 * libmedia color transform sdr to dst nits relative
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function computeSdrRelativeToNitsFactor(unityNits, options) {
    options.metadata.sdrRelativeToNitsFactor = options.dstSdrMaxLuminanceNits / unityNits;
}
function colorTransformSdrToDstNitsRelative(options) {
    return `
    color.r *= sdr_relative_to_nits_factor;
    color.g *= sdr_relative_to_nits_factor;
    color.b *= sdr_relative_to_nits_factor;
 `;
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/colorTransformSrcNitsToSdrRelative.ts":
/*!*********************************************************************************!*\
  !*** ./src/avrender/image/colorTransform/colorTransformSrcNitsToSdrRelative.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeNitsToSdrRelativeFactor: () => (/* binding */ computeNitsToSdrRelativeFactor),
/* harmony export */   "default": () => (/* binding */ colorTransformSrcNitsToSdrRelative)
/* harmony export */ });
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./options */ "./src/avrender/image/colorTransform/options.ts");
/*
 * libmedia color transform src nits to sdr relative
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function computeNitsToSdrRelativeFactor(unityNits, useSrcSdrWhite, options) {
    let sdrWhiteNits = options.dstSdrMaxLuminanceNits;
    if (useSrcSdrWhite) {
        sdrWhiteNits = _options__WEBPACK_IMPORTED_MODULE_0__.DefaultSDRWhiteLevel;
        if (options.ndwl) {
            sdrWhiteNits = options.ndwl;
        }
    }
    options.metadata.nitsToSdrRelativeFactor = unityNits / sdrWhiteNits;
}
function colorTransformSrcNitsToSdrRelative(options) {
    return `
    color.r *= nits_to_sdr_relative_factor;
    color.g *= nits_to_sdr_relative_factor;
    color.b *= nits_to_sdr_relative_factor;
  `;
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/colorTransformToneMapInRec2020Linear.ts":
/*!***********************************************************************************!*\
  !*** ./src/avrender/image/colorTransform/colorTransformToneMapInRec2020Linear.ts ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeTonemapAB: () => (/* binding */ computeTonemapAB),
/* harmony export */   "default": () => (/* binding */ colorTransformToneMapInRec2020Linear)
/* harmony export */ });
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./options */ "./src/avrender/image/colorTransform/options.ts");
/*
 * libmedia colorTransform tone map in rec2020 linear
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function computeSrcMaxLumRelative(src, options) {
    let srcMaxLumNits = _options__WEBPACK_IMPORTED_MODULE_0__.HLGRefMaxLumNits;
    if (src.getTransferId() !== 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */) {
        if (options.maxContentLightLevel > 0) {
            srcMaxLumNits = options.maxContentLightLevel;
        }
    }
    return srcMaxLumNits / options.dstSdrMaxLuminanceNits;
}
function computeTonemapAB(src, options) {
    const srcMaxLumRelative = computeSrcMaxLumRelative(src, options);
    if (srcMaxLumRelative > options.dstMaxLuminanceRelative) {
        options.metadata.pqTonemapA = options.dstMaxLuminanceRelative /
            (srcMaxLumRelative * srcMaxLumRelative);
        options.metadata.pqTonemapB = 1.0 / options.dstMaxLuminanceRelative;
    }
    else {
        options.metadata.pqTonemapA = 0;
        options.metadata.pqTonemapB = 0;
    }
}
function colorTransformToneMapInRec2020Linear(options) {
    return `
    {
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let maximum: f32' : 'float maximum'} = max(color.r, max(color.g, color.b));
      if (maximum > 0.0) {
        color.r *= (1.0 + pq_tonemap_a * maximum) / (1.0 + pq_tonemap_b * maximum);
        color.g *= (1.0 + pq_tonemap_a * maximum) / (1.0 + pq_tonemap_b * maximum);
        color.b *= (1.0 + pq_tonemap_a * maximum) / (1.0 + pq_tonemap_b * maximum);
      }
    }
 `;
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/function/toFloatString.ts":
/*!*********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/function/toFloatString.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toFloatString)
/* harmony export */ });
/*
 * libmedia to float string
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function toFloatString(v) {
    if (v === (v >>> 0)) {
        return `${v}.0`;
    }
    return v.toString();
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/generateSteps.ts":
/*!************************************************************!*\
  !*** ./src/avrender/image/colorTransform/generateSteps.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ generateSteps)
/* harmony export */ });
/* harmony import */ var _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colorSpace/ColorSpace */ "./src/avrender/image/colorSpace/ColorSpace.ts");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./options */ "./src/avrender/image/colorTransform/options.ts");
/* harmony import */ var _colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./colorTransformMatrix */ "./src/avrender/image/colorTransform/colorTransformMatrix.ts");
/* harmony import */ var _transferFn_hlgInvOETF__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transferFn/hlgInvOETF */ "./src/avrender/image/colorTransform/transferFn/hlgInvOETF.ts");
/* harmony import */ var _transferFn_pq2Linear__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transferFn/pq2Linear */ "./src/avrender/image/colorTransform/transferFn/pq2Linear.ts");
/* harmony import */ var _transferFn_transferFn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transferFn/transferFn */ "./src/avrender/image/colorTransform/transferFn/transferFn.ts");
/* harmony import */ var _transferFn_toLinear__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transferFn/toLinear */ "./src/avrender/image/colorTransform/transferFn/toLinear.ts");
/* harmony import */ var _colorTransformHLGOOTF__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./colorTransformHLGOOTF */ "./src/avrender/image/colorTransform/colorTransformHLGOOTF.ts");
/* harmony import */ var _colorTransformSrcNitsToSdrRelative__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./colorTransformSrcNitsToSdrRelative */ "./src/avrender/image/colorTransform/colorTransformSrcNitsToSdrRelative.ts");
/* harmony import */ var _colorTransformToneMapInRec2020Linear__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./colorTransformToneMapInRec2020Linear */ "./src/avrender/image/colorTransform/colorTransformToneMapInRec2020Linear.ts");
/* harmony import */ var _colorTransformSdrToDstNitsRelative__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./colorTransformSdrToDstNitsRelative */ "./src/avrender/image/colorTransform/colorTransformSdrToDstNitsRelative.ts");
/* harmony import */ var _transferFn_hlgOETF__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./transferFn/hlgOETF */ "./src/avrender/image/colorTransform/transferFn/hlgOETF.ts");
/* harmony import */ var _transferFn_pqFromLinear__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transferFn/pqFromLinear */ "./src/avrender/image/colorTransform/transferFn/pqFromLinear.ts");
/* harmony import */ var _transferFn_fromLinear__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./transferFn/fromLinear */ "./src/avrender/image/colorTransform/transferFn/fromLinear.ts");
/*
 * libmedia generate fragment steps
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */














function generateSteps(src, dst, options) {
    const steps = [];
    const srcMatrixIsIdentityOrYcgco = src.getMatrixId() === 8 /* AVColorSpace.AVCOL_SPC_YCOCG */;
    // 1. limited range  full range
    const srcRangeAdjustStep = (0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(src.getRangeAdjustMatrix(options.bitDepth), options);
    if (!srcMatrixIsIdentityOrYcgco) {
        steps.push(srcRangeAdjustStep);
    }
    if (src.getMatrixId() === 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */) {
        // BT2020 CL is a special case.
        // not to do
    }
    else {
        // 2.  ColorSpace MatrixYCbCr  RGB
        steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(src.getTransferMatrix(options.bitDepth).invert(), options));
    }
    if (srcMatrixIsIdentityOrYcgco) {
        steps.push(srcRangeAdjustStep);
    }
    if (dst.isValid()) {
        if ( true && src.isHDR()) {
            switch (src.getTransferId()) {
                // 3.  HLG  HLG  OETF
                case 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */:
                    steps.push((0,_transferFn_hlgInvOETF__WEBPACK_IMPORTED_MODULE_3__["default"])(options));
                    break;
                // 3.  PQ  PQ 
                case 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */:
                    steps.push((0,_transferFn_pq2Linear__WEBPACK_IMPORTED_MODULE_4__["default"])(options));
                    break;
                default:
                    const fn = src.getTransferFunction();
                    if (fn) {
                        steps.push((0,_transferFn_transferFn__WEBPACK_IMPORTED_MODULE_5__["default"])(fn, src.hasExtendedSkTransferFn(), options));
                    }
                    else {
                        steps.push((0,_transferFn_toLinear__WEBPACK_IMPORTED_MODULE_6__["default"])(src.getTransferId(), options));
                    }
            }
            if (src.getMatrixId() === 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */) {
                steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(src.getTransferMatrix(options.bitDepth).invert(), options));
            }
            // 4. RGB  XYZ 
            steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(src.getPrimaryMatrix(), options));
            const rec2020Linear = new _colorSpace_ColorSpace__WEBPACK_IMPORTED_MODULE_0__["default"](0 /* AVColorSpace.AVCOL_SPC_RGB */, 9 /* AVColorPrimaries.AVCOL_PRI_BT2020 */, 8 /* AVColorTransferCharacteristic.AVCOL_TRC_LINEAR */, 2 /* AVColorRange.AVCOL_RANGE_JPEG */);
            switch (src.getTransferId()) {
                // HLG
                case 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */:
                    if (options.toneMapPQAndHlgToDst) {
                        (0,_colorTransformHLGOOTF__WEBPACK_IMPORTED_MODULE_7__.computeHLGToneMapConstants)(options);
                        steps.push((0,_colorTransformHLGOOTF__WEBPACK_IMPORTED_MODULE_7__["default"])(options));
                    }
                    else {
                        (0,_colorTransformSrcNitsToSdrRelative__WEBPACK_IMPORTED_MODULE_8__.computeNitsToSdrRelativeFactor)(12.0 / _options__WEBPACK_IMPORTED_MODULE_1__.DefaultSDRWhiteLevel, false, options);
                        steps.push((0,_colorTransformSrcNitsToSdrRelative__WEBPACK_IMPORTED_MODULE_8__["default"])(options));
                    }
                    break;
                case 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */:
                    (0,_colorTransformSrcNitsToSdrRelative__WEBPACK_IMPORTED_MODULE_8__.computeNitsToSdrRelativeFactor)(_options__WEBPACK_IMPORTED_MODULE_1__.PQRefMaxLumNits, true, options);
                    steps.push((0,_colorTransformSrcNitsToSdrRelative__WEBPACK_IMPORTED_MODULE_8__["default"])(options));
                    if (options.toneMapPQAndHlgToDst) {
                        // 5. XYZ  Rec2020
                        steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(rec2020Linear.getPrimaryMatrix().invert(), options));
                        (0,_colorTransformToneMapInRec2020Linear__WEBPACK_IMPORTED_MODULE_9__.computeTonemapAB)(src, options);
                        // 6.  + UI  Tone Mapping
                        steps.push((0,_colorTransformToneMapInRec2020Linear__WEBPACK_IMPORTED_MODULE_9__["default"])(options));
                        // 7. Rec2020  XYZ
                        steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(rec2020Linear.getPrimaryMatrix(), options));
                    }
                    break;
                default:
                    break;
            }
            // 8. XYZ  RGB
            steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(dst.getPrimaryMatrix().invert(), options));
            if (dst.getMatrixId() === 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */) {
                steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(dst.getTransferMatrix(options.bitDepth), options));
            }
            switch (dst.getTransferId()) {
                // 9.  HLG  HLG  OETF
                case 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */:
                    (0,_colorTransformSdrToDstNitsRelative__WEBPACK_IMPORTED_MODULE_10__.computeSdrRelativeToNitsFactor)(_options__WEBPACK_IMPORTED_MODULE_1__.DefaultSDRWhiteLevel, options);
                    steps.push((0,_colorTransformSdrToDstNitsRelative__WEBPACK_IMPORTED_MODULE_10__["default"])(options));
                    steps.push((0,_transferFn_hlgOETF__WEBPACK_IMPORTED_MODULE_11__["default"])(options));
                    break;
                // 9  PQ  PQ 
                case 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */:
                    (0,_colorTransformSdrToDstNitsRelative__WEBPACK_IMPORTED_MODULE_10__.computeSdrRelativeToNitsFactor)(_options__WEBPACK_IMPORTED_MODULE_1__.PQRefMaxLumNits, options);
                    steps.push((0,_colorTransformSdrToDstNitsRelative__WEBPACK_IMPORTED_MODULE_10__["default"])(options));
                    steps.push((0,_transferFn_pqFromLinear__WEBPACK_IMPORTED_MODULE_12__["default"])(options));
                default:
                    const fn = dst.getInverseTransferFunction();
                    if (fn) {
                        steps.push((0,_transferFn_transferFn__WEBPACK_IMPORTED_MODULE_5__["default"])(fn, src.hasExtendedSkTransferFn(), options));
                    }
                    else {
                        steps.push((0,_transferFn_fromLinear__WEBPACK_IMPORTED_MODULE_13__["default"])(src.getTransferId(), options));
                    }
                    break;
            }
        }
        /**
         *  RGB 
         *  RGB  
         * 
         */
        if (!options.outputRGB) {
            const dstMatrixIsIdentityOrYcgco = dst.getMatrixId() === 8 /* AVColorSpace.AVCOL_SPC_YCOCG */;
            // 10. Range 
            const dstRangeAdjustStep = (0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(dst.getRangeAdjustMatrix(options.bitDepth).invert(), options);
            if (dstMatrixIsIdentityOrYcgco) {
                steps.push(dstRangeAdjustStep);
            }
            if (dst.getMatrixId() === 10 /* AVColorSpace.AVCOL_SPC_BT2020_CL */) {
                // not to do
            }
            else {
                steps.push((0,_colorTransformMatrix__WEBPACK_IMPORTED_MODULE_2__["default"])(dst.getTransferMatrix(options.bitDepth), options));
            }
            if (!dstMatrixIsIdentityOrYcgco) {
                steps.push(dstRangeAdjustStep);
            }
        }
    }
    return steps;
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/options.ts":
/*!******************************************************!*\
  !*** ./src/avrender/image/colorTransform/options.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultSDRWhiteLevel: () => (/* binding */ DefaultSDRWhiteLevel),
/* harmony export */   HLGRefMaxLumNits: () => (/* binding */ HLGRefMaxLumNits),
/* harmony export */   PQRefMaxLumNits: () => (/* binding */ PQRefMaxLumNits)
/* harmony export */ });
/*
 * libmedia ColorTransformOptions defined
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const DefaultSDRWhiteLevel = 203.0;
// The maximum brightness of the reference display for HLG computations.
const HLGRefMaxLumNits = 1000.0;
// The maximum reference brightness of a PQ signal.
const PQRefMaxLumNits = 10000.0;


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts":
/*!********************************************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ colorTransformPerChannelTransferFn)
/* harmony export */ });
/*
 * libmedia colorTransformPerChannelTransferFn
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function colorTransformPerChannelTransferFn(fn, extended, options) {
    if (extended) {
        return `
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = abs(color.r);
        ${fn()}
        color.r = sign(color.r) * v;
      }
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = abs(color.g);
        ${fn()}
        color.g = sign(color.g) * v;
      }
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = abs(color.b);
        ${fn()}
        color.b = sign(color.b) * v;
      }
    `;
    }
    else {
        return `
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = color.r;
        ${fn()}
        color.r = v;
      }
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = color.g;
        ${fn()}
        color.g = v;
      }
      {
        ${options.type === 1 /* GLType.kWebGPU */ ? 'var v: f32' : 'float v'} = color.b;
        ${fn()}
        color.b = v;
      }
    `;
    }
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/fromLinear.ts":
/*!********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/fromLinear.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fromLinear)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia linear oetf
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function fromLinear(transferId, options) {
    function fn() {
        switch (transferId) {
            case 9 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG */:
                return `
          if (v < 0.0) {
            v = 0.0;
          }
          else {
            v =  1.0 + log(v) / log(10.0) / 2.0;
          }
        `;
            case 10 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG_SQRT */:
                return `
          if (v < sqrt(10.0) / 1000.0)
            v = 0.0;
          }
          else {
            v = 1.0 + log(v) / log(10.0) / 2.5;
          }
        `;
            case 11 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4 */:
                return `
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 1.099296826809442;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let b: f32' : 'float b'}= 0.018053968510807;
          if (v < -b) {
            v = -a * pow(-v, 0.45) + (a - 1.0);
          }
          else if (v <= b) {
            v = 4.5 * v;
          }
          else {
            v = a * pow(v, 0.45) - (a - 1.0);
          }
        `;
            case 12 /* AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG */:
                return `
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 1.099;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let b: f32' : 'float b'} = 0.018;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let l: f32' : 'float l'} = 0.0045;

          if (v < -l) {
            v = -(a * pow(-4.0 * v, 0.45) + (a - 1.0)) / 4.0;
          }
          else if (v <= b) {
            v = 4.5 * v;
          }
          else {
            v = a * pow(v, 0.45) - (a - 1.0);
          }
        `;
            default:
                return '';
        }
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/hlgInvOETF.ts":
/*!********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/hlgInvOETF.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hlgInvOETF)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia hlg oetf
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function hlgInvOETF(options) {
    function fn() {
        let source = `
      v = max(0.0, v);
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 0.17883277f;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let b: f32' : 'float b'} = 0.28466892f;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c: f32' : 'float c'} = 0.55991073f;
      if (v <= 0.5) {
        v = v * v + 4.0;
      }
      else {
        v = exp((v - c) / a) + b;
      }
      v = v / 12.0;
    `;
        return source;
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/hlgOETF.ts":
/*!*****************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/hlgOETF.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hlgOETF)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia hlg oetf
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function hlgOETF(options) {
    function fn() {
        let source = `
      v = max(0.0, v);
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 0.17883277f;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let b: f32' : 'float b'} = 0.28466892f;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c: f32' : 'float c'} = 0.55991073f;
      if (v <= 1.0) {
        v = 0.5 * sqrt(v);
      }
      else {
        v = a * log(v - b) + c;
      }
    `;
        return source;
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/pq2Linear.ts":
/*!*******************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/pq2Linear.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pq2Linear)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia pq eotf
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function pq2Linear(options) {
    function fn() {
        let source = `
      v = max(0.0, v);
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let m1: f32' : 'float m1'} = (2610.0 / 4096.0) / 4.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let m2: f32' : 'float m2'} = (2523.0 / 4096.0) * 128.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c1: f32' : 'float c1'} = 3424.0 / 4096.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c2: f32' : 'float c2'} = (2413.0 / 4096.0) * 32.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c3: f32' : 'float c3'} = (2392.0 / 4096.0) * 32.0;
      
      ${options.type === 0 /* GLType.kWebGL */ ? `
        #ifdef GL_FRAGMENT_PRECISION_HIGH
        highp float v2 = v;
        #else
        float v2 = v;
        #endif
      ` : 'var v2: f32 = v;'}
  
      v2 = pow(max(pow(v2, 1.0 / m2) - c1, 0.0) / (c2 - c3 * pow(v2, 1.0 / m2)), 1.0 / m1);
      v = v2;
    `;
        return source;
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/pqFromLinear.ts":
/*!**********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/pqFromLinear.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pqFromLinear)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia pq oetf
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function pqFromLinear(options) {
    function fn() {
        let source = `
      v = max(0.0, v);
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let m1: f32' : 'float m1'} = (2610.0 / 4096.0) / 4.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let m2: f32' : 'float m2'} = (2523.0 / 4096.0) * 128.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c1: f32' : 'float c1'} = 3424.0 / 4096.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c2: f32' : 'float c2'} = (2413.0 / 4096.0) * 32.0;
      ${options.type === 1 /* GLType.kWebGPU */ ? 'let c3: f32' : 'float c3'} = (2392.0 / 4096.0) * 32.0;
      v =  pow((c1 + c2 * pow(v, m1)) / (1.0 + c3 * pow(v, m1)), m2);
    `;
        return source;
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/toLinear.ts":
/*!******************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/toLinear.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toLinear)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/*
 * libmedia linear eotf
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function toLinear(transferId, options) {
    function fn() {
        switch (transferId) {
            case 9 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG */:
                return `
          if (v < 0.0) {
            v = 0.0;
          }
          else {
            v = pow(10.0, (v - 1.0) * 2.0);
          }
        `;
            case 10 /* AVColorTransferCharacteristic.AVCOL_TRC_LOG_SQRT */:
                return `
          if (v < 0.0) {
            v = 0.0;
          }
          else {
            v = pow(10.0, (v - 1.0) * 2.5);
          }
        `;
            case 11 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4 */:
                return `
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 1.099296826809442;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let from_linear_neg_a: f32' : 'float from_linear_neg_a'} = -1.047844;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let from_linear_b: f32' : 'float from_linear_b'} = 0.081243;
          if (v < from_linear_neg_a) {
            v = -pow((a - 1.0 - v) / a, 1.0 / 0.45);
          }
          else if (v <= from_linear_b) {
            v = v / 4.5;
          }
          else {
            v = pow((v + a - 1.0) / a, 1.0 / 0.45);
          }
        `;
            case 12 /* AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG */:
                return `
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let a: f32' : 'float a'} = 1.099;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let from_linear_neg_l: f32' : 'float from_linear_neg_l'} = -0.020250;
          ${options.type === 1 /* GLType.kWebGPU */ ? 'let from_linear_b: f32' : 'float from_linear_b'} = 0.081000;
          if (v < from_linear_neg_l) {
            v = -pow((1.0 - a - v * 4.0) / a, 1.0 / 0.45) / 4.0;
          }
          else if (v <= from_linear_b) {
            v = v / 4.5;
          }
          else {
            v = pow((v + a - 1.0) / a, 1.0 / 0.45);
          }
        `;
            default:
                return '';
        }
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/colorTransform/transferFn/transferFn.ts":
/*!********************************************************************!*\
  !*** ./src/avrender/image/colorTransform/transferFn/transferFn.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ transferFn)
/* harmony export */ });
/* harmony import */ var _colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorTransformPerChannelTransferFn */ "./src/avrender/image/colorTransform/transferFn/colorTransformPerChannelTransferFn.ts");
/* harmony import */ var _function_toFloatString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/toFloatString */ "./src/avrender/image/colorTransform/function/toFloatString.ts");
/*
 * libmedia transfer fn
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function transferFn(tfn, extended, options) {
    function fn() {
        let epsilon = 0.0009765625;
        let linear = 'v';
        if (Math.abs(tfn.c - 1.0) > epsilon) {
            linear = `${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_1__["default"])(tfn.c)} * ${linear}`;
        }
        if (Math.abs(tfn.f) > epsilon) {
            linear = `${linear} + ${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_1__["default"])(tfn.f)}`;
        }
        let nonlinear = 'v';
        if (Math.abs(tfn.a = 1.0) > epsilon) {
            nonlinear = `${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_1__["default"])(tfn.a)} * ${nonlinear}`;
        }
        if (Math.abs(tfn.b) > epsilon) {
            nonlinear = `${nonlinear} + ${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_1__["default"])(tfn.b)}`;
        }
        if (Math.abs(tfn.g - 1.0) > epsilon) {
            nonlinear = `pow(${nonlinear}, ${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_1__["default"])(tfn.g)})`;
        }
        if (Math.abs(tfn.e) > epsilon) {
            nonlinear = `${nonlinear} + ${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_1__["default"])(tfn.e)}`;
        }
        let source = `
      if (v < ${(0,_function_toFloatString__WEBPACK_IMPORTED_MODULE_1__["default"])(tfn.d)}) {
        v = ${linear};
      }
      else {
        v = ${nonlinear};
      }
    `;
        return source;
    }
    return (0,_colorTransformPerChannelTransferFn__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, false, options);
}


/***/ }),

/***/ "./src/avrender/image/function/flipVertex.ts":
/*!***************************************************!*\
  !*** ./src/avrender/image/function/flipVertex.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ flipVertex)
/* harmony export */ });
/*
 * libmedia flip vertex
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function flipVertex(vertex, flipHorizontal, flipVertical) {
    if (flipHorizontal) {
        let x = vertex[3];
        let y = vertex[4];
        vertex[3] = vertex[17];
        vertex[4] = vertex[18];
        vertex[17] = x;
        vertex[18] = y;
        x = vertex[10];
        y = vertex[11];
        vertex[10] = vertex[24];
        vertex[11] = vertex[25];
        vertex[24] = x;
        vertex[25] = y;
    }
    if (flipVertical) {
        let x = vertex[3];
        let y = vertex[4];
        vertex[3] = vertex[10];
        vertex[4] = vertex[11];
        vertex[10] = x;
        vertex[11] = y;
        x = vertex[17];
        y = vertex[18];
        vertex[17] = vertex[24];
        vertex[18] = vertex[25];
        vertex[24] = x;
        vertex[25] = y;
    }
}


/***/ }),

/***/ "./src/avrender/image/struct/HdrMetadata.ts":
/*!**************************************************!*\
  !*** ./src/avrender/image/struct/HdrMetadata.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HdrMetadata)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia HdrMetadata defined
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class HdrMetadata {
    offset;
    multiplier;
    pqTonemapA;
    pqTonemapB;
    hlgOOTFGammaMinusOne;
    hlgDstMaxLuminanceRelative;
    nitsToSdrRelativeFactor;
    sdrRelativeToNitsFactor;
}
(function (prototype) {
    var map = new Map();
    map.set("offset", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("multiplier", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("pqTonemapA", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("pqTonemapB", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("hlgOOTFGammaMinusOne", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("hlgDstMaxLuminanceRelative", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("nitsToSdrRelativeFactor", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("sdrRelativeToNitsFactor", { 0: 18, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 32);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(HdrMetadata.prototype);


/***/ }),

/***/ "./src/avrender/image/webgl/program/BaseProgram.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/image/webgl/program/BaseProgram.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseProgram)
/* harmony export */ });
/* harmony import */ var _Program__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Program */ "./src/avrender/image/webgl/program/Program.ts");
/*
 * libmedia BaseProgram
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class BaseProgram extends _Program__WEBPACK_IMPORTED_MODULE_0__["default"] {
    enableColor;
    aPoint;
    aColor;
    constructor(vertexShader, fragmentShader, enableColor = true) {
        super(vertexShader, fragmentShader);
        this.enableColor = enableColor;
    }
    link(gl) {
        super.link(gl);
        this.aPoint = this.gl.getAttribLocation(this.program, 'point');
        this.aColor = this.gl.getAttribLocation(this.program, 'color');
        if (this.enableColor) {
            this.gl.enableVertexAttribArray(this.aPoint);
            this.gl.enableVertexAttribArray(this.aColor);
        }
        else {
            this.gl.enableVertexAttribArray(this.aPoint);
        }
    }
    bind() {
        super.bind();
        if (this.enableColor) {
            this.gl.vertexAttribPointer(this.aPoint, 3, this.gl.FLOAT, false, 7 * Float32Array.BYTES_PER_ELEMENT, 0);
            this.gl.vertexAttribPointer(this.aColor, 4, this.gl.FLOAT, false, 7 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);
        }
        else {
            this.gl.vertexAttribPointer(this.aPoint, 3, this.gl.FLOAT, false, 7 * Float32Array.BYTES_PER_ELEMENT, 0);
        }
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/Program.ts":
/*!*****************************************************!*\
  !*** ./src/avrender/image/webgl/program/Program.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Program)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avrender\\image\\webgl\\program\\Program.ts";

class Program {
    gl;
    _program;
    vertexShader;
    fragmentShader;
    constructor(vertexShader, fragmentShader) {
        this.vertexShader = vertexShader;
        this.fragmentShader = fragmentShader;
    }
    link(gl) {
        this.gl = gl;
        if (this.vertexShader) {
            this.vertexShader.compile(this.gl);
        }
        if (this.fragmentShader) {
            this.fragmentShader.compile(this.gl);
        }
        // 
        this._program = this.gl.createProgram();
        this.gl.attachShader(this._program, this.vertexShader.shader);
        this.gl.attachShader(this._program, this.fragmentShader.shader);
        this.gl.linkProgram(this._program);
        if (true) {
            if (!this.gl.getProgramParameter(this._program, this.gl.LINK_STATUS)) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal(this.gl.getProgramInfoLog(this._program), cheap__fileName__0, 62);
            }
        }
    }
    stop() {
        this.vertexShader.stop(this.gl);
        this.fragmentShader.stop(this.gl);
        this.gl.deleteProgram(this._program);
        this.vertexShader = null;
        this.fragmentShader = null;
        this._program = null;
    }
    bind() {
        this.gl.useProgram(this._program);
    }
    get program() {
        return this._program;
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/RGB8Program.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/image/webgl/program/RGB8Program.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RGB8Program)
/* harmony export */ });
/* harmony import */ var _RGBProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RGBProgram */ "./src/avrender/image/webgl/program/RGBProgram.ts");
/*
 * libmedia RGB8Program
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class RGB8Program extends _RGBProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(rgbFragmentSource) {
        super(rgbFragmentSource);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/RGBProgram.ts":
/*!********************************************************!*\
  !*** ./src/avrender/image/webgl/program/RGBProgram.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RGBProgram)
/* harmony export */ });
/* harmony import */ var _VideoProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VideoProgram */ "./src/avrender/image/webgl/program/VideoProgram.ts");
/*
 * libmedia RGBProgram
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class RGBProgram extends _VideoProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    rgbSamplerLocation;
    constructor(rgbFragmentSource) {
        super(rgbFragmentSource);
    }
    link(gl) {
        super.link(gl);
        this.rgbSamplerLocation = this.gl.getUniformLocation(this.program, 'rgb_Sampler');
    }
    bindRGBTexture(unit = 0) {
        this.gl.uniform1i(this.rgbSamplerLocation, unit);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/VideoProgram.ts":
/*!**********************************************************!*\
  !*** ./src/avrender/image/webgl/program/VideoProgram.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoProgram)
/* harmony export */ });
/* harmony import */ var _BaseProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseProgram */ "./src/avrender/image/webgl/program/BaseProgram.ts");
/* harmony import */ var _shader_VertexShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader/VertexShader */ "./src/avrender/image/webgl/shader/VertexShader.ts");
/* harmony import */ var _shader_FragmentShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shader/FragmentShader */ "./src/avrender/image/webgl/shader/FragmentShader.ts");
/* harmony import */ var _glsl_vertex_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../glsl/vertex.vert */ "./src/avrender/image/webgl/glsl/vertex.vert");
/*
 * libmedia VideoProgram
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class VideoProgram extends _BaseProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    rotateMatrixLocation;
    constructor(yuvFragmentSource) {
        super(new _shader_VertexShader__WEBPACK_IMPORTED_MODULE_1__["default"](_glsl_vertex_vert__WEBPACK_IMPORTED_MODULE_3__["default"]), new _shader_FragmentShader__WEBPACK_IMPORTED_MODULE_2__["default"](yuvFragmentSource));
    }
    link(gl) {
        super.link(gl);
        this.rotateMatrixLocation = this.gl.getUniformLocation(this.program, 'rotateMatrix');
    }
    setRotateMatrix(matrix) {
        this.gl.uniformMatrix4fv(this.rotateMatrixLocation, false, new Float32Array(matrix));
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/YUV16Program.ts":
/*!**********************************************************!*\
  !*** ./src/avrender/image/webgl/program/YUV16Program.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ YUV16Program)
/* harmony export */ });
/* harmony import */ var _YUVProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./YUVProgram */ "./src/avrender/image/webgl/program/YUVProgram.ts");
/*
 * libmedia YUV16Program
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class YUV16Program extends _YUVProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    maxUniformLocation;
    offsetLocation;
    multiplierLocation;
    pqTonemapALocation;
    pqTonemapBLocation;
    hlgOOTFGammaMinusOneLocation;
    hlgDstMaxLuminanceRelativeLocation;
    nitsToSdrRelativeFactorLocation;
    sdrRelativeToNitsFactorLocation;
    constructor(yuvFragmentSource) {
        super(yuvFragmentSource);
    }
    link(gl) {
        super.link(gl);
        this.maxUniformLocation = this.gl.getUniformLocation(this.program, 'v_max');
        this.offsetLocation = this.gl.getUniformLocation(this.program, 'offset');
        this.multiplierLocation = this.gl.getUniformLocation(this.program, 'multiplier');
        this.pqTonemapALocation = this.gl.getUniformLocation(this.program, 'pq_tonemap_a');
        this.pqTonemapBLocation = this.gl.getUniformLocation(this.program, 'pq_tonemap_b');
        this.hlgOOTFGammaMinusOneLocation = this.gl.getUniformLocation(this.program, 'hlg_ootf_gamma_minus_one');
        this.hlgDstMaxLuminanceRelativeLocation = this.gl.getUniformLocation(this.program, 'hlg_dst_max_luminance_relative');
        this.nitsToSdrRelativeFactorLocation = this.gl.getUniformLocation(this.program, 'nits_to_sdr_relative_factor');
        this.sdrRelativeToNitsFactorLocation = this.gl.getUniformLocation(this.program, 'sdr_relative_to_nits_factor');
    }
    setMax(max) {
        this.gl.uniform1f(this.maxUniformLocation, max);
    }
    setMetaData(data) {
        this.gl.uniform1f(this.offsetLocation, data.offset);
        this.gl.uniform1f(this.multiplierLocation, data.multiplier);
        this.gl.uniform1f(this.pqTonemapALocation, data.pqTonemapA);
        this.gl.uniform1f(this.pqTonemapBLocation, data.pqTonemapB);
        this.gl.uniform1f(this.hlgOOTFGammaMinusOneLocation, data.hlgOOTFGammaMinusOne);
        this.gl.uniform1f(this.hlgDstMaxLuminanceRelativeLocation, data.hlgDstMaxLuminanceRelative);
        this.gl.uniform1f(this.nitsToSdrRelativeFactorLocation, data.nitsToSdrRelativeFactor);
        this.gl.uniform1f(this.sdrRelativeToNitsFactorLocation, data.sdrRelativeToNitsFactor);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/YUV8Program.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/image/webgl/program/YUV8Program.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ YUV8Program)
/* harmony export */ });
/* harmony import */ var _YUVProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./YUVProgram */ "./src/avrender/image/webgl/program/YUVProgram.ts");
/*
 * libmedia YUV8Program
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class YUV8Program extends _YUVProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(yuvFragmentSource) {
        super(yuvFragmentSource);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/program/YUVProgram.ts":
/*!********************************************************!*\
  !*** ./src/avrender/image/webgl/program/YUVProgram.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ YUVProgram)
/* harmony export */ });
/* harmony import */ var _VideoProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VideoProgram */ "./src/avrender/image/webgl/program/VideoProgram.ts");
/*
 * libmedia YUVProgram
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class YUVProgram extends _VideoProgram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    ySamplerLocation;
    uSamplerLocation;
    vSamplerLocation;
    aSamplerLocation;
    constructor(yuvFragmentSource) {
        super(yuvFragmentSource);
    }
    link(gl) {
        super.link(gl);
        this.ySamplerLocation = this.gl.getUniformLocation(this.program, 'y_Sampler');
        this.uSamplerLocation = this.gl.getUniformLocation(this.program, 'u_Sampler');
        this.vSamplerLocation = this.gl.getUniformLocation(this.program, 'v_Sampler');
        this.aSamplerLocation = this.gl.getUniformLocation(this.program, 'a_Sampler');
    }
    bindYTexture(unit = 0) {
        this.gl.uniform1i(this.ySamplerLocation, unit);
    }
    bindUTexture(unit = 0) {
        this.gl.uniform1i(this.uSamplerLocation, unit);
    }
    bindVTexture(unit = 0) {
        this.gl.uniform1i(this.vSamplerLocation, unit);
    }
    bindATexture(unit = 0) {
        this.gl.uniform1i(this.aSamplerLocation, unit);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/shader/FragmentShader.ts":
/*!***********************************************************!*\
  !*** ./src/avrender/image/webgl/shader/FragmentShader.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FragmentShader)
/* harmony export */ });
/* harmony import */ var _Shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shader */ "./src/avrender/image/webgl/shader/Shader.ts");
/*
 * libmedia FragmentShader
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class FragmentShader extends _Shader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(source) {
        super(1 /* ShaderType.FRAGMENT */, source);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/shader/Shader.ts":
/*!***************************************************!*\
  !*** ./src/avrender/image/webgl/shader/Shader.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Shader)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avrender\\image\\webgl\\shader\\Shader.ts";
/*
 * libmedia Shader
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class Shader {
    type;
    _shader;
    _source;
    compiled;
    constructor(type, source) {
        this.type = type;
        this._shader = null;
        this._source = source;
        this.compiled = false;
    }
    compile(gl) {
        if (this.compiled) {
            return;
        }
        this._shader = gl.createShader(this.type === 0 /* ShaderType.VERTEX */ ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
        gl.shaderSource(this._shader, this._source);
        gl.compileShader(this._shader);
        if (true) {
            if (!gl.getShaderParameter(this._shader, gl.COMPILE_STATUS)) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal(gl.getShaderInfoLog(this._shader), cheap__fileName__0, 60);
            }
        }
        this.compiled = true;
    }
    stop(gl) {
        gl.deleteShader(this._shader);
        this._shader = null;
    }
    get shader() {
        return this._shader;
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/shader/VertexShader.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/image/webgl/shader/VertexShader.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VertexShader)
/* harmony export */ });
/* harmony import */ var _Shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shader */ "./src/avrender/image/webgl/shader/Shader.ts");
/*
 * libmedia VertexShader
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class VertexShader extends _Shader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(source) {
        super(0 /* ShaderType.VERTEX */, source);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/texture/RGBTexture.ts":
/*!********************************************************!*\
  !*** ./src/avrender/image/webgl/texture/RGBTexture.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RGBTexture)
/* harmony export */ });
/* harmony import */ var _Texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture */ "./src/avrender/image/webgl/texture/Texture.ts");
/*
 * libmedia RGBTexture
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class RGBTexture extends _Texture__WEBPACK_IMPORTED_MODULE_0__["default"] {
    filter;
    format;
    internalformat;
    dataType;
    constructor(gl, width, height) {
        super(gl, width, height);
        this.format = this.gl.RGB;
        this.filter = this.gl.LINEAR;
        this.internalformat = this.gl.RGB;
        this.dataType = this.gl.UNSIGNED_BYTE;
    }
    init() {
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.filter);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.filter);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    }
    setFormat(format) {
        this.format = format;
    }
    setInternalformat(format) {
        this.internalformat = format;
    }
    setDataType(type) {
        this.dataType = type;
    }
    setFilter(filter) {
        this.filter = filter;
    }
    fill(data) {
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.setUnpackAlignment();
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.internalformat, this.width, this.height, 0, this.format, this.dataType, data);
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/texture/Texture.ts":
/*!*****************************************************!*\
  !*** ./src/avrender/image/webgl/texture/Texture.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Texture)
/* harmony export */ });
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/*
 * libmedia Texture
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class Texture {
    gl;
    width;
    height;
    texture;
    constructor(gl, width, height) {
        this.gl = gl;
        this.width = width;
        this.height = height;
        this.texture = this.gl.createTexture();
    }
    getTexture() {
        return this.texture;
    }
    bind(unit) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.number(unit)) {
            this.gl.activeTexture(this.gl.TEXTURE0 + unit);
        }
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
    }
    setSize(width, height) {
        this.width = width;
        this.height = height;
    }
    /**
     * 
     */
    setUnpackAlignment() {
        if (this.width % 8 === 0) {
            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 8);
        }
        else if (this.width % 4 === 0) {
            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 4);
        }
        else if (this.width % 2 === 0) {
            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 2);
        }
        else {
            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
        }
    }
    destroy() {
        if (this.texture) {
            this.gl.deleteTexture(this.texture);
            this.texture = null;
        }
    }
}


/***/ }),

/***/ "./src/avrender/image/webgl/texture/YUVTexture.ts":
/*!********************************************************!*\
  !*** ./src/avrender/image/webgl/texture/YUVTexture.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ YUVTexture)
/* harmony export */ });
/* harmony import */ var _Texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture */ "./src/avrender/image/webgl/texture/Texture.ts");
/*
 * libmedia YUVTexture
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class YUVTexture extends _Texture__WEBPACK_IMPORTED_MODULE_0__["default"] {
    filter;
    format;
    internalformat;
    dataType;
    constructor(gl, width, height) {
        super(gl, width, height);
        this.format = this.gl.LUMINANCE;
        this.filter = this.gl.LINEAR;
        this.internalformat = this.gl.LUMINANCE;
        this.dataType = this.gl.UNSIGNED_BYTE;
    }
    init() {
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.filter);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.filter);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    }
    setFormat(format) {
        this.format = format;
    }
    setInternalformat(format) {
        this.internalformat = format;
    }
    setDataType(type) {
        this.dataType = type;
    }
    setFilter(filter) {
        this.filter = filter;
    }
    fill(data) {
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.setUnpackAlignment();
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.internalformat, this.width, this.height, 0, this.format, this.dataType, data);
    }
}


/***/ }),

/***/ "./src/avrender/pcm/AudioSourceBufferNode.ts":
/*!***************************************************!*\
  !*** ./src/avrender/pcm/AudioSourceBufferNode.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioSourceBufferNode)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var avutil_struct_avpcmbuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/struct/avpcmbuffer */ "./src/avutil/struct/avpcmbuffer.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var cheap_config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/config */ "./src/cheap/config.ts");
/* harmony import */ var common_util_os__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/os */ "./src/common/util/os.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
var cheap__fileName__16 = "src\\avrender\\pcm\\AudioSourceBufferNode.ts";


/*
 * libmedia AudioSourceBufferNode
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */









const BUFFER_LENGTH = (common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].windows || common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].mac || common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].linux) ? 20 : 30;
class AudioSourceBufferNode {
    context;
    observer;
    options;
    pullIPC;
    buffer;
    channels;
    ended;
    float32;
    buffered;
    pause;
    startTime;
    dest;
    queue;
    firstRendered;
    constructor(context, observer, options = {}) {
        this.context = context;
        this.observer = observer;
        this.options = options;
    }
    async request(method, params, transfer) {
        switch (method) {
            case 'init': {
                break;
            }
            case 'start': {
                const { port, channels } = params;
                this.channels = channels;
                this.pullIPC = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__["default"](port);
                this.buffer = this.allocBuffer();
                this.float32 = new Float32Array((0,cheap_heap__WEBPACK_IMPORTED_MODULE_4__.getHeapU8)().buffer);
                this.queue = [];
                this.startTime = 0;
                this.ended = false;
                this.pause = false;
                this.firstRendered = false;
                await this.pullInterval();
                this.buffering();
                await this.pullInterval();
                this.buffered = true;
                this.process();
                break;
            }
            case 'restart': {
                if (!this.ended) {
                    return;
                }
                this.buffer = this.allocBuffer();
                this.queue = [];
                this.startTime = 0;
                this.ended = false;
                this.pause = false;
                this.firstRendered = false;
                await this.pullIPC.request('pull', {
                    buffer: this.buffer
                });
                this.buffering();
                await this.pullIPC.request('pull', {
                    buffer: this.buffer
                });
                this.buffered = true;
                this.process();
                break;
            }
            case 'stop': {
                this.freeBuffer(this.buffer);
                this.buffer = null;
                this.ended = true;
                this.pullIPC.destroy();
                break;
            }
            case 'clear': {
                this.queue.forEach((buffer) => {
                    buffer.disconnect();
                });
                this.queue.length = 0;
                break;
            }
            case 'pause': {
                this.pause = true;
                break;
            }
            case 'unpause': {
                this.pause = false;
                if (!this.queue.length) {
                    this.process();
                }
                break;
            }
        }
    }
    allocBuffer() {
        const buffer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(40);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](buffer, (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(4 * this.channels));
        const data = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(512 * BUFFER_LENGTH * this.channels);
        for (let i = 0; i < this.channels; i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](buffer) + (i * 4), data + 128 * BUFFER_LENGTH * 4 * i);
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](buffer + 12, 128 * BUFFER_LENGTH);
        return buffer;
    }
    freeBuffer(buffer) {
        if (!buffer) {
            return;
        }
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](buffer));
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avFreep)(buffer);
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(buffer);
    }
    async pullInterval() {
        let ret = 0;
        if (this.options.isMainWorker) {
            const buffer = await this.pullIPC.request('pullBuffer', {
                nbSamples: BUFFER_LENGTH * 128
            });
            if (common_util_is__WEBPACK_IMPORTED_MODULE_9__.arrayBuffer(buffer)) {
                ret = 0;
                (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_10__.memcpyFromUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](this.buffer)), buffer.byteLength, new Uint8Array(buffer));
            }
            else {
                ret = buffer;
            }
        }
        else {
            ret = await this.pullIPC.request('pull', {
                buffer: this.buffer
            });
        }
        return ret;
    }
    async pull() {
        this.buffered = false;
        const ret = await this.pullInterval();
        if (ret < 0) {
            this.ended = true;
        }
        else {
            this.buffered = true;
            if (!this.queue.length) {
                this.process();
            }
        }
    }
    buffering() {
        if (!this.float32.length) {
            this.float32 = new Float32Array((0,cheap_heap__WEBPACK_IMPORTED_MODULE_4__.getHeapU8)().buffer);
        }
        const audioBuffer = this.context.createBuffer(this.channels, BUFFER_LENGTH * 128, this.context.sampleRate);
        for (let i = 0; i < this.channels; i++) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](this.buffer) + (i * 4))) {
                let pos = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](this.buffer) + (i * 4)) >>> 2;
                if (audioBuffer.copyToChannel && !cheap_config__WEBPACK_IMPORTED_MODULE_7__.USE_THREADS) {
                    audioBuffer.copyToChannel(this.float32.subarray(pos, pos + BUFFER_LENGTH * 128), i, 0);
                }
                else {
                    const audioData = audioBuffer.getChannelData(i);
                    audioData.set(this.float32.subarray(pos, pos + BUFFER_LENGTH * 128), 0);
                }
            }
        }
        const bufferSource = this.context.createBufferSource();
        bufferSource.buffer = audioBuffer;
        bufferSource.onended = () => {
            this.queue.shift();
            if (this.ended && !this.queue.length) {
                this.freeBuffer(this.buffer);
                common_util_logger__WEBPACK_IMPORTED_MODULE_6__.info('audio source ended', cheap__fileName__16, 252);
                this.observer.onEnded();
                return;
            }
            this.process();
            if (!this.queue.length) {
                this.observer.onStutter();
            }
            if (!this.firstRendered) {
                this.firstRendered = true;
                this.observer.onFirstRendered();
            }
        };
        if (this.startTime === 0) {
            this.startTime = this.context.currentTime;
        }
        bufferSource.start(this.startTime);
        if (this.dest) {
            bufferSource.connect(this.dest);
        }
        this.startTime += bufferSource.buffer.duration;
        this.queue.push(bufferSource);
    }
    connect(dest) {
        this.dest = dest;
    }
    disconnect() {
        for (let i = 0; i < this.queue.length; i++) {
            this.queue[i].disconnect();
        }
        this.dest = null;
        this.queue.length = 0;
    }
    process() {
        if (this.buffer && !this.pause && this.buffered) {
            this.buffering();
            this.pull();
        }
    }
}


/***/ }),

/***/ "./src/avrender/pcm/AudioSourceWorkletNode.ts":
/*!****************************************************!*\
  !*** ./src/avrender/pcm/AudioSourceWorkletNode.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioSourceWorkletNode)
/* harmony export */ });
/* harmony import */ var _audioWorklet_base_AudioWorkletNodeBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audioWorklet/base/AudioWorkletNodeBase */ "./src/avrender/pcm/audioWorklet/base/AudioWorkletNodeBase.ts");
/*
 * libmedia AudioSourceWorkletNode
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class AudioSourceWorkletNode extends _audioWorklet_base_AudioWorkletNodeBase__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, observer, options = {}) {
        super(context, observer, 'audio-source-processor', options);
    }
}


/***/ }),

/***/ "./src/avrender/pcm/AudioSourceWorkletProcessor.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/pcm/AudioSourceWorkletProcessor.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var _audioWorklet_base_AudioWorkletProcessorBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audioWorklet/base/AudioWorkletProcessorBase */ "./src/avrender/pcm/audioWorklet/base/AudioWorkletProcessorBase.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_os__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/os */ "./src/common/util/os.ts");
var cheap__fileName__0 = "src\\avrender\\pcm\\AudioSourceWorkletProcessor.ts";
/*
 * libmedia AudioSourceWorkletProcessor
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





const BUFFER_LENGTH = (common_util_os__WEBPACK_IMPORTED_MODULE_4__["default"].windows || common_util_os__WEBPACK_IMPORTED_MODULE_4__["default"].mac || common_util_os__WEBPACK_IMPORTED_MODULE_4__["default"].linux) ? 10 : 20;
class AudioSourceWorkletProcessor extends _audioWorklet_base_AudioWorkletProcessorBase__WEBPACK_IMPORTED_MODULE_1__["default"] {
    pullIPC;
    frontBuffer;
    backBuffer;
    channels;
    backBufferOffset;
    ended;
    frontBuffered;
    pause;
    firstRendered;
    stopped;
    afterPullResolve;
    constructor() {
        super();
        this.ended = false;
        this.pause = true;
        this.ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.REQUEST, async (request) => {
            switch (request.method) {
                case 'init': {
                    this.ipcPort.reply(request);
                    break;
                }
                case 'start': {
                    const { port, channels } = request.params;
                    this.channels = channels;
                    this.pullIPC = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](port);
                    const backBuffer = [];
                    const frontBuffer = [];
                    await this.pull(backBuffer);
                    await this.pull(frontBuffer);
                    this.frontBuffer = frontBuffer;
                    this.backBuffer = backBuffer;
                    this.backBufferOffset = 0;
                    this.ended = false;
                    this.frontBuffered = true;
                    this.pause = false;
                    this.firstRendered = false;
                    this.stopped = false;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'restart': {
                    if (!this.ended) {
                        this.ipcPort.reply(request);
                        return;
                    }
                    const backBuffer = [];
                    const frontBuffer = [];
                    await this.pull(backBuffer);
                    await this.pull(frontBuffer);
                    this.frontBuffer = frontBuffer;
                    this.backBuffer = backBuffer;
                    this.backBufferOffset = 0;
                    this.ended = false;
                    this.frontBuffered = true;
                    this.pause = false;
                    this.firstRendered = false;
                    this.stopped = false;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'clear': {
                    this.backBufferOffset = BUFFER_LENGTH;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'stop': {
                    if (!this.ended && !this.pause) {
                        await new Promise((resolve) => {
                            this.afterPullResolve = resolve;
                        });
                    }
                    this.stopped = true;
                    this.pullIPC.destroy();
                    this.ipcPort.reply(request);
                    break;
                }
                case 'pause': {
                    this.pause = true;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'unpause': {
                    this.pause = false;
                    this.ipcPort.reply(request);
                    break;
                }
            }
        });
    }
    async pull(data) {
        const buffer = await this.pullIPC.request('pullBuffer', {
            nbSamples: BUFFER_LENGTH * 128
        });
        if (common_util_is__WEBPACK_IMPORTED_MODULE_2__.number(buffer)) {
            this.ended = true;
        }
        else {
            const float = new Float32Array(buffer);
            for (let i = 0; i < this.channels; i++) {
                data[i] = float.subarray(i * BUFFER_LENGTH * 128, (i + 1) * BUFFER_LENGTH * 128);
            }
        }
        if (this.afterPullResolve) {
            this.afterPullResolve();
        }
    }
    swapBuffer() {
        if (this.frontBuffered) {
            this.backBuffer = this.frontBuffer;
            this.backBufferOffset = 0;
            this.frontBuffer = [];
        }
        else {
            return false;
        }
        this.frontBuffered = false;
        this.pull(this.frontBuffer).then(() => {
            this.frontBuffered = true;
        });
        return true;
    }
    process(inputs, outputs, parameters) {
        if (this.stopped) {
            return false;
        }
        if (this.backBuffer && !this.pause) {
            if (this.backBufferOffset === BUFFER_LENGTH) {
                if (this.ended) {
                    this.backBuffer = null;
                    this.frontBuffer = null;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_3__.info('audio source ended', cheap__fileName__0, 199);
                    this.ipcPort.notify('ended');
                    return true;
                }
                if (!this.swapBuffer()) {
                    this.ipcPort.notify('stutter');
                    return true;
                }
            }
            const output = outputs[0];
            for (let i = 0; i < this.channels; i++) {
                output[i].set(this.backBuffer[i].subarray(this.backBufferOffset * 128, (this.backBufferOffset + 1) * 128), 0);
            }
            this.backBufferOffset++;
            if (!this.firstRendered) {
                this.firstRendered = true;
                this.ipcPort.notify('firstRendered');
            }
        }
        return true;
    }
}
// @ts-ignore
registerProcessor('audio-source-processor', AudioSourceWorkletProcessor);


/***/ }),

/***/ "./src/avrender/pcm/AudioSourceWorkletProcessor2.ts":
/*!**********************************************************!*\
  !*** ./src/avrender/pcm/AudioSourceWorkletProcessor2.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var _audioWorklet_base_AudioWorkletProcessorBase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./audioWorklet/base/AudioWorkletProcessorBase */ "./src/avrender/pcm/audioWorklet/base/AudioWorkletProcessorBase.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var avutil_struct_avpcmbuffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/struct/avpcmbuffer */ "./src/avutil/struct/avpcmbuffer.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_os__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/os */ "./src/common/util/os.ts");
var cheap__fileName__10 = "src\\avrender\\pcm\\AudioSourceWorkletProcessor2.ts";


/*
 * libmedia AudioSourceWorkletProcessor in share memory
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */







const BUFFER_LENGTH = (common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].windows || common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].mac || common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].linux) ? 10 : 20;
class AudioSourceWorkletProcessor2 extends _audioWorklet_base_AudioWorkletProcessorBase__WEBPACK_IMPORTED_MODULE_3__["default"] {
    pullIPC;
    frontBuffer;
    backBuffer;
    channels;
    backBufferOffset;
    ended;
    frontBuffered;
    firstRendered;
    float32;
    pause;
    stopped;
    afterPullResolve;
    constructor() {
        super();
        this.ended = false;
        this.pause = true;
        this.ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_2__.REQUEST, async (request) => {
            switch (request.method) {
                case 'init': {
                    const { memory } = request.params;
                    await (0,cheap_heap__WEBPACK_IMPORTED_MODULE_4__.initThread)({
                        memory,
                        disableAsm: true
                    });
                    this.ipcPort.reply(request);
                    break;
                }
                case 'start': {
                    const { port, channels } = request.params;
                    this.channels = channels;
                    this.pullIPC = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_2__["default"](port);
                    const frontBuffer = this.allocBuffer();
                    const backBuffer = this.allocBuffer();
                    await this.pullIPC.request('pull', {
                        buffer: backBuffer
                    });
                    await this.pullIPC.request('pull', {
                        buffer: frontBuffer
                    });
                    this.frontBuffer = frontBuffer;
                    this.backBuffer = backBuffer;
                    this.backBufferOffset = 0;
                    this.ended = false;
                    this.pause = false;
                    this.frontBuffered = true;
                    this.firstRendered = false;
                    this.stopped = false;
                    this.float32 = new Float32Array((0,cheap_heap__WEBPACK_IMPORTED_MODULE_4__.getHeapU8)().buffer);
                    this.ipcPort.reply(request);
                    break;
                }
                case 'restart': {
                    if (!this.ended) {
                        this.ipcPort.reply(request);
                        return;
                    }
                    const frontBuffer = this.allocBuffer();
                    const backBuffer = this.allocBuffer();
                    await this.pullIPC.request('pull', {
                        buffer: backBuffer
                    });
                    await this.pullIPC.request('pull', {
                        buffer: frontBuffer
                    });
                    this.frontBuffer = frontBuffer;
                    this.backBuffer = backBuffer;
                    this.backBufferOffset = 0;
                    this.ended = false;
                    this.pause = false;
                    this.frontBuffered = true;
                    this.firstRendered = false;
                    this.stopped = false;
                    this.float32 = new Float32Array((0,cheap_heap__WEBPACK_IMPORTED_MODULE_4__.getHeapU8)().buffer);
                    this.ipcPort.reply(request);
                    break;
                }
                case 'stop': {
                    if (!this.ended && !this.pause) {
                        await new Promise((resolve) => {
                            this.afterPullResolve = resolve;
                        });
                    }
                    this.freeBuffer(this.backBuffer);
                    this.freeBuffer(this.frontBuffer);
                    this.backBuffer = 0;
                    this.frontBuffer = 0;
                    this.stopped = true;
                    this.pullIPC.destroy();
                    this.ipcPort.reply(request);
                    break;
                }
                case 'clear': {
                    this.backBufferOffset = BUFFER_LENGTH;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'pause': {
                    this.pause = true;
                    this.ipcPort.reply(request);
                    break;
                }
                case 'unpause': {
                    this.pause = false;
                    this.ipcPort.reply(request);
                    break;
                }
            }
        });
    }
    allocBuffer() {
        const buffer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avMallocz)(40);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](buffer, (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avMallocz)(4 * this.channels));
        const data = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avMallocz)(512 * BUFFER_LENGTH * this.channels);
        for (let i = 0; i < this.channels; i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](buffer) + (i * 4), data + 128 * BUFFER_LENGTH * 4 * i);
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](buffer + 12, 128 * BUFFER_LENGTH);
        return buffer;
    }
    freeBuffer(buffer) {
        if (!buffer) {
            return;
        }
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](buffer));
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avFreep)(buffer);
        (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avFree)(buffer);
    }
    async pull() {
        const ret = await this.pullIPC.request('pull', {
            buffer: this.frontBuffer
        });
        if (ret < 0) {
            this.ended = true;
        }
        if (this.afterPullResolve) {
            this.afterPullResolve();
        }
    }
    swapBuffer() {
        if (this.frontBuffered) {
            const backBuffer = this.backBuffer;
            this.backBuffer = this.frontBuffer;
            this.frontBuffer = backBuffer;
            this.backBufferOffset = 0;
        }
        else {
            return false;
        }
        this.frontBuffered = false;
        this.pull().then(() => {
            this.frontBuffered = true;
        });
        return true;
    }
    process(inputs, outputs, parameters) {
        if (this.stopped) {
            return false;
        }
        if (this.backBuffer && !this.pause) {
            if (this.backBufferOffset === BUFFER_LENGTH) {
                if (this.ended) {
                    this.freeBuffer(this.backBuffer);
                    this.freeBuffer(this.frontBuffer);
                    this.backBuffer = 0;
                    this.frontBuffer = 0;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info('audio source ended', cheap__fileName__10, 239);
                    this.ipcPort.notify('ended');
                    return true;
                }
                if (!this.swapBuffer()) {
                    this.ipcPort.notify('stutter');
                    return true;
                }
            }
            const output = outputs[0];
            for (let i = 0; i < this.channels; i++) {
                output[i].set(this.float32.subarray((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](this.backBuffer) + (i * 4)) >>> 2) + this.backBufferOffset * 128, (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](this.backBuffer) + (i * 4)) >>> 2) + (this.backBufferOffset + 1) * 128), 0);
            }
            this.backBufferOffset++;
            if (!this.firstRendered) {
                this.firstRendered = true;
                this.ipcPort.notify('firstRendered');
            }
        }
        return true;
    }
}
// @ts-ignore
registerProcessor('audio-source-processor', AudioSourceWorkletProcessor2);


/***/ }),

/***/ "./src/avrender/pcm/audioWorklet/base/AudioWorkletNodeBase.ts":
/*!********************************************************************!*\
  !*** ./src/avrender/pcm/audioWorklet/base/AudioWorkletNodeBase.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioWorkletNodeBase)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/*
 * libmedia AudioWorkletNodeBase
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class AudioWorkletNodeBase {
    audioWorkletNode;
    ipcPort;
    observer;
    constructor(context, observer, processor, options = {}) {
        this.observer = observer;
        this.audioWorkletNode = new AudioWorkletNode(context, processor, options);
        this.ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](this.audioWorkletNode.port);
        this.ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.NOTIFY, (request) => {
            switch (request.method) {
                case 'ended':
                    this.observer.onEnded();
                    break;
                case 'firstRendered':
                    this.observer.onFirstRendered();
                    break;
                case 'stutter':
                    this.observer.onStutter();
                    break;
            }
        });
    }
    async request(method, params, transfer) {
        return this.ipcPort.request(method, params, transfer);
    }
    connect(audioNode) {
        this.audioWorkletNode.connect(audioNode);
    }
    getNode() {
        return this.audioWorkletNode;
    }
    disconnect() {
        this.audioWorkletNode.disconnect();
    }
    getParameters(type) {
        const parameters = this.audioWorkletNode.parameters;
        // @ts-ignore
        if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.func(parameters.get)) {
            // @ts-ignore
            return parameters.get(type);
        }
        parameters.forEach((value, key) => {
            if (key === type) {
                return value;
            }
        });
    }
}


/***/ }),

/***/ "./src/avrender/pcm/audioWorklet/base/AudioWorkletProcessorBase.ts":
/*!*************************************************************************!*\
  !*** ./src/avrender/pcm/audioWorklet/base/AudioWorkletProcessorBase.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioWorkletProcessorBase)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/*
 * libmedia AudioWorkletProcessorBase
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class AudioWorkletProcessorBase extends AudioWorkletProcessor {
    ipcPort;
    constructor() {
        super();
        this.ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](this.port);
    }
    async request(method, params, transfer) {
        return this.ipcPort.request(method, params, transfer);
    }
    notify(method, params, transfer) {
        this.ipcPort.notify(method, params, transfer);
    }
}


/***/ }),

/***/ "./src/avrender/pcm/audioWorklet/base/registerProcessor.ts":
/*!*****************************************************************!*\
  !*** ./src/avrender/pcm/audioWorklet/base/registerProcessor.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ registerProcessor)
/* harmony export */ });
/* harmony import */ var common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/function/sourceLoad */ "./src/common/function/sourceLoad.ts");
/*
 * libmedia registerProcessor
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

async function registerProcessor(audioContext, moduleId) {
    const source = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_0__["default"])(moduleId, {
        varName: 'processor'
    });
    const blob = new Blob([source], { type: 'text/javascript' });
    const workerUrl = URL.createObjectURL(blob);
    await audioContext.audioWorklet.addModule(workerUrl);
}


/***/ }),

/***/ "./src/avrender/track/Track.ts":
/*!*************************************!*\
  !*** ./src/avrender/track/Track.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Track)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\avrender\\track\\Track.ts";
/*
 * libmedia Track
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


var Operator;
(function (Operator) {
    Operator[Operator["ADD"] = 0] = "ADD";
    Operator[Operator["REMOVE"] = 1] = "REMOVE";
    Operator[Operator["UPDATE_TIMESTAMP_OFFSET"] = 2] = "UPDATE_TIMESTAMP_OFFSET";
})(Operator || (Operator = {}));
const defaultTrackOptions = {
    mediaBufferMax: 10
};
class Track {
    sourceBuffer;
    operatorQueue;
    updating;
    lastRemoveTime;
    paddingCallback;
    options;
    ending;
    onQuotaExceededError;
    onEnded;
    constructor(options = {}) {
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend({}, defaultTrackOptions, options);
        this.operatorQueue = [];
        this.updating = false;
        this.lastRemoveTime = 0;
        this.ending = false;
    }
    setSourceBuffer(sourceBuffer) {
        this.sourceBuffer = sourceBuffer;
        this.sourceBuffer.onupdateend = () => {
            if (this.paddingCallback) {
                this.paddingCallback();
                this.paddingCallback = null;
            }
            if (this.operatorQueue && this.operatorQueue.length) {
                this.enqueue();
            }
            else {
                this.updating = false;
                if (this.ending) {
                    if (this.onEnded) {
                        this.onEnded();
                    }
                }
            }
        };
        this.sourceBuffer.onerror = (error) => {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.error(`track update buffer error: ${error}`, cheap__fileName__0, 102);
        };
    }
    changeMimeType(type) {
        if (this.sourceBuffer) {
            this.sourceBuffer.changeType(type);
        }
    }
    enqueue() {
        if (this.operatorQueue.length) {
            const operator = this.operatorQueue.shift();
            if (operator.operator === Operator.ADD) {
                try {
                    this.sourceBuffer.appendBuffer(operator.buffer);
                    this.updating = true;
                    if (operator.callback) {
                        this.paddingCallback = operator.callback;
                    }
                }
                catch (error) {
                    if (error instanceof DOMException && error.name === 'QuotaExceededError') {
                        // buffer 
                        this.operatorQueue.unshift(operator);
                        if (this.onQuotaExceededError) {
                            this.onQuotaExceededError();
                        }
                        this.updating = false;
                    }
                    else {
                        throw error;
                    }
                }
            }
            else if (operator.operator === Operator.REMOVE) {
                this.sourceBuffer.remove(operator.start, operator.end);
                this.updating = true;
                if (operator.callback) {
                    this.paddingCallback = operator.callback;
                }
            }
            else if (operator.operator === Operator.UPDATE_TIMESTAMP_OFFSET) {
                this.sourceBuffer.timestampOffset = operator.timestampOffset;
                if (operator.callback) {
                    operator.callback();
                }
                this.enqueue();
            }
        }
    }
    addBuffer(buffer, callback) {
        if (!buffer) {
            if (callback) {
                callback();
            }
            return;
        }
        this.operatorQueue.push({
            operator: Operator.ADD,
            buffer,
            callback
        });
        if (!this.updating) {
            this.enqueue();
        }
    }
    updateTimestampOffset(timestampOffset, callback) {
        this.operatorQueue.push({
            operator: Operator.UPDATE_TIMESTAMP_OFFSET,
            timestampOffset,
            callback
        });
        if (!this.updating) {
            this.enqueue();
        }
    }
    removeBuffer(time, callback) {
        if (this.ending) {
            return;
        }
        time = Math.floor(time);
        if (time - this.lastRemoveTime < this.options.mediaBufferMax << 1) {
            return;
        }
        this.operatorQueue.push({
            operator: Operator.REMOVE,
            start: this.lastRemoveTime,
            end: time - this.options.mediaBufferMax,
            callback
        });
        if (!this.updating) {
            this.enqueue();
        }
        this.lastRemoveTime = time - this.options.mediaBufferMax;
    }
    removeAllBuffer(callback) {
        if (this.sourceBuffer.buffered.length) {
            this.operatorQueue.push({
                operator: Operator.REMOVE,
                start: this.sourceBuffer.buffered.start(0),
                end: this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1),
                callback
            });
            if (!this.updating) {
                this.enqueue();
            }
        }
        else if (callback) {
            callback();
        }
    }
    end() {
        this.ending = true;
        if (!this.updating && !this.operatorQueue.length) {
            if (this.onEnded) {
                this.onEnded();
            }
        }
    }
    stop() {
        if (this.sourceBuffer) {
            try {
                this.sourceBuffer.abort();
                this.updating = false;
            }
            catch (error) { }
            try {
                if (this.sourceBuffer.buffered.length) {
                    if (!this.updating) {
                        this.sourceBuffer.remove(this.sourceBuffer.buffered.start(0), this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1));
                        this.updating = true;
                    }
                    else {
                        this.operatorQueue.push({
                            operator: Operator.REMOVE,
                            start: this.sourceBuffer.buffered.start(0),
                            end: this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1)
                        });
                    }
                }
                if (this.paddingCallback) {
                    this.paddingCallback();
                    this.paddingCallback = null;
                }
            }
            catch (error) { }
        }
    }
    reset() {
        this.stop();
        this.operatorQueue.length = 0;
        this.ending = false;
    }
    isPaused() {
        return !this.updating && this.operatorQueue.length;
    }
    getQueueLength() {
        return this.operatorQueue.length;
    }
    getBufferedTime() {
        if (this.sourceBuffer && this.sourceBuffer.buffered.length) {
            return this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1) - this.sourceBuffer.buffered.start(0);
        }
        return 0;
    }
    getBufferedStart() {
        if (this.sourceBuffer && this.sourceBuffer.buffered.length) {
            return this.sourceBuffer.buffered.start(0);
        }
        return 0;
    }
    getBufferedEnd() {
        if (this.sourceBuffer && this.sourceBuffer.buffered.length) {
            return this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1);
        }
        return 0;
    }
    getSourceBuffer() {
        return this.sourceBuffer;
    }
    setMediaBufferMax(max) {
        this.options.mediaBufferMax = max;
    }
    getMediaBufferMax() {
        return this.options.mediaBufferMax;
    }
    destroy() {
        this.stop();
        this.operatorQueue = null;
        if (this.sourceBuffer) {
            this.sourceBuffer.onupdateend = this.sourceBuffer.onerror = null;
            this.sourceBuffer = null;
        }
    }
}


/***/ }),

/***/ "./src/avrender/track/function/getAudioMimeType.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/track/function/getAudioMimeType.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getAudioMimeType)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avcodec/function/getAudioCodec */ "./src/avcodec/function/getAudioCodec.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");

/*
 * libmedia get audio mimetype
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function getAudioMimeType(codecpar) {
    let mimeType = '';
    // firefox supports 'audio/mp4, codecs="mp3"', use 'audio/mpeg' for chrome, safari
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 4) === 86017 /* AVCodecID.AV_CODEC_ID_MP3 */ && !common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].firefox) {
        mimeType = 'audio/mpeg';
    }
    else {
        mimeType = `audio/mp4; codecs="${(0,avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_1__["default"])(codecpar)}"`;
    }
    return mimeType;
}


/***/ }),

/***/ "./src/avrender/track/function/getVideoMimeType.ts":
/*!*********************************************************!*\
  !*** ./src/avrender/track/function/getVideoMimeType.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getVideoMimeType)
/* harmony export */ });
/* harmony import */ var avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avcodec/function/getVideoCodec */ "./src/avcodec/function/getVideoCodec.ts");
/*
 * libmedia get video mimetype
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function getVideoMimeType(codecpar) {
    return `video/mp4; codecs="${(0,avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_0__["default"])(codecpar)}"`;
}


/***/ }),

/***/ "./src/avutil/constant.ts":
/*!********************************!*\
  !*** ./src/avutil/constant.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AV_MILLI_TIME_BASE: () => (/* binding */ AV_MILLI_TIME_BASE),
/* harmony export */   AV_MILLI_TIME_BASE_Q: () => (/* binding */ AV_MILLI_TIME_BASE_Q),
/* harmony export */   AV_TIME_BASE: () => (/* binding */ AV_TIME_BASE),
/* harmony export */   AV_TIME_BASE_Q: () => (/* binding */ AV_TIME_BASE_Q),
/* harmony export */   INT32_MAX: () => (/* binding */ INT32_MAX),
/* harmony export */   NOPTS_VALUE: () => (/* binding */ NOPTS_VALUE),
/* harmony export */   NOPTS_VALUE_BIGINT: () => (/* binding */ NOPTS_VALUE_BIGINT),
/* harmony export */   UINT16_MAX: () => (/* binding */ UINT16_MAX),
/* harmony export */   UINT32_MAX: () => (/* binding */ UINT32_MAX)
/* harmony export */ });
/* unused harmony exports AV_TIME_BASE1_Q, INT8_MAX, INT16_MAX, INT8_MIN, INT16_MIN, INT32_MIN, UINT8_MAX */
/* harmony import */ var _struct_rational__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./struct/rational */ "./src/avutil/struct/rational.ts");
/*
 * libmedia constant
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const NOPTS_VALUE_BIGINT = -BigInt(1);
const NOPTS_VALUE = -1;
const AV_TIME_BASE = 1000000;
const AV_MILLI_TIME_BASE = 1000;
/**
 * 
 */
const AV_TIME_BASE_Q = new _struct_rational__WEBPACK_IMPORTED_MODULE_0__.Rational({ den: AV_TIME_BASE, num: 1 });
/**
 * 
 */
const AV_MILLI_TIME_BASE_Q = new _struct_rational__WEBPACK_IMPORTED_MODULE_0__.Rational({ den: AV_MILLI_TIME_BASE, num: 1 });
/**
 * 
 */
const AV_TIME_BASE1_Q = new _struct_rational__WEBPACK_IMPORTED_MODULE_0__.Rational({ den: 1, num: 1 });
const INT8_MAX = 127;
const INT16_MAX = 32767;
const INT32_MAX = 2147483647;
const INT8_MIN = -128;
const INT16_MIN = -32768;
const INT32_MIN = -INT32_MAX - 1;
const UINT8_MAX = 255;
const UINT16_MAX = 65535;
const UINT32_MAX = 4294967295;


/***/ }),

/***/ "./src/avutil/error.ts":
/*!*****************************!*\
  !*** ./src/avutil/error.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CODEC_NOT_SUPPORT: () => (/* binding */ CODEC_NOT_SUPPORT),
/* harmony export */   DATA_INVALID: () => (/* binding */ DATA_INVALID),
/* harmony export */   EAGAIN: () => (/* binding */ EAGAIN),
/* harmony export */   EOF: () => (/* binding */ EOF),
/* harmony export */   FORMAT_NOT_SUPPORT: () => (/* binding */ FORMAT_NOT_SUPPORT),
/* harmony export */   INVALID_ARGUMENT: () => (/* binding */ INVALID_ARGUMENT),
/* harmony export */   INVALID_OPERATE: () => (/* binding */ INVALID_OPERATE),
/* harmony export */   NO_MEMORY: () => (/* binding */ NO_MEMORY),
/* harmony export */   OPERATE_NOT_SUPPORT: () => (/* binding */ OPERATE_NOT_SUPPORT)
/* harmony export */ });
/*
 * libmedia error defined
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const FORMAT_NOT_SUPPORT = -1;
const DATA_INVALID = -2;
const INVALID_ARGUMENT = -3;
const NO_MEMORY = -4;
const INVALID_OPERATE = -5;
const EAGAIN = -6;
const EOF = -7;
const CODEC_NOT_SUPPORT = -8;
const OPERATE_NOT_SUPPORT = -9;


/***/ }),

/***/ "./src/avutil/function/analyzeAVFormat.ts":
/*!************************************************!*\
  !*** ./src/avutil/function/analyzeAVFormat.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ analyzeAVFormat)
/* harmony export */ });
/*
 * libmedia analyzeAVFormat
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
async function analyzeAVFormat(ioReader, defaultFormat = -1 /* AVFormat.UNKNOWN */) {
    let signature = await ioReader.peekString(8);
    if (/^FLV/.test(signature)) {
        return 0 /* AVFormat.FLV */;
    }
    else if (/^DKIF/.test(signature)) {
        return 5 /* AVFormat.IVF */;
    }
    else if (/^ftyp/.test(signature.slice(4, 8))) {
        return 1 /* AVFormat.MP4 */;
    }
    else if (/^OggS/.test(signature)) {
        return 4 /* AVFormat.OGG */;
    }
    else if (/^ID3/.test(signature)) {
        return 12 /* AVFormat.MP3 */;
    }
    else if (/^fLaC/.test(signature)) {
        return 15 /* AVFormat.FLAC */;
    }
    else if (/^RIFF/.test(signature)) {
        const dataType = (await ioReader.peekString(12)).slice(8);
        if (/^WAVE/.test(dataType)) {
            return 14 /* AVFormat.WAV */;
        }
    }
    else if (/^ADIF/.test(signature)) {
        return 13 /* AVFormat.AAC */;
    }
    else if ((await ioReader.peekUint32()) === 0x1A45DFA3) {
        return 6 /* AVFormat.MATROSKA */;
    }
    else {
        const buf = await ioReader.peekBuffer(2);
        switch (buf[0]) {
            case 0x56:
                if ((buf[1] & 0xe0) === 0xe0) {
                    return 13 /* AVFormat.AAC */;
                }
                break;
            case 0xff:
                if ((buf[1] & 0xf6) === 0xf0) {
                    return 13 /* AVFormat.AAC */;
                }
                else if ([0xf2, 0xf4, 0xf6, 0xfa, 0xfc].includes(buf[1] & 0xfe)) {
                    return 12 /* AVFormat.MP3 */;
                }
                break;
        }
    }
    return defaultFormat;
}


/***/ }),

/***/ "./src/avutil/function/audioData2AVFrame.ts":
/*!**************************************************!*\
  !*** ./src/avutil/function/audioData2AVFrame.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   audioData2AVFrame: () => (/* binding */ audioData2AVFrame)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _util_avframe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var _util_sample__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/sample */ "./src/avutil/util/sample.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");


/* libmedia AudioData to AVFrame utils
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function mapFormat(format) {
    switch (format) {
        case 'u8':
            return 0 /* AVSampleFormat.AV_SAMPLE_FMT_U8 */;
        case 's16':
            return 1 /* AVSampleFormat.AV_SAMPLE_FMT_S16 */;
        case 's32':
            return 2 /* AVSampleFormat.AV_SAMPLE_FMT_S32 */;
        case 'f32':
            return 3 /* AVSampleFormat.AV_SAMPLE_FMT_FLT */;
        case 'u8-planar':
            return 5 /* AVSampleFormat.AV_SAMPLE_FMT_U8P */;
        case 's16-planar':
            return 6 /* AVSampleFormat.AV_SAMPLE_FMT_S16P */;
        case 's32-planar':
            return 7 /* AVSampleFormat.AV_SAMPLE_FMT_S32P */;
        case 'f32-planar':
            return 8 /* AVSampleFormat.AV_SAMPLE_FMT_FLTP */;
        default:
            throw new Error('not support');
    }
}
function audioData2AVFrame(audioData, avframe = 0) {
    if (avframe === 0) {
        avframe = (0,_util_avframe__WEBPACK_IMPORTED_MODULE_2__.createAVFrame)();
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 152, audioData.sampleRate);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 76, audioData.numberOfFrames);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 292, audioData.numberOfChannels);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 80, mapFormat(audioData.format));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avframe + 104, BigInt(Math.floor(audioData.timestamp)));
    (0,_util_avframe__WEBPACK_IMPORTED_MODULE_2__.getAudioBuffer)(avframe);
    const planar = (0,_util_sample__WEBPACK_IMPORTED_MODULE_3__.sampleFormatIsPlanar)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 80));
    const planes = planar ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 292) : 1;
    for (let i = 0; i < planes; i++) {
        audioData.copyTo((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avframe + 64) + (i * 4)), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 32)), {
            planeIndex: i
        });
    }
    return avframe;
}


/***/ }),

/***/ "./src/avutil/function/avpacket2EncodedAudioChunk.ts":
/*!***********************************************************!*\
  !*** ./src/avutil/function/avpacket2EncodedAudioChunk.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ avpacket2EncodedAudioChunk)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");


function avpacket2EncodedAudioChunk(avpacket, pts) {
    const timestamp = Number(pts ?? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8));
    const key = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */;
    return new EncodedAudioChunk({
        type: key ? 'key' : 'delta',
        timestamp,
        data: (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28))
    });
}


/***/ }),

/***/ "./src/avutil/function/avpacket2EncodedVideoChunk.ts":
/*!***********************************************************!*\
  !*** ./src/avutil/function/avpacket2EncodedVideoChunk.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ avpacket2EncodedVideoChunk)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");


function avpacket2EncodedVideoChunk(avpacket, pts) {
    const timestamp = Number(pts ?? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8));
    const key = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */;
    return new EncodedVideoChunk({
        type: key ? 'key' : 'delta',
        timestamp,
        data: (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28))
    });
}


/***/ }),

/***/ "./src/avutil/function/compileResource.ts":
/*!************************************************!*\
  !*** ./src/avutil/function/compileResource.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ compileResource)
/* harmony export */ });
/* harmony import */ var cheap_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/config */ "./src/cheap/config.ts");
/* harmony import */ var cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/webassembly/compiler */ "./src/cheap/webassembly/compiler.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");




async function compileResource(wasmUrl, thread = false) {
    let resource;
    if (common_util_is__WEBPACK_IMPORTED_MODULE_2__.string(wasmUrl) || common_util_is__WEBPACK_IMPORTED_MODULE_2__.arrayBuffer(wasmUrl)) {
        resource = await (0,cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_1__["default"])({
            source: wasmUrl
        });
        if (cheap_config__WEBPACK_IMPORTED_MODULE_0__.USE_THREADS && true && thread) {
            resource.threadModule = await (0,cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_1__["default"])({
                // firefox  arraybuffer 
                source: common_util_browser__WEBPACK_IMPORTED_MODULE_3__["default"].firefox ? wasmUrl : resource.buffer
            }, {
                child: true
            });
        }
        delete resource.buffer;
    }
    else {
        resource = wasmUrl;
    }
    return resource;
}


/***/ }),

/***/ "./src/avutil/function/hasAlphaChannel.ts":
/*!************************************************!*\
  !*** ./src/avutil/function/hasAlphaChannel.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hasAlphaChannel)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");

/*
 * libmedia hasAlphaChannel
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function hasAlphaChannel(parameters) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters) !== 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
        return false;
    }
    const descriptor = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_1__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 28)];
    return descriptor && (descriptor.flags & 128 /* PixelFormatFlags.ALPHA */);
}


/***/ }),

/***/ "./src/avutil/function/isHdr.ts":
/*!**************************************!*\
  !*** ./src/avutil/function/isHdr.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isHdr)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");

/*
 * libmedia isHdr
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function isHdr(parameters) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters) !== 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
        return false;
    }
    const descriptor = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_1__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 28)];
    if (!descriptor || descriptor.comp[0].depth <= 8) {
        return false;
    }
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 92) === 18 /* AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 */
        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 92) === 16 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 */;
}


/***/ }),

/***/ "./src/avutil/implement/AVFramePoolImpl.ts":
/*!*************************************************!*\
  !*** ./src/avutil/implement/AVFramePoolImpl.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVFramePoolImpl)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _struct_avframe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../struct/avframe */ "./src/avutil/struct/avframe.ts");
/* harmony import */ var cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _util_avframe__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/avframe */ "./src/avutil/util/avframe.ts");


/*
 * libmedia AVFrame pool implement
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





class AVFramePoolImpl {
    list;
    mutex;
    constructor(list, mutex) {
        this.list = list;
        this.mutex = mutex;
    }
    alloc() {
        let avframe = this.list.find((avframe) => {
            return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(avframe + 320, -1, 1, 16, 2) === -1;
        }, 20);
        if (!avframe) {
            avframe = (0,_util_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(328);
            (0,_util_avframe__WEBPACK_IMPORTED_MODULE_6__.getAVFrameDefault)(avframe);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[16](avframe + 320, 1);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.lock(this.mutex);
            }
            this.list.push(avframe, 20);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.unlock(this.mutex);
            }
        }
        return avframe;
    }
    release(avframe) {
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.load(avframe + 320, 16, 2) <= 0) {
            return;
        }
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.sub(avframe + 320, 1, 16, 2) === 1) {
            (0,_util_avframe__WEBPACK_IMPORTED_MODULE_6__.unrefAVFrame)(avframe);
            cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.store(avframe + 320, -1, 16, 2);
        }
    }
}


/***/ }),

/***/ "./src/avutil/implement/AVPCMBufferPoolImpl.ts":
/*!*****************************************************!*\
  !*** ./src/avutil/implement/AVPCMBufferPoolImpl.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVPCMBufferPoolImpl)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _struct_avpcmbuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../struct/avpcmbuffer */ "./src/avutil/struct/avpcmbuffer.ts");
/* harmony import */ var cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");


/*
 * libmedia AVPCMBuffer pool implement
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class AVPCMBufferPoolImpl {
    list;
    mutex;
    constructor(list, mutex) {
        this.list = list;
        this.mutex = mutex;
    }
    alloc() {
        let buffer = this.list.find((buffer) => {
            return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(buffer + 40, -1, 1, 16, 2) === -1;
        }, 20);
        if (!buffer) {
            buffer = (0,_util_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(48);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[16](buffer + 40, 1);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.lock(this.mutex);
            }
            this.list.push(buffer, 20);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.unlock(this.mutex);
            }
        }
        return buffer;
    }
    release(buffer) {
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.load(buffer + 40, 16, 2) <= 0) {
            return;
        }
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.sub(buffer + 40, 1, 16, 2) === 1) {
            cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_3__.store(buffer + 40, -1, 16, 2);
        }
    }
}


/***/ }),

/***/ "./src/avutil/implement/AVPacketPoolImpl.ts":
/*!**************************************************!*\
  !*** ./src/avutil/implement/AVPacketPoolImpl.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVPacketPoolImpl)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _struct_avpacket__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../struct/avpacket */ "./src/avutil/struct/avpacket.ts");
/* harmony import */ var _util_avpacket__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/avpacket */ "./src/avutil/util/avpacket.ts");







class AVPacketPoolImpl {
    list;
    mutex;
    constructor(list, mutex) {
        this.list = list;
        this.mutex = mutex;
    }
    alloc() {
        let avpacket = this.list.find((avpacket) => {
            return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_2__.compareExchange(avpacket + 88, -1, 1, 16, 2) === -1;
        }, 20);
        if (!avpacket) {
            avpacket = (0,_util_mem__WEBPACK_IMPORTED_MODULE_4__.avMallocz)(96);
            (0,_util_avpacket__WEBPACK_IMPORTED_MODULE_6__.getAVPacketDefault)(avpacket);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[16](avpacket + 88, 1);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.lock(this.mutex);
            }
            this.list.push(avpacket, 20);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(this.mutex);
            }
        }
        return avpacket;
    }
    release(avpacket) {
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_2__.load(avpacket + 88, 16, 2) <= 0) {
            return;
        }
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_2__.sub(avpacket + 88, 1, 16, 2) === 1) {
            (0,_util_avpacket__WEBPACK_IMPORTED_MODULE_6__.unrefAVPacket)(avpacket);
            cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_2__.store(avpacket + 88, -1, 16, 2);
        }
    }
}


/***/ }),

/***/ "./src/avutil/pixelFormatDescriptor.ts":
/*!*********************************************!*\
  !*** ./src/avutil/pixelFormatDescriptor.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PixelFormatDescriptorsMap: () => (/* binding */ PixelFormatDescriptorsMap)
/* harmony export */ });
/*
 * libmedia pixel format descriptor
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const PixelFormatDescriptorsMap = {
    /**
     * 1 
     */
    [0 /* AVPixelFormat.AV_PIX_FMT_YUV420P */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [12 /* AVPixelFormat.AV_PIX_FMT_YUVJ420P */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [4 /* AVPixelFormat.AV_PIX_FMT_YUV422P */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [13 /* AVPixelFormat.AV_PIX_FMT_YUVJ422P */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [5 /* AVPixelFormat.AV_PIX_FMT_YUV444P */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [14 /* AVPixelFormat.AV_PIX_FMT_YUVJ444P */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [23 /* AVPixelFormat.AV_PIX_FMT_NV12 */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 2,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 2,
                offset: 1,
                shift: 0,
                depth: 8
            }
        ]
    },
    /**
     * 2  yuv420
     */
    [59 /* AVPixelFormat.AV_PIX_FMT_YUV420P9BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [60 /* AVPixelFormat.AV_PIX_FMT_YUV420P9LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [61 /* AVPixelFormat.AV_PIX_FMT_YUV420P10BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [62 /* AVPixelFormat.AV_PIX_FMT_YUV420P10LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [122 /* AVPixelFormat.AV_PIX_FMT_YUV420P12BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [123 /* AVPixelFormat.AV_PIX_FMT_YUV420P12LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [124 /* AVPixelFormat.AV_PIX_FMT_YUV420P14BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [125 /* AVPixelFormat.AV_PIX_FMT_YUV420P14LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [46 /* AVPixelFormat.AV_PIX_FMT_YUV420P16BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    [45 /* AVPixelFormat.AV_PIX_FMT_YUV420P16LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    /**
     * 2  yuv422
     */
    [69 /* AVPixelFormat.AV_PIX_FMT_YUV422P9BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [70 /* AVPixelFormat.AV_PIX_FMT_YUV422P9LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [63 /* AVPixelFormat.AV_PIX_FMT_YUV422P10BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [64 /* AVPixelFormat.AV_PIX_FMT_YUV422P10LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [126 /* AVPixelFormat.AV_PIX_FMT_YUV422P12BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [127 /* AVPixelFormat.AV_PIX_FMT_YUV422P12LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [128 /* AVPixelFormat.AV_PIX_FMT_YUV422P14BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [129 /* AVPixelFormat.AV_PIX_FMT_YUV422P14LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [48 /* AVPixelFormat.AV_PIX_FMT_YUV422P16BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    [47 /* AVPixelFormat.AV_PIX_FMT_YUV422P16LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    /**
     * 2  yuv444
     */
    [65 /* AVPixelFormat.AV_PIX_FMT_YUV444P9BE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [66 /* AVPixelFormat.AV_PIX_FMT_YUV444P9LE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [67 /* AVPixelFormat.AV_PIX_FMT_YUV444P10BE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [68 /* AVPixelFormat.AV_PIX_FMT_YUV444P10LE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [130 /* AVPixelFormat.AV_PIX_FMT_YUV444P12BE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [131 /* AVPixelFormat.AV_PIX_FMT_YUV444P12LE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [132 /* AVPixelFormat.AV_PIX_FMT_YUV444P14BE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [133 /* AVPixelFormat.AV_PIX_FMT_YUV444P14LE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [50 /* AVPixelFormat.AV_PIX_FMT_YUV444P16BE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    [49 /* AVPixelFormat.AV_PIX_FMT_YUV444P16LE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    [26 /* AVPixelFormat.AV_PIX_FMT_RGBA */]: {
        nbComponents: 4,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 32 /* PixelFormatFlags.RGB */ | 128 /* PixelFormatFlags.ALPHA */,
        comp: [
            {
                plane: 0,
                step: 4,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 1,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 2,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 3,
                shift: 0,
                depth: 8
            }
        ]
    },
    [119 /* AVPixelFormat.AV_PIX_FMT_RGB0 */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 32 /* PixelFormatFlags.RGB */,
        comp: [
            {
                plane: 0,
                step: 4,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 1,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 2,
                shift: 0,
                depth: 8
            }
        ]
    },
    [28 /* AVPixelFormat.AV_PIX_FMT_BGRA */]: {
        nbComponents: 4,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 32 /* PixelFormatFlags.RGB */ | 128 /* PixelFormatFlags.ALPHA */,
        comp: [
            {
                plane: 0,
                step: 4,
                offset: 2,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 1,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 3,
                shift: 0,
                depth: 8
            }
        ]
    },
    [121 /* AVPixelFormat.AV_PIX_FMT_BGR0 */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 32 /* PixelFormatFlags.RGB */,
        comp: [
            {
                plane: 0,
                step: 4,
                offset: 2,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 1,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [33 /* AVPixelFormat.AV_PIX_FMT_YUVA420P */]: {
        nbComponents: 4,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */ | 128 /* PixelFormatFlags.ALPHA */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 3,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    }
};


/***/ }),

/***/ "./src/avutil/sampleFormatDescriptor.ts":
/*!**********************************************!*\
  !*** ./src/avutil/sampleFormatDescriptor.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVSampleFormatDescriptors: () => (/* binding */ AVSampleFormatDescriptors)
/* harmony export */ });
const AVSampleFormatDescriptors = {
    [0 /* AVSampleFormat.AV_SAMPLE_FMT_U8 */]: {
        bits: 8,
        planar: false
    },
    [1 /* AVSampleFormat.AV_SAMPLE_FMT_S16 */]: {
        bits: 16,
        planar: false
    },
    [2 /* AVSampleFormat.AV_SAMPLE_FMT_S32 */]: {
        bits: 32,
        planar: false
    },
    [10 /* AVSampleFormat.AV_SAMPLE_FMT_S64 */]: {
        bits: 64,
        planar: false
    },
    [3 /* AVSampleFormat.AV_SAMPLE_FMT_FLT */]: {
        bits: 32,
        planar: false
    },
    [4 /* AVSampleFormat.AV_SAMPLE_FMT_DBL */]: {
        bits: 64,
        planar: false
    },
    [5 /* AVSampleFormat.AV_SAMPLE_FMT_U8P */]: {
        bits: 8,
        planar: true
    },
    [6 /* AVSampleFormat.AV_SAMPLE_FMT_S16P */]: {
        bits: 16,
        planar: true
    },
    [7 /* AVSampleFormat.AV_SAMPLE_FMT_S32P */]: {
        bits: 32,
        planar: true
    },
    [11 /* AVSampleFormat.AV_SAMPLE_FMT_S64P */]: {
        bits: 64,
        planar: true
    },
    [8 /* AVSampleFormat.AV_SAMPLE_FMT_FLTP */]: {
        bits: 32,
        planar: true
    },
    [9 /* AVSampleFormat.AV_SAMPLE_FMT_DBLP */]: {
        bits: 64,
        planar: true
    },
};


/***/ }),

/***/ "./src/avutil/stringEnum.ts":
/*!**********************************!*\
  !*** ./src/avutil/stringEnum.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AudioCodecString2CodecId: () => (/* binding */ AudioCodecString2CodecId),
/* harmony export */   CodecId2MimeType: () => (/* binding */ CodecId2MimeType),
/* harmony export */   Ext2Format: () => (/* binding */ Ext2Format),
/* harmony export */   Ext2IOLoader: () => (/* binding */ Ext2IOLoader),
/* harmony export */   Format2AVFormat: () => (/* binding */ Format2AVFormat),
/* harmony export */   PixfmtString2AVPixelFormat: () => (/* binding */ PixfmtString2AVPixelFormat),
/* harmony export */   SampleFmtString2SampleFormat: () => (/* binding */ SampleFmtString2SampleFormat),
/* harmony export */   SubtitleCodecString2CodecId: () => (/* binding */ SubtitleCodecString2CodecId),
/* harmony export */   VideoCodecString2CodecId: () => (/* binding */ VideoCodecString2CodecId),
/* harmony export */   colorRange2AVColorRange: () => (/* binding */ colorRange2AVColorRange),
/* harmony export */   colorSpace2AVColorSpace: () => (/* binding */ colorSpace2AVColorSpace),
/* harmony export */   disposition2AVDisposition: () => (/* binding */ disposition2AVDisposition),
/* harmony export */   mediaType2AVMediaType: () => (/* binding */ mediaType2AVMediaType)
/* harmony export */ });
/* unused harmony exports colorPrimaries2AVColorPrimaries, colorTrc2AVColorTransferCharacteristic */
const CodecId2MimeType = {
    [86017 /* AVCodecID.AV_CODEC_ID_MP3 */]: 'mp3',
    [86018 /* AVCodecID.AV_CODEC_ID_AAC */]: 'mp4a.40',
    [86021 /* AVCodecID.AV_CODEC_ID_VORBIS */]: 'vorbis',
    [86028 /* AVCodecID.AV_CODEC_ID_FLAC */]: 'flac',
    [86076 /* AVCodecID.AV_CODEC_ID_OPUS */]: 'opus',
    [65542 /* AVCodecID.AV_CODEC_ID_PCM_MULAW */]: 'ulaw',
    [65543 /* AVCodecID.AV_CODEC_ID_PCM_ALAW */]: 'alaw',
    [225 /* AVCodecID.AV_CODEC_ID_AV1 */]: 'av01',
    [27 /* AVCodecID.AV_CODEC_ID_H264 */]: 'avc1',
    [173 /* AVCodecID.AV_CODEC_ID_HEVC */]: 'hev1',
    [196 /* AVCodecID.AV_CODEC_ID_VVC */]: 'vvc1',
    [139 /* AVCodecID.AV_CODEC_ID_VP8 */]: 'vp8',
    [167 /* AVCodecID.AV_CODEC_ID_VP9 */]: 'vp09',
    [12 /* AVCodecID.AV_CODEC_ID_MPEG4 */]: 'mp4v'
};
const Ext2Format = {
    'flv': 0 /* AVFormat.FLV */,
    'mp4': 1 /* AVFormat.MOV */,
    'mov': 1 /* AVFormat.MOV */,
    'ts': 2 /* AVFormat.MPEGTS */,
    'ivf': 5 /* AVFormat.IVF */,
    'opus': 4 /* AVFormat.OGG */,
    'oggs': 4 /* AVFormat.OGG */,
    'ogg': 4 /* AVFormat.OGG */,
    'm3u8': 2 /* AVFormat.MPEGTS */,
    'm3u': 2 /* AVFormat.MPEGTS */,
    'mpd': 1 /* AVFormat.MOV */,
    'mp3': 12 /* AVFormat.MP3 */,
    'mkv': 6 /* AVFormat.MATROSKA */,
    'mka': 6 /* AVFormat.MATROSKA */,
    'webm': 7 /* AVFormat.WEBM */,
    'aac': 13 /* AVFormat.AAC */,
    'flac': 15 /* AVFormat.FLAC */,
    'wav': 14 /* AVFormat.WAV */,
    'srt': 17 /* AVFormat.SUBRIP */,
    'vtt': 16 /* AVFormat.WEBVTT */,
    'ssa': 18 /* AVFormat.ASS */,
    'ass': 18 /* AVFormat.ASS */,
    'xml': 19 /* AVFormat.TTML */,
    'ttml': 19 /* AVFormat.TTML */,
    'h264': 9 /* AVFormat.H264 */,
    '264': 9 /* AVFormat.H264 */,
    'avc': 9 /* AVFormat.H264 */,
    'h265': 10 /* AVFormat.HEVC */,
    '265': 10 /* AVFormat.HEVC */,
    'hevc': 10 /* AVFormat.HEVC */,
    'h266': 11 /* AVFormat.VVC */,
    '266': 11 /* AVFormat.VVC */,
    'vvc': 11 /* AVFormat.VVC */,
    'mpeg': 3 /* AVFormat.MPEGPS */,
    'mpg': 3 /* AVFormat.MPEGPS */
};
const Ext2IOLoader = {
    'm3u8': 2 /* IOType.HLS */,
    'm3u': 2 /* IOType.HLS */,
    'mpd': 3 /* IOType.DASH */
};
const VideoCodecString2CodecId = {
    'copy': 0 /* AVCodecID.AV_CODEC_ID_NONE */,
    'h264': 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    'avc': 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    'hevc': 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    'h265': 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    'vvc': 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    'h266': 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    'av1': 225 /* AVCodecID.AV_CODEC_ID_AV1 */,
    'vp9': 167 /* AVCodecID.AV_CODEC_ID_VP9 */,
    'vp8': 139 /* AVCodecID.AV_CODEC_ID_VP8 */,
    'mpeg4': 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */,
    'theora': 30 /* AVCodecID.AV_CODEC_ID_THEORA */,
    'mpeg2video': 2 /* AVCodecID.AV_CODEC_ID_MPEG2VIDEO */
};
const AudioCodecString2CodecId = {
    'copy': 0 /* AVCodecID.AV_CODEC_ID_NONE */,
    'aac': 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    'ac3': 86019 /* AVCodecID.AV_CODEC_ID_AC3 */,
    'eac3': 86056 /* AVCodecID.AV_CODEC_ID_EAC3 */,
    'dca': 86020 /* AVCodecID.AV_CODEC_ID_DTS */,
    'mp3': 86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
    'opus': 86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
    'flac': 86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
    'speex': 86051 /* AVCodecID.AV_CODEC_ID_SPEEX */,
    'vorbis': 86021 /* AVCodecID.AV_CODEC_ID_VORBIS */,
    'pcm_alaw': 65543 /* AVCodecID.AV_CODEC_ID_PCM_ALAW */,
    'pcm_mulaw': 65542 /* AVCodecID.AV_CODEC_ID_PCM_MULAW */
};
const SubtitleCodecString2CodecId = {
    'webvtt': 94226 /* AVCodecID.AV_CODEC_ID_WEBVTT */,
    'subrip': 94225 /* AVCodecID.AV_CODEC_ID_SUBRIP */,
    'ass': 94230 /* AVCodecID.AV_CODEC_ID_ASS */,
    'ttml': 94232 /* AVCodecID.AV_CODEC_ID_TTML */,
    'mov_text': 94213 /* AVCodecID.AV_CODEC_ID_MOV_TEXT */,
    'hdmv_pgs': 94214 /* AVCodecID.AV_CODEC_ID_HDMV_PGS_SUBTITLE */,
    'hdmv_text': 94231 /* AVCodecID.AV_CODEC_ID_HDMV_TEXT_SUBTITLE */,
    'dvd': 94208 /* AVCodecID.AV_CODEC_ID_DVD_SUBTITLE */,
    'dvb': 94209 /* AVCodecID.AV_CODEC_ID_DVB_SUBTITLE */,
    'eia_608': 94218 /* AVCodecID.AV_CODEC_ID_EIA_608 */
};
const PixfmtString2AVPixelFormat = {
    'yuv420p': 0 /* AVPixelFormat.AV_PIX_FMT_YUV420P */,
    'yuv422p': 4 /* AVPixelFormat.AV_PIX_FMT_YUV422P */,
    'yuv444p': 5 /* AVPixelFormat.AV_PIX_FMT_YUV444P */,
    'yuva420p': 33 /* AVPixelFormat.AV_PIX_FMT_YUVA420P */,
    'yuva422p': 78 /* AVPixelFormat.AV_PIX_FMT_YUVA422P */,
    'yuva444p': 79 /* AVPixelFormat.AV_PIX_FMT_YUVA444P */,
    'yuv420p10le': 62 /* AVPixelFormat.AV_PIX_FMT_YUV420P10LE */,
    'yuv422p10le': 64 /* AVPixelFormat.AV_PIX_FMT_YUV422P10LE */,
    'yuv444p10le': 68 /* AVPixelFormat.AV_PIX_FMT_YUV444P10LE */,
    'yuva420p10le': 87 /* AVPixelFormat.AV_PIX_FMT_YUVA420P10LE */,
    'yuva422p10le': 89 /* AVPixelFormat.AV_PIX_FMT_YUVA422P10LE */,
    'yuva444p10le': 91 /* AVPixelFormat.AV_PIX_FMT_YUVA444P10LE */,
    'yuv420p10be': 61 /* AVPixelFormat.AV_PIX_FMT_YUV420P10BE */,
    'yuv422p10be': 63 /* AVPixelFormat.AV_PIX_FMT_YUV422P10BE */,
    'yuv444p10be': 67 /* AVPixelFormat.AV_PIX_FMT_YUV444P10BE */,
    'yuva420p10be': 86 /* AVPixelFormat.AV_PIX_FMT_YUVA420P10BE */,
    'yuva422p10be': 88 /* AVPixelFormat.AV_PIX_FMT_YUVA422P10BE */,
    'yuva444p10be': 90 /* AVPixelFormat.AV_PIX_FMT_YUVA444P10BE */,
};
const SampleFmtString2SampleFormat = {
    'u8': 0 /* AVSampleFormat.AV_SAMPLE_FMT_U8 */,
    'u8-planar': 5 /* AVSampleFormat.AV_SAMPLE_FMT_U8P */,
    's16': 1 /* AVSampleFormat.AV_SAMPLE_FMT_S16 */,
    's16-planar': 6 /* AVSampleFormat.AV_SAMPLE_FMT_S16P */,
    's32': 2 /* AVSampleFormat.AV_SAMPLE_FMT_S32 */,
    's32-planar': 7 /* AVSampleFormat.AV_SAMPLE_FMT_S32P */,
    's64': 10 /* AVSampleFormat.AV_SAMPLE_FMT_S64 */,
    's64-planar': 11 /* AVSampleFormat.AV_SAMPLE_FMT_S64P */,
    'float': 3 /* AVSampleFormat.AV_SAMPLE_FMT_FLT */,
    'float-planar': 8 /* AVSampleFormat.AV_SAMPLE_FMT_FLTP */,
    'double': 4 /* AVSampleFormat.AV_SAMPLE_FMT_DBL */,
    'double-planar': 9 /* AVSampleFormat.AV_SAMPLE_FMT_DBLP */,
};
const Format2AVFormat = {
    'flv': 0 /* AVFormat.FLV */,
    'mp4': 1 /* AVFormat.MOV */,
    'mov': 1 /* AVFormat.MOV */,
    'ts': 2 /* AVFormat.MPEGTS */,
    'mpegts': 2 /* AVFormat.MPEGTS */,
    'mpeg': 3 /* AVFormat.MPEGPS */,
    'ivf': 5 /* AVFormat.IVF */,
    'ogg': 4 /* AVFormat.OGG */,
    'opus': 4 /* AVFormat.OGG */,
    'm3u8': 2 /* AVFormat.MPEGTS */,
    'm3u': 2 /* AVFormat.MPEGTS */,
    'mpd': 1 /* AVFormat.MOV */,
    'mp3': 12 /* AVFormat.MP3 */,
    'mkv': 6 /* AVFormat.MATROSKA */,
    'matroska': 6 /* AVFormat.MATROSKA */,
    'mka': 6 /* AVFormat.MATROSKA */,
    'webm': 7 /* AVFormat.WEBM */,
    'aac': 13 /* AVFormat.AAC */,
    'flac': 15 /* AVFormat.FLAC */,
    'wav': 14 /* AVFormat.WAV */,
    'raw_h264': 9 /* AVFormat.H264 */,
    'raw_h265': 10 /* AVFormat.HEVC */,
    'raw_vvc': 11 /* AVFormat.VVC */
};
const colorRange2AVColorRange = {
    'tv': 1 /* AVColorRange.AVCOL_RANGE_MPEG */,
    'pc': 2 /* AVColorRange.AVCOL_RANGE_JPEG */
};
const colorSpace2AVColorSpace = {
    'bt709': 1 /* AVColorSpace.AVCOL_SPC_BT709 */,
    'fcc': 4 /* AVColorSpace.AVCOL_SPC_FCC */,
    'bt470bg': 5 /* AVColorSpace.AVCOL_SPC_BT470BG */,
    'smpte170m': 6 /* AVColorSpace.AVCOL_SPC_SMPTE170M */,
    'smpte240m': 7 /* AVColorSpace.AVCOL_SPC_SMPTE240M */,
    'ycgco': 8 /* AVColorSpace.AVCOL_SPC_YCGCO */,
    'gbr': 0 /* AVColorSpace.AVCOL_SPC_RGB */,
    'bt2020ncl': 9 /* AVColorSpace.AVCOL_SPC_BT2020_NCL */
};
const colorPrimaries2AVColorPrimaries = {
    'bt709': 1 /* AVColorPrimaries.AVCOL_PRI_BT709 */,
    'bt470m': 4 /* AVColorPrimaries.AVCOL_PRI_BT470M */,
    'bt470bg': 5 /* AVColorPrimaries.AVCOL_PRI_BT470BG */,
    'smpte170m': 6 /* AVColorPrimaries.AVCOL_PRI_SMPTE170M */,
    'smpte240m': 7 /* AVColorPrimaries.AVCOL_PRI_SMPTE240M */,
    'smpte428': 10 /* AVColorPrimaries.AVCOL_PRI_SMPTE428 */,
    'film': 8 /* AVColorPrimaries.AVCOL_PRI_FILM */,
    'smpte431': 11 /* AVColorPrimaries.AVCOL_PRI_SMPTE431 */,
    'smpte432': 12 /* AVColorPrimaries.AVCOL_PRI_SMPTE432 */,
    'bt2020': 9 /* AVColorPrimaries.AVCOL_PRI_BT2020 */,
    'jedec-p22': 22 /* AVColorPrimaries.AVCOL_PRI_JEDEC_P22 */,
    'ebu3213': 22 /* AVColorPrimaries.AVCOL_PRI_EBU3213 */
};
const colorTrc2AVColorTransferCharacteristic = {
    'bt709': 1 /* AVColorTransferCharacteristic.AVCOL_TRC_BT709 */,
    'gamma22': 4 /* AVColorTransferCharacteristic.AVCOL_TRC_GAMMA22 */,
    'gamma28': 5 /* AVColorTransferCharacteristic.AVCOL_TRC_GAMMA28 */,
    'smpte170m': 6 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE170M */,
    'smpte240m': 7 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE240M */,
    'srgb': 13 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_1 */,
    'xvycc': 11 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4 */,
    'bt2020-10': 14 /* AVColorTransferCharacteristic.AVCOL_TRC_BT2020_10 */,
    'bt2020-12': 15 /* AVColorTransferCharacteristic.AVCOL_TRC_BT2020_12 */
};
const mediaType2AVMediaType = {
    'Audio': 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */,
    'Video': 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */,
    'Subtitle': 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */,
    'Attachment': 4 /* AVMediaType.AVMEDIA_TYPE_ATTACHMENT */,
    'Data': 2 /* AVMediaType.AVMEDIA_TYPE_DATA */
};
const disposition2AVDisposition = {
    'default': 1 /* AVDisposition.DEFAULT */,
    'dub': 2 /* AVDisposition.DUB */,
    'original': 4 /* AVDisposition.ORIGINAL */,
    'comment': 8 /* AVDisposition.COMMENT */,
    'lyrics': 16 /* AVDisposition.LYRICS */,
    'karaoke': 32 /* AVDisposition.KARAOKE */,
    'forced': 64 /* AVDisposition.FORCED */,
    'hearing impaired': 128 /* AVDisposition.HEARING_IMPAIRED */,
    'visual impaired': 256 /* AVDisposition.VISUAL_IMPAIRED */,
    'clean effects': 512 /* AVDisposition.CLEAN_EFFECTS */,
    'attached pic': 1024 /* AVDisposition.ATTACHED_PIC */,
    'timed thumbnails': 2048 /* AVDisposition.TIMED_THUMBNAILS */,
    'captions': 65536 /* AVDisposition.CAPTIONS */,
    'descriptions': 131072 /* AVDisposition.DESCRIPTIONS */,
    'metadata': 262144 /* AVDisposition.METADATA */,
    'dependent': 524288 /* AVDisposition.DEPENDENT */,
    'still image': 1048576 /* AVDisposition.STILL_IMAGE */
};


/***/ }),

/***/ "./src/avutil/struct/audiosample.ts":
/*!******************************************!*\
  !*** ./src/avutil/struct/audiosample.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVChannelLayout: () => (/* binding */ AVChannelLayout)
/* harmony export */ });
/* unused harmony export AVChannelCustom */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


class AVChannelCustom {
    id;
    name;
    opaque;
}
(function (prototype) {
    var map = new Map();
    map.set("id", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("name", { 0: 4, 1: 0, 2: 0, 3: 1, 4: 16, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 24);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVChannelCustom.prototype);
class AVChannelLayout {
    /**
     * Channel order used in this layout.
     * This is a mandatory field.
     */
    order;
    /**
     * Number of channels in this layout. Mandatory field.
     */
    nbChannels;
    /**
     * Details about which channels are present in this layout.
     * For AV_CHANNEL_ORDER_UNSPEC, this field is undefined and must not be
     * used.
     */
    u;
    /**
     * For some private data of the user.
     */
    opaque;
}
(function (prototype) {
    var map = new Map();
    map.set("order", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("nbChannels", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("u", { 0: (function (prototype) {
            var map = new Map();
            map.set("mask", { 0: 10, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
            map.set("map", { 0: AVChannelCustom, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
            return prototype;
        })({}), 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 24);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVChannelLayout.prototype);


/***/ }),

/***/ "./src/avutil/struct/avbuffer.ts":
/*!***************************************!*\
  !*** ./src/avutil/struct/avbuffer.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVBufferRef: () => (/* binding */ AVBufferRef)
/* harmony export */ });
/* unused harmony exports AVBuffer, AVBufferPool, BufferPoolEntry */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\..\cheap\thread\mutex.ts */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
var cheap__BufferPoolEntry__16;



/*
 * libmedia AVBuffer defined
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class AVBuffer {
    /**
     * data described by this buffer
     */
    data = 0;
    /**
     * size of data in bytes
     */
    size = 0;
    /**
     *  number of existing AVBufferRef instances referring to this buffer
     */
    refcount = 0;
    /**
     * a callback for freeing the data
     */
    free = 0;
    /**
     * an opaque pointer, to be used by the freeing callback
     */
    opaque = 0;
    /**
     * A combination of AV_BUFFER_FLAG_*
     */
    flags = 0 /* AVBufferFlags.NONE */;
    /**
     * A combination of BUFFER_FLAG_*
     */
    flagsInternal = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("refcount", { 0: 9, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("free", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("flagsInternal", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 28);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVBuffer.prototype);
function avbufferDefaultFree(opaque, data) {
    (0,_util_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(data);
}
class AVBufferRef {
    buffer = 0;
    /**
     * The data buffer. It is considered writable if and only if
     * this is the only reference to the buffer, in which case
     * av_buffer_is_writable() returns 1.
     */
    data = 0;
    /**
     * Size of data in bytes.
     */
    size = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("buffer", { 0: AVBuffer, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVBufferRef.prototype);
class AVBufferPool {
    mutex;
    pool = 0;
    /**
     *  number of existing AVBufferRef instances referring to this buffer
     */
    refcount = 0;
    /**
     * Size of data in bytes.
     */
    size = 0;
    /**
     * an opaque pointer, to be used by the freeing callback
     */
    opaque = 0;
    alloc = 0;
    alloc2 = 0;
    poolFree = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("mutex", { 0: _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_2__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("pool", { 0: cheap__BufferPoolEntry__16, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("refcount", { 0: 9, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("alloc", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("alloc2", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("poolFree", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 32);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVBufferPool.prototype);
class BufferPoolEntry {
    data = 0;
    /**
     * an opaque pointer, to be used by the freeing callback
     */
    opaque = 0;
    /**
     * a callback for freeing the data
     */
    free = 0;
    pool = 0;
    next = 0;
    /*
     * An AVBuffer structure to (re)use as AVBuffer for subsequent uses
     * of this BufferPoolEntry.
     */
    buffer;
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("free", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("pool", { 0: AVBufferPool, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("next", { 0: BufferPoolEntry, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("buffer", { 0: AVBuffer, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 48);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(BufferPoolEntry.prototype);
cheap__BufferPoolEntry__16 = BufferPoolEntry;


/***/ }),

/***/ "./src/avutil/struct/avcodecparameters.ts":
/*!************************************************!*\
  !*** ./src/avutil/struct/avcodecparameters.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVCodecParameters)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _avpacket_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./avpacket.ts */ "./src/avutil/struct/avpacket.ts");
/* harmony import */ var _rational_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rational */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _audiosample_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./audiosample.ts */ "./src/avutil/struct/audiosample.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _util_codecparameters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/codecparameters */ "./src/avutil/util/codecparameters.ts");





/*
 * libmedia AVCodecParameters defined
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




/**
 * FFmpeg AVCodecParameters 
 */
class AVCodecParameters {
    /**
     * General type of the encoded data.
     */
    codecType = -1 /* AVMediaType.AVMEDIA_TYPE_UNKNOWN */;
    /**
     * Specific type of the encoded data (the codec used).
     */
    codecId = 0 /* AVCodecID.AV_CODEC_ID_NONE */;
    /**
     * Additional information about the codec (corresponds to the AVI FOURCC).
     */
    codecTag = 0;
    /**
     * Extra binary data needed for initializing the decoder, codec-dependent.
     *
     * Must be allocated with av_malloc() and will be freed by
     * avcodec_parameters_free(). The allocated size of extradata must be at
     * least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding
     * bytes zeroed.
     */
    extradata = 0;
    extradataSize = 0;
    /**
     * Additional data associated with the entire stream.
     *
     * Should be allocated with av_packet_side_data_new() or
     * av_packet_side_data_add(), and will be freed by avcodec_parameters_free().
     */
    codedSideData = 0;
    /**
     * Amount of entries in @ref coded_side_data.
     */
    nbCodedSideData = 0;
    /**
     * - video: the pixel format, the value corresponds to enum AVPixelFormat.
     * - audio: the sample format, the value corresponds to enum AVSampleFormat.
     */
    format = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * The average bitrate of the encoded data (in bits per second).
     */
    bitrate = BigInt(0);
    /**
     * The number of bits per sample in the codedwords.
     *
     * This is basically the bitrate per sample. It is mandatory for a bunch of
     * formats to actually decode them. It's the number of bits for one sample in
     * the actual coded bitstream.
     *
     * This could be for example 4 for ADPCM
     * For PCM formats this matches bits_per_raw_sample
     * Can be 0
     */
    bitsPerCodedSample = 0;
    /**
     * This is the number of valid bits in each output sample. If the
     * sample format has more bits, the least significant bits are additional
     * padding bits, which are always 0. Use right shifts to reduce the sample
     * to its actual size. For example, audio formats with 24 bit samples will
     * have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.
     * To get the original sample use "(int32_t)sample >> 8"."
     *
     * For ADPCM this might be 12 or 16 or similar
     * Can be 0
     */
    bitsPerRawSample = 0;
    /**
     * Codec-specific bitstream restrictions that the stream conforms to.
     */
    profile = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    level = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * Video only. The dimensions of the video frame in pixels.
     */
    width = 0;
    height = 0;
    /**
     * Video only. The aspect ratio (width / height) which a single pixel
     * should have when displayed.
     *
     * When the aspect ratio is unknown / undefined, the numerator should be
     * set to 0 (the denominator may have any value).
     */
    sampleAspectRatio = new _rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational({ den: 1, num: 1 });
    /**
     * Video only. Number of frames per second, for streams with constant frame
     * durations. Should be set to { 0, 1 } when some frames have differing
     * durations or if the value is not known.
     *
     * @note This field correponds to values that are stored in codec-level
     * headers and is typically overridden by container/transport-layer
     * timestamps, when available. It should thus be used only as a last resort,
     * when no higher-level timing information is available.
     */
    framerate = new _rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational({ den: 1, num: 0 });
    /**
     * Video only. The order of the fields in interlaced video.
     */
    fieldOrder = 0 /* AVFieldOrder.AV_FIELD_UNKNOWN */;
    /**
     * Video only. Additional colorspace characteristics.
     */
    colorRange = 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */;
    colorPrimaries = 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */;
    colorTrc = 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */;
    colorSpace = 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */;
    chromaLocation = 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */;
    /**
     * Video only. Number of delayed frames.
     */
    videoDelay = 0;
    /**
     * Audio only. The channel layout and number of channels.
     */
    chLayout;
    /**
     * Audio only. The number of audio samples per second.
     */
    sampleRate = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * Audio only. The number of bytes per coded audio frame, required by some
     * formats.
     *
     * Corresponds to nBlockAlign in WAVEFORMATEX.
     */
    blockAlign = 0;
    /**
     * Audio only. Audio frame size, if known. Required by some formats to be static.
     */
    frameSize = 0;
    /**
     * Audio only. The amount of padding (in samples) inserted by the encoder at
     * the beginning of the audio. I.e. this number of leading decoded samples
     * must be discarded by the caller to get the original audio without leading
     * padding.
     */
    initialPadding = 0;
    /**
     * Audio only. The amount of padding (in samples) appended by the encoder to
     * the end of the audio. I.e. this number of decoded samples must be
     * discarded by the caller from the end of the stream to get the original
     * audio without any trailing padding.
     */
    trailingPadding = 0;
    /**
     * Audio only. Number of samples to skip after a discontinuity.
     */
    seekPreroll = 0;
    /**
     * 
     *  h264/h265/h266  annexb  avcc 
     */
    bitFormat = 0;
    destroy() {
        (0,_util_codecparameters__WEBPACK_IMPORTED_MODULE_6__.freeCodecParameters)(this[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
        this[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] = 0;
    }
}
(function (prototype) {
    var map = new Map();
    map.set("codecType", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("codecId", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("codecTag", { 0: 8, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("extradata", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("extradataSize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("codedSideData", { 0: _avpacket_ts__WEBPACK_IMPORTED_MODULE_2__.AVPacketSideData, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("nbCodedSideData", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("format", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    map.set("bitrate", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    map.set("bitsPerCodedSample", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 40, 8: 0 });
    map.set("bitsPerRawSample", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 44, 8: 0 });
    map.set("profile", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 48, 8: 0 });
    map.set("level", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 52, 8: 0 });
    map.set("width", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 56, 8: 0 });
    map.set("height", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 60, 8: 0 });
    map.set("sampleAspectRatio", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("framerate", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("fieldOrder", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    map.set("colorRange", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 84, 8: 0 });
    map.set("colorPrimaries", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 88, 8: 0 });
    map.set("colorTrc", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 92, 8: 0 });
    map.set("colorSpace", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 96, 8: 0 });
    map.set("chromaLocation", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 100, 8: 0 });
    map.set("videoDelay", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 104, 8: 0 });
    map.set("chLayout", { 0: _audiosample_ts__WEBPACK_IMPORTED_MODULE_4__.AVChannelLayout, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 112, 8: 0 });
    map.set("sampleRate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 136, 8: 0 });
    map.set("blockAlign", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 140, 8: 0 });
    map.set("frameSize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 144, 8: 0 });
    map.set("initialPadding", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 148, 8: 0 });
    map.set("trailingPadding", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 152, 8: 0 });
    map.set("seekPreroll", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 156, 8: 0 });
    map.set("bitFormat", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 160, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 168);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVCodecParameters.prototype);


/***/ }),

/***/ "./src/avutil/struct/avdict.ts":
/*!*************************************!*\
  !*** ./src/avutil/struct/avdict.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVDictionary: () => (/* binding */ AVDictionary)
/* harmony export */ });
/* unused harmony export AVDictionaryEntry */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


class AVDictionaryEntry {
    key = 0;
    value = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("key", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("value", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVDictionaryEntry.prototype);
class AVDictionary {
    count = 0;
    elems = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("count", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("elems", { 0: AVDictionaryEntry, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVDictionary.prototype);


/***/ }),

/***/ "./src/avutil/struct/avframe.ts":
/*!**************************************!*\
  !*** ./src/avutil/struct/avframe.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AV_NUM_DATA_POINTERS: () => (/* binding */ AV_NUM_DATA_POINTERS)
/* harmony export */ });
/* unused harmony exports AVFrameSideData, AVMasteringDisplayMetadata, AVContentLightMetadata, default, AVFrameRef */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _avdict_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./avdict.ts */ "./src/avutil/struct/avdict.ts");
/* harmony import */ var _avbuffer_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./avbuffer.ts */ "./src/avutil/struct/avbuffer.ts");
/* harmony import */ var _rational_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rational */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var _audiosample_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./audiosample.ts */ "./src/avutil/struct/audiosample.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _util_avframe__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/avframe */ "./src/avutil/util/avframe.ts");







/*
 * libmedia AVFrame defined
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




const AV_NUM_DATA_POINTERS = 8;
class AVFrameSideData {
    type = 0;
    data = 0;
    size = 0;
    metadata = 0;
    buf = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("type", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("metadata", { 0: _avdict_ts__WEBPACK_IMPORTED_MODULE_2__.AVDictionary, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("buf", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_3__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 20);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVFrameSideData.prototype);
class AVMasteringDisplayMetadata {
    /**
     * CIE 1931 xy chromaticity coords of color primaries (r, g, b order).
     */
    displayPrimaries;
    /**
     * CIE 1931 xy chromaticity coords of white point.
     */
    whitePoint;
    /**
     * Min luminance of mastering display (cd/m^2).
     */
    minLuminance;
    /**
     * Max luminance of mastering display (cd/m^2).
     */
    maxLuminance;
    /**
     * Flag indicating whether the display primaries (and white point) are set.
     */
    hasPrimaries;
    /**
     * Flag indicating whether the luminance (min_ and max_) have been set.
     */
    hasLuminance;
}
(function (prototype) {
    var map = new Map();
    map.set("displayPrimaries", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 1, 4: 6, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("whitePoint", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 1, 4: 2, 5: 0, 6: 0, 7: 48, 8: 0 });
    map.set("minLuminance", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("maxLuminance", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("hasPrimaries", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    map.set("hasLuminance", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 84, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 88);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVMasteringDisplayMetadata.prototype);
class AVContentLightMetadata {
    /**
     * Max content light level (cd/m^2).
     */
    maxCLL;
    /**
     * Max average light level per frame (cd/m^2).
     */
    maxFALL;
}
(function (prototype) {
    var map = new Map();
    map.set("maxCLL", { 0: 8, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("maxFALL", { 0: 8, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVContentLightMetadata.prototype);
/**
 * FFmpeg AVFrame 
 */
class AVFrame {
    /**
     * pointer to the picture/channel planes.
     * This might be different from the first allocated byte
     *
     * Some decoders access areas outside 0,0 - width, height, please
     * see avcodec_align_dimensions2(). Some filters and swscale can read
     * up to 16 bytes beyond the planes, if these filters are to be used,
     * then 16 extra bytes must be allocated.
     *
     * NOTE: Except for hwaccel formats, pointers not needed by the format
     * MUST be set to NULL.
     */
    data = new Array(AV_NUM_DATA_POINTERS).fill(0, 0, AV_NUM_DATA_POINTERS);
    /**
     * For video, size in bytes of each picture line.
     * For audio, size in bytes of each plane.
     *
     * For audio, only linesize[0] may be set. For planar audio, each channel
     * plane must be the same size.
     *
     * For video the linesizes should be multiples of the CPUs alignment
     * preference, this is 16 or 32 for modern desktop CPUs.
     * Some code requires such alignment other code can be slower without
     * correct alignment, for yet other it makes no difference.
     *
     * @note The linesize may be larger than the size of usable data -- there
     * may be extra padding present for performance reasons.
     */
    linesize = new Array(AV_NUM_DATA_POINTERS).fill(0, 0, AV_NUM_DATA_POINTERS);
    /**
     * pointers to the data planes/channels.
     *
     * For video, this should simply point to data[].
     *
     * For planar audio, each channel has a separate data pointer, and
     * linesize[0] contains the size of each channel buffer.
     * For packed audio, there is just one data pointer, and linesize[0]
     * contains the total size of the buffer for all channels.
     *
     * Note: Both data and extended_data should always be set in a valid frame,
     * but for planar audio with more channels that can fit in data,
     * extended_data must be used in order to access all channels.
     */
    extendedData = 0;
    /**
     * @name Video dimensions
     * Video frames only. The coded dimensions (in pixels) of the video frame,
     * i.e. the size of the rectangle that contains some well-defined values.
     *
     * @note The part of the frame intended for display/presentation is further
     * restricted by the @ref cropping "Cropping rectangle".
     *
     */
    width = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    height = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * number of audio samples (per channel) described by this frame
     */
    nbSamples = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * format of the frame, -1 if unknown or unset
     * Values correspond to enum AVPixelFormat for video frames,
     * enum AVSampleFormat for audio)
     */
    format = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * 1 -> keyframe, 0-> not
     *
     * @deprecated Use AV_FRAME_FLAG_KEY instead
     */
    keyFrame = 0;
    /**
     * Picture type of the frame.
     */
    pictType = 0 /* AVPictureType.AV_PICTURE_TYPE_NONE */;
    /**
     * Sample aspect ratio for the video frame, 0/1 if unknown/unspecified.
     */
    sampleAspectRatio = new _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational({ den: 1, num: 0 });
    /**
     * Presentation timestamp in time_base units (time when frame should be shown to user).
     */
    pts = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE_BIGINT;
    /**
     * DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn't used)
     * This is also the Presentation time of this AVFrame calculated from
     * only AVPacket.dts values without pts values.
     */
    pktDts = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE_BIGINT;
    /**
     * Time base for the timestamps in this frame.
     * In the future, this field may be set on frames output by decoders or
     * filters, but its value will be by default ignored on input to encoders
     * or filters.
     */
    timeBase;
    /**
     * quality (between 1 (good) and FF_LAMBDA_MAX (bad))
     */
    quality = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * Frame owner's private data.
     *
     * This field may be set by the code that allocates/owns the frame data.
     * It is then not touched by any library functions, except:
     * - it is copied to other references by av_frame_copy_props() (and hence by
     *   av_frame_ref());
     * - it is set to NULL when the frame is cleared by av_frame_unref()
     * - on the caller's explicit request. E.g. libavcodec encoders/decoders
     *   will copy this field to/from @ref AVPacket "AVPackets" if the caller sets
     *   @ref AV_CODEC_FLAG_COPY_OPAQUE.
     *
     * @see opaque_ref the reference-counted analogue
     */
    opaque = 0;
    /**
     * Number of fields in this frame which should be repeated, i.e. the total
     * duration of this frame should be repeat_pict + 2 normal field durations.
     *
     * For interlaced frames this field may be set to 1, which signals that this
     * frame should be presented as 3 fields: beginning with the first field (as
     * determined by AV_FRAME_FLAG_TOP_FIELD_FIRST being set or not), followed
     * by the second field, and then the first field again.
     *
     * For progressive frames this field may be set to a multiple of 2, which
     * signals that this frame's duration should be (repeat_pict + 2) / 2
     * normal frame durations.
     *
     * @note This field is computed from MPEG2 repeat_first_field flag and its
     * associated flags, H.264 pic_struct from picture timing SEI, and
     * their analogues in other codecs. Typically it should only be used when
     * higher-layer timing information is not available.
     */
    repeatPict = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * The content of the picture is interlaced.
     *
     * @deprecated Use AV_FRAME_FLAG_INTERLACED instead
     */
    interlacedFrame = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * If the content is interlaced, is top field displayed first.
     *
     * @deprecated Use AV_FRAME_FLAG_TOP_FIELD_FIRST instead
     */
    topFieldFirst = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * Tell user application that palette has changed from previous frame.
     *  @deprecated
     */
    paletteHasChanged = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * Sample rate of the audio data.
     */
    sampleRate = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * AVBuffer references backing the data for this frame. If all elements of
     * this array are NULL, then this frame is not reference counted. This array
     * must be filled contiguously -- if buf[i] is non-NULL then buf[j] must
     * also be non-NULL for all j < i.
     *
     * There may be at most one AVBuffer per data plane, so for video this array
     * always contains all the references. For planar audio with more than
     * AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in
     * this array. Then the extra AVBufferRef pointers are stored in the
     * extended_buf array.
     */
    buf = new Array(AV_NUM_DATA_POINTERS).fill(0, 0, AV_NUM_DATA_POINTERS);
    /**
     * For planar audio which requires more than AV_NUM_DATA_POINTERS
     * AVBufferRef pointers, this array will hold all the references which
     * cannot fit into AVFrame.buf.
     *
     * Note that this is different from AVFrame.extended_data, which always
     * contains all the pointers. This array only contains the extra pointers,
     * which cannot fit into AVFrame.buf.
     *
     * This array is always allocated using av_malloc() by whoever constructs
     * the frame. It is freed in av_frame_unref().
     */
    extendedBuf = 0;
    /**
     * Number of elements in extended_buf.
     */
    nbExtendedBuf = 0;
    sideData = 0;
    nbSideData = 0;
    /**
     * Frame flags, a combination of @ref lavu_frame_flags
     */
    flags = 0 /* AVFrameFlags.AV_FRAME_FLAG_NONE */;
    /**
     * MPEG vs JPEG YUV range.
     * - encoding: Set by user
     * - decoding: Set by libavcodec
     */
    colorRange = 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */;
    colorPrimaries = 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */;
    colorTrc = 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */;
    /**
     * YUV colorspace type.
     * - encoding: Set by user
     * - decoding: Set by libavcodec
     */
    colorSpace = 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */;
    chromaLocation = 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */;
    /**
     * frame timestamp estimated using various heuristics, in stream time base
     * - encoding: unused
     * - decoding: set by libavcodec, read by user.
     */
    bestEffortTimestamp = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE_BIGINT;
    /**
     * reordered pos from the last AVPacket that has been input into the decoder
     * - encoding: unused
     * - decoding: Read by user.
     * @deprecated use AV_CODEC_FLAG_COPY_OPAQUE to pass through arbitrary user
     *             data from packets to frames
     */
    pktPos = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE_BIGINT;
    /**
     * metadata.
     * - encoding: Set by user.
     * - decoding: Set by libavcodec.
     */
    metadata = 0;
    /**
     * decode error flags of the frame, set to a combination of
     * FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there
     * were errors during the decoding.
     * - encoding: unused
     * - decoding: set by libavcodec, read by user.
     */
    decodeErrorFlags = 0 /* FFDecodeError.NONE */;
    /**
     * size of the corresponding packet containing the compressed
     * frame.
     * It is set to a negative value if unknown.
     * - encoding: unused
     * - decoding: set by libavcodec, read by user.
     * @deprecated use AV_CODEC_FLAG_COPY_OPAQUE to pass through arbitrary user
     *             data from packets to frames
     */
    pktSize = _constant__WEBPACK_IMPORTED_MODULE_7__.NOPTS_VALUE;
    /**
     * For hwaccel-format frames, this should be a reference to the
     * AVHWFramesContext describing the frame.
     */
    hwFramesCtx = 0;
    /**
     * AVBufferRef for free use by the API user. FFmpeg will never check the
     * contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when
     * the frame is unreferenced. av_frame_copy_props() calls create a new
     * reference with av_buffer_ref() for the target frame's opaque_ref field.
     *
     * This is unrelated to the opaque field, although it serves a similar
     * purpose.
     */
    opaqueRef = 0;
    /**
     * @anchor cropping
     * @name Cropping
     * Video frames only. The number of pixels to discard from the the
     * top/bottom/left/right border of the frame to obtain the sub-rectangle of
     * the frame intended for presentation.
     */
    cropTop = 0;
    cropBottom = 0;
    cropLeft = 0;
    cropRight = 0;
    /**
     * AVBufferRef for internal use by a single libav* library.
     * Must not be used to transfer data between libraries.
     * Has to be NULL when ownership of the frame leaves the respective library.
     *
     * Code outside the FFmpeg libs should never check or change the contents of the buffer ref.
     *
     * FFmpeg calls av_buffer_unref() on it when the frame is unreferenced.
     * av_frame_copy_props() calls create a new reference with av_buffer_ref()
     * for the target frame's private_ref field.
     */
    privateRef = 0;
    /**
     * Channel layout of the audio data.
     */
    chLayout;
    /**
     * Duration of the frame, in the same units as pts. 0 if unknown.
     */
    duration = BigInt(0);
    close() {
        (0,_util_avframe__WEBPACK_IMPORTED_MODULE_8__.unrefAVFrame)(this[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress]);
        (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_5__["default"])(this);
    }
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 1, 4: 8, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("linesize", { 0: 15, 1: 0, 2: 0, 3: 1, 4: 8, 5: 0, 6: 0, 7: 32, 8: 0 });
    map.set("extendedData", { 0: 2, 1: 1, 2: 2, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("width", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 68, 8: 0 });
    map.set("height", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("nbSamples", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 76, 8: 0 });
    map.set("format", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    map.set("keyFrame", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 84, 8: 0 });
    map.set("pictType", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 88, 8: 0 });
    map.set("sampleAspectRatio", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 92, 8: 0 });
    map.set("pts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 104, 8: 0 });
    map.set("pktDts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 112, 8: 0 });
    map.set("timeBase", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 120, 8: 0 });
    map.set("quality", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 128, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 132, 8: 0 });
    map.set("repeatPict", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 136, 8: 0 });
    map.set("interlacedFrame", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 140, 8: 0 });
    map.set("topFieldFirst", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 144, 8: 0 });
    map.set("paletteHasChanged", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 148, 8: 0 });
    map.set("sampleRate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 152, 8: 0 });
    map.set("buf", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_3__.AVBufferRef, 1: 1, 2: 1, 3: 1, 4: 8, 5: 0, 6: 0, 7: 156, 8: 0 });
    map.set("extendedBuf", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_3__.AVBufferRef, 1: 1, 2: 2, 3: 0, 4: 0, 5: 0, 6: 0, 7: 188, 8: 0 });
    map.set("nbExtendedBuf", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 192, 8: 0 });
    map.set("sideData", { 0: AVFrameSideData, 1: 1, 2: 2, 3: 0, 4: 0, 5: 0, 6: 0, 7: 196, 8: 0 });
    map.set("nbSideData", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 200, 8: 0 });
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 204, 8: 0 });
    map.set("colorRange", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 208, 8: 0 });
    map.set("colorPrimaries", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 212, 8: 0 });
    map.set("colorTrc", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 216, 8: 0 });
    map.set("colorSpace", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 220, 8: 0 });
    map.set("chromaLocation", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 224, 8: 0 });
    map.set("bestEffortTimestamp", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 232, 8: 0 });
    map.set("pktPos", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 240, 8: 0 });
    map.set("metadata", { 0: _avdict_ts__WEBPACK_IMPORTED_MODULE_2__.AVDictionary, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 248, 8: 0 });
    map.set("decodeErrorFlags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 252, 8: 0 });
    map.set("pktSize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 256, 8: 0 });
    map.set("hwFramesCtx", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_3__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 260, 8: 0 });
    map.set("opaqueRef", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_3__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 264, 8: 0 });
    map.set("cropTop", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 268, 8: 0 });
    map.set("cropBottom", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 272, 8: 0 });
    map.set("cropLeft", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 276, 8: 0 });
    map.set("cropRight", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 280, 8: 0 });
    map.set("privateRef", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_3__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 284, 8: 0 });
    map.set("chLayout", { 0: _audiosample_ts__WEBPACK_IMPORTED_MODULE_6__.AVChannelLayout, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 288, 8: 0 });
    map.set("duration", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 312, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 320);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVFrame.prototype);
class AVFrameRef extends AVFrame {
    refCount;
}
(function (prototype) {
    var map = new Map();
    map.set("refCount", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 320, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 328);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVFrameRef.prototype);


/***/ }),

/***/ "./src/avutil/struct/avpacket.ts":
/*!***************************************!*\
  !*** ./src/avutil/struct/avpacket.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVPacketSideData: () => (/* binding */ AVPacketSideData)
/* harmony export */ });
/* unused harmony exports default, AVPacketRef */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _avbuffer_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./avbuffer.ts */ "./src/avutil/struct/avbuffer.ts");
/* harmony import */ var _rational_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rational */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");






class AVPacketSideData {
    data = 0;
    size = _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE;
    type = -1 /* AVPacketSideDataType.AV_PKT_DATA_UNKNOWN */;
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("type", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVPacketSideData.prototype);
/**
 * FFmpeg AVPacket 
 */
class AVPacket {
    /**
     * A reference to the reference-counted buffer where the packet data is
     * stored.
     * May be NULL, then the packet data is not reference-counted.
     */
    buf = 0;
    /**
     * Presentation timestamp in AVStream->time_base units; the time at which
     * the decompressed packet will be presented to the user.
     * Can be AV_NOPTS_VALUE if it is not stored in the file.
     * pts MUST be larger or equal to dts as presentation cannot happen before
     * decompression, unless one wants to view hex dumps. Some formats misuse
     * the terms dts and pts/cts to mean something different. Such timestamps
     * must be converted to true pts/dts before they are stored in AVPacket.
     */
    pts = _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT;
    /**
     * Decompression timestamp in AVStream->time_base units; the time at which
     * the packet is decompressed.
     * Can be AV_NOPTS_VALUE if it is not stored in the file.
     */
    dts = _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT;
    data = 0;
    size = 0;
    streamIndex = _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE;
    /**
     * A combination of @AVPacketFlags values
     */
    flags = 0;
    /**
     * Additional packet data that can be provided by the container.
     * Packet can contain several types of side information.
     */
    sideData = 0;
    sideDataElems = 0;
    /**
     * Duration of this packet in AVStream->time_base units, 0 if unknown.
     * Equals next_pts - this_pts in presentation order.
     */
    duration = _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT;
    pos = _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT;
    /**
     * for some private data of the user
     */
    opaque = 0;
    /**
     * AVBufferRef for free use by the API user. FFmpeg will never check the
     * contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when
     * the packet is unreferenced. av_packet_copy_props() calls create a new
     * reference with av_buffer_ref() for the target packet's opaque_ref field.
     *
     * This is unrelated to the opaque field, although it serves a similar
     * purpose.
     */
    opaqueRef = 0;
    /**
     * 
     *
     * 
     */
    timeBase = new _rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational({ den: _constant__WEBPACK_IMPORTED_MODULE_4__.AV_TIME_BASE, num: 1 });
    /**
     * 
     *  h264/h265/h266  annexb  avcc 
     */
    bitFormat = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("buf", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_2__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("pts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("dts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    map.set("streamIndex", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 36, 8: 0 });
    map.set("sideData", { 0: AVPacketSideData, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 40, 8: 0 });
    map.set("sideDataElems", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 44, 8: 0 });
    map.set("duration", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 48, 8: 0 });
    map.set("pos", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 56, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("opaqueRef", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_2__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 68, 8: 0 });
    map.set("timeBase", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_3__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("bitFormat", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 88);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVPacket.prototype);
class AVPacketRef extends AVPacket {
    refCount;
}
(function (prototype) {
    var map = new Map();
    map.set("refCount", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 88, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 96);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVPacketRef.prototype);


/***/ }),

/***/ "./src/avutil/struct/avpcmbuffer.ts":
/*!******************************************!*\
  !*** ./src/avutil/struct/avpcmbuffer.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVPCMBuffer)
/* harmony export */ });
/* unused harmony export AVPCMBufferRef */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia AVPCMBuffer defined
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class AVPCMBuffer {
    /**
     * pcm 
     *  channel 
     */
    data;
    /**
     * data  channel 
     */
    linesize;
    /**
     * 
     */
    nbSamples;
    /**
     *  data  channel 
     */
    maxnbSamples;
    /**
     * 
     */
    channels;
    /**
     * 
     */
    sampleRate;
    /**
     * pts
     */
    timestamp;
    /**
     * 
     */
    duration;
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 2, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("linesize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("nbSamples", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("maxnbSamples", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("channels", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("sampleRate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("timestamp", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("duration", { 0: 19, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 40);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVPCMBuffer.prototype);
class AVPCMBufferRef extends AVPCMBuffer {
    refCount;
}
(function (prototype) {
    var map = new Map();
    map.set("refCount", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 40, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 48);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(AVPCMBufferRef.prototype);


/***/ }),

/***/ "./src/avutil/struct/rational.ts":
/*!***************************************!*\
  !*** ./src/avutil/struct/rational.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Rational: () => (/* binding */ Rational)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia Rational defined
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class Rational {
    /**
     * 
     */
    num = 1;
    /**
     * 
     */
    den = 1;
    constructor(init) {
        if (init) {
            this.den = init.den;
            this.num = init.num;
        }
    }
}
(function (prototype) {
    var map = new Map();
    map.set("num", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("den", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(Rational.prototype);


/***/ }),

/***/ "./src/avutil/util/av1syntax.ts":
/*!**************************************!*\
  !*** ./src/avutil/util/av1syntax.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   f: () => (/* binding */ f),
/* harmony export */   leb128: () => (/* binding */ leb128),
/* harmony export */   uvlc: () => (/* binding */ uvlc)
/* harmony export */ });
/* unused harmony exports le, su, ns, L, NS */
/*
 * libmedia av1 syntax util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function f(bitReader, n) {
    let x = 0;
    for (let i = 0; i < n; i++) {
        x = 2 * x + bitReader.readU1();
    }
    return x;
}
function uvlc(bitReader) {
    let leadingZeros = 0;
    while (true) {
        let done = f(bitReader, 1);
        if (done) {
            break;
        }
        leadingZeros++;
    }
    if (leadingZeros >= 32) {
        return (1) - 1;
    }
    const value = f(bitReader, leadingZeros);
    return value + (1 << leadingZeros) - 1;
}
function le(bitReader, n) {
    let t = 0;
    for (let i = 0; i < n; i++) {
        let byte = f(bitReader, 8);
        t += (byte << (i * 8));
    }
    return t;
}
function leb128(bitReader) {
    let value = 0;
    let Leb128Bytes = 0;
    for (let i = 0; i < 8; i++) {
        let leb128Byte_ = f(bitReader, 8);
        value |= ((leb128Byte_ & 0x7f) << (i * 7));
        Leb128Bytes += 1;
        if (!(leb128Byte_ & 0x80)) {
            break;
        }
    }
    return value;
}
function su(bitReader, n) {
    let value = f(bitReader, n);
    let signMask = 1 << (n - 1);
    if (value & signMask) {
        value = value - 2 * signMask;
    }
    return value;
}
function ns(bitReader, n) {
    let w = Math.floor(Math.log2(n)) + 1;
    let m = (1 << w) - n;
    let v = f(bitReader, w - 1);
    if (v < m) {
        return v;
    }
    let extraBit = f(bitReader, 1);
    return (v << 1) - m + extraBit;
}
function L(bitReader, n) {
    let x = 0;
    for (let i = 0; i < n; i++) {
        x = 2 * x + bitReader.readU1();
    }
    return x;
}
function NS(bitReader, n) {
    let w = Math.floor(Math.log2(n)) + 1;
    let m = (1 << w) - n;
    let v = L(bitReader, w - 1);
    if (v < m) {
        return v;
    }
    let extraBit = L(bitReader, 1);
    return (v << 1) - m + extraBit;
}


/***/ }),

/***/ "./src/avutil/util/avbuffer.ts":
/*!*************************************!*\
  !*** ./src/avutil/util/avbuffer.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avbufferAlloc: () => (/* binding */ avbufferAlloc),
/* harmony export */   avbufferCreate: () => (/* binding */ avbufferCreate),
/* harmony export */   avbufferRealloc: () => (/* binding */ avbufferRealloc),
/* harmony export */   avbufferRef: () => (/* binding */ avbufferRef),
/* harmony export */   avbufferReplace: () => (/* binding */ avbufferReplace),
/* harmony export */   avbufferUnref: () => (/* binding */ avbufferUnref)
/* harmony export */ });
/* unused harmony exports bufferCreate, avbufferAllocz, bufferReplace, avbufferIsWritable, avbufferGetOpaque, avbufferGetRefCount, avbufferMakeWritable, bufferPoolFlush, bufferPoolFree, poolReleaseBuffer */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var _struct_avbuffer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../struct/avbuffer */ "./src/avutil/struct/avbuffer.ts");
/* harmony import */ var cheap_stack__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/stack */ "./src/cheap/stack.ts");





/*
 * libmedia avbuffer util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */






const BUFFER_FLAG_REALLOCATABLE = 1;
function bufferCreate(buf, data, size, free = 0, opaque = 0, flags = 0) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](buf, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](buf + 4, size);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](buf + 12, free);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](buf + 16, opaque);
    cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_6__.store(buf + 8, 1, 9, 2);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](buf + 20, flags);
    const ref = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(12);
    if (!ref) {
        return 0;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](ref, buf);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](ref + 4, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](ref + 8, size);
    return ref;
}
function avbufferCreate(data, size, free = 0, opaque = 0, flags = 0) {
    const buf = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(28);
    if (!buf) {
        return 0;
    }
    const ref = bufferCreate(buf, data, size, free, opaque, flags);
    if (!ref) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(buf);
        return 0;
    }
    return ref;
}
function avbufferAlloc(size) {
    const data = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(size);
    return avbufferCreate(data, size);
}
function avbufferAllocz(size) {
    const p = avbufferAlloc(size);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](p + 4), 0, size);
    return p;
}
function avbufferRef(buf) {
    const ref = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(12);
    // @ts-ignore
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(ref, buf, 12);
    cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_6__.add(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 8, 1, 9, 2);
    return ref;
}
function bufferReplace(dst, src) {
    const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst));
    if (src) {
        // @ts-ignore
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src), 12);
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFreep)(src);
    }
    else {
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFreep)(dst);
    }
    if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_6__.sub(buf + 8, 1, 9, 2) === 1) {
        const freeAvbuffer = !(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](buf + 24) & 2 /* BufferFlags.BUFFER_FLAG_NO_FREE */);
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf + 16)) {
            poolReleaseBuffer(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf + 16), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf));
        }
        else {
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf));
        }
        if (freeAvbuffer) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(buf);
        }
    }
}
function avbufferUnref(buf) {
    if (!buf || !cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf)) {
        return;
    }
    bufferReplace(buf, 0);
}
function avbufferIsWritable(buf) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 20) & 1 /* AVBufferFlags.READONLY */) {
        return 0;
    }
    return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_6__.load(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 8, 9, 2) === 1 ? 1 : 0;
}
function avbufferGetOpaque(buf) {
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 16);
}
function avbufferGetRefCount(buf) {
    return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_6__.load(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 8, 9, 2);
}
function avbufferMakeWritable(pbuf) {
    const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pbuf);
    if (!buf) {
        return -1;
    }
    if (avbufferIsWritable(buf)) {
        return 0;
    }
    const newbuf = avbufferAlloc(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](buf + 8));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](newbuf + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](buf + 8));
    let newbufp = cheap_stack__WEBPACK_IMPORTED_MODULE_8__.malloc(4);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](newbufp, newbuf);
    bufferReplace(pbuf, newbufp);
    cheap_stack__WEBPACK_IMPORTED_MODULE_8__.free(4);
    return 0;
}
function avbufferReplace(pdst, src) {
    const dst = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pdst);
    if (!src) {
        avbufferUnref(pdst);
        return 0;
    }
    if (dst && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 4) === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 4)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 4));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 8));
        return 0;
    }
    const tmp = avbufferRef(src);
    avbufferUnref(pdst);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](pdst, tmp);
    return 0;
}
function avbufferRealloc(pdst, size) {
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pdst)) {
        const data = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avRealloc)(0, size);
        const buf = avbufferCreate(data, size);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](pdst, buf);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 24) | BUFFER_FLAG_REALLOCATABLE);
        return 0;
    }
    const ref = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pdst);
    const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](ref);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](ref + 8) === size) {
        return 0;
    }
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](buf + 24) & BUFFER_FLAG_REALLOCATABLE)
        || !avbufferIsWritable(ref)
        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](ref + 4) !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf)) {
        let newRef = cheap_stack__WEBPACK_IMPORTED_MODULE_8__.malloc(4);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](newRef, 0);
        const ret = avbufferRealloc(newRef, size);
        if (ret < 0) {
            cheap_stack__WEBPACK_IMPORTED_MODULE_8__.free(4);
            return ret;
        }
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](newRef) + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf), Math.min(size, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](buf + 4)));
        bufferReplace(pdst, newRef);
        cheap_stack__WEBPACK_IMPORTED_MODULE_8__.free(4);
        return 0;
    }
    const tmp = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avRealloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf), size);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](ref + 4, tmp), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](buf, tmp);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](ref + 8, size), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](buf + 4, size);
    return 0;
}
function bufferPoolFlush(pool) {
    while (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pool + 4)) {
        const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pool + 4);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](pool + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf + 16));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf + 4)) {
            poolReleaseBuffer(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf));
        }
        else {
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf));
        }
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(buf);
    }
}
function bufferPoolFree(pool) {
    bufferPoolFlush(pool);
    _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.destroy(pool);
    (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(pool);
}
function poolReleaseBuffer(opaque, data) {
    const buf = opaque;
    const pool = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf + 12);
    _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.lock(pool);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](buf + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pool + 4));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](pool + 4, buf);
    _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.unlock(pool);
    if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_6__.sub(pool + 8, 1, 9, 2) === 1) {
        bufferPoolFree(pool);
    }
}


/***/ }),

/***/ "./src/avutil/util/avdict.ts":
/*!***********************************!*\
  !*** ./src/avutil/util/avdict.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avDictSet: () => (/* binding */ avDictSet),
/* harmony export */   freeAVDict: () => (/* binding */ freeAVDict),
/* harmony export */   freeAVDict2: () => (/* binding */ freeAVDict2)
/* harmony export */ });
/* unused harmony exports avDictCount, avDictIterate, avDictGet, avDictCopy */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _struct_avdict_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../struct/avdict */ "./src/avutil/struct/avdict.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");





/*
 * libmedia avdict util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function freeAVDict(pm) {
    freeAVDict2(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pm));
    (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avFreep)(pm);
}
function freeAVDict2(m) {
    if (m) {
        while (cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](m, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) - 1), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) + 1) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8);
            (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8 + 4);
        }
        (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avFreep)(m + 4);
    }
}
function avDictCount(m) {
    return m ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) : 0;
}
function avDictIterate(m, prev) {
    let i = 0;
    if (!m) {
        return 0;
    }
    if (prev) {
        i = ((prev - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4)) >>> 3) + 1;
    }
    if (i >= cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m)) {
        return 0;
    }
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + (i * 8);
}
function avDictGet(m, key, prev = 0, flags = 0) {
    if (!m) {
        return 0;
    }
    let entry = prev;
    if (!key) {
        return 0;
    }
    while ((entry = avDictIterate(m, entry))) {
        let s = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.readCString)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](entry));
        if (flags & 1 /* AVDictFlags.MATCH_CASE */) {
            s.toLocaleLowerCase();
            key.toLocaleLowerCase();
        }
        if (s === key
            || ((flags & 2 /* AVDictFlags.IGNORE_SUFFIX */)
                && s.indexOf(key) === 0)) {
            return entry;
        }
    }
}
function avDictSet(m, key, value, flags = 0) {
    if (!m) {
        throw new Error('m is nullptr');
    }
    let tag = 0;
    if (flags & 64 /* AVDictFlags.MULTIKEY */) {
        tag = avDictGet(m, key, 0, flags);
    }
    if (tag) {
        if (flags & 16 /* AVDictFlags.DONT_OVERWRITE */) {
            return 0;
        }
        if (flags & 32 /* AVDictFlags.APPEND */) {
            value = `${(0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.readCString)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](tag + 4))},${value}`;
        }
        cheap_heap__WEBPACK_IMPORTED_MODULE_4__.Allocator.free(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](tag + 4));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](tag + 4, cheap_heap__WEBPACK_IMPORTED_MODULE_4__.Allocator.malloc(value.length + 1));
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.writeCString)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](tag + 4), value, value.length);
    }
    else {
        let tmp = cheap_heap__WEBPACK_IMPORTED_MODULE_4__.Allocator.realloc(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4), (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) + 1) * 8);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](m + 4, tmp);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8, cheap_heap__WEBPACK_IMPORTED_MODULE_4__.Allocator.malloc(key.length + 1));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8 + 4, cheap_heap__WEBPACK_IMPORTED_MODULE_4__.Allocator.malloc(value.length + 1));
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.writeCString)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8), key, key.length);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.writeCString)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8 + 4), value, value.length);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](m, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) + 1);
    }
    return 0;
}
function avDictCopy(dst, src, flags) {
    if (!dst || !src) {
        return -1;
    }
    let t = 0;
    while ((t = avDictIterate(src, t))) {
        let ret = avDictSet(dst, (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.readCString)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](t)), (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.readCString)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](t + 4)), flags);
        if (ret < 0) {
            return ret;
        }
    }
    return 0;
}


/***/ }),

/***/ "./src/avutil/util/avframe.ts":
/*!************************************!*\
  !*** ./src/avutil/util/avframe.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createAVFrame: () => (/* binding */ createAVFrame),
/* harmony export */   destroyAVFrame: () => (/* binding */ destroyAVFrame),
/* harmony export */   getAVFrameDefault: () => (/* binding */ getAVFrameDefault),
/* harmony export */   getAVFrameSideData: () => (/* binding */ getAVFrameSideData),
/* harmony export */   getAudioBuffer: () => (/* binding */ getAudioBuffer),
/* harmony export */   unrefAVFrame: () => (/* binding */ unrefAVFrame)
/* harmony export */ });
/* unused harmony exports freeSideData, wipeSideData, getVideoBuffer, getBuffer, refAVFrame, copyAVFrameProps, cloneAVFrame */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _struct_audiosample_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./..\struct\audiosample.ts */ "./src/avutil/struct/audiosample.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./..\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _struct_avframe__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../struct/avframe */ "./src/avutil/struct/avframe.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _avbuffer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./avbuffer */ "./src/avutil/util/avbuffer.ts");
/* harmony import */ var _avdict__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./avdict */ "./src/avutil/util/avdict.ts");
/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../error */ "./src/avutil/error.ts");
/* harmony import */ var _channel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./channel */ "./src/avutil/util/channel.ts");
/* harmony import */ var _sample__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./sample */ "./src/avutil/util/sample.ts");
/* harmony import */ var _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var cheap_stack__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! cheap/stack */ "./src/cheap/stack.ts");
/* harmony import */ var _pixel__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./pixel */ "./src/avutil/util/pixel.ts");
/* harmony import */ var common_math_align__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! common/math/align */ "./src/common/math/align.ts");






/*
 * libmedia avframe util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */














function createAVFrame() {
    const frame = (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avMallocz)(320);
    getAVFrameDefault(frame);
    return frame;
}
function destroyAVFrame(frame) {
    unrefAVFrame(frame);
    (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avFree)(frame);
}
function freeSideData(ptr) {
    const sideData = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](ptr);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferUnref)(sideData + 16);
    (0,_avdict__WEBPACK_IMPORTED_MODULE_10__.freeAVDict)(sideData + 12);
    (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avFreep)(ptr);
}
function wipeSideData(frame) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 200); i++) {
        freeSideData(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 196) + (i * 4));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 200, 0);
    (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avFreep)(frame + 196);
}
function getAVFrameSideData(frame, type) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 200); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 196) + i * 4)) === type) {
            return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 196) + (i * 4));
        }
    }
    return 0;
}
function getAVFrameDefault(frame) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 64) !== frame) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avFreep)(frame + 64);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memset)(frame, 0, 320);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](frame + 104, _constant__WEBPACK_IMPORTED_MODULE_8__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](frame + 112, _constant__WEBPACK_IMPORTED_MODULE_8__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](frame + 232, _constant__WEBPACK_IMPORTED_MODULE_8__.NOPTS_VALUE_BIGINT);
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](frame + 240, _constant__WEBPACK_IMPORTED_MODULE_8__.NOPTS_VALUE_BIGINT);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 256, -1);
    }
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 84, 1);
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 92, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 96, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 80, -1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + 64, frame);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 212, 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 216, 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 220, 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 208, 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 224, 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 204, 0);
}
function getVideoBuffer(frame, algin = 0) {
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_14__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80)];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_11__.INVALID_ARGUMENT;
    }
    const linesizes = cheap_stack__WEBPACK_IMPORTED_MODULE_15__.malloc(16);
    const sizes = cheap_stack__WEBPACK_IMPORTED_MODULE_15__.malloc(16);
    const planePadding = Math.max(32, algin);
    let ret = 0;
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32)) {
        if (algin <= 0) {
            algin = 32;
        }
        for (let i = 1; i < algin; i += i) {
            ret = (0,_pixel__WEBPACK_IMPORTED_MODULE_16__.pixelFillLinesizes)(frame + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80), (0,common_math_align__WEBPACK_IMPORTED_MODULE_17__["default"])(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 68), i));
            if (ret < 0) {
                defer();
                return ret;
            }
            if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32) & (algin - 1))) {
                break;
            }
        }
        for (let i = 0; i < 4 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32 + 4 * (i)); i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 32 + i * 4, (0,common_math_align__WEBPACK_IMPORTED_MODULE_17__["default"])(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32 + 4 * (i)), algin));
        }
    }
    for (let i = 0; i < 4; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](linesizes + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32 + 4 * (i)));
    }
    const paddingHeight = (0,common_math_align__WEBPACK_IMPORTED_MODULE_17__["default"])(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 72), 32);
    if ((ret = (0,_pixel__WEBPACK_IMPORTED_MODULE_16__.pixelFillPlaneSizes)(sizes, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80), paddingHeight, linesizes)) < 0) {
        defer();
        return ret;
    }
    let totalSize = 4 * planePadding;
    for (let i = 0; i < 4; i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](sizes + (i * 4)) > _constant__WEBPACK_IMPORTED_MODULE_8__.INT32_MAX - totalSize) {
            _error__WEBPACK_IMPORTED_MODULE_11__.INVALID_ARGUMENT;
        }
        totalSize += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](sizes + (i * 4));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + 156, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferAlloc)(totalSize));
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 156)) {
        unrefAVFrame(frame);
        defer();
        return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
    }
    if ((ret = (0,_pixel__WEBPACK_IMPORTED_MODULE_16__.pixelFillPointer)(frame, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80), paddingHeight, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 156) + 4), linesizes)) < 0) {
        unrefAVFrame(frame);
        defer();
        return ret;
    }
    for (let i = 1; i < 4; i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 4 * (i))) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + i * 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 4 * (i)) + i * planePadding);
        }
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + 64, frame);
    defer();
    return 0;
    function defer() {
        cheap_stack__WEBPACK_IMPORTED_MODULE_15__.free(16);
        cheap_stack__WEBPACK_IMPORTED_MODULE_15__.free(16);
    }
}
function getAudioBuffer(frame, algin) {
    const planar = (0,_sample__WEBPACK_IMPORTED_MODULE_13__.sampleFormatIsPlanar)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80));
    const channels = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 292);
    const planes = planar ? channels : 1;
    let ret = 0;
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32)) {
        ret = (0,_sample__WEBPACK_IMPORTED_MODULE_13__.sampleFormatGetLinesize)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80), channels, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 76), algin);
        if (ret < 0) {
            return ret;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 32, ret);
    }
    if (planes > _struct_avframe__WEBPACK_IMPORTED_MODULE_6__.AV_NUM_DATA_POINTERS) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + 64, (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avMalloc)(planes * 4));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + 188, (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avMalloc)(planes * 4));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 188) || !cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 64)) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avFreep)(frame + 64);
            (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avFreep)(frame + 188);
            return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](frame + 192, planes - _struct_avframe__WEBPACK_IMPORTED_MODULE_6__.AV_NUM_DATA_POINTERS);
    }
    else {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + 64, frame);
    }
    for (let i = 0; i < Math.min(planes, _struct_avframe__WEBPACK_IMPORTED_MODULE_6__.AV_NUM_DATA_POINTERS); i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + 156 + i * 4, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferAlloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32)));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 156 + 4 * (i))) {
            unrefAVFrame(frame);
            return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 64) + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 156 + i * 4) + 4)), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](frame + i * 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 156 + i * 4) + 4));
    }
    for (let i = 0; i < planes - _struct_avframe__WEBPACK_IMPORTED_MODULE_6__.AV_NUM_DATA_POINTERS; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 188) + (i * 4), (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferAlloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32)));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 188) + (i * 4))) {
            unrefAVFrame(frame);
            return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 64) + (i + _struct_avframe__WEBPACK_IMPORTED_MODULE_6__.AV_NUM_DATA_POINTERS), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 188) + i * 4) + 4));
    }
}
function getBuffer(frame, algin) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80) < 0) {
        return _error__WEBPACK_IMPORTED_MODULE_11__.INVALID_ARGUMENT;
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 68) > 0 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 72) > 0) {
        return getVideoBuffer(frame, algin);
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 76) > 0 && (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[10](frame + 296) || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 292) > 0)) {
        return getAudioBuffer(frame, algin);
    }
    return _error__WEBPACK_IMPORTED_MODULE_11__.INVALID_ARGUMENT;
}
function refAVFrame(dst, src) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 80));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 68, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 68));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 72, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 72));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(dst + 288, src + 288, 24);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 76, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 76));
    let ret = copyAVFrameProps(dst, src);
    if (ret < 0) {
        return ret;
    }
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 156)) {
        for (let i = 0; i < 8; i++) {
            if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 4 * (i)) || !cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 32 + 4 * (i))) {
                continue;
            }
            let size = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 32 + 4 * (i));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + i * 4, (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avMalloc)(size));
            if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 4 * (i))) {
                unrefAVFrame(dst);
                return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
            }
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 4 * (i)), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 4 * (i)), size);
        }
        return 0;
    }
    for (let i = 0; i < 8; i++) {
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 156 + 4 * (i))) {
            continue;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 156 + i * 4, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 156 + 4 * (i))));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 156 + 4 * (i))) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
        }
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 188)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 188, (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avMallocz)(4 * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 192)));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 188)) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 192, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 192));
        for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 192); i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 188) + (i * 4), (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 188) + (i * 4))));
            if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 188) + (i * 4))) {
                unrefAVFrame(dst);
                return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
            }
        }
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 64) !== src) {
        let ch = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 292);
        if (!ch) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_11__.INVALID_ARGUMENT;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 64, (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avMallocz)(4 * ch));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 64)) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_11__.NO_MEMORY;
        }
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 64), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 64), 4 * ch);
    }
    else {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 64, dst);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(dst, src, 32);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(dst + 32, src + 32, 32);
    return 0;
}
function unrefAVFrame(frame) {
    wipeSideData(frame);
    for (let i = 0; i < (8); i++) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferUnref)(frame + 156 + i * 4);
    }
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 192); i++) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferUnref)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 188) + (i * 4));
    }
    (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avFreep)(frame + 188);
    (0,_avdict__WEBPACK_IMPORTED_MODULE_10__.freeAVDict)(frame + 248);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferUnref)(frame + 260);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferUnref)(frame + 264);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferUnref)(frame + 284);
    getAVFrameDefault(frame);
}
function copyAVFrameProps(dst, src) {
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 84, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 84));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 88, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 88));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(dst + 92, src + 92, 8);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 268, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 268));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 272, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 272));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 276, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 276));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 280, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 280));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 104, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 104));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 136, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 136));
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 140, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 140));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 144));
    }
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 148, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 148));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 152, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 152));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 132, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 132));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 112, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 112));
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 240, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 240));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 256, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 256));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 128, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 128));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 232, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 232));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 204, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 204));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 252, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 252));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 212, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 212));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 216, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 216));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 220, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 220));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 208, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 208));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 224, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 224));
    let ret = (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferReplace)(dst + 264, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 264));
    ret |= (0,_avbuffer__WEBPACK_IMPORTED_MODULE_9__.avbufferReplace)(dst + 284, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 284));
    return ret;
}
function cloneAVFrame(frame) {
    const ret = createAVFrame();
    refAVFrame(ret, frame);
    return ret;
}


/***/ }),

/***/ "./src/avutil/util/avpacket.ts":
/*!*************************************!*\
  !*** ./src/avutil/util/avpacket.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAVPacketData: () => (/* binding */ addAVPacketData),
/* harmony export */   addAVPacketSideData: () => (/* binding */ addAVPacketSideData),
/* harmony export */   addSideData: () => (/* binding */ addSideData),
/* harmony export */   copyAVPacketData: () => (/* binding */ copyAVPacketData),
/* harmony export */   copyAVPacketProps: () => (/* binding */ copyAVPacketProps),
/* harmony export */   createAVPacket: () => (/* binding */ createAVPacket),
/* harmony export */   deleteAVPacketSideData: () => (/* binding */ deleteAVPacketSideData),
/* harmony export */   destroyAVPacket: () => (/* binding */ destroyAVPacket),
/* harmony export */   freeAVPacketSideData: () => (/* binding */ freeAVPacketSideData),
/* harmony export */   getAVPacketData: () => (/* binding */ getAVPacketData),
/* harmony export */   getAVPacketDefault: () => (/* binding */ getAVPacketDefault),
/* harmony export */   getAVPacketSideData: () => (/* binding */ getAVPacketSideData),
/* harmony export */   hasAVPacketSideData: () => (/* binding */ hasAVPacketSideData),
/* harmony export */   newSideData: () => (/* binding */ newSideData),
/* harmony export */   refAVPacket: () => (/* binding */ refAVPacket),
/* harmony export */   unrefAVPacket: () => (/* binding */ unrefAVPacket)
/* harmony export */ });
/* unused harmony exports initAVPacketData, copyAVPacketSideData */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _struct_avpacket_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../struct/avpacket */ "./src/avutil/struct/avpacket.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _avbuffer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./avbuffer */ "./src/avutil/util/avbuffer.ts");





/*
 * libmedia avpacket util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





const AV_INPUT_BUFFER_PADDING_SIZE = 64;
function getAVPacketData(avpacket, safe) {
    return safe ? (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapSafeUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28)) : (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28));
}
function initAVPacketData(avpacket, length) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 24, (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(length));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 28, length);
    return (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28));
}
function getAVPacketSideData(avpacket, type) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 8) === type) {
            return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + (i * 12);
        }
    }
    return 0;
}
function hasAVPacketSideData(avpacket, type) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 8) === type) {
            return true;
        }
    }
    return false;
}
function addSideData(psd, pnbSd, type, data, length) {
    const sideDataElems = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](pnbSd);
    const sideData = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](psd);
    for (let i = 0; i < sideDataElems; i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](sideData + i * 12 + 8) === type) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](sideData + i * 12));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](sideData + i * 12, data);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](sideData + i * 12 + 4, length);
            return;
        }
    }
    const len = (sideDataElems + 1) * 12;
    const newSideData = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(len);
    if (sideDataElems) {
        for (let i = 0; i < sideDataElems; i++) {
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(newSideData + (i * 12), sideData + (i * 12), 12);
        }
    }
    const ele = newSideData + (sideDataElems * 12);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](ele, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](ele + 8, type);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](ele + 4, length);
    if (sideData) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(sideData);
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](psd, newSideData);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](pnbSd, sideDataElems + 1);
    return ele;
}
function newSideData(psd, pnbSd, type, size) {
    const data = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(size + AV_INPUT_BUFFER_PADDING_SIZE);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memset)(data + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
    return addSideData(psd, pnbSd, type, data, size);
}
function addAVPacketSideData(avpacket, type, data, length) {
    addSideData(avpacket + 40, avpacket + 44, type, data, length);
}
function deleteAVPacketSideData(avpacket, type) {
    let index = -1;
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 8) === type) {
            index = i;
            break;
        }
    }
    if (index > -1) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) === 1) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40)));
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 40, 0);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 44, 0);
        }
        else {
            const len = (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) - 1) * 12;
            const sideData = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(len);
            for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
                if (i !== index) {
                    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(sideData + (i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + (i * 12), 12);
                }
                else {
                    (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12));
                }
            }
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 40, sideData);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 44, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) - 1);
        }
    }
}
function createAVPacket() {
    const avpacket = (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(88);
    getAVPacketDefault(avpacket);
    return avpacket;
}
function destroyAVPacket(avpacket) {
    unrefAVPacket(avpacket);
    (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(avpacket);
}
function freeAVPacketSideData(pSideData, pnbSideData) {
    const sideData = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pSideData);
    const nbSideData = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](pnbSideData);
    if (sideData) {
        for (let i = 0; i < nbSideData; i++) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](sideData + i * 12));
        }
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFreep)(pSideData);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](pnbSideData, 0);
    }
}
function getAVPacketDefault(avpacket) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 24, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 28, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 40, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 44, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 32, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 56, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 48, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 36, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 16, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 8, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 76, _constant__WEBPACK_IMPORTED_MODULE_6__.AV_TIME_BASE);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 72, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 80, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket, 0);
}
function copyAVPacketSideData(dst, src) {
    freeAVPacketSideData(dst + 40, dst + 44);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44)) {
        let size = 12;
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 40, (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMallocz)(size * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44)));
        for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44); i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12 + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 4));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12 + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 8));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12, (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 4)));
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 4));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 44, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44));
    }
}
function copyAVPacketProps(dst, src) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 32));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 56));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 48, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 48));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 36));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 16));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 8));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 64, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 64));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 76, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 76));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 72, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 72));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 80));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 68, 0);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferReplace)(dst + 68, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 68));
    copyAVPacketSideData(dst, src);
    return 0;
}
function allocAVPacket(buf, size) {
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferRealloc)(buf, size + AV_INPUT_BUFFER_PADDING_SIZE);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 4) + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
    return 0;
}
function refAVPacket(dst, src) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferUnref)(dst);
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, 0);
    copyAVPacketProps(dst, src);
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src) && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
        allocAVPacket(dst, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4));
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 28, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
    return 0;
}
function unrefAVPacket(avpacket) {
    freeAVPacketSideData(avpacket + 40, avpacket + 44);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferUnref)(avpacket + 68);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferUnref)(avpacket);
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24)) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24));
    }
    getAVPacketDefault(avpacket);
}
function copyAVPacketData(dst, src) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferUnref)(dst);
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, 0);
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src) && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
        allocAVPacket(dst, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4));
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 28, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
}
function addAVPacketData(avpacket, data, size) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferUnref)(avpacket);
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24)) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_7__.avbufferCreate)(data, size + AV_INPUT_BUFFER_PADDING_SIZE));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 24, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 28, size);
}


/***/ }),

/***/ "./src/avutil/util/channel.ts":
/*!************************************!*\
  !*** ./src/avutil/util/channel.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setChannelLayoutFromMask: () => (/* binding */ setChannelLayoutFromMask),
/* harmony export */   unInitChannelLayout: () => (/* binding */ unInitChannelLayout)
/* harmony export */ });
/* unused harmony export getChannelLayoutNBChannels */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common */ "./src/avutil/util/common.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../error */ "./src/avutil/error.ts");






function getChannelLayoutNBChannels(layout) {
    return (0,_common__WEBPACK_IMPORTED_MODULE_2__.popCount64)(layout);
}
function unInitChannelLayout(channelLayout) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](channelLayout) == 2 /* AVChannelOrder.AV_CHANNEL_ORDER_CUSTOM */) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFreep)(channelLayout + 8);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.memset)(channelLayout, 0, 24);
}
function setChannelLayoutFromMask(channelLayout, mask) {
    if (!mask) {
        return _error__WEBPACK_IMPORTED_MODULE_5__.INVALID_ARGUMENT;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](channelLayout, 1 /* AVChannelOrder.AV_CHANNEL_ORDER_NATIVE */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](channelLayout + 4, (0,_common__WEBPACK_IMPORTED_MODULE_2__.popCount64)(BigInt(mask >>> 0)));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[10](channelLayout + 8, BigInt(mask >>> 0));
    return 0;
}


/***/ }),

/***/ "./src/avutil/util/codecparameters.ts":
/*!********************************************!*\
  !*** ./src/avutil/util/codecparameters.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copyCodecParameters: () => (/* binding */ copyCodecParameters),
/* harmony export */   freeCodecParameters: () => (/* binding */ freeCodecParameters)
/* harmony export */ });
/* unused harmony export resetCodecParameters */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _struct_audiosample_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./..\struct\audiosample.ts */ "./src/avutil/struct/audiosample.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./..\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _channel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./channel */ "./src/avutil/util/channel.ts");
/* harmony import */ var _avpacket__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _struct_avpacket__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../struct/avpacket */ "./src/avutil/struct/avpacket.ts");












function copyCodecParametersSideData(pDst, pnbDst, src, nbSrc) {
    if (!src) {
        return;
    }
    const dst = (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avMallocz)(nbSrc * 12);
    for (let i = 0; i < nbSrc; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + i * 12 + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + i * 12 + 8));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + i * 12 + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + i * 12 + 4));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + i * 12, (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avMalloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + i * 12 + 4)));
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(dst + i * 12, src + i * 12, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + i * 12 + 4));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](pnbDst, nbSrc);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](pDst, dst);
    return 0;
}
function copyCodecParameters(dst, src) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 4));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[8](dst + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[8](src + 8));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 28, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 32));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 40, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 40));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 44, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 48, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 48));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 52, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 52));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 56));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 60, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 60));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 68, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 68));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 64, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 64));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 80));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 84, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 84));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 88, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 88));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 92, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 92));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 96, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 96));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 100, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 100));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 104, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 104));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(dst + 112, src + 112, 24);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 136, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 136));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 140, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 140));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 144));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 148, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 148));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 152, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 152));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 156, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 156));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(dst + 72, src + 72, 8);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 12)) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 12)) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 12));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 12, (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avMalloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 16)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 16));
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 16));
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 20)) {
        copyCodecParametersSideData(dst + 20, dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 20), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 24));
    }
}
function resetCodecParameters(par) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](par + 12)) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avFreep)(par + 12);
    }
    (0,_channel__WEBPACK_IMPORTED_MODULE_7__.unInitChannelLayout)(par + 112);
    (0,_avpacket__WEBPACK_IMPORTED_MODULE_8__.freeAVPacketSideData)(par + 20, par + 24);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memset)(par, 0, 168);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par, -1 /* AVMediaType.AVMEDIA_TYPE_UNKNOWN */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 4, 0 /* AVCodecID.AV_CODEC_ID_NONE */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 28, -1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 112, 0 /* AVChannelOrder.AV_CHANNEL_ORDER_UNSPEC */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 80, 0 /* AVFieldOrder.AV_FIELD_UNKNOWN */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 84, 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 88, 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 92, 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 96, 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 100, 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 64, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 68, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 72, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 72, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 48, _constant__WEBPACK_IMPORTED_MODULE_9__.NOPTS_VALUE);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](par + 52, _constant__WEBPACK_IMPORTED_MODULE_9__.NOPTS_VALUE);
}
function freeCodecParameters(par) {
    if (!par) {
        return;
    }
    resetCodecParameters(par);
    (0,_mem__WEBPACK_IMPORTED_MODULE_6__.avFree)(par);
}


/***/ }),

/***/ "./src/avutil/util/common.ts":
/*!***********************************!*\
  !*** ./src/avutil/util/common.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   milliSecond2Second: () => (/* binding */ milliSecond2Second),
/* harmony export */   popCount64: () => (/* binding */ popCount64)
/* harmony export */ });
/* unused harmony export popCount */
/*
 * libmedia common util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function popCount(x) {
    x -= (x >> 1) & 0x55555555;
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0F0F0F0F;
    x += x >> 8;
    return (x + (x >> 16)) & 0x3F;
}
function popCount64(x) {
    return popCount(Number(BigInt.asUintN(32, x))) + popCount(Number(BigInt.asUintN(32, x >> BigInt(32))));
}
function milliSecond2Second(time) {
    const integer = time / BigInt(1000);
    const decimal = time - integer * BigInt(1000);
    return Number(integer) + Number(decimal) / 1000;
}


/***/ }),

/***/ "./src/avutil/util/expgolomb.ts":
/*!**************************************!*\
  !*** ./src/avutil/util/expgolomb.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readSE: () => (/* binding */ readSE),
/* harmony export */   readUE: () => (/* binding */ readUE)
/* harmony export */ });
/* unused harmony exports readTE, writeUE, writeSE, writeTE */
/*
 * libmedia expgolomb util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const UESizeTable = [
    // 0 
    1,
    // 1     
    1,
    // 2~3    
    2, 2,
    // 4~7 
    3, 3, 3, 3,
    // 8~15 
    4, 4, 4, 4, 4, 4, 4, 4,
    // 16~31 
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    // 32~63 
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    // 64~127 
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    // 128~255 
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
];
/**
 * ue(v) 
 */
function readUE(bitReader) {
    let result = 0;
    // leadingZeroBits
    let i = 0;
    while (i < 32 && bitReader.readU1() === 0) {
        i++;
    }
    //  read_bits ( leadingZeroBits )
    result = bitReader.readU(i);
    //  codeNum1 << i  2  i 
    result += (1 << i) - 1;
    return result;
}
/**
 * se(v) 
 */
function readSE(bitReader) {
    let result = readUE(bitReader);
    //  result 
    if (result & 0x01) {
        //  > 0
        result = (result + 1) / 2;
    }
    else {
        //  <= 0
        result = -result / 2;
    }
    return result;
}
/**
 * te(v) 
 */
function readTE(bitReader, x) {
    let result = 0;
    // 
    if (x === 1) {
        //  1 
        result = 1 - bitReader.readU1();
    }
    else if (x > 1) {
        //  ue(v) 
        result = readUE(bitReader);
    }
    return result;
}
/**
 * ue(v) 
 */
function writeUE(bitWriter, value) {
    let size = 0;
    if (value === 0) {
        // 0  1
        bitWriter.writeU1(1);
    }
    else {
        let tmp = ++value;
        //  16 
        if (tmp >= 0x00010000) {
            size += 16;
            tmp >>= 16;
        }
        //  8 
        if (tmp >= 0x100) {
            size += 8;
            tmp >>= 8;
        }
        //  tmp  8 
        size += UESizeTable[tmp];
        //  value 2 * size - 1
        bitWriter.writeU(2 * size - 1, value);
    }
}
/**
 * se(v) 
 */
function writeSE(bitWriter, value) {
    if (value <= 0) {
        writeUE(bitWriter, -value * 2);
    }
    else {
        writeUE(bitWriter, value * 2 - 1);
    }
}
/**
 * te(v) 
 */
function writeTE(bitWriter, x, value) {
    if (x === 1) {
        bitWriter.writeU1(1 & ~value);
    }
    else if (x > 1) {
        writeUE(bitWriter, value);
    }
}


/***/ }),

/***/ "./src/avutil/util/intread.ts":
/*!************************************!*\
  !*** ./src/avutil/util/intread.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r8: () => (/* binding */ r8),
/* harmony export */   rb16: () => (/* binding */ rb16),
/* harmony export */   rb24: () => (/* binding */ rb24),
/* harmony export */   rb32: () => (/* binding */ rb32),
/* harmony export */   rl16: () => (/* binding */ rl16),
/* harmony export */   rl32: () => (/* binding */ rl32)
/* harmony export */ });
/* unused harmony exports rl24, rl64, rb64 */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");

/*
 * libmedia int read util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function r8(p) {
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[2](p);
}
function rl16(p) {
    return (r8(p + 1) << 8) | r8(p);
}
function rb16(p) {
    return (r8(p) << 8) | r8(p + 1);
}
function rl24(p) {
    return (r8(p + 2) << 16) | (r8(p + 1) << 8) + r8(p);
}
function rb24(p) {
    return (r8(p) << 16) | (r8(p + 1) << 8) | r8(p + 2);
}
function rl32(p) {
    return (rl16(p + 2) << 16) | rl16(p);
}
function rb32(p) {
    return (rb16(p) << 16) | rb16(p + 2);
}
function rl64(p) {
    return (BigInt(rl32(p + 4)) << BigInt(32)) | BigInt(rl32(p));
}
function rb64(p) {
    return (BigInt(rb32(p)) << BigInt(32)) | BigInt(rb32(p + 4));
}


/***/ }),

/***/ "./src/avutil/util/mem.ts":
/*!********************************!*\
  !*** ./src/avutil/util/mem.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avFree: () => (/* binding */ avFree),
/* harmony export */   avFreep: () => (/* binding */ avFreep),
/* harmony export */   avMalloc: () => (/* binding */ avMalloc),
/* harmony export */   avMallocz: () => (/* binding */ avMallocz),
/* harmony export */   avRealloc: () => (/* binding */ avRealloc)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__1 = "src\\avutil\\util\\mem.ts";



/*
 * libmedia mem util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function avMalloc(len) {
    const p = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(len);
    if (!p) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal('can not alloc buffer', cheap__fileName__1, 32);
    }
    return p;
}
function avMallocz(len) {
    const p = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(len);
    if (!p) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal('can not alloc buffer', cheap__fileName__1, 40);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memset)(p, 0, len);
    return p;
}
function avFree(p) {
    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(p);
}
function avFreep(p) {
    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](p));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](p, 0);
}
function avRealloc(p, size) {
    return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.realloc(p, size);
}


/***/ }),

/***/ "./src/avutil/util/nalu.ts":
/*!*********************************!*\
  !*** ./src/avutil/util/nalu.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getNextNaluStart: () => (/* binding */ getNextNaluStart),
/* harmony export */   isAnnexb: () => (/* binding */ isAnnexb),
/* harmony export */   naluUnescape: () => (/* binding */ naluUnescape),
/* harmony export */   splitNaluByStartCode: () => (/* binding */ splitNaluByStartCode)
/* harmony export */ });
/* unused harmony exports splitNaluByLength, joinNaluByStartCode, joinNaluByLength, naluEscape */
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/*
 * libmedia nalu util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function isAnnexb(data) {
    return data.length > 4
        && data[0] === 0
        && data[1] === 0
        && (data[2] === 1
            || data[2] === 0 && data[3] === 1);
}
function getNextNaluStart(data, offset) {
    let t = 0;
    for (let i = offset; i < data.length; i++) {
        switch (data[i]) {
            case 0:
                t++;
                break;
            case 1:
                if (t >= 2) {
                    return {
                        offset: i - Math.min(t, 3),
                        startCode: Math.min(t + 1, 4)
                    };
                }
                t = 0;
                break;
            default:
                t = 0;
        }
    }
    return {
        offset: -1,
        startCode: 0
    };
}
function splitNaluByStartCode(buffer) {
    const list = [];
    let offset = 0;
    let current = getNextNaluStart(buffer, offset);
    let next = {
        offset: -1,
        startCode: 0
    };
    while (next = getNextNaluStart(buffer, current.offset + current.startCode), next.offset > -1) {
        list.push(buffer.subarray(current.offset + current.startCode, next.offset, true));
        current = next;
    }
    list.push(buffer.subarray(current.offset + current.startCode, undefined, true));
    return list;
}
function splitNaluByLength(buffer, naluLengthSizeMinusOne) {
    const list = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](buffer);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = buffer.subarray(Number(BigInt.asIntN(32, bufferReader.getPos())), Number(BigInt.asIntN(32, bufferReader.getPos())) + length, true);
        bufferReader.skip(length);
        list.push(nalu);
    }
    return list;
}
function joinNaluByStartCode(nalus, output, slice = false) {
    if (!output) {
        let length = nalus.reduce((prev, nalu, index) => {
            return prev + ((index || slice) ? 3 : 4) + nalu.length;
        }, 0);
        output = new Uint8Array(length);
    }
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__["default"](output);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu, index) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        if (!index && !slice) {
            bufferWriter.writeUint8(0x00);
        }
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(nalu);
    });
    return output;
}
function joinNaluByLength(nalus, naluLengthSizeMinusOne, output) {
    if (!output) {
        const length = nalus.reduce((prev, nalu) => {
            return prev + naluLengthSizeMinusOne + 1 + nalu.length;
        }, 0);
        output = new Uint8Array(length);
    }
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__["default"](output);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu) => {
        if (naluLengthSizeMinusOne === 3) {
            bufferWriter.writeUint32(nalu.length);
        }
        else if (naluLengthSizeMinusOne === 2) {
            bufferWriter.writeUint24(nalu.length);
        }
        else if (naluLengthSizeMinusOne === 1) {
            bufferWriter.writeUint16(nalu.length);
        }
        else {
            bufferWriter.writeUint8(nalu.length);
        }
        bufferWriter.writeBuffer(nalu);
    });
    return output;
}
function naluUnescape(data, start = 0, end) {
    if (!end) {
        end = data.length;
    }
    const buffer = new Uint8Array(data.length);
    let zeroCount = 0;
    let pos = 0;
    for (let i = 0; i < data.length; i++) {
        if (i >= start && i < end) {
            if (data[i] === 0) {
                zeroCount++;
            }
            else {
                if (data[i] === 3 && zeroCount === 2 && i + 1 < data.length && data[i + 1] <= 3) {
                    i++;
                    if (i === data.length) {
                        break;
                    }
                    else {
                        if (data[i] === 0) {
                            zeroCount = 1;
                        }
                        else {
                            zeroCount = 0;
                        }
                    }
                }
                else {
                    zeroCount = 0;
                }
            }
        }
        buffer[pos++] = data[i];
    }
    return buffer.slice(0, pos);
}
function naluEscape(data, start = 0, end) {
    if (!end) {
        end = data.length;
    }
    const indexes = [];
    let zeroCount = 0;
    for (let i = start; i < end; i++) {
        if (i >= end) {
            break;
        }
        if (data[i] === 0) {
            zeroCount++;
        }
        else {
            if (data[i] <= 3 && zeroCount === 2) {
                indexes.push(i);
            }
            zeroCount = 0;
        }
    }
    if (indexes.length) {
        const buffer = new Uint8Array(data.length + indexes.length);
        let pos = 0;
        let subData = data.subarray(0, indexes[0]);
        buffer.set(subData, pos);
        pos += subData.length;
        buffer[pos++] = 3;
        for (let i = 1; i < indexes.length; i++) {
            subData = data.subarray(indexes[i - 1], indexes[i]);
            buffer.set(subData, pos);
            pos += subData.length;
            buffer[pos++] = 3;
        }
        subData = data.subarray(indexes[indexes.length - 1], data.length);
        buffer.set(subData, pos);
        pos += subData.length;
        return buffer;
    }
    else {
        return data;
    }
}


/***/ }),

/***/ "./src/avutil/util/pixel.ts":
/*!**********************************!*\
  !*** ./src/avutil/util/pixel.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pixelFillLinesizes: () => (/* binding */ pixelFillLinesizes),
/* harmony export */   pixelFillPlaneSizes: () => (/* binding */ pixelFillPlaneSizes),
/* harmony export */   pixelFillPointer: () => (/* binding */ pixelFillPointer)
/* harmony export */ });
/* unused harmony exports chromaLocation2Pos, pixelGetLinesize, pixelAlloc, pixelGetSize */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../error */ "./src/avutil/error.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_stack__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/stack */ "./src/cheap/stack.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var common_math_align__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/math/align */ "./src/common/math/align.ts");


/*
 * libmedia video pixel util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */







function chromaLocation2Pos(pos) {
    if (pos <= 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */ || pos >= 7 /* AVChromaLocation.AVCHROMA_LOC_NB */) {
        return;
    }
    return {
        x: (pos & 1) * 128,
        y: ((pos >>> 1) ^ (pos < 4 ? 1 : 0)) * 128
    };
}
function getMaxPixSteps(desc) {
    const maxPixSteps = [0, 0, 0, 0];
    const maxPixStepsComps = [0, 0, 0, 0];
    for (let i = 0; i < 4; i++) {
        if (desc.comp[i] && desc.comp[i].step > maxPixSteps[desc.comp[i].plane]) {
            maxPixSteps[desc.comp[i].plane] = desc.comp[i].step;
            maxPixStepsComps[desc.comp[i].plane] = i;
        }
    }
    return {
        maxPixSteps,
        maxPixStepsComps
    };
}
function setSystematicPal(pal, pixfmt) {
    for (let i = 0; i < 256; i++) {
        let r, g, b;
        switch (pixfmt) {
            case 20 /* AVPixelFormat.AV_PIX_FMT_RGB8 */:
                r = (i >> 5) * 36;
                g = ((i >> 2) & 7) * 36;
                b = (i & 3) * 85;
                break;
            case 17 /* AVPixelFormat.AV_PIX_FMT_BGR8 */:
                b = (i >> 6) * 85;
                g = ((i >> 3) & 7) * 36;
                r = (i & 7) * 36;
                break;
            case 22 /* AVPixelFormat.AV_PIX_FMT_RGB4_BYTE */:
                r = (i >> 3) * 255;
                g = ((i >> 1) & 3) * 85;
                b = (i & 1) * 255;
                break;
            case 19 /* AVPixelFormat.AV_PIX_FMT_BGR4_BYTE */:
                b = (i >> 3) * 255;
                g = ((i >> 1) & 3) * 85;
                r = (i & 1) * 255;
                break;
            case 8 /* AVPixelFormat.AV_PIX_FMT_GRAY8 */:
                r = b = g = i;
                break;
            default:
                return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[8](pal + (i * 4), b + (g << 8) + (r << 16) + (-16777216));
    }
    return 0;
}
function pixelGetLinesize_(width, plane, maxStep, maxStepComp, desc) {
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    if (width < 0) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    const s = (maxStepComp === 1 || maxStepComp === 2) ? desc.log2ChromaW : 0;
    const shiftedW = ((width + (1 << s) - 1)) >>> s;
    if (shiftedW && maxStep > _constant__WEBPACK_IMPORTED_MODULE_4__.INT32_MAX / shiftedW) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    let linesize = maxStep * shiftedW;
    if (desc.flags & 4 /* PixelFormatFlags.BIT_STREAM */) {
        linesize = (linesize + 7) >>> 3;
    }
    return linesize;
}
function pixelGetLinesize(pixfmt, width, plane) {
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[pixfmt];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    const { maxPixSteps, maxPixStepsComps } = getMaxPixSteps(desc);
    return pixelGetLinesize_(width, plane, maxPixSteps[plane], maxPixStepsComps[plane], desc);
}
function pixelFillLinesizes(linesizes, pixfmt, width) {
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[pixfmt];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    const { maxPixSteps, maxPixStepsComps } = getMaxPixSteps(desc);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memset)(linesizes, 0, 16);
    let ret = 0;
    for (let i = 0; i < 4; i++) {
        if ((ret = pixelGetLinesize_(width, i, maxPixSteps[i], maxPixStepsComps[i], desc)) < 0) {
            return ret;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](linesizes + (i * 4), ret);
    }
}
function pixelFillPlaneSizes(sizes, pixfmt, height, linesizes) {
    const hasPlane = [0, 0, 0, 0];
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[pixfmt];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memset)(sizes, 0, 16);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes) > _constant__WEBPACK_IMPORTED_MODULE_4__.INT32_MAX / height) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](sizes, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes) * height);
    if (desc.flags & 2 /* PixelFormatFlags.PALETTE */) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](sizes + 4, 1024);
        return 0;
    }
    for (let i = 0; i < 4; i++) {
        if (desc.comp[i]) {
            hasPlane[desc.comp[i].plane] = 1;
        }
    }
    for (let i = 0; i < 4 && hasPlane[i]; i++) {
        let s = (i === 1 || i === 2) ? desc.log2ChromaH : 0;
        let h = (height + (1 << s) - 1) >> s;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes + (i * 4)) > _constant__WEBPACK_IMPORTED_MODULE_4__.INT32_MAX / h) {
            return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](sizes + (i * 4), h * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes + (i * 4)));
    }
    return 0;
}
function pixelFillPointer(data, pixfmt, height, ptr, linesizes) {
    const linesizes1 = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    const sizes = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memset)(data, 0, 16);
    for (let i = 0; i < 4; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](linesizes1 + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes + (i * 4)));
    }
    let ret = pixelFillPlaneSizes(sizes, pixfmt, height, linesizes1);
    if (ret < 0) {
        defer();
        return ret;
    }
    ret = 0;
    for (let i = 0; i < 4; i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i * 4)) > _constant__WEBPACK_IMPORTED_MODULE_4__.INT32_MAX - ret) {
            defer();
            return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
        }
        ret += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i * 4));
    }
    if (!ptr) {
        defer();
        return ret;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](data, ptr);
    for (let i = 1; i < 4 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i * 4)); i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](data + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](data + (i - 1)) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i - 1)));
    }
    defer();
    return ret;
    function defer() {
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
    }
}
function pixelAlloc(pointers, linesizes, w, h, pixfmt, align = 1) {
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[pixfmt];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    const linesizes1 = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    const sizes = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    let ret = 0;
    if ((ret = pixelFillLinesizes(linesizes, pixfmt, align > 7 ? (0,common_math_align__WEBPACK_IMPORTED_MODULE_8__["default"])(w, 8) : w)) < 0) {
        defer();
        return ret;
    }
    for (let i = 0; i < 4; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](linesizes + (i * 4), (0,common_math_align__WEBPACK_IMPORTED_MODULE_8__["default"])(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes + (i * 4)), align));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](linesizes1 + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes + (i * 4)));
    }
    if ((ret = pixelFillPlaneSizes(sizes, pixfmt, h, linesizes1)) < 0) {
        defer();
        return ret;
    }
    let totalSize = align;
    for (let i = 0; i < 4; i++) {
        if (totalSize > _constant__WEBPACK_IMPORTED_MODULE_4__.INT32_MAX - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i * 4))) {
            defer();
            return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
        }
        totalSize += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i * 4));
    }
    const buf = (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avMalloc)(totalSize);
    if (!buf) {
        defer();
        return _error__WEBPACK_IMPORTED_MODULE_3__.NO_MEMORY;
    }
    if ((ret = pixelFillPointer(pointers, pixfmt, h, buf, linesizes)) < 0) {
        defer();
        return ret;
    }
    if (desc.flags & 2 /* PixelFormatFlags.PALETTE */) {
        if (align < 4) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_7__.avFree)(buf);
            defer();
            return ret;
        }
        setSystematicPal(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pointers + 4), pixfmt);
    }
    if ((desc.flags & 2 /* PixelFormatFlags.PALETTE */)
        && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pointers + 4)
        && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pointers + 4) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pointers) > cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes) * h) {
        /* zero-initialize the padding before the palette */
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pointers) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes) * h, 0, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pointers + 4) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pointers) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes) * h);
    }
    defer();
    return ret;
    function defer() {
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
    }
}
function pixelGetSize(pixfmt, width, height, align) {
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[pixfmt];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
    }
    const linesizes = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    const alignedLinesizes = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    const sizes = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    let ret = 0;
    if ((ret = pixelFillLinesizes(linesizes, pixfmt, width)) < 0) {
        defer();
        return ret;
    }
    for (let i = 0; i < 4; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](alignedLinesizes + (i * 4), (0,common_math_align__WEBPACK_IMPORTED_MODULE_8__["default"])(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](linesizes + (i * 4)), align));
    }
    if ((ret = pixelFillPlaneSizes(sizes, pixfmt, height, alignedLinesizes)) < 0) {
        defer();
        return ret;
    }
    let totalSize = 0;
    for (let i = 0; i < 4; i++) {
        if (totalSize > _constant__WEBPACK_IMPORTED_MODULE_4__.INT32_MAX - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i * 4))) {
            defer();
            return _error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
        }
        totalSize += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](sizes + (i * 4));
    }
    defer();
    return totalSize;
    function defer() {
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
    }
}


/***/ }),

/***/ "./src/avutil/util/rational.ts":
/*!*************************************!*\
  !*** ./src/avutil/util/rational.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avQ2D: () => (/* binding */ avQ2D),
/* harmony export */   avReduce: () => (/* binding */ avReduce),
/* harmony export */   avRescaleQ: () => (/* binding */ avRescaleQ)
/* harmony export */ });
/* unused harmony exports avRescaleQ2, avQ2D2, avReduce2 */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_math_gcd__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/math/gcd */ "./src/common/math/gcd.ts");



/**
 * 
 *
 * @param a 
 * @param bp 
 * @param cq 
 */
function avRescaleQ(a, bq, cq) {
    const b = a * BigInt(bq.num >> 0) * BigInt(cq.den >> 0);
    const c = BigInt(bq.den >> 0) * BigInt(cq.num >> 0);
    return b / c;
}
/**
 * 
 *
 * @param a 
 * @param bp 
 * @param cq 
 */
function avRescaleQ2(a, bq, cq) {
    const b = a * BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](bq) >> 0) * BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](cq + 4) >> 0);
    const c = BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](bq + 4) >> 0) * BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](cq) >> 0);
    return b / c;
}
/**
 *  double
 *
 * @param a
 */
function avQ2D(a) {
    return a.num / a.den;
}
/**
 *  double
 *
 * @param a
 */
function avQ2D2(a) {
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a + 4);
}
/**
 *  Rational
 *
 * @param a
 */
function avReduce(a) {
    const gcdValue = (0,common_math_gcd__WEBPACK_IMPORTED_MODULE_2__["default"])(a.num, a.den);
    if (gcdValue <= 1) {
        return;
    }
    a.den /= gcdValue;
    a.num /= gcdValue;
}
/**
 *  Rational
 *
 * @param a
 */
function avReduce2(a) {
    const gcdValue = (0,common_math_gcd__WEBPACK_IMPORTED_MODULE_2__["default"])(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a + 4));
    if (gcdValue <= 1) {
        return;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](a + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a + 4) / gcdValue);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](a, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a) / gcdValue);
}


/***/ }),

/***/ "./src/avutil/util/sample.ts":
/*!***********************************!*\
  !*** ./src/avutil/util/sample.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sampleFormatGetLinesize: () => (/* binding */ sampleFormatGetLinesize),
/* harmony export */   sampleFormatIsPlanar: () => (/* binding */ sampleFormatIsPlanar)
/* harmony export */ });
/* unused harmony exports getBytesPerSample, sampleFillArrays, sampleAlloc, sampleSetSilence */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_math_align__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/math/align */ "./src/common/math/align.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _sampleFormatDescriptor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../sampleFormatDescriptor */ "./src/avutil/sampleFormatDescriptor.ts");


/*
 * libmedia audio sample util
 *
 *  (C) 2024 
 * Copyright (C) 2024 Gaoxing Zhao
 *
 *  libmedia 
 * This file is part of libmedia.
 *
 * libmedia  GNU Lesser General Public LicenseGNU LGPL3.1
 * 
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 
 *  libmedia  GNU Lesser General Public License 
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





function getBytesPerSample(format) {
    return (format < 0 || format >= 12 /* AVSampleFormat.AV_SAMPLE_FMT_NB */)
        ? 0
        : _sampleFormatDescriptor__WEBPACK_IMPORTED_MODULE_6__.AVSampleFormatDescriptors[format].bits >> 3;
}
function sampleFormatIsPlanar(format) {
    return (format < 0 || format >= 12 /* AVSampleFormat.AV_SAMPLE_FMT_NB */)
        ? false
        : _sampleFormatDescriptor__WEBPACK_IMPORTED_MODULE_6__.AVSampleFormatDescriptors[format].planar;
}
function sampleFormatGetLinesize(format, channels, nbSamples, align) {
    const sampleSize = getBytesPerSample(format);
    const planar = sampleFormatIsPlanar(format);
    if (!sampleSize || nbSamples <= 0 || channels <= 0) {
        return -1;
    }
    if (!align) {
        align = 1;
        nbSamples = (0,common_math_align__WEBPACK_IMPORTED_MODULE_4__["default"])(nbSamples, 32);
    }
    if (channels > _constant__WEBPACK_IMPORTED_MODULE_3__.INT32_MAX / align || channels * nbSamples > (_constant__WEBPACK_IMPORTED_MODULE_3__.INT32_MAX - align * channels) / sampleSize) {
        return -1;
    }
    return planar ? (0,common_math_align__WEBPACK_IMPORTED_MODULE_4__["default"])(nbSamples * sampleSize, align) : (0,common_math_align__WEBPACK_IMPORTED_MODULE_4__["default"])(nbSamples * sampleSize * channels, align);
}
function sampleFillArrays(audioData, buf, format, linesize, channels) {
    const planar = sampleFormatIsPlanar(format);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.memset)(audioData, 0, planar ? 4 * channels : 4);
    if (!buf) {
        return -1;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](audioData, buf);
    if (planar) {
        for (let i = 1; i < channels; i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](audioData + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](audioData + (i - 1)) + linesize);
        }
    }
    return 0;
}
function sampleAlloc(audioData, format, linesize, channels) {
    const planar = sampleFormatIsPlanar(format);
    const bufSize = planar ? linesize * channels : linesize;
    if (bufSize < 0) {
        return bufSize;
    }
    const buf = (0,_util_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(bufSize);
    const ret = sampleFillArrays(audioData, buf, format, linesize, channels);
    if (ret < 0) {
        (0,_util_mem__WEBPACK_IMPORTED_MODULE_5__.avFree)(buf);
        return ret;
    }
    return 0;
}
function sampleSetSilence(audioData, offset, format, nbSamples, channels) {
    const planar = sampleFormatIsPlanar(format);
    const planes = planar ? channels : 1;
    const blockAlign = getBytesPerSample(format) * (planar ? 1 : channels);
    const dataSize = nbSamples * blockAlign;
    const fillChar = (format === 0 /* AVSampleFormat.AV_SAMPLE_FMT_U8 */ || format === 5 /* AVSampleFormat.AV_SAMPLE_FMT_U8P */)
        ? 0x80
        : 0x00;
    offset *= blockAlign;
    for (let i = 0; i < planes; i++) {
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](audioData + (i * 4)) + offset, fillChar, dataSize);
    }
}


/***/ }),

/***/ "./src/avutil/util/serialize.ts":
/*!**************************************!*\
  !*** ./src/avutil/util/serialize.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   serializeAVCodecParameters: () => (/* binding */ serializeAVCodecParameters),
/* harmony export */   serializeAVPacket: () => (/* binding */ serializeAVPacket),
/* harmony export */   unserializeAVCodecParameters: () => (/* binding */ unserializeAVCodecParameters),
/* harmony export */   unserializeAVPacket: () => (/* binding */ unserializeAVPacket)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _avpacket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _struct_avcodecparameters__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../struct/avcodecparameters */ "./src/avutil/struct/avcodecparameters.ts");






function serializeAVPacket(avpacket) {
    const serialize = {
        pts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8),
        dts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 16),
        data: (0,_avpacket__WEBPACK_IMPORTED_MODULE_3__.getAVPacketData)(avpacket).slice(),
        streamIndex: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 32),
        flags: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36),
        sideData: [],
        duration: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 48),
        pos: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 56),
        timeBase: {
            den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 76),
            num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 72)
        },
        bitFormat: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 80)
    };
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 44); i++) {
        const ele = {
            type: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 8),
            data: (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 40) + i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 4)).slice()
        };
        serialize.sideData.push(ele);
    }
    return serialize;
}
function unserializeAVPacket(serialize, avpacket = 0) {
    if (!avpacket) {
        avpacket = (0,_avpacket__WEBPACK_IMPORTED_MODULE_3__.createAVPacket)();
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avpacket + 8, serialize.pts);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avpacket + 16, serialize.dts);
    const data = (0,_mem__WEBPACK_IMPORTED_MODULE_4__.avMalloc)(serialize.data.length);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.memcpyFromUint8Array)(data, serialize.data.length, serialize.data);
    (0,_avpacket__WEBPACK_IMPORTED_MODULE_3__.addAVPacketData)(avpacket, data, serialize.data.length);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 32, serialize.streamIndex);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 36, serialize.flags);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avpacket + 48, serialize.duration);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avpacket + 56, serialize.pos);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 76, serialize.timeBase.den);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 72, serialize.timeBase.num);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 80, serialize.bitFormat);
    if (serialize.sideData.length) {
        for (let i = 0; i < serialize.sideData.length; i++) {
            const data = (0,_mem__WEBPACK_IMPORTED_MODULE_4__.avMalloc)(serialize.sideData[i].data.length);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.memcpyFromUint8Array)(data, serialize.sideData[i].data.length, serialize.sideData[i].data);
            (0,_avpacket__WEBPACK_IMPORTED_MODULE_3__.addAVPacketSideData)(avpacket, serialize.sideData[i].type, data, serialize.sideData[i].data.length);
        }
    }
    else {
        (0,_avpacket__WEBPACK_IMPORTED_MODULE_3__.freeAVPacketSideData)(avpacket + 40, avpacket + 44);
    }
    return avpacket;
}
function serializeAVCodecParameters(codecpar) {
    const serialize = {
        codecType: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar),
        codecId: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 4),
        codecTag: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[8](codecpar + 8),
        extradata: null,
        codedSideData: [],
        format: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 28),
        bitrate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](codecpar + 32),
        bitsPerCodedSample: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 40),
        bitsPerRawSample: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 44),
        profile: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 48),
        level: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 52),
        width: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 56),
        height: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 60),
        sampleAspectRatio: {
            den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 68),
            num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 64)
        },
        framerate: {
            den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 76),
            num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 72)
        },
        fieldOrder: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 80),
        colorRange: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 84),
        colorPrimaries: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 88),
        colorTrc: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 92),
        colorSpace: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 96),
        chromaLocation: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 100),
        videoDelay: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 104),
        chLayout: {
            order: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 112),
            nbChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 116),
            u: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[10](codecpar + 120)
        },
        sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 136),
        blockAlign: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 140),
        frameSize: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 144),
        initialPadding: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 148),
        trailingPadding: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 152),
        seekPreroll: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 156),
        bitFormat: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 160)
    };
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 16)) {
        serialize.extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](codecpar + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 16)).slice();
    }
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 24); i++) {
        const ele = {
            type: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](codecpar + 20) + i * 12 + 8),
            data: (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](codecpar + 20) + i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](codecpar + 20) + i * 12 + 4)).slice()
        };
        serialize.codedSideData.push(ele);
    }
    return serialize;
}
function unserializeAVCodecParameters(serialize, codecpar = 0) {
    if (!codecpar) {
        codecpar = (0,_mem__WEBPACK_IMPORTED_MODULE_4__.avMalloc)(168);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.memset)(codecpar, 0, 168);
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar, serialize.codecType);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 4, serialize.codecId);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[8](codecpar + 8, serialize.codecTag);
    if (serialize.extradata) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](codecpar + 12)) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_4__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](codecpar + 12));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](codecpar + 12, (0,_mem__WEBPACK_IMPORTED_MODULE_4__.avMalloc)(serialize.extradata.length));
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.memcpyFromUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](codecpar + 12), serialize.extradata.length, serialize.extradata);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 16, serialize.extradata.length);
    }
    if (serialize.codedSideData.length) {
        for (let i = 0; i < serialize.codedSideData.length; i++) {
            const data = (0,_mem__WEBPACK_IMPORTED_MODULE_4__.avMalloc)(serialize.codedSideData[i].data.length);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.memcpyFromUint8Array)(data, serialize.codedSideData[i].data.length, serialize.codedSideData[i].data);
            (0,_avpacket__WEBPACK_IMPORTED_MODULE_3__.addSideData)(codecpar + 20, codecpar + 24, serialize.codedSideData[i].type, data, serialize.codedSideData[i].data.length);
        }
    }
    else {
        (0,_avpacket__WEBPACK_IMPORTED_MODULE_3__.freeAVPacketSideData)(codecpar + 20, codecpar + 24);
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 28, serialize.format);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](codecpar + 32, serialize.bitrate);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 40, serialize.bitsPerCodedSample);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 44, serialize.bitsPerRawSample);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 48, serialize.profile);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 52, serialize.level);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 56, serialize.width);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 60, serialize.height);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 68, serialize.sampleAspectRatio.den);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 64, serialize.sampleAspectRatio.num);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 76, serialize.framerate.den);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 72, serialize.framerate.num);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 80, serialize.fieldOrder);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 84, serialize.colorRange);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 88, serialize.colorPrimaries);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 92, serialize.colorTrc);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 96, serialize.colorSpace);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 100, serialize.chromaLocation);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 104, serialize.videoDelay);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 112, serialize.chLayout.order);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 116, serialize.chLayout.nbChannels);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[10](codecpar + 120, serialize.chLayout.u);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 136, serialize.sampleRate);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 140, serialize.blockAlign);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 144, serialize.frameSize);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 148, serialize.initialPadding);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 152, serialize.trailingPadding);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 156, serialize.seekPreroll);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](codecpar + 160, serialize.bitFormat);
    return codecpar;
}


/***/ }),

/***/ "./src/cheap/allocator/AllocatorJS.ts":
/*!********************************************!*\
  !*** ./src/cheap/allocator/AllocatorJS.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AllocatorJS)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var _thread_mutex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _staticData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../staticData */ "./src/cheap/staticData.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\cheap\\allocator\\AllocatorJS.ts";





const ALIGNMENT_IN_BYTES = 8;
const ALIGNMENT_MASK = ALIGNMENT_IN_BYTES - 1;
const POINTER_SIZE_IN_BYTES = 4;
const BYTES_TO_QUADS_SHIFT = 2;
const MIN_FREEABLE_SIZE_IN_BYTES = 16;
const MIN_FREEABLE_SIZE_IN_QUADS = bytesToQuads(MIN_FREEABLE_SIZE_IN_BYTES);
const MAX_HEIGHT = 32;
const HEADER_SIZE_IN_QUADS = 1 + (MAX_HEIGHT * 2);
const HEADER_OFFSET_IN_QUADS = 1;
const HEIGHT_OFFSET_IN_QUADS = 0;
const NEXT_OFFSET_IN_QUADS = 2;
const POINTER_SIZE_IN_QUADS = 1;
const POINTER_OVERHEAD_IN_QUADS = 2;
const FIRST_BLOCK_OFFSET_IN_QUADS = HEADER_OFFSET_IN_QUADS + HEADER_SIZE_IN_QUADS + POINTER_OVERHEAD_IN_QUADS;
const FIRST_BLOCK_OFFSET_IN_BYTES = FIRST_BLOCK_OFFSET_IN_QUADS * POINTER_SIZE_IN_BYTES;
const OVERHEAD_IN_BYTES = (FIRST_BLOCK_OFFSET_IN_QUADS + 1) * POINTER_SIZE_IN_BYTES;
class AllocatorJS {
    buffer;
    byteOffset;
    heapOffset;
    heapLength;
    int32Array;
    updates;
    options;
    shared;
    handles;
    constructor(options, init = true) {
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend({
            growSize: 1048576,
            maxHeapSize: 2097152000
        }, options);
        this.handles = [];
        this.buffer = options.buffer;
        this.shared = false;
        if (this.options.memory || this.buffer instanceof ArrayBuffer || this.buffer instanceof SharedArrayBuffer) {
            this.byteOffset = options.byteOffset ?? 0;
            this.heapOffset = alignHeapOffset(this.byteOffset + quadsToBytes(MAX_HEIGHT), options.byteLength ?? this.buffer.byteLength);
            this.heapLength = alignHeapLength((options.byteLength ?? this.buffer.byteLength) - this.heapOffset);
            this.int32Array = new Int32Array(this.buffer, this.heapOffset, bytesToQuads(this.heapLength));
            this.updates = new Int32Array(this.buffer, this.byteOffset, MAX_HEIGHT);
            if (typeof SharedArrayBuffer === 'function' && this.buffer instanceof SharedArrayBuffer) {
                this.shared = true;
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal('Expected buffer to be an instance of Buffer or ArrayBuffer', cheap__fileName__0, 109);
        }
        if (init) {
            this.updates.fill(HEADER_OFFSET_IN_QUADS);
            prepare(this.int32Array);
            checkListIntegrity(this.int32Array);
        }
    }
    addUpdateHandle(handle) {
        if (!common_util_array__WEBPACK_IMPORTED_MODULE_1__.has(this.handles, handle)) {
            this.handles.push(handle);
        }
    }
    removeUpdateHandle(handle) {
        common_util_array__WEBPACK_IMPORTED_MODULE_1__.remove(this.handles, handle);
    }
    malloc_(size) {
        size = align(size, ALIGNMENT_MASK);
        if (size < MIN_FREEABLE_SIZE_IN_BYTES) {
            size = MIN_FREEABLE_SIZE_IN_BYTES;
        }
        const minimumSize = bytesToQuads(size);
        const block = this.findFreeBlock(this.int32Array, minimumSize);
        if (block <= HEADER_OFFSET_IN_QUADS) {
            return 0;
        }
        const blockSize = readSize(this.int32Array, block);
        if (blockSize - (minimumSize + POINTER_OVERHEAD_IN_QUADS) >= MIN_FREEABLE_SIZE_IN_QUADS) {
            split(this.int32Array, block, minimumSize, blockSize, this.updates);
        }
        else {
            remove(this.int32Array, block, blockSize, this.updates);
        }
        return quadsToBytes(block) + this.heapOffset;
    }
    /**
     * Allocate a given number of bytes and return the offset.
     * If allocation fails, returns 0.
     */
    malloc(size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex, !false);
            this.checkBuffer();
        }
        const address = this.malloc_(size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex);
        }
        return address;
    }
    calloc_(num, size) {
        let numberOfBytes = num * size;
        if (numberOfBytes < MIN_FREEABLE_SIZE_IN_BYTES) {
            numberOfBytes = MIN_FREEABLE_SIZE_IN_BYTES;
        }
        else {
            numberOfBytes = align(numberOfBytes, ALIGNMENT_MASK);
        }
        const address = this.malloc_(numberOfBytes);
        if (address === 0) {
            // Not enough space
            return 0;
        }
        const offset = bytesToQuads(address - this.heapOffset);
        this.int32Array.subarray(offset, offset + bytesToQuads(numberOfBytes)).fill(0);
        return address;
    }
    calloc(num, size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex, !false);
            this.checkBuffer();
        }
        const address = this.calloc_(num, size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex);
        }
        return address;
    }
    realloc_(address, size) {
        if (address === 0) {
            return this.malloc_(size);
        }
        const originAddress = address;
        if (size === 0) {
            this.free_(originAddress);
            return 0;
        }
        address = address - this.heapOffset;
        let originBlock = bytesToQuads(address);
        let block = originBlock;
        let padding = 0;
        if (isAlign(this.int32Array, originBlock)) {
            block = this.int32Array[originBlock - 1];
            padding = originBlock - block;
        }
        const blockSize = readSize(this.int32Array, block) - padding;
        const minimumSize = bytesToQuads(align(size, ALIGNMENT_MASK));
        if (blockSize >= minimumSize) {
            return originAddress;
        }
        else {
            const newAddress = this.malloc_(size);
            if (newAddress === 0) {
                this.free_(originAddress);
                return 0;
            }
            this.int32Array.set(this.int32Array.subarray(originBlock, originBlock + blockSize), bytesToQuads(newAddress - this.heapOffset));
            this.free_(originAddress);
            return newAddress;
        }
    }
    realloc(address, size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex, !false);
            this.checkBuffer();
        }
        address = this.realloc_(address, size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex);
        }
        return address;
    }
    alignedAlloc_(alignment, size) {
        if (alignment <= ALIGNMENT_IN_BYTES) {
            // malloc  ALIGNMENT_IN_BYTES 
            return this.malloc_(size);
        }
        const address = this.malloc_(size + alignment - 1 + POINTER_SIZE_IN_BYTES);
        if (address === 0) {
            return 0;
        }
        const alignmentAddress = (address + alignment - 1 + POINTER_SIZE_IN_BYTES) & ~(alignment - 1);
        this.int32Array[bytesToQuads(alignmentAddress - this.heapOffset) - POINTER_SIZE_IN_QUADS] = bytesToQuads(address - this.heapOffset);
        return alignmentAddress;
    }
    alignedAlloc(alignment, size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex, !false);
            this.checkBuffer();
        }
        const address = this.alignedAlloc_(alignment, size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex);
        }
        return address;
    }
    free_(address) {
        if (address === 0) {
            return;
        }
        address = address - this.heapOffset;
        let block = bytesToQuads(address);
        if (isAlign(this.int32Array, block)) {
            block = this.int32Array[block - POINTER_SIZE_IN_QUADS];
        }
        if (isFree(this.int32Array, block)) {
            return;
        }
        const blockSize = readSize(this.int32Array, block);
        const preceding = getFreeBlockBefore(this.int32Array, block);
        const trailing = getFreeBlockAfter(this.int32Array, block);
        if (preceding !== 0) {
            if (trailing !== 0) {
                insertMiddle(this.int32Array, preceding, block, blockSize, trailing, this.updates);
            }
            else {
                insertAfter(this.int32Array, preceding, block, blockSize, this.updates);
            }
        }
        else if (trailing !== 0) {
            insertBefore(this.int32Array, trailing, block, blockSize, this.updates);
        }
        else {
            insert(this.int32Array, block, blockSize, this.updates);
        }
    }
    /**
     * Free a number of bytes from the given address.
     */
    free(address) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex, !false);
            this.checkBuffer();
        }
        this.free_(address);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex);
        }
    }
    /**
     * Return the size of the block at the given address.
     */
    sizeof(address) {
        if (address === 0) {
            return 0;
        }
        address -= this.heapOffset;
        let block = bytesToQuads(address);
        if (isAlign(this.int32Array, block)) {
            block = this.int32Array[block - POINTER_SIZE_IN_QUADS];
        }
        return quadsToBytes(readSize(this.int32Array, block));
    }
    /**
     * 
     *
     * @returns
     */
    inspect() {
        this.checkBuffer();
        return inspect(this.int32Array, this.heapOffset);
    }
    findFreeBlock(int32Array, minimumSize) {
        let block = findFreeBlock(int32Array, minimumSize);
        if (block === HEADER_OFFSET_IN_QUADS) {
            if (this.options.growAllowed && this.heapLength < this.options.maxHeapSize) {
                const block = this.int32Array.length + 1;
                let int32Array;
                let updates;
                let byteOffset = 0;
                let heapLength = 0;
                let heapOffset = 0;
                if (this.options.onResize) {
                    const result = this.options.onResize(this.int32Array, this.int32Array.byteLength + align(Math.max(this.options.growSize, quadsToBytes(minimumSize)), ALIGNMENT_MASK));
                    byteOffset = result.byteOffset ?? 0;
                    heapOffset = alignHeapOffset(byteOffset + quadsToBytes(MAX_HEIGHT), result.byteLength ?? result.buffer.byteLength);
                    heapLength = alignHeapLength((result.byteLength ?? result.buffer.byteLength) - heapOffset);
                    int32Array = new Int32Array(result.buffer, heapOffset, bytesToQuads(heapLength));
                    updates = new Int32Array(result.buffer, byteOffset, MAX_HEIGHT);
                }
                else {
                    const buffer = new ArrayBuffer(this.int32Array.length + bytesToQuads(this.options.growSize));
                    heapOffset = alignHeapOffset(byteOffset + quadsToBytes(MAX_HEIGHT), buffer.byteLength);
                    heapLength = alignHeapLength(buffer.byteLength - heapOffset);
                    int32Array = new Int32Array(buffer, heapOffset, bytesToQuads(heapLength));
                    int32Array.set(this.int32Array, 0);
                    updates = new Int32Array(buffer, byteOffset, MAX_HEIGHT);
                }
                this.byteOffset = byteOffset;
                this.heapOffset = heapOffset;
                this.buffer = int32Array.buffer;
                this.heapLength = heapLength;
                this.int32Array = int32Array;
                this.updates = updates;
                const blockSize = int32Array.length - (block - 1) - POINTER_OVERHEAD_IN_QUADS;
                writeFreeBlockSize(int32Array, blockSize, block);
                const preceding = getFreeBlockBefore(int32Array, block);
                if (preceding !== 0) {
                    insertAfter(int32Array, preceding, block, blockSize, this.updates);
                }
                else {
                    insert(int32Array, block, blockSize, this.updates);
                }
                if (this.handles.length) {
                    common_util_array__WEBPACK_IMPORTED_MODULE_1__.each(this.handles, (func) => {
                        func(this.buffer);
                    });
                }
                return this.findFreeBlock(this.int32Array, minimumSize);
            }
            return block;
        }
        else {
            return block;
        }
    }
    getBuffer() {
        return this.buffer;
    }
    isAlloc(pointer) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex, !false);
            this.checkBuffer();
        }
        const block = bytesToQuads(pointer - this.heapOffset);
        let next = this.int32Array[HEADER_OFFSET_IN_QUADS + NEXT_OFFSET_IN_QUADS];
        // sometime get undefined from the last free node in v8
        // but it's is all right |=_=
        while (next && next !== HEADER_OFFSET_IN_QUADS) {
            if (block >= next && block < next + this.int32Array[next - POINTER_SIZE_IN_QUADS]) {
                if (this.shared) {
                    (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex);
                }
                return false;
            }
            next = this.int32Array[next + NEXT_OFFSET_IN_QUADS];
        }
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_3__.heapMutex);
        }
        return true;
    }
    checkBuffer() {
        if (this.options.memory && this.options.memory.buffer !== this.buffer) {
            this.buffer = this.options.memory.buffer;
            this.heapLength = alignHeapLength(this.buffer.byteLength - this.heapOffset);
            this.int32Array = new Int32Array(this.buffer, this.heapOffset, bytesToQuads(this.heapLength));
        }
    }
}
/**
 * Prepare the given int32Array and ensure it contains a valid header.
 */
function prepare(int32Array) {
    if (!verifyHeader(int32Array)) {
        writeInitialHeader(int32Array);
    }
}
/**
 * Verify that the int32Array contains a valid header.
 */
function verifyHeader(int32Array) {
    return int32Array[HEADER_OFFSET_IN_QUADS - 1] === HEADER_SIZE_IN_QUADS
        && int32Array[HEADER_OFFSET_IN_QUADS + HEADER_SIZE_IN_QUADS] === HEADER_SIZE_IN_QUADS;
}
/**
 * Write the initial header for an empty int32Array.
 */
function writeInitialHeader(int32Array) {
    const header = HEADER_OFFSET_IN_QUADS;
    const headerSize = HEADER_SIZE_IN_QUADS;
    const block = FIRST_BLOCK_OFFSET_IN_QUADS;
    const blockSize = int32Array.length - (header + headerSize + POINTER_OVERHEAD_IN_QUADS + POINTER_SIZE_IN_QUADS);
    writeFreeBlockSize(int32Array, headerSize, header);
    int32Array[header + HEIGHT_OFFSET_IN_QUADS] = 1;
    int32Array[header + NEXT_OFFSET_IN_QUADS] = block;
    for (let height = 1; height < MAX_HEIGHT; height++) {
        int32Array[header + NEXT_OFFSET_IN_QUADS + height] = HEADER_OFFSET_IN_QUADS;
    }
    writeFreeBlockSize(int32Array, blockSize, block);
    int32Array[block + HEIGHT_OFFSET_IN_QUADS] = 1;
    int32Array[block + NEXT_OFFSET_IN_QUADS] = header;
}
/**
 * Check the integrity of the freelist in the given array.
 */
function checkListIntegrity(int32Array) {
    let block = FIRST_BLOCK_OFFSET_IN_QUADS;
    while (block < int32Array.length - POINTER_SIZE_IN_QUADS) {
        const size = readSize(int32Array, block);
        /* istanbul ignore if  */
        if (size < POINTER_OVERHEAD_IN_QUADS || size >= int32Array.length - FIRST_BLOCK_OFFSET_IN_QUADS) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal(`Got invalid sized chunk at ${quadsToBytes(block)} (${quadsToBytes(size)} bytes).`, cheap__fileName__0, 568);
        }
        else if (isFree(int32Array, block)) {
            checkFreeBlockIntegrity(int32Array, block, size);
        }
        else {
            checkUsedBlockIntegrity(int32Array, block, size);
        }
        block += size + POINTER_OVERHEAD_IN_QUADS;
    }
    return true;
}
function checkFreeBlockIntegrity(int32Array, block, blockSize) {
    /* istanbul ignore if  */
    if (int32Array[block - 1] !== int32Array[block + blockSize]) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal(`Block length header does not match footer (${quadsToBytes(int32Array[block - 1])} vs ${quadsToBytes(int32Array[block + blockSize])}).`, cheap__fileName__0, 584);
    }
    const height = int32Array[block + HEIGHT_OFFSET_IN_QUADS];
    /* istanbul ignore if  */
    if (height < 1 || height > MAX_HEIGHT) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal(`Block ${quadsToBytes(block)} height must be between 1 and ${MAX_HEIGHT}, got ${height}.`, cheap__fileName__0, 589);
    }
    for (let i = 0; i < height; i++) {
        const pointer = int32Array[block + NEXT_OFFSET_IN_QUADS + i];
        /* istanbul ignore if  */
        if (pointer >= FIRST_BLOCK_OFFSET_IN_QUADS && !isFree(int32Array, pointer)) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal(`Block ${quadsToBytes(block)} has a pointer to a non-free block (${quadsToBytes(pointer)}).`, cheap__fileName__0, 595);
        }
    }
    return true;
}
function checkUsedBlockIntegrity(int32Array, block, blockSize) {
    /* istanbul ignore if  */
    if (int32Array[block - 1] !== int32Array[block + blockSize]) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal(`Block length header does not match footer (${quadsToBytes(int32Array[block - 1])} vs ${quadsToBytes(int32Array[block + blockSize])}).`, cheap__fileName__0, 604);
    }
    else {
        return true;
    }
}
/**
 * Inspect the freelist in the given array.
 */
function inspect(int32Array, byteOffset) {
    const blocks = [];
    const header = readListNode(int32Array, HEADER_OFFSET_IN_QUADS, byteOffset);
    let block = FIRST_BLOCK_OFFSET_IN_QUADS;
    let used = 0;
    while (block < int32Array.length - POINTER_SIZE_IN_QUADS) {
        const size = readSize(int32Array, block);
        /* istanbul ignore if  */
        if (size < POINTER_OVERHEAD_IN_QUADS || size >= int32Array.length) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal(`Got invalid sized chunk at ${quadsToBytes(block)} (${quadsToBytes(size)})`, cheap__fileName__0, 624);
        }
        if (isFree(int32Array, block)) {
            // @flowIssue todo
            blocks.push(readListNode(int32Array, block, byteOffset));
        }
        else {
            used += quadsToBytes(size);
            blocks.push({
                type: 'used',
                block: block,
                offset: quadsToBytes(block) + byteOffset,
                size: quadsToBytes(size)
            });
        }
        block += size + POINTER_OVERHEAD_IN_QUADS;
    }
    return { header, blocks, total: quadsToBytes(int32Array.length), used };
}
/**
 * Convert quads to bytes.
 */
function quadsToBytes(num) {
    return (num << BYTES_TO_QUADS_SHIFT) >>> 0;
}
/**
 * Convert bytes to quads.
 */
function bytesToQuads(num) {
    return num >>> BYTES_TO_QUADS_SHIFT;
}
/**
 * Align the given value to 8 bytes.
 */
function align(value, alignment) {
    return ((value + alignment) & ~alignment) >>> 0;
}
/**
 * align heap
 *
 * @param offset heap start offset
 * @param byteLength  buffer length
 * @returns
 */
function alignHeapOffset(offset, byteLength) {
    const length = byteLength - offset;
    //  heapLength  ALIGNMENT_IN_BYTES 
    let heapOffset = offset + (align(length, ALIGNMENT_MASK) === length
        ? 0
        : (length - align(length, ALIGNMENT_MASK) + ALIGNMENT_IN_BYTES));
    return heapOffset;
}
function alignHeapLength(length) {
    // header  int length  body 
    if (!((HEADER_OFFSET_IN_QUADS + HEADER_SIZE_IN_QUADS) % 2)) {
        length -= POINTER_SIZE_IN_BYTES;
    }
    return length;
}
/**
 * Read the list pointers for a given block.
 */
function readListNode(int32Array, block, byteOffset) {
    const height = int32Array[block + HEIGHT_OFFSET_IN_QUADS];
    const pointers = [];
    for (let i = 0; i < height; i++) {
        pointers.push(int32Array[block + NEXT_OFFSET_IN_QUADS + i]);
    }
    return {
        type: 'free',
        block,
        offset: quadsToBytes(block) + byteOffset,
        height,
        pointers,
        size: quadsToBytes(int32Array[block - 1])
    };
}
/**
 * Read the size (in quads) of the block at the given address.
 */
function readSize(int32Array, block) {
    const n = int32Array[block - 1];
    const mask = n >> 31;
    return (n + mask) ^ mask;
}
/**
 * Write the size of the block at the given address.
 * Note: This ONLY works for free blocks, not blocks in use.
 */
function writeFreeBlockSize(int32Array, size, block) {
    int32Array[block - 1] = size;
    int32Array[block + size] = size;
}
/**
 * Populate the `UPDATES` array with the offset of the last item in each
 * list level, *before* a node of at least the given size.
 */
function findPredecessors(int32Array, minimumSize, UPDATES) {
    const listHeight = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS];
    let node = HEADER_OFFSET_IN_QUADS;
    for (let height = listHeight; height > 0; height--) {
        let next = node + NEXT_OFFSET_IN_QUADS + (height - 1);
        while (int32Array[next] >= FIRST_BLOCK_OFFSET_IN_QUADS && int32Array[int32Array[next] - 1] < minimumSize) {
            node = int32Array[next];
            next = node + NEXT_OFFSET_IN_QUADS + (height - 1);
        }
        UPDATES[height - 1] = node;
    }
}
/**
 * Find a free block with at least the given size and return its offset in quads.
 */
function findFreeBlock(int32Array, minimumSize) {
    let block = HEADER_OFFSET_IN_QUADS;
    for (let height = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS]; height > 0; height--) {
        let next = int32Array[block + NEXT_OFFSET_IN_QUADS + (height - 1)];
        while (next !== HEADER_OFFSET_IN_QUADS && int32Array[next - POINTER_SIZE_IN_QUADS] < minimumSize) {
            block = next;
            next = int32Array[block + NEXT_OFFSET_IN_QUADS + (height - 1)];
        }
    }
    block = int32Array[block + NEXT_OFFSET_IN_QUADS];
    if (block === HEADER_OFFSET_IN_QUADS) {
        return block;
    }
    else {
        return block;
    }
}
/**
 * Split the given block after a certain number of bytes and add the second half to the freelist.
 */
function split(int32Array, block, firstSize, blockSize, UPDATES) {
    const second = (block + firstSize + POINTER_OVERHEAD_IN_QUADS);
    const secondSize = (blockSize - (second - block));
    remove(int32Array, block, blockSize, UPDATES);
    int32Array[block - 1] = -firstSize;
    int32Array[block + firstSize] = -firstSize;
    int32Array[second - 1] = -secondSize;
    int32Array[second + secondSize] = -secondSize;
    insert(int32Array, second, secondSize, UPDATES);
}
/**
 * Remove the given block from the freelist and mark it as allocated.
 */
function remove(int32Array, block, blockSize, UPDATES) {
    findPredecessors(int32Array, blockSize, UPDATES);
    let node = int32Array[UPDATES[0] + NEXT_OFFSET_IN_QUADS];
    while (node !== block && node !== HEADER_OFFSET_IN_QUADS && int32Array[node - 1] <= blockSize) {
        for (let height = int32Array[node + HEIGHT_OFFSET_IN_QUADS] - 1; height >= 0; height--) {
            if (int32Array[node + NEXT_OFFSET_IN_QUADS + height] === block) {
                UPDATES[height] = node;
            }
        }
        node = int32Array[node + NEXT_OFFSET_IN_QUADS];
    }
    let listHeight = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS];
    for (let height = 0; height < listHeight; height++) {
        const next = int32Array[UPDATES[height] + NEXT_OFFSET_IN_QUADS + height];
        if (next !== block) {
            break;
        }
        int32Array[UPDATES[height] + NEXT_OFFSET_IN_QUADS + height] = int32Array[block + NEXT_OFFSET_IN_QUADS + height];
    }
    while (listHeight > 0 && int32Array[HEADER_OFFSET_IN_QUADS + NEXT_OFFSET_IN_QUADS + (listHeight - 1)] === HEADER_OFFSET_IN_QUADS) {
        listHeight--;
        int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS] = listHeight;
    }
    // invert the size sign to signify an allocated block
    int32Array[block - 1] = -blockSize;
    int32Array[block + blockSize] = -blockSize;
}
/**
 * Determine whether the block at the given address is free or not.
 */
function isFree(int32Array, block) {
    /* istanbul ignore if  */
    if (block < HEADER_SIZE_IN_QUADS) {
        return false;
    }
    const size = int32Array[block - POINTER_SIZE_IN_QUADS];
    if (size < 0) {
        return false;
    }
    else {
        return true;
    }
}
/**
 * Determine whether the block at the given address is free or not.
 */
function isAlign(int32Array, block) {
    /* istanbul ignore if  */
    if (block < HEADER_SIZE_IN_QUADS) {
        return false;
    }
    const origin = int32Array[block - POINTER_SIZE_IN_QUADS];
    if (origin < 0) {
        return false;
    }
    else {
        return true;
    }
}
/**
 * Get the address of the block before the given one and return the address *if it is free*,
 * otherwise 0.
 */
function getFreeBlockBefore(int32Array, block) {
    if (block <= FIRST_BLOCK_OFFSET_IN_QUADS) {
        return 0;
    }
    const beforeSize = int32Array[block - POINTER_OVERHEAD_IN_QUADS];
    if (beforeSize < POINTER_OVERHEAD_IN_QUADS) {
        return 0;
    }
    return block - (POINTER_OVERHEAD_IN_QUADS + beforeSize);
}
/**
 * Get the address of the block after the given one and return its address *if it is free*,
 * otherwise 0.
 */
function getFreeBlockAfter(int32Array, block) {
    const blockSize = readSize(int32Array, block);
    if (block + blockSize + POINTER_OVERHEAD_IN_QUADS >= int32Array.length - 2) {
        // Block is the last in the list.
        return 0;
    }
    const next = (block + blockSize + POINTER_OVERHEAD_IN_QUADS);
    const nextSize = int32Array[next - POINTER_SIZE_IN_QUADS];
    if (nextSize < POINTER_OVERHEAD_IN_QUADS) {
        return 0;
    }
    return next;
}
/**
 * Insert the given block into the freelist and return the number of bytes that were freed.
 */
function insert(int32Array, block, blockSize, UPDATES) {
    findPredecessors(int32Array, blockSize, UPDATES);
    const blockHeight = generateHeight(int32Array, block, blockSize, UPDATES);
    for (let height = 1; height <= blockHeight; height++) {
        const update = UPDATES[height - 1] + NEXT_OFFSET_IN_QUADS + (height - 1);
        int32Array[block + NEXT_OFFSET_IN_QUADS + (height - 1)] = int32Array[update];
        int32Array[update] = block;
        UPDATES[height - 1] = HEADER_OFFSET_IN_QUADS;
    }
    int32Array[block - 1] = blockSize;
    int32Array[block + blockSize] = blockSize;
    return blockSize;
}
/**
 * Insert the given block into the freelist before the given free block,
 * joining them together, returning the number of bytes which were freed.
 */
function insertBefore(int32Array, trailing, block, blockSize, UPDATES) {
    const trailingSize = readSize(int32Array, trailing);
    remove(int32Array, trailing, trailingSize, UPDATES);
    const size = (blockSize + trailingSize + POINTER_OVERHEAD_IN_QUADS);
    int32Array[block - POINTER_SIZE_IN_QUADS] = -size;
    int32Array[trailing + trailingSize] = -size;
    insert(int32Array, block, size, UPDATES);
    return blockSize;
}
/**
 * Insert the given block into the freelist in between the given free blocks,
 * joining them together, returning the number of bytes which were freed.
 */
function insertMiddle(int32Array, preceding, block, blockSize, trailing, UPDATES) {
    const precedingSize = readSize(int32Array, preceding);
    const trailingSize = readSize(int32Array, trailing);
    const size = ((trailing - preceding) + trailingSize);
    remove(int32Array, preceding, precedingSize, UPDATES);
    remove(int32Array, trailing, trailingSize, UPDATES);
    int32Array[preceding - POINTER_SIZE_IN_QUADS] = -size;
    int32Array[trailing + trailingSize] = -size;
    insert(int32Array, preceding, size, UPDATES);
    return blockSize;
}
/**
 * Insert the given block into the freelist after the given free block,
 * joining them together, returning the number of bytes which were freed.
 */
function insertAfter(int32Array, preceding, block, blockSize, UPDATES) {
    const precedingSize = (block - preceding) - POINTER_OVERHEAD_IN_QUADS;
    const size = ((block - preceding) + blockSize);
    remove(int32Array, preceding, precedingSize, UPDATES);
    int32Array[preceding - POINTER_SIZE_IN_QUADS] = -size;
    int32Array[block + blockSize] = -size;
    insert(int32Array, preceding, size, UPDATES);
    return blockSize;
}
/**
 * Generate a random height for a block, growing the list height by 1 if required.
 */
function generateHeight(int32Array, block, blockSize, UPDATES) {
    const listHeight = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS];
    let height = randomHeight();
    if (blockSize - 1 < height + 1) {
        height = blockSize - 2;
    }
    if (height > listHeight) {
        const newHeight = listHeight + 1;
        int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS] = newHeight;
        int32Array[HEADER_OFFSET_IN_QUADS + NEXT_OFFSET_IN_QUADS + (newHeight - 1)] = HEADER_OFFSET_IN_QUADS;
        UPDATES[newHeight] = HEADER_OFFSET_IN_QUADS;
        int32Array[block + HEIGHT_OFFSET_IN_QUADS] = newHeight;
        return newHeight;
    }
    else {
        int32Array[block + HEIGHT_OFFSET_IN_QUADS] = height;
        return height;
    }
}
/**
 * Generate a random height for a new block.
 */
function randomHeight() {
    let height = 1;
    while (Math.random() < 0.5 && height < MAX_HEIGHT) {
        height += 1;
    }
    return height;
}


/***/ }),

/***/ "./src/cheap/allocator/Table.ts":
/*!**************************************!*\
  !*** ./src/cheap/allocator/Table.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebassemblyTable: () => (/* binding */ WebassemblyTable)
/* harmony export */ });
const INIT_SIZE = 10;
class WebassemblyTable {
    table;
    pointer;
    nodes;
    constructor() {
        this.table = new WebAssembly.Table({
            initial: 6 /* BuiltinTableSlot.SLOT_NB */ + INIT_SIZE,
            element: 'anyfunc'
        });
        this.pointer = 6 /* BuiltinTableSlot.SLOT_NB */;
        this.nodes = [{
                pointer: this.pointer,
                length: INIT_SIZE,
                free: true
            }];
    }
    getPointer() {
        return this.pointer;
    }
    alloc(count) {
        let p = this.findFree(count);
        if (p < 0) {
            const last = this.nodes[this.nodes.length - 1];
            const length = count - (last.free ? last.length : 0);
            this.table.grow(length);
            if (last.free) {
                last.length = last.length + length;
            }
            else {
                this.nodes.push({
                    pointer: last.pointer + last.length,
                    length,
                    free: true
                });
            }
            p = this.findFree(count);
        }
        const node = this.nodes[p];
        if (node.length > count) {
            this.nodes.splice(p + 1, 0, {
                pointer: node.pointer + count,
                length: node.length - count,
                free: true
            });
            node.length = count;
        }
        node.free = false;
        return node.pointer;
    }
    free(pointer) {
        let p = this.findNode(pointer);
        const node = this.nodes[p];
        if (node && !node.free) {
            const before = this.nodes[p - 1];
            const after = this.nodes[p + 1];
            if (before && before.free) {
                if (after && after.free) {
                    before.length += (node.length + after.length);
                    this.nodes.splice(p, 2);
                }
                else {
                    before.length += node.length;
                    this.nodes.splice(p, 1);
                }
            }
            else {
                if (after && after.free) {
                    node.length += after.length;
                    this.nodes.splice(p + 1, 1);
                    node.free = true;
                }
                else {
                    node.free = true;
                }
            }
        }
        if (this.nodes.length === 1 && this.nodes[0].free) {
            //  free  Table WebAssembly  chrome 
            const table = new WebAssembly.Table({
                initial: 6 /* BuiltinTableSlot.SLOT_NB */ + INIT_SIZE,
                element: 'anyfunc'
            });
            this.pointer = 6 /* BuiltinTableSlot.SLOT_NB */;
            this.nodes = [{
                    pointer: this.pointer,
                    length: INIT_SIZE,
                    free: true
                }];
            for (let i = 1; i < this.pointer; i++) {
                table.set(i, this.table.get(i));
            }
            this.table = table;
        }
    }
    get(index) {
        return this.table.get(index);
    }
    set(index, value) {
        if (index < 0 || index >= this.pointer) {
            throw new RangeError('index out of bound');
        }
        this.table.set(index, value);
    }
    inspect() {
        return this.nodes;
    }
    findFree(length) {
        let index = -1;
        for (let i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i].length >= length && this.nodes[i].free) {
                index = i;
                break;
            }
        }
        return index;
    }
    findNode(pointer) {
        let index = -1;
        for (let i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i].pointer === pointer) {
                index = i;
                break;
            }
        }
        return index;
    }
}


/***/ }),

/***/ "./src/cheap/asm/memory.ts":
/*!*********************************!*\
  !*** ./src/cheap/asm/memory.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* unused harmony exports instance, support */
/* harmony import */ var common_util_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/base64 */ "./src/common/util/base64.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
/* harmony import */ var _memory_asm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./memory.asm */ "./src/cheap/asm/memory.asm");
/* harmony import */ var _memory_asm__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_memory_asm__WEBPACK_IMPORTED_MODULE_5__);
var cheap__fileName__0 = "src\\cheap\\asm\\memory.ts";






/**
 * WebAssembly runtime 
 */
let instance;
function support() {
    return !!instance;
}
async function init(memory) {
    try {
        let wasm = (0,common_util_base64__WEBPACK_IMPORTED_MODULE_0__.base64ToUint8Array)((_memory_asm__WEBPACK_IMPORTED_MODULE_5___default()));
        common_util_wasm__WEBPACK_IMPORTED_MODULE_4__.setMemoryShared(wasm, typeof SharedArrayBuffer === 'function' && memory.buffer instanceof SharedArrayBuffer);
        instance = (await WebAssembly.instantiate(wasm, {
            env: {
                memory
            }
        })).instance;
        (0,_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.override)({
            [4 /* CTypeEnum.char */]: instance.exports.readU8,
            [5 /* CTypeEnum.atomic_char */]: instance.exports.readU8,
            [2 /* CTypeEnum.uint8 */]: instance.exports.readU8,
            [3 /* CTypeEnum.atomic_uint8 */]: instance.exports.readU8,
            [6 /* CTypeEnum.uint16 */]: instance.exports.readU16,
            [7 /* CTypeEnum.atomic_uint16 */]: instance.exports.readU16,
            [8 /* CTypeEnum.uint32 */]: (pointer) => {
                return instance.exports.read32(pointer) >>> 0;
            },
            [9 /* CTypeEnum.atomic_uint32 */]: (pointer) => {
                return instance.exports.read32(pointer) >>> 0;
            },
            [10 /* CTypeEnum.uint64 */]: (pointer) => {
                return BigInt.asUintN(64, instance.exports.read64(pointer));
            },
            [22 /* CTypeEnum.atomic_uint64 */]: (pointer) => {
                return BigInt.asUintN(64, instance.exports.read64(pointer));
            },
            [11 /* CTypeEnum.int8 */]: instance.exports.read8,
            [12 /* CTypeEnum.atomic_int8 */]: instance.exports.read8,
            [13 /* CTypeEnum.int16 */]: instance.exports.read16,
            [14 /* CTypeEnum.atomic_int16 */]: instance.exports.read16,
            [15 /* CTypeEnum.int32 */]: instance.exports.read32,
            [16 /* CTypeEnum.atomic_int32 */]: instance.exports.read32,
            [17 /* CTypeEnum.int64 */]: instance.exports.read64,
            [21 /* CTypeEnum.atomic_int64 */]: instance.exports.read64,
            [18 /* CTypeEnum.float */]: instance.exports.readf32,
            [19 /* CTypeEnum.double */]: instance.exports.readf64,
            [20 /* CTypeEnum.pointer */]: (pointer) => {
                return instance.exports.read32(pointer) >>> 0;
            }
        });
        (0,_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.override)({
            [4 /* CTypeEnum.char */]: instance.exports.write8,
            [5 /* CTypeEnum.atomic_char */]: instance.exports.write8,
            [2 /* CTypeEnum.uint8 */]: instance.exports.write8,
            [3 /* CTypeEnum.atomic_uint8 */]: instance.exports.write8,
            [6 /* CTypeEnum.uint16 */]: instance.exports.write16,
            [7 /* CTypeEnum.atomic_uint16 */]: instance.exports.write16,
            [8 /* CTypeEnum.uint32 */]: instance.exports.write32,
            [9 /* CTypeEnum.atomic_uint32 */]: instance.exports.write32,
            [10 /* CTypeEnum.uint64 */]: instance.exports.write64,
            [22 /* CTypeEnum.atomic_uint64 */]: instance.exports.write64,
            [11 /* CTypeEnum.int8 */]: instance.exports.write8,
            [12 /* CTypeEnum.atomic_int8 */]: instance.exports.write8,
            [13 /* CTypeEnum.int16 */]: instance.exports.write16,
            [14 /* CTypeEnum.atomic_int16 */]: instance.exports.write16,
            [15 /* CTypeEnum.int32 */]: instance.exports.write32,
            [16 /* CTypeEnum.atomic_int32 */]: instance.exports.write32,
            [17 /* CTypeEnum.int64 */]: instance.exports.write64,
            [21 /* CTypeEnum.atomic_int64 */]: instance.exports.write64,
            [18 /* CTypeEnum.float */]: instance.exports.writef32,
            [19 /* CTypeEnum.double */]: instance.exports.writef64,
            [20 /* CTypeEnum.pointer */]: instance.exports.write32
        });
    }
    catch (error) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.warn('memory asm not support, cannot use asm memory function', cheap__fileName__0, 96);
    }
}


/***/ }),

/***/ "./src/cheap/config.ts":
/*!*****************************!*\
  !*** ./src/cheap/config.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HEAP_INITIAL: () => (/* binding */ HEAP_INITIAL),
/* harmony export */   HEAP_MAXIMUM: () => (/* binding */ HEAP_MAXIMUM),
/* harmony export */   HEAP_OFFSET: () => (/* binding */ HEAP_OFFSET),
/* harmony export */   STACK_ALIGNMENT: () => (/* binding */ STACK_ALIGNMENT),
/* harmony export */   STACK_SIZE: () => (/* binding */ STACK_SIZE),
/* harmony export */   USE_THREADS: () => (/* binding */ USE_THREADS)
/* harmony export */ });
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var common_util_os__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/os */ "./src/common/util/os.ts");




/**
 * 
 */
const USE_THREADS =  true && (common_util_support__WEBPACK_IMPORTED_MODULE_0__["default"].thread || false) && common_util_constant__WEBPACK_IMPORTED_MODULE_1__.SELF.CHEAP_DISABLE_THREAD !== true;
/**
 * 
 *  16  wasm  v128 16 
 */
let STACK_ALIGNMENT = 16;
/**
 *  STACK_ALIGNMENT 
 */
let STACK_SIZE = 1048576;
/**
 * 
 */
const HEAP_OFFSET = 1024;
/**
 * 
 */
const HEAP_INITIAL = (common_util_constant__WEBPACK_IMPORTED_MODULE_1__.SELF.CHEAP_HEAP_INITIAL ?? 265);
/**
 * 
 * ios safari 16  
 */
const HEAP_MAXIMUM = common_util_constant__WEBPACK_IMPORTED_MODULE_1__.SELF.CHEAP_HEAP_MAXIMUM ?? (USE_THREADS && (common_util_os__WEBPACK_IMPORTED_MODULE_3__["default"].ios && common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].majorVersion, '17', true)) ? 8192 : 65536);


/***/ }),

/***/ "./src/cheap/ctypeEnumImpl.ts":
/*!************************************!*\
  !*** ./src/cheap/ctypeEnumImpl.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_function_isLittleEndian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/function/isLittleEndian */ "./src/common/function/isLittleEndian.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");



let getAllocator;
let getView;
const littleEndian = (0,common_function_isLittleEndian__WEBPACK_IMPORTED_MODULE_0__["default"])();
function writeU8(pointer, value) {
    getView().setUint8(pointer, value);
}
function readU8(pointer) {
    return getView().getUint8(pointer);
}
function writeU16(pointer, value) {
    getView().setUint16(pointer, value, littleEndian);
}
function readU16(pointer) {
    return getView().getUint16(pointer, littleEndian);
}
function writeU32(pointer, value) {
    getView().setUint32(pointer, value, littleEndian);
}
function readU32(pointer) {
    return getView().getUint32(pointer, littleEndian);
}
function writeU64(pointer, value) {
    getView().setBigUint64(pointer, value, littleEndian);
}
function readU64(pointer) {
    return getView().getBigUint64(pointer, littleEndian);
}
function write8(pointer, value) {
    getView().setInt8(pointer, value);
}
function read8(pointer) {
    return getView().getInt8(pointer);
}
function write16(pointer, value) {
    getView().setInt16(pointer, value, littleEndian);
}
function read16(pointer) {
    return getView().getInt16(pointer, littleEndian);
}
function write32(pointer, value) {
    getView().setInt32(pointer, value, littleEndian);
}
function read32(pointer) {
    return getView().getInt32(pointer, littleEndian);
}
function write64(pointer, value) {
    getView().setBigInt64(pointer, value, littleEndian);
}
function read64(pointer) {
    return getView().getBigInt64(pointer, littleEndian);
}
function writef32(pointer, value) {
    getView().setFloat32(pointer, value, littleEndian);
}
function readf32(pointer) {
    return getView().getFloat32(pointer, littleEndian);
}
function writef64(pointer, value) {
    getView().setFloat64(pointer, value, littleEndian);
}
function readf64(pointer) {
    return getView().getFloat64(pointer, littleEndian);
}
function readPointer(pointer) {
    return getView().getUint32(pointer, littleEndian);
}
function writePointer(pointer, value) {
    return getView().setUint32(pointer, value, littleEndian);
}
function init(getAllocator_, getView_) {
    getAllocator = getAllocator_;
    getView = getView_;
    (0,_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.override)({
        [4 /* CTypeEnum.char */]: readU8,
        [5 /* CTypeEnum.atomic_char */]: readU8,
        [2 /* CTypeEnum.uint8 */]: readU8,
        [3 /* CTypeEnum.atomic_uint8 */]: readU8,
        [6 /* CTypeEnum.uint16 */]: readU16,
        [7 /* CTypeEnum.atomic_uint16 */]: readU16,
        [8 /* CTypeEnum.uint32 */]: readU32,
        [9 /* CTypeEnum.atomic_uint32 */]: readU32,
        [10 /* CTypeEnum.uint64 */]: readU64,
        [11 /* CTypeEnum.int8 */]: read8,
        [12 /* CTypeEnum.atomic_int8 */]: read8,
        [13 /* CTypeEnum.int16 */]: read16,
        [14 /* CTypeEnum.atomic_int16 */]: read16,
        [15 /* CTypeEnum.int32 */]: read32,
        [16 /* CTypeEnum.atomic_int32 */]: read32,
        [17 /* CTypeEnum.int64 */]: read64,
        [18 /* CTypeEnum.float */]: readf32,
        [19 /* CTypeEnum.double */]: readf64,
        [20 /* CTypeEnum.pointer */]: readPointer,
        [23 /* CTypeEnum.bool */]: (pointer) => {
            return !!read8(pointer);
        },
        [24 /* CTypeEnum.atomic_bool */]: (pointer) => {
            return !!read8(pointer);
        }
    });
    (0,_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.override)({
        [4 /* CTypeEnum.char */]: writeU8,
        [5 /* CTypeEnum.atomic_char */]: writeU8,
        [2 /* CTypeEnum.uint8 */]: writeU8,
        [3 /* CTypeEnum.atomic_uint8 */]: writeU8,
        [6 /* CTypeEnum.uint16 */]: writeU16,
        [7 /* CTypeEnum.atomic_uint16 */]: writeU16,
        [8 /* CTypeEnum.uint32 */]: writeU32,
        [9 /* CTypeEnum.atomic_uint32 */]: writeU32,
        [10 /* CTypeEnum.uint64 */]: writeU64,
        [11 /* CTypeEnum.int8 */]: write8,
        [12 /* CTypeEnum.atomic_int8 */]: write8,
        [13 /* CTypeEnum.int16 */]: write16,
        [14 /* CTypeEnum.atomic_int16 */]: write16,
        [15 /* CTypeEnum.int32 */]: write32,
        [16 /* CTypeEnum.atomic_int32 */]: write32,
        [17 /* CTypeEnum.int64 */]: write64,
        [18 /* CTypeEnum.float */]: writef32,
        [19 /* CTypeEnum.double */]: writef64,
        [20 /* CTypeEnum.pointer */]: writePointer,
        [23 /* CTypeEnum.bool */]: (pointer, value) => {
            write8(pointer, value ? 1 : 0);
        },
        [24 /* CTypeEnum.atomic_bool */]: ((pointer, value) => {
            write8(pointer, value ? 1 : 0);
        })
    });
}


/***/ }),

/***/ "./src/cheap/ctypeEnumRead.ts":
/*!************************************!*\
  !*** ./src/cheap/ctypeEnumRead.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CTypeEnumRead: () => (/* binding */ CTypeEnumRead),
/* harmony export */   override: () => (/* binding */ override)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");

const CTypeEnumRead = {
    [4 /* CTypeEnum.char */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [5 /* CTypeEnum.atomic_char */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [2 /* CTypeEnum.uint8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [3 /* CTypeEnum.atomic_uint8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [6 /* CTypeEnum.uint16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [7 /* CTypeEnum.atomic_uint16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [8 /* CTypeEnum.uint32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [9 /* CTypeEnum.atomic_uint32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [10 /* CTypeEnum.uint64 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [11 /* CTypeEnum.int8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [12 /* CTypeEnum.atomic_int8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [13 /* CTypeEnum.int16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [14 /* CTypeEnum.atomic_int16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [15 /* CTypeEnum.int32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [16 /* CTypeEnum.atomic_int32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [17 /* CTypeEnum.int64 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [18 /* CTypeEnum.float */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [19 /* CTypeEnum.double */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [20 /* CTypeEnum.pointer */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [0 /* CTypeEnum.null */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [1 /* CTypeEnum.void */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [22 /* CTypeEnum.atomic_uint64 */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [21 /* CTypeEnum.atomic_int64 */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [23 /* CTypeEnum.bool */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [24 /* CTypeEnum.atomic_bool */]: function (pointer) {
        throw new Error('invalid operate');
    }
};
function override(funcs) {
    common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend(CTypeEnumRead, funcs);
}


/***/ }),

/***/ "./src/cheap/ctypeEnumWrite.ts":
/*!*************************************!*\
  !*** ./src/cheap/ctypeEnumWrite.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CTypeEnumWrite: () => (/* binding */ CTypeEnumWrite),
/* harmony export */   override: () => (/* binding */ override)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");

const CTypeEnumWrite = {
    [4 /* CTypeEnum.char */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [5 /* CTypeEnum.atomic_char */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [2 /* CTypeEnum.uint8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [3 /* CTypeEnum.atomic_uint8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [6 /* CTypeEnum.uint16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [7 /* CTypeEnum.atomic_uint16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [8 /* CTypeEnum.uint32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [9 /* CTypeEnum.atomic_uint32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [10 /* CTypeEnum.uint64 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [11 /* CTypeEnum.int8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [12 /* CTypeEnum.atomic_int8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [13 /* CTypeEnum.int16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [14 /* CTypeEnum.atomic_int16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [15 /* CTypeEnum.int32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [16 /* CTypeEnum.atomic_int32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [17 /* CTypeEnum.int64 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [18 /* CTypeEnum.float */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [19 /* CTypeEnum.double */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [20 /* CTypeEnum.pointer */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [0 /* CTypeEnum.null */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [1 /* CTypeEnum.void */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [22 /* CTypeEnum.atomic_uint64 */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [21 /* CTypeEnum.atomic_int64 */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [23 /* CTypeEnum.bool */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [24 /* CTypeEnum.atomic_bool */]: function (pointer, value) {
        throw new Error('invalid operate');
    }
};
function override(funcs) {
    common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend(CTypeEnumWrite, funcs);
}


/***/ }),

/***/ "./src/cheap/definedStruct.ts":
/*!************************************!*\
  !*** ./src/cheap/definedStruct.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   definedStruct: () => (/* binding */ definedStruct),
/* harmony export */   revokeDefinedStruct: () => (/* binding */ revokeDefinedStruct)
/* harmony export */ });
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./typedef */ "./src/cheap/typedef.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_function_toString__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/function/toString */ "./src/common/function/toString.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");









function definedProperty(target, key, get, set) {
    Object.defineProperty(target, key, {
        get,
        set,
        configurable: true,
        enumerable: true
    });
}
/**
 * 
 *
 * @param address
 * @returns
 */
function getPointerValue(address) {
    return function () {
        return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20 /* CTypeEnum.pointer */](address());
    };
}
function getStruct(target, key, address, struct) {
    return function () {
        return target[`__$__${key}`] || (target[`__$__${key}`] = definedStruct(address(), struct));
    };
}
function getCTypeEnumValue(address, type) {
    return function () {
        return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[type](address());
    };
}
function getBitFieldValue(address, type, bitLen, offset) {
    const shift = _typedef__WEBPACK_IMPORTED_MODULE_4__.CTypeEnum2Bytes[type] * 8 - offset - bitLen;
    const valueMask = Math.pow(2, bitLen) - 1;
    return function () {
        let value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[type](address());
        return (value >>> shift) & valueMask;
    };
}
function setPointerValue(address) {
    return function (newValue) {
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20 /* CTypeEnum.pointer */](address(), newValue);
    };
}
function setStruct(obj, key, address, struct) {
    const localKey = `__$__${key}`;
    return function (newValue) {
        const proxy = obj[localKey] || (obj[localKey] = definedStruct(address(), struct));
        common_util_object__WEBPACK_IMPORTED_MODULE_6__.each(newValue, (value, key) => {
            proxy[key] = value;
        });
        obj[localKey] = proxy;
    };
}
function setCTypeEnumValue(address, type) {
    return function (newValue) {
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[type](address(), newValue);
    };
}
function setBitFieldValue(address, type, bitLen, offset) {
    let zeroMask = 0;
    let len = _typedef__WEBPACK_IMPORTED_MODULE_4__.CTypeEnum2Bytes[type] * 8;
    for (let i = 0; i < bitLen; i++) {
        zeroMask |= (1 << (len - 1 - (i + offset)));
    }
    const valueMask = Math.pow(2, bitLen) - 1;
    const shift = len - offset - bitLen;
    return function (newValue) {
        const addr = address();
        const value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[type](addr);
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[type](addr, (value & ~zeroMask) | ((newValue & valueMask) << shift));
    };
}
function definedArrayStruct(address, length, type) {
    const obj = {};
    let size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_0__["default"])(type);
    for (let i = 0; i < length; i++) {
        const key = (0,common_function_toString__WEBPACK_IMPORTED_MODULE_7__["default"])(i);
        definedProperty(obj, key, getStruct(obj, key, () => {
            return address() + size * i;
        }, type), setStruct(obj, key, () => {
            return address() + size * i;
        }, type));
    }
    return obj;
}
function definedArrayCTypeEnum(address, length, type) {
    const obj = {};
    let size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_0__["default"])(type);
    for (let i = 0; i < length; i++) {
        const key = (0,common_function_toString__WEBPACK_IMPORTED_MODULE_7__["default"])(i);
        definedProperty(obj, key, getCTypeEnumValue(() => {
            return address() + size * i;
        }, type), setCTypeEnumValue(() => {
            return address() + size * i;
        }, type));
    }
    return obj;
}
function getArray(address, target, key) {
    return function () {
        const t = target[`__$__${key}`];
        t[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = address();
        return t;
    };
}
function setArrayStruct(obj, key, address, length, type) {
    const localKey = `__$__${key}`;
    return function (newValue) {
        let proxy = obj[localKey] || definedArrayStruct(address, length, type);
        proxy[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = address();
        common_util_array__WEBPACK_IMPORTED_MODULE_8__.each(newValue, (value, key) => {
            proxy[key] = value;
        });
        obj[localKey] = proxy;
    };
}
function setArrayCTypeEnum(obj, key, address, length, type) {
    const localKey = `__$__${key}`;
    return function (newValue) {
        let proxy = obj[localKey] || definedArrayCTypeEnum(address, length, type);
        proxy[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = address();
        common_util_array__WEBPACK_IMPORTED_MODULE_8__.each(newValue, (value, key) => {
            proxy[key] = value;
        });
        obj[localKey] = proxy;
    };
}
function definedStruct(address, struct) {
    let prototype = common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(struct) ? struct.prototype : struct;
    const obj = {};
    obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = address;
    Object.setPrototypeOf(obj, prototype);
    while (true) {
        let keysMeta = prototype[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta];
        if (keysMeta) {
            keysMeta.forEach((meta, key) => {
                if (meta[3 /* KeyMetaKey.Array */]) {
                    if (meta[1 /* KeyMetaKey.Pointer */]) {
                        definedProperty(obj, key, getArray(() => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, obj, key), setArrayCTypeEnum(obj, key, () => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, meta[4 /* KeyMetaKey.ArrayLength */], 20 /* CTypeEnum.pointer */));
                    }
                    else {
                        if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_5__.object(meta[0 /* KeyMetaKey.Type */])) {
                            definedProperty(obj, key, getArray(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, obj, key), setArrayStruct(obj, key, () => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[4 /* KeyMetaKey.ArrayLength */], meta[0 /* KeyMetaKey.Type */]));
                        }
                        else {
                            definedProperty(obj, key, getArray(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, obj, key), setArrayCTypeEnum(obj, key, () => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[4 /* KeyMetaKey.ArrayLength */], meta[0 /* KeyMetaKey.Type */]));
                        }
                    }
                }
                else {
                    if (meta[1 /* KeyMetaKey.Pointer */]) {
                        definedProperty(obj, key, getPointerValue(() => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }), setPointerValue(() => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }));
                    }
                    else if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_5__.object(meta[0 /* KeyMetaKey.Type */])) {
                        definedProperty(obj, key, getStruct(obj, key, () => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, meta[0 /* KeyMetaKey.Type */]), setStruct(obj, key, () => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, meta[0 /* KeyMetaKey.Type */]));
                    }
                    else {
                        if (meta[5 /* KeyMetaKey.BitField */]) {
                            definedProperty(obj, key, getBitFieldValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */], meta[6 /* KeyMetaKey.BitFieldLength */], meta[8 /* KeyMetaKey.BaseBitOffset */]), setBitFieldValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */], meta[6 /* KeyMetaKey.BitFieldLength */], meta[8 /* KeyMetaKey.BaseBitOffset */]));
                        }
                        else {
                            definedProperty(obj, key, getCTypeEnumValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */]), setCTypeEnumValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */]));
                        }
                    }
                }
            });
        }
        prototype = Object.getPrototypeOf(prototype);
        if (!prototype) {
            break;
        }
    }
    return obj;
}
function revokeDefinedStruct(target) {
    let prototype = Object.getPrototypeOf(target);
    while (true) {
        let keysMeta = prototype[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta];
        if (keysMeta) {
            keysMeta.forEach((meta, key) => {
                delete target[key];
            });
        }
        prototype = Object.getPrototypeOf(prototype);
        if (!prototype) {
            break;
        }
    }
}


/***/ }),

/***/ "./src/cheap/function/definedMetaProperty.ts":
/*!***************************************************!*\
  !*** ./src/cheap/function/definedMetaProperty.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ definedMetaProperty)
/* harmony export */ });
function definedMetaProperty(target, key, value) {
    Object.defineProperty(target, key, {
        value,
        writable: false,
        enumerable: false,
        configurable: false
    });
}


/***/ }),

/***/ "./src/cheap/heap.ts":
/*!***************************!*\
  !*** ./src/cheap/heap.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Allocator: () => (/* binding */ Allocator),
/* harmony export */   Memory: () => (/* binding */ Memory),
/* harmony export */   StackPointer: () => (/* binding */ StackPointer),
/* harmony export */   StackTop: () => (/* binding */ StackTop),
/* harmony export */   Table: () => (/* binding */ Table),
/* harmony export */   allocThreadId: () => (/* binding */ allocThreadId),
/* harmony export */   getHeap16: () => (/* binding */ getHeap16),
/* harmony export */   getHeap32: () => (/* binding */ getHeap32),
/* harmony export */   getHeap64: () => (/* binding */ getHeap64),
/* harmony export */   getHeap8: () => (/* binding */ getHeap8),
/* harmony export */   getHeapF32: () => (/* binding */ getHeapF32),
/* harmony export */   getHeapF64: () => (/* binding */ getHeapF64),
/* harmony export */   getHeapU16: () => (/* binding */ getHeapU16),
/* harmony export */   getHeapU32: () => (/* binding */ getHeapU32),
/* harmony export */   getHeapU64: () => (/* binding */ getHeapU64),
/* harmony export */   getHeapU8: () => (/* binding */ getHeapU8),
/* harmony export */   getView: () => (/* binding */ getView),
/* harmony export */   initThread: () => (/* binding */ initThread)
/* harmony export */ });
/* unused harmony exports ThreadId, isMainThread, ThreadName, StackSize, getAtomicsBuffer, initMain */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var _allocator_AllocatorJS__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./allocator/AllocatorJS */ "./src/cheap/allocator/AllocatorJS.ts");
/* harmony import */ var _allocator_Table__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./allocator/Table */ "./src/cheap/allocator/Table.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config */ "./src/cheap/config.ts");
/* harmony import */ var _staticData__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./staticData */ "./src/cheap/staticData.ts");
/* harmony import */ var _thread_atomicsImpl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./thread/atomicsImpl */ "./src/cheap/thread/atomicsImpl.ts");
/* harmony import */ var _asm_memory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./asm/memory */ "./src/cheap/asm/memory.ts");
/* harmony import */ var _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./thread/asm/atomics */ "./src/cheap/thread/asm/atomics.ts");
/* harmony import */ var _ctypeEnumImpl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ctypeEnumImpl */ "./src/cheap/ctypeEnumImpl.ts");
/* harmony import */ var common_function_isAudioWorklet__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/function/isAudioWorklet */ "./src/common/function/isAudioWorklet.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");













/**
 *  id
 */
let ThreadId = -1;
let isMainThread = true;
/**
 * 
 */
let ThreadName = '';
/**
 * 
 */
let StackPointer = null;
/**
 * 
 */
let StackTop = null;
/**
 * 
 */
let StackSize = 0;
/**
 *  Table
 */
let Table = null;
/**
 * 
 */
let Allocator = null;
/**
 * 
 */
let Memory = null;
/**
 * 1 
 * - int8
 * - -128 to 127
 */
let Heap8 = null;
/**
 * 2 
 * - int16
 * - -32768 to 32767
 */
let Heap16 = null;
/**
 * 4 
 * - int32
 * - -2147483648 to 2147483647
 */
let Heap32 = null;
/**
 * 8 
 * - int64
 * - 0 to 4294967295
 */
let Heap64 = null;
/**
 * 1 
 * - uint8
 * - 0 to 255
 */
let HeapU8 = null;
/**
 * 2 
 * - uint16
 * - 0 to 65535
 */
let HeapU16 = null;
/**
 * 4 
 * - uint32
 * - 0 to 4294967295
 */
let HeapU32 = null;
/**
 * 8 
 * - uint64
 * - 0 to 4294967295
 */
let HeapU64 = null;
/**
 * 32 
 * float
 */
let HeapFloat32 = null;
/**
 * 64 
 * double
 */
let HeapFloat64 = null;
/**
 * 
 */
let view = null;
let AtomicBufferMap = {
    [5 /* CTypeEnum.atomic_char */]: HeapU8,
    [3 /* CTypeEnum.atomic_uint8 */]: HeapU8,
    [7 /* CTypeEnum.atomic_uint16 */]: HeapU16,
    [9 /* CTypeEnum.atomic_uint32 */]: HeapU32,
    [22 /* CTypeEnum.atomic_uint64 */]: HeapU64,
    [12 /* CTypeEnum.atomic_int8 */]: Heap8,
    [14 /* CTypeEnum.atomic_int16 */]: Heap16,
    [16 /* CTypeEnum.atomic_int32 */]: Heap32,
    [21 /* CTypeEnum.atomic_int64 */]: Heap64
};
function checkHeap() {
    if (Memory && Memory.buffer !== HeapU8.buffer) {
        return true;
    }
    return false;
}
function getHeapU8() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU8;
}
function getHeap8() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap8;
}
function getHeapU16() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU16;
}
function getHeap16() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap16;
}
function getHeapU32() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU32;
}
function getHeap32() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap32;
}
function getHeap64() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap64;
}
function getHeapU64() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU64;
}
function getHeapF32() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapFloat32;
}
function getHeapF64() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapFloat64;
}
function getView() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return view;
}
function getAtomicsBuffer(type) {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return AtomicBufferMap[type];
}
function setAllocator(a) {
    if (Allocator) {
        Allocator.removeUpdateHandle(updateHeap);
    }
    Allocator = a;
    if (common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap) {
        common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.Allocator = Allocator;
    }
    Allocator.addUpdateHandle(updateHeap);
    updateHeap(Allocator.getBuffer());
}
function updateHeap(heap) {
    Heap8 = new Int8Array(heap);
    Heap16 = new Int16Array(heap);
    Heap32 = new Int32Array(heap);
    Heap64 = new BigInt64Array(heap);
    HeapU8 = new Uint8Array(heap);
    HeapU16 = new Uint16Array(heap);
    HeapU32 = new Uint32Array(heap);
    HeapU64 = new BigUint64Array(heap);
    HeapFloat32 = new Float32Array(heap);
    HeapFloat64 = new Float64Array(heap);
    view = new DataView(heap);
    AtomicBufferMap = {
        [5 /* CTypeEnum.atomic_char */]: HeapU8,
        [3 /* CTypeEnum.atomic_uint8 */]: HeapU8,
        [7 /* CTypeEnum.atomic_uint16 */]: HeapU16,
        [9 /* CTypeEnum.atomic_uint32 */]: HeapU32,
        [22 /* CTypeEnum.atomic_uint64 */]: HeapU64,
        [12 /* CTypeEnum.atomic_int8 */]: Heap8,
        [14 /* CTypeEnum.atomic_int16 */]: Heap16,
        [16 /* CTypeEnum.atomic_int32 */]: Heap32,
        [21 /* CTypeEnum.atomic_int64 */]: Heap64
    };
}
function allocThreadId() {
    return Atomics.add(HeapU32, _staticData__WEBPACK_IMPORTED_MODULE_6__.threadCounter >>> 2, 1);
}
/**
 * 
 *
 * @param options
 */
async function initThread(options) {
    (0,_ctypeEnumImpl__WEBPACK_IMPORTED_MODULE_10__["default"])(() => {
        return Allocator;
    }, getView);
    (0,_thread_atomicsImpl__WEBPACK_IMPORTED_MODULE_7__["default"])(getAtomicsBuffer);
    Memory = options.memory;
    const allocator = new _allocator_AllocatorJS__WEBPACK_IMPORTED_MODULE_2__["default"]({
        buffer: Memory.buffer,
        memory: Memory,
        byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET,
        maxHeapSize: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_MAXIMUM * 64 * 1024,
        growAllowed: true,
        onResize(old, need) {
            Memory.grow((need - old.byteLength) >>> 16);
            return {
                buffer: Memory.buffer,
                byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET
            };
        }
    }, false);
    setAllocator(allocator);
    if (options.stackPointer) {
        StackSize = options.stackSize;
        StackTop = options.stackPointer;
        StackPointer = new WebAssembly.Global({
            value: 'i32',
            mutable: true
        }, StackTop + StackSize);
        Table = new _allocator_Table__WEBPACK_IMPORTED_MODULE_3__.WebassemblyTable();
    }
    if (typeof options.id === 'number') {
        ThreadId = options.id;
    }
    else {
        ThreadId = Atomics.add(HeapU32, _staticData__WEBPACK_IMPORTED_MODULE_6__.threadCounter >>> 2, 1);
    }
    ThreadName = options.name ?? 'anonymous';
    common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap = {
        initThread,
        Allocator,
        Table,
        ThreadId,
        ThreadName,
        Memory,
        Config: _config__WEBPACK_IMPORTED_MODULE_5__,
        StackSize,
        StackTop,
        StackPointer,
        isMainThread: false
    };
    isMainThread = false;
    {
        if (!options.disableAsm) {
            // @ts-ignore
            if (typeof BigInt === 'function' && BigInt !== Number
                && (common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '85', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '78', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '15', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].newEdge)) {
                await (0,_asm_memory__WEBPACK_IMPORTED_MODULE_8__["default"])(Memory);
            }
            if ( true && _config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS
                && (common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '85', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '78', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '15', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].newEdge)) {
                await (0,_thread_asm_atomics__WEBPACK_IMPORTED_MODULE_9__["default"])(Memory);
            }
        }
    }
}
/**
 * 
 */
function initMain() {
    (0,_ctypeEnumImpl__WEBPACK_IMPORTED_MODULE_10__["default"])(() => {
        return Allocator;
    }, getView);
    (0,_thread_atomicsImpl__WEBPACK_IMPORTED_MODULE_7__["default"])(getAtomicsBuffer);
    Memory = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.Memory ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.Memory : new WebAssembly.Memory({
        initial: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_INITIAL,
        maximum: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_MAXIMUM,
        shared: _config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS
    });
    Allocator = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.Allocator ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.Allocator : new _allocator_AllocatorJS__WEBPACK_IMPORTED_MODULE_2__["default"]({
        buffer: Memory.buffer,
        memory: Memory,
        byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET,
        maxHeapSize: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_MAXIMUM * 64 * 1024,
        growAllowed: true,
        onResize(old, need) {
            Memory.grow((need - old.byteLength) >>> 16);
            return {
                buffer: Memory.buffer,
                byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET
            };
        }
    });
    Allocator.addUpdateHandle(updateHeap);
    updateHeap(Allocator.getBuffer());
    StackSize = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.StackSize ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.StackSize : _config__WEBPACK_IMPORTED_MODULE_5__.STACK_SIZE;
    StackTop = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.StackTop ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.StackTop : Allocator.malloc(StackSize);
    StackPointer = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.StackPointer ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.StackPointer : new WebAssembly.Global({
        value: 'i32',
        mutable: true
    }, StackTop + StackSize);
    Table = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.Table ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.Table : new _allocator_Table__WEBPACK_IMPORTED_MODULE_3__.WebassemblyTable();
    ThreadId = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.ThreadId ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.ThreadId : 0;
    ThreadName = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap?.ThreadName ? common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.ThreadName : 'main';
    if (!common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap) {
        if (_config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS && true) {
            Atomics.store(HeapU32, _staticData__WEBPACK_IMPORTED_MODULE_6__.threadCounter >>> 2, ThreadId + 1);
            Atomics.store(Heap32, _staticData__WEBPACK_IMPORTED_MODULE_6__.heapMutex >>> 2, 0);
        }
        else {
            HeapU32[_staticData__WEBPACK_IMPORTED_MODULE_6__.threadCounter >>> 2] = ThreadId + 1;
            let index = _staticData__WEBPACK_IMPORTED_MODULE_6__.heapMutex >>> 2;
            Heap32[index] = 0;
        }
    }
    {
        // @ts-ignore
        if (typeof BigInt === 'function' && BigInt !== Number
            && (common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '85', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '78', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '15', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].newEdge)) {
            (0,_asm_memory__WEBPACK_IMPORTED_MODULE_8__["default"])(Memory);
        }
        if (_config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS
            && true
            && (common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '85', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '78', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].majorVersion, '15', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].newEdge)) {
            (0,_thread_asm_atomics__WEBPACK_IMPORTED_MODULE_9__["default"])(Memory);
        }
    }
    if (!common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap) {
        common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap = {
            Allocator,
            Table,
            ThreadId,
            ThreadName,
            Memory,
            Config: _config__WEBPACK_IMPORTED_MODULE_5__,
            StackSize,
            StackTop,
            StackPointer,
            isMainThread: true,
            threadCounter: _staticData__WEBPACK_IMPORTED_MODULE_6__.threadCounter,
            heapMutex: _staticData__WEBPACK_IMPORTED_MODULE_6__.heapMutex
        };
    }
    isMainThread = true;
}
{
    if (!(0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_1__["default"])() && !(0,common_function_isAudioWorklet__WEBPACK_IMPORTED_MODULE_11__["default"])() || ((0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_1__["default"])() && !_config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS)) {
        initMain();
    }
    else {
        common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap = {
            initThread,
            isMainThread: false,
            Config: _config__WEBPACK_IMPORTED_MODULE_5__
        };
        isMainThread = false;
    }
}


/***/ }),

/***/ "./src/cheap/proxyStruct.ts":
/*!**********************************!*\
  !*** ./src/cheap/proxyStruct.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   proxyStruct: () => (/* binding */ proxyStruct),
/* harmony export */   revokeProxyStruct: () => (/* binding */ revokeProxyStruct)
/* harmony export */ });
/* unused harmony export findKeyMeta */
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./typedef */ "./src/cheap/typedef.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_function_toNumber__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/function/toNumber */ "./src/common/function/toNumber.ts");









const ObjectPro = Object.getPrototypeOf({});
function findKeyMeta(prototype, key) {
    while (true) {
        let keysMeta = prototype[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta];
        if (keysMeta) {
            const meta = keysMeta.get(key);
            if (meta) {
                return meta;
            }
        }
        prototype = Object.getPrototypeOf(prototype);
        if (!prototype || prototype === ObjectPro) {
            return null;
        }
    }
}
function proxyArray(address, length, type, pointer) {
    const obj = {};
    obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = address;
    let size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_0__["default"])(pointer ? 20 /* CTypeEnum.pointer */ : type);
    const proxy = new Proxy(obj, {
        get(target, propertyKey, receiver) {
            if (propertyKey === _symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress) {
                return target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress];
            }
            const index = (0,common_function_toNumber__WEBPACK_IMPORTED_MODULE_8__["default"])(propertyKey);
            if (pointer) {
                return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20 /* CTypeEnum.pointer */](target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + index * size);
            }
            else {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(type)) {
                    return target[propertyKey];
                }
                else {
                    return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[type](target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + index * size);
                }
            }
        },
        set(target, propertyKey, newValue, receiver) {
            if (propertyKey === _symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress) {
                target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = newValue;
                return true;
            }
            const index = (0,common_function_toNumber__WEBPACK_IMPORTED_MODULE_8__["default"])(propertyKey);
            if (pointer) {
                _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20 /* CTypeEnum.pointer */](target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + index * size, newValue);
                target[propertyKey] = newValue;
            }
            else {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(type)) {
                    const proxy = target[propertyKey] || (target[propertyKey] = proxyStruct(target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + index * size, type));
                    common_util_object__WEBPACK_IMPORTED_MODULE_6__.each(newValue, (value, key) => {
                        proxy[key] = value;
                    });
                    target[propertyKey] = proxy;
                }
                else {
                    _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[type](target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + index * size, newValue);
                    target[propertyKey] = newValue;
                }
            }
            return true;
        }
    });
    return proxy;
}
function proxyStruct(address, struct) {
    const prototype = common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(struct) ? struct.prototype : struct;
    const obj = {};
    obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = address;
    Object.setPrototypeOf(obj, prototype);
    const { proxy, revoke } = Proxy.revocable(obj, {
        get(target, propertyKey, receiver) {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.string(propertyKey)) {
                const meta = findKeyMeta(prototype, propertyKey.replace(/^\$+/, ''));
                if (meta) {
                    const address = target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                    if (meta[3 /* KeyMetaKey.Array */]) {
                        const t = target[propertyKey];
                        t[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = address;
                        return t;
                    }
                    else if (meta[1 /* KeyMetaKey.Pointer */]) {
                        let p = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20 /* CTypeEnum.pointer */](address);
                        return p;
                    }
                    else if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_5__.object(meta[0 /* KeyMetaKey.Type */])) {
                        return target[propertyKey] || (target[propertyKey] = proxyStruct(address, meta[0 /* KeyMetaKey.Type */]));
                    }
                    else {
                        let value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[meta[0 /* KeyMetaKey.Type */]](address);
                        if (meta[5 /* KeyMetaKey.BitField */]) {
                            value = ((value >>> (_typedef__WEBPACK_IMPORTED_MODULE_4__.CTypeEnum2Bytes[meta[0 /* KeyMetaKey.Type */]] * 8 - meta[8 /* KeyMetaKey.BaseBitOffset */] - meta[6 /* KeyMetaKey.BitFieldLength */]))
                                & (Math.pow(2, meta[6 /* KeyMetaKey.BitFieldLength */]) - 1));
                        }
                        return value;
                    }
                }
                else {
                    return target[propertyKey];
                }
            }
            else {
                return target[propertyKey];
            }
        },
        set(target, propertyKey, newValue, receiver) {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.string(propertyKey)) {
                const meta = findKeyMeta(prototype, propertyKey.replace(/^\$+/, ''));
                if (meta) {
                    const address = target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                    if (meta[3 /* KeyMetaKey.Array */]) {
                        const proxy = target[propertyKey] || proxyArray(address, meta[4 /* KeyMetaKey.ArrayLength */], meta[0 /* KeyMetaKey.Type */], meta[1 /* KeyMetaKey.Pointer */]);
                        common_util_array__WEBPACK_IMPORTED_MODULE_7__.each(newValue, (value, key) => {
                            proxy[key] = value;
                        });
                        target[propertyKey] = proxy;
                    }
                    else {
                        if (meta[1 /* KeyMetaKey.Pointer */]) {
                            _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20 /* CTypeEnum.pointer */](address, newValue);
                            target[propertyKey] = newValue;
                        }
                        else if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_5__.object(meta[0 /* KeyMetaKey.Type */])) {
                            const proxy = target[propertyKey] || (target[propertyKey] = proxyStruct(address, meta[0 /* KeyMetaKey.Type */]));
                            common_util_object__WEBPACK_IMPORTED_MODULE_6__.each(newValue, (value, key) => {
                                proxy[key] = value;
                            });
                            target[propertyKey] = proxy;
                        }
                        else {
                            if (meta[5 /* KeyMetaKey.BitField */]) {
                                let mask = 0;
                                let len = _typedef__WEBPACK_IMPORTED_MODULE_4__.CTypeEnum2Bytes[meta[0 /* KeyMetaKey.Type */]] * 8;
                                for (let i = 0; i < meta[6 /* KeyMetaKey.BitFieldLength */]; i++) {
                                    mask |= (1 << (len - 1 - (i + meta[8 /* KeyMetaKey.BaseBitOffset */])));
                                }
                                const value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[meta[0 /* KeyMetaKey.Type */]](address);
                                _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[meta[0 /* KeyMetaKey.Type */]](address, (value & ~mask) | ((newValue & (Math.pow(2, meta[6 /* KeyMetaKey.BitFieldLength */]) - 1))
                                    << (len - meta[8 /* KeyMetaKey.BaseBitOffset */] - meta[6 /* KeyMetaKey.BitFieldLength */])));
                            }
                            else {
                                _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[meta[0 /* KeyMetaKey.Type */]](address, newValue);
                            }
                            target[propertyKey] = newValue;
                        }
                    }
                }
                else {
                    target[propertyKey] = newValue;
                }
            }
            else {
                target[propertyKey] = newValue;
            }
            return true;
        }
    });
    obj[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructProxyRevoke] = revoke;
    return proxy;
}
function revokeProxyStruct(target) {
    const revoke = target[_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructProxyRevoke];
    if (revoke) {
        revoke();
    }
}


/***/ }),

/***/ "./src/cheap/stack.ts":
/*!****************************!*\
  !*** ./src/cheap/stack.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   free: () => (/* binding */ free),
/* harmony export */   malloc: () => (/* binding */ malloc)
/* harmony export */ });
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./heap */ "./src/cheap/heap.ts");

function malloc(size) {
    _heap__WEBPACK_IMPORTED_MODULE_0__.StackPointer.value -= size;
    return _heap__WEBPACK_IMPORTED_MODULE_0__.StackPointer.value;
}
function free(size) {
    _heap__WEBPACK_IMPORTED_MODULE_0__.StackPointer.value += size;
}


/***/ }),

/***/ "./src/cheap/staticData.ts":
/*!*********************************!*\
  !*** ./src/cheap/staticData.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   heapMutex: () => (/* binding */ heapMutex),
/* harmony export */   malloc: () => (/* binding */ malloc),
/* harmony export */   threadCounter: () => (/* binding */ threadCounter)
/* harmony export */ });
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ "./src/cheap/config.ts");
/* harmony import */ var _thread_mutex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./thread/mutex */ "./src/cheap/thread/mutex.ts");
/**
 * 
 * 
 */



/**
 * 
 */
let pointer = (0) + 1;
function malloc(length, algin = 1) {
    let address = pointer;
    while (address % algin) {
        address = address + 1;
    }
    pointer = address + length;
    return address;
}
/**
 * 
 */
const threadCounter = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.threadCounter
    ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.threadCounter
    : malloc(4, 4);
/**
 * 
 */
const heapMutex = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.heapMutex
    ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.heapMutex
    : malloc(4, 4);


/***/ }),

/***/ "./src/cheap/std/buffer/SafeUint8Array.ts":
/*!************************************************!*\
  !*** ./src/cheap/std/buffer/SafeUint8Array.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SafeUint8Array)
/* harmony export */ });
/* unused harmony export SafeBufferView */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../heap */ "./src/cheap/heap.ts");
/* harmony import */ var common_interface_ArrayLike__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/interface/ArrayLike */ "./src/common/interface/ArrayLike.ts");




class SafeBufferView {
    pointer;
    len;
    constructor(pointer, len) {
        this.pointer = pointer;
        this.len = len;
    }
    get byteLength() {
        return this.len;
    }
    get buffer() {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getHeapU8)().buffer;
    }
    get byteOffset() {
        return this.pointer;
    }
    getFloat32(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getFloat32(this.pointer + byteOffset, littleEndian);
    }
    getFloat64(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getFloat64(this.pointer + byteOffset, littleEndian);
    }
    getInt8(byteOffset) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getInt8(this.pointer + byteOffset);
    }
    getInt16(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getInt16(this.pointer + byteOffset, littleEndian);
    }
    getInt32(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getInt32(this.pointer + byteOffset, littleEndian);
    }
    getUint8(byteOffset) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getUint8(this.pointer + byteOffset);
    }
    getUint16(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getUint16(this.pointer + byteOffset, littleEndian);
    }
    getUint32(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getUint32(this.pointer + byteOffset, littleEndian);
    }
    setFloat32(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setFloat32(this.pointer + byteOffset, value, littleEndian);
    }
    setFloat64(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setFloat64(this.pointer + byteOffset, value, littleEndian);
    }
    setInt8(byteOffset, value) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setInt8(this.pointer + byteOffset, value);
    }
    setInt16(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setInt16(this.pointer + byteOffset, value, littleEndian);
    }
    setInt32(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setInt32(this.pointer + byteOffset, value, littleEndian);
    }
    setUint8(byteOffset, value) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setUint8(this.pointer + byteOffset, value);
    }
    setUint16(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setUint16(this.pointer + byteOffset, value, littleEndian);
    }
    setUint32(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setUint32(this.pointer + byteOffset, value, littleEndian);
    }
    getBigInt64(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getBigInt64(this.pointer + byteOffset, littleEndian);
    }
    getBigUint64(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().getBigUint64(this.pointer + byteOffset, littleEndian);
    }
    setBigInt64(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setBigInt64(this.pointer + byteOffset, value, littleEndian);
    }
    setBigUint64(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getView)().setBigUint64(this.pointer + byteOffset, value, littleEndian);
    }
}
class SafeUint8Array extends common_interface_ArrayLike__WEBPACK_IMPORTED_MODULE_3__["default"] {
    pointer;
    len;
    constructor(pointer, len) {
        super();
        this.pointer = pointer;
        this.len = len;
        return this.proxy;
    }
    getIndexValue(index) {
        return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[2](this.pointer + index);
    }
    setIndexValue(index, value) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[2](this.pointer + index, value);
    }
    set(array, offset = 0) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getHeapU8)().set(array, this.pointer + offset);
    }
    subarray(begin = 0, end, safe) {
        if (safe) {
            return new SafeUint8Array(this.pointer + begin, (end ? end : this.len) - begin);
        }
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getHeapU8)().subarray(this.pointer + begin, this.pointer + (end ?? this.len));
    }
    slice(start = 0, end) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getHeapU8)().slice(this.pointer + start, this.pointer + (end ?? this.len));
    }
    get length() {
        return this.len;
    }
    get byteLength() {
        return this.len;
    }
    get buffer() {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_2__.getHeapU8)().buffer;
    }
    get byteOffset() {
        return this.pointer;
    }
    get view() {
        return new SafeBufferView(this.pointer, this.len);
    }
}


/***/ }),

/***/ "./src/cheap/std/collection/List.ts":
/*!******************************************!*\
  !*** ./src/cheap/std/collection/List.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ List)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var _std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _structAccess__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../structAccess */ "./src/cheap/std/structAccess.ts");












class ListNode {
    // @ts-ignore
    prev;
    // @ts-ignore
    next;
    data;
}
(function (prototype) {
    var map = new Map();
    map.set("prev", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("next", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("data", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(ListNode.prototype);
class List {
    length = 0;
    head = 0;
    tail = 0;
    createNode(item, type, move = false) {
        const pNode = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc(12);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode + 4, 0);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode, 0);
        if (common_util_is__WEBPACK_IMPORTED_MODULE_7__.number(type)) {
            if (type === 20) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode + 8, item);
            }
            else {
                const p = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc((0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__["default"])(type));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[type](p, item);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode + 8, p);
            }
        }
        else {
            if (move) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode + 8, item);
            }
            else {
                const p = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc((0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__["default"])(type));
                (0,_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpy)(p, item[cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress], (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__["default"])(type));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode + 8, p);
            }
        }
        return pNode;
    }
    getItem(data, type) {
        let result;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_7__.number(type)) {
            if (type === 20) {
                result = data;
            }
            else {
                result = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[type](data);
            }
        }
        else {
            result = (0,_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(data, type);
        }
        return result;
    }
    push(item, type, move = false) {
        const pNode = this.createNode(item, type, move);
        if (!this.tail) {
            this.head = pNode;
            this.tail = pNode;
        }
        else {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](this.tail + 4, pNode);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode, this.tail);
            this.tail = pNode;
        }
        this.length++;
    }
    pop(type) {
        const pNode = this.tail;
        let result = this.getItem(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode + 8), type);
        if (this.length > 1) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode) + 4, 0);
            this.tail = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode);
        }
        else {
            this.head = 0, this.tail = 0;
        }
        this.length--;
        cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode + 8));
        cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(pNode);
        return result;
    }
    shift(type) {
        const pNode = this.head;
        let result = this.getItem(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode + 8), type);
        if (this.length > 1) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode + 4), 0);
            this.head = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode + 4);
        }
        else {
            this.head = 0, this.tail = 0;
        }
        this.length--;
        cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](pNode + 8));
        cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(pNode);
        return result;
    }
    unshift(item, type, move = false) {
        const pNode = this.createNode(item, type, move);
        if (!this.head) {
            this.head = pNode;
            this.tail = pNode;
        }
        else {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](this.head, pNode);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](pNode + 4, this.head);
            this.head = pNode;
        }
        this.length++;
    }
    forEach(callback, type) {
        if (!this.length) {
            return;
        }
        let current = this.head;
        let index = 0;
        while (current !== 0) {
            if (callback(this.getItem(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 8), type), index) === false) {
                break;
            }
            current = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 4);
            index++;
        }
    }
    find(callback, type) {
        if (!this.length) {
            return 0;
        }
        let current = this.head;
        let index = 0;
        while (current !== 0) {
            const item = this.getItem(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 8), type);
            if (callback(item, index) === true) {
                return item;
            }
            current = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 4);
            index++;
        }
        return 0;
    }
    indexOf(index, type) {
        if (!this.length) {
            return 0;
        }
        let current = this.head;
        let i = 0;
        while (current !== 0) {
            if (i === index) {
                return this.getItem(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 8), type);
            }
            current = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 4);
            i++;
        }
        return 0;
    }
    clear(callback, type) {
        if (this.length) {
            let current = this.head;
            while (current !== 0) {
                if (callback) {
                    callback(this.getItem(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 8), type));
                }
                cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 8));
                const next = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](current + 4);
                cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(current);
                current = next;
            }
        }
        this.head = 0, this.tail = 0;
        this.length = 0;
    }
}
(function (prototype) {
    var map = new Map();
    map.set("length", { 0: 8, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("head", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("tail", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(List.prototype);


/***/ }),

/***/ "./src/cheap/std/function/isPointer.ts":
/*!*********************************************!*\
  !*** ./src/cheap/std/function/isPointer.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isPointer)
/* harmony export */ });
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");

function isPointer(p) {
    return common_util_is__WEBPACK_IMPORTED_MODULE_0__.number(p) && p >= 0;
}


/***/ }),

/***/ "./src/cheap/std/make.ts":
/*!*******************************!*\
  !*** ./src/cheap/std/make.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ make)
/* harmony export */ });
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var _memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_function_isDef__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/function/isDef */ "./src/common/function/isDef.ts");
/* harmony import */ var _structAccess__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./structAccess */ "./src/cheap/std/structAccess.ts");







/**
 *  struct 
 *
 * @param target
 * @returns
 */
function make(init, struct) {
    if (!(0,common_function_isDef__WEBPACK_IMPORTED_MODULE_5__["default"])(struct)) {
        struct = init;
        init = null;
    }
    const size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_0__["default"])(struct);
    const address = cheap_heap__WEBPACK_IMPORTED_MODULE_1__.Allocator.malloc(size);
    if (!address) {
        throw new TypeError('cannot alloc memory for struct');
    }
    (0,_memory__WEBPACK_IMPORTED_MODULE_2__.memset)(address, 0, size);
    const target = (0,_structAccess__WEBPACK_IMPORTED_MODULE_6__["default"])(address, struct);
    const data = new struct();
    if (init) {
        common_util_object__WEBPACK_IMPORTED_MODULE_4__.extend(data, init);
    }
    common_util_object__WEBPACK_IMPORTED_MODULE_4__.each(data, (value, key) => {
        if ((0,common_function_isDef__WEBPACK_IMPORTED_MODULE_5__["default"])(value)) {
            target[key] = value;
        }
    });
    return target;
}


/***/ }),

/***/ "./src/cheap/std/memory.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/memory.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapSafeUint8Array: () => (/* binding */ mapSafeUint8Array),
/* harmony export */   mapUint16Array: () => (/* binding */ mapUint16Array),
/* harmony export */   mapUint8Array: () => (/* binding */ mapUint8Array),
/* harmony export */   memcpy: () => (/* binding */ memcpy),
/* harmony export */   memcpyFromUint8Array: () => (/* binding */ memcpyFromUint8Array),
/* harmony export */   memset: () => (/* binding */ memset),
/* harmony export */   readCString: () => (/* binding */ readCString),
/* harmony export */   writeCString: () => (/* binding */ writeCString)
/* harmony export */ });
/* unused harmony exports memmove, mapInt8Array, mapInt16Array, mapUint32Array, mapInt32Array, mapUint64Array, mapInt64Array, mapFloat32Array, mapFloat64Array */
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../heap */ "./src/cheap/heap.ts");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string */ "./src/cheap/std/string.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./buffer/SafeUint8Array */ "./src/cheap/std/buffer/SafeUint8Array.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");






function memcpy(dst, src, size) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().set((0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().subarray(src, src + size), dst);
}
function memcpyFromUint8Array(dst, max, data) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().set(data.subarray(0, max), dst);
}
function memmove(dst, src, size) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().copyWithin(dst, src, src + size);
}
function memset(src, c, n) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().subarray(src, src + n).fill(c);
}
function mapSafeUint8Array(src, n) {
    return _config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS ? mapUint8Array(src, n) : new _buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_4__["default"](src, n);
}
function mapUint8Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().subarray(src, src + n);
}
function mapInt8Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap8)().subarray(src, src + n);
}
function mapUint16Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU16)().subarray(src >>> 1, (src >>> 1) + n);
}
function mapInt16Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap16)().subarray(src >>> 1, (src >>> 1) + n);
}
function mapUint32Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU32)().subarray(src >>> 2, (src >>> 2) + n);
}
function mapInt32Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap32)().subarray(src >>> 2, (src >>> 2) + n);
}
function mapUint64Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU64)().subarray(src >>> 3, (src >>> 3) + n);
}
function mapInt64Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap64)().subarray(src >>> 3, (src >>> 3) + n);
}
function mapFloat32Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapF32)().subarray(src >>> 2, (src >>> 2) + n);
}
function mapFloat64Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapF64)().subarray(src >>> 3, (src >>> 3) + n);
}
function readCString(pointer, max) {
    const stringLen = (0,_string__WEBPACK_IMPORTED_MODULE_1__.strlen)(pointer);
    const len = Math.min(stringLen, max ?? stringLen);
    return common_util_text__WEBPACK_IMPORTED_MODULE_2__.decode(mapUint8Array(pointer, len));
}
function writeCString(dst, str, max, addNull = true) {
    const data = common_util_text__WEBPACK_IMPORTED_MODULE_2__.encode(str);
    let len = data.length;
    let remain = addNull ? 1 : 0;
    if (max && len - remain > max) {
        len = max - remain;
    }
    memcpyFromUint8Array(dst, len, data);
    if (addNull) {
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[11 /* CTypeEnum.int8 */](dst + len, 0);
    }
}


/***/ }),

/***/ "./src/cheap/std/sizeof.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/sizeof.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sizeof)
/* harmony export */ });
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typedef */ "./src/cheap/typedef.ts");



function sizeof(type) {
    if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(type)) {
        return _typedef__WEBPACK_IMPORTED_MODULE_2__.CTypeEnum2Bytes[type] || 0;
    }
    else if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.func(type) && type.prototype[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct]) {
        return type.prototype[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength];
    }
    return 0;
}


/***/ }),

/***/ "./src/cheap/std/string.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/string.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   strlen: () => (/* binding */ strlen)
/* harmony export */ });
/* unused harmony exports strcpy, strcat, strcmp */
/* harmony import */ var _memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");


/**
 * \0
 *
 * @param pointer
 */
function strlen(pointer) {
    let len = 0;
    while (_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[4 /* CTypeEnum.char */]((pointer = pointer + 1, pointer - 1))) {
        len++;
    }
    return len;
}
/**
 * 
 *
 * @param destination
 * @param source
 */
function strcpy(destination, source) {
    const len = strlen(source) + 1;
    (0,_memory__WEBPACK_IMPORTED_MODULE_0__.memcpyFromUint8Array)(destination, len, (0,_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(source, len));
}
/**
 * 
 *
 * @param destination
 * @param source
 */
function strcat(destination, source) {
    const len = strlen(source) + 1;
    const len1 = strlen(destination);
    (0,_memory__WEBPACK_IMPORTED_MODULE_0__.memcpyFromUint8Array)(destination + len1, len, (0,_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(source, len));
}
/**
 * 
 */
function strcmp(str1, str2) {
    const len1 = strlen(str1);
    const len2 = strlen(str2);
    const len = Math.min(len1, len2);
    for (let i = 0; i < len; i++) {
        const char1 = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[4 /* CTypeEnum.char */](str1 + i);
        const char2 = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[4 /* CTypeEnum.char */](str2 + i);
        if (char1 > char2) {
            return 1;
        }
        else if (char1 < char2) {
            return -1;
        }
    }
    if (len1 > len2) {
        return 1;
    }
    else if (len1 < len2) {
        return -1;
    }
    else {
        return 0;
    }
}


/***/ }),

/***/ "./src/cheap/std/structAccess.ts":
/*!***************************************!*\
  !*** ./src/cheap/std/structAccess.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ structAccess)
/* harmony export */ });
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _proxyStruct__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../proxyStruct */ "./src/cheap/proxyStruct.ts");
/* harmony import */ var _definedStruct__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../definedStruct */ "./src/cheap/definedStruct.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_keypath__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/keypath */ "./src/common/util/keypath.ts");






/**
 *  struct 
 *
 * @param target
 * @param address
 * @returns
 */
function structAccess(address, struct) {
    if (arguments[2] && common_util_is__WEBPACK_IMPORTED_MODULE_4__.string(arguments[2])) {
        struct = struct.prototype;
        common_util_keypath__WEBPACK_IMPORTED_MODULE_5__.each(arguments[2], (key) => {
            const meta = struct[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta];
            struct = meta.get(key)[0 /* KeyMetaKey.Type */];
        });
    }
    return common_util_support__WEBPACK_IMPORTED_MODULE_3__["default"].proxy ? (0,_proxyStruct__WEBPACK_IMPORTED_MODULE_1__.proxyStruct)(address, struct) : (0,_definedStruct__WEBPACK_IMPORTED_MODULE_2__.definedStruct)(address, struct);
}


/***/ }),

/***/ "./src/cheap/std/unmake.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/unmake.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ unmake)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _proxyStruct__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proxyStruct */ "./src/cheap/proxyStruct.ts");
/* harmony import */ var _definedStruct__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../definedStruct */ "./src/cheap/definedStruct.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");





/**
 *  struct  make  unmake
 *
 * @param target
 */
function unmake(target) {
    const p = target[_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress];
    if (p) {
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(p);
        target[_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress] = 0;
        common_util_support__WEBPACK_IMPORTED_MODULE_4__["default"].proxy ? (0,_proxyStruct__WEBPACK_IMPORTED_MODULE_2__.revokeProxyStruct)(target) : (0,_definedStruct__WEBPACK_IMPORTED_MODULE_3__.revokeDefinedStruct)(target);
    }
}


/***/ }),

/***/ "./src/cheap/symbol.ts":
/*!*****************************!*\
  !*** ./src/cheap/symbol.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   symbolStruct: () => (/* binding */ symbolStruct),
/* harmony export */   symbolStructAddress: () => (/* binding */ symbolStructAddress),
/* harmony export */   symbolStructKeysMeta: () => (/* binding */ symbolStructKeysMeta),
/* harmony export */   symbolStructLength: () => (/* binding */ symbolStructLength),
/* harmony export */   symbolStructMaxBaseTypeByteLength: () => (/* binding */ symbolStructMaxBaseTypeByteLength),
/* harmony export */   symbolStructProxyRevoke: () => (/* binding */ symbolStructProxyRevoke)
/* harmony export */ });
/* unused harmony exports symbolStructKeysQueue, symbolStructKeysInstance */
const symbolStruct = Symbol('Struct');
const symbolStructLength = Symbol('StructLength');
const symbolStructMaxBaseTypeByteLength = Symbol('StructMaxBaseTypeByteLength');
const symbolStructAddress = Symbol('StructAddress');
const symbolStructKeysQueue = Symbol('StructKeysQueue');
const symbolStructKeysMeta = Symbol('StructKeysMeta');
const symbolStructKeysInstance = Symbol('StructKeysInstance');
const symbolStructProxyRevoke = Symbol('StructProxyRevoke');


/***/ }),

/***/ "./src/cheap/thread/asm/atomics.ts":
/*!*****************************************!*\
  !*** ./src/cheap/thread/asm/atomics.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init),
/* harmony export */   instance: () => (/* binding */ instance),
/* harmony export */   isSupport: () => (/* binding */ isSupport)
/* harmony export */ });
/* harmony import */ var common_util_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/base64 */ "./src/common/util/base64.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
/* harmony import */ var _atomics_asm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./atomics.asm */ "./src/cheap/thread/asm/atomics.asm");
/* harmony import */ var _atomics_asm__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_atomics_asm__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../atomics */ "./src/cheap/thread/atomics.ts");
var cheap__fileName__0 = "src\\cheap\\thread\\asm\\atomics.ts";





/**
 * WebAssembly runtime 
 */
let instance;
function isSupport() {
    return !!instance;
}
async function init(memory) {
    try {
        if (typeof SharedArrayBuffer === 'function' && memory.buffer instanceof SharedArrayBuffer) {
            const wasm = (0,common_util_base64__WEBPACK_IMPORTED_MODULE_0__.base64ToUint8Array)((_atomics_asm__WEBPACK_IMPORTED_MODULE_3___default()));
            common_util_wasm__WEBPACK_IMPORTED_MODULE_2__.setMemoryShared(wasm, true);
            instance = (await WebAssembly.instantiate(wasm, {
                env: {
                    memory
                }
            })).instance;
        }
        else {
            return;
        }
        (0,_atomics__WEBPACK_IMPORTED_MODULE_4__.override)({
            add: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.add8(address, value) & 0xff);
                    case 12:
                        return instance.exports.add8(address, value);
                    case 14:
                        return instance.exports.add16(address, value);
                    case 7:
                        return (instance.exports.add16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.add32(address, value);
                    case 9:
                        return (instance.exports.add32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.add64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.add64(address, value));
                }
            },
            sub: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.sub8(address, value) & 0xff);
                    case 12:
                        return instance.exports.sub8(address, value);
                    case 14:
                        return instance.exports.sub16(address, value);
                    case 7:
                        return (instance.exports.sub16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.sub32(address, value);
                    case 9:
                        return (instance.exports.sub32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.sub64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.sub64(address, value));
                }
            },
            and: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.and8(address, value) & 0xff);
                    case 12:
                        return instance.exports.and8(address, value);
                    case 14:
                        return instance.exports.and16(address, value);
                    case 7:
                        return (instance.exports.and16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.and32(address, value);
                    case 9:
                        return (instance.exports.and32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.and64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.and64(address, value));
                }
            },
            or: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.or8(address, value) & 0xff);
                    case 12:
                        return instance.exports.or8(address, value);
                    case 14:
                        return instance.exports.or16(address, value);
                    case 7:
                        return (instance.exports.or16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.or32(address, value);
                    case 9:
                        return instance.exports.or32(address, value);
                    case 21:
                        return instance.exports.or64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.or64(address, value));
                }
            },
            xor: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.xor8(address, value) & 0xff);
                    case 12:
                        return instance.exports.xor8(address, value);
                    case 14:
                        return instance.exports.xor16(address, value);
                    case 7:
                        return (instance.exports.xor16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.xor32(address, value);
                    case 9:
                        return instance.exports.xor32(address, value);
                    case 21:
                        return instance.exports.xor64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.xor64(address, value));
                }
            },
            store: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 12:
                    case 3:
                        return instance.exports.store8(address, value);
                    case 14:
                    case 7:
                        return instance.exports.store16(address, value);
                    case 16:
                    case 9:
                        return instance.exports.store32(address, value);
                    case 21:
                    case 22:
                        return instance.exports.store64(address, value);
                }
            },
            load: function (address, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.load8(address) & 0xff);
                    case 12:
                        return instance.exports.load8(address);
                    case 14:
                        return instance.exports.load16(address);
                    case 7:
                        return instance.exports.load16(address);
                    case 16:
                        return instance.exports.load32(address);
                    case 9:
                        return (instance.exports.load32(address) & 0xffffffff);
                    case 21:
                        return instance.exports.load64(address);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.load64(address));
                }
            },
            compareExchange: function (address, expectedValue, replacementValue, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.compare_exchange8(address, expectedValue, replacementValue) & 0xff);
                    case 12:
                        return instance.exports.compare_exchange8(address, expectedValue, replacementValue);
                    case 14:
                        return instance.exports.compare_exchange16(address, expectedValue, replacementValue);
                    case 7:
                        return (instance.exports.compare_exchange16(address, expectedValue, replacementValue) & 0xffff);
                    case 16:
                        return instance.exports.compare_exchange32(address, expectedValue, replacementValue);
                    case 9:
                        return (instance.exports.compare_exchange32(address, expectedValue, replacementValue) & 0xffffffff);
                    case 21:
                        return instance.exports.compare_exchange64(address, expectedValue, replacementValue);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.compare_exchange64(address, expectedValue, replacementValue));
                }
            },
            exchange: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.exchange8(address, value) & 0xff);
                    case 12:
                        return instance.exports.exchange8(address, value);
                    case 14:
                        return instance.exports.exchange16(address, value);
                    case 7:
                        return (instance.exports.exchange16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.exchange32(address, value);
                    case 9:
                        return (instance.exports.exchange32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.exchange64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.exchange64(address, value));
                }
            },
            notify: function (address, count) {
                return instance.exports.notify(address, count);
            },
            wait: function (address, value) {
                return instance.exports.wait(address, value);
            },
            waitTimeout: function (address, value, timeout) {
                return instance.exports.waitTimeout(address, value, BigInt(timeout >> 0));
            }
        });
    }
    catch (error) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.warn('atomics asm not support, cannot use asm atomics function', cheap__fileName__0, 284);
    }
}


/***/ }),

/***/ "./src/cheap/thread/atomics.ts":
/*!*************************************!*\
  !*** ./src/cheap/thread/atomics.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   and: () => (/* binding */ and),
/* harmony export */   compareExchange: () => (/* binding */ compareExchange),
/* harmony export */   exchange: () => (/* binding */ exchange),
/* harmony export */   load: () => (/* binding */ load),
/* harmony export */   notify: () => (/* binding */ notify),
/* harmony export */   or: () => (/* binding */ or),
/* harmony export */   override: () => (/* binding */ override),
/* harmony export */   store: () => (/* binding */ store),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   wait: () => (/* binding */ wait),
/* harmony export */   waitAsync: () => (/* binding */ waitAsync),
/* harmony export */   waitTimeout: () => (/* binding */ waitTimeout),
/* harmony export */   waitTimeoutAsync: () => (/* binding */ waitTimeoutAsync),
/* harmony export */   xor: () => (/* binding */ xor)
/* harmony export */ });
/**
 * 
 *
 * 
 *
 */
let add;
/**
 * 
 *
 * 
 *
 */
let sub;
/**
 * 
 *
 * 
 *
 */
let and;
/**
 * 
 *
 * 
 *
 */
let or;
/**
 * 
 *
 * 
 *
 */
let xor;
/**
 * 
 *
 * 
 *
 */
let store;
/**
 * 
 *
 * 
 *
 */
let load;
/**
 * 
 *
 * 
 *
 */
let compareExchange;
/**
 * 
 *
 * 
 *
 */
let exchange;
/**
 * 
 *
 *  0 
 *
 */
let notify;
/**
 * 
 *
 * 0 "ok"1 "not-equal"
 *
 */
let wait;
/**
 * 
 *
 * 0 "ok"1 "not-equal"  2 "time-out"
 *
 */
let waitTimeout;
/**
 * 
 *
 * 
 *
 * 0 "ok"1 "not-equal"
 *
 */
let waitAsync;
/**
 * 
 *
 * 
 *
 * 0 "ok"1 "not-equal"  2 "time-out"
 *
 */
let waitTimeoutAsync;
function override(funcs) {
    if (funcs.add) {
        add = funcs.add;
    }
    if (funcs.sub) {
        sub = funcs.sub;
    }
    if (funcs.and) {
        and = funcs.and;
    }
    if (funcs.or) {
        or = funcs.or;
    }
    if (funcs.xor) {
        xor = funcs.xor;
    }
    if (funcs.store) {
        store = funcs.store;
    }
    if (funcs.load) {
        load = funcs.load;
    }
    if (funcs.compareExchange) {
        compareExchange = funcs.compareExchange;
    }
    if (funcs.exchange) {
        exchange = funcs.exchange;
    }
    if (funcs.notify) {
        notify = funcs.notify;
    }
    if (funcs.wait) {
        wait = funcs.wait;
    }
    if (funcs.waitTimeout) {
        waitTimeout = funcs.waitTimeout;
    }
    if (funcs.waitAsync) {
        waitAsync = funcs.waitAsync;
    }
    if (funcs.waitTimeoutAsync) {
        waitTimeoutAsync = funcs.waitTimeoutAsync;
    }
}


/***/ }),

/***/ "./src/cheap/thread/atomicsImpl.ts":
/*!*****************************************!*\
  !*** ./src/cheap/thread/atomicsImpl.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var common_function_nextTick__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/function/nextTick */ "./src/common/function/nextTick.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");






let getAtomicsBuffer;
const useAtomics = _config__WEBPACK_IMPORTED_MODULE_3__.USE_THREADS || (!common_util_browser__WEBPACK_IMPORTED_MODULE_4__["default"].chrome && common_util_support__WEBPACK_IMPORTED_MODULE_5__["default"].atomics || common_util_browser__WEBPACK_IMPORTED_MODULE_4__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_4__["default"].majorVersion, '94', true));
/**
 * 
 *
 * 
 *
 */
function add(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.add(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] += value;
        return old;
    }
}
/**
 * 
 *
 * 
 *
 */
function sub(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.sub(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] -= value;
        return old;
    }
}
/**
 * 
 *
 * 
 *
 */
function and(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.and(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] &= value;
        return old;
    }
}
/**
 * 
 *
 * 
 *
 */
function or(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.or(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] |= value;
        return old;
    }
}
/**
 * 
 *
 * 
 *
 */
function xor(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.xor(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] ^= value;
        return old;
    }
}
/**
 * 
 *
 * 
 *
 */
function store(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.store(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] = value;
        return old;
    }
}
/**
 * 
 *
 * 
 *
 */
function load(address, type, shift) {
    if ( true && useAtomics) {
        return Atomics.load(getAtomicsBuffer(type), address >>> shift);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        return old;
    }
}
/**
 * 
 *
 * 
 *
 */
function compareExchange(address, expectedValue, replacementValue, type, shift) {
    if ( true && useAtomics) {
        return Atomics.compareExchange(getAtomicsBuffer(type), address >>> shift, expectedValue, replacementValue);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        if (old === expectedValue) {
            buffer[index] = replacementValue;
        }
        return old;
    }
}
/**
 * 
 *
 * 
 *
 */
function exchange(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.exchange(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] = value;
        return old;
    }
}
/**
 * 
 *
 * 
 *
 */
function notify(address, count) {
    if ( true && useAtomics) {
        return Atomics.notify(getAtomicsBuffer(16), address >>> 2, count);
    }
    else {
        return;
    }
}
/**
 * 
 *
 * 0 "ok"1 "not-equal"  2 "timed-out"
 *
 */
const waitMap = {
    'ok': 0,
    'not-equal': 1,
    'timed-out': 2
};
function wait(address, value) {
    return waitMap[Atomics.wait(getAtomicsBuffer(16), address >>> 2, value)];
}
/**
 * 
 *
 * 0 "ok"1 "not-equal"  2 "time-out"
 *
 */
function waitTimeout(address, value, timeout) {
    return waitMap[Atomics.wait(getAtomicsBuffer(16), address >>> 2, value, timeout)];
}
/**
 * 
 *
 * 0 "ok"1 "not-equal"  2 "timed-out"
 *
 */
async function waitAsync(address, value) {
    if (Atomics.waitAsync) {
        const result = Atomics.waitAsync(getAtomicsBuffer(16), address >>> 2, value);
        if (result.async) {
            return waitMap[await result.value];
        }
        return waitMap[result.value];
    }
    else {
        if (load(address) !== value) {
            return 1;
        }
        else {
            while (load(address) === value) {
                // 
                await new Promise((resolve) => {
                    (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_1__["default"])(() => {
                        resolve();
                    });
                });
            }
            return 0;
        }
    }
}
/**
 * 
 *
 * 0 "ok"1 "not-equal"  2 "time-out"
 *
 */
async function waitTimeoutAsync(address, value, timeout) {
    if (Atomics.waitAsync) {
        const result = Atomics.waitAsync(getAtomicsBuffer(16), address >>> 2, value, timeout);
        if (result.async) {
            return waitMap[await result.value];
        }
        return waitMap[result.value];
    }
    else {
        if (load(address) !== value) {
            return 1;
        }
        else {
            const now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_0__["default"])();
            while (load(address) === value && ((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_0__["default"])() - now < timeout)) {
                // 
                await new Promise((resolve) => {
                    (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_1__["default"])(() => {
                        resolve();
                    });
                });
            }
            return load(address) !== value ? 0 : 2;
        }
    }
}
function init(getAtomicsBuffer_) {
    getAtomicsBuffer = getAtomicsBuffer_;
    (0,_atomics__WEBPACK_IMPORTED_MODULE_2__.override)({
        add,
        sub,
        and,
        or,
        xor,
        store,
        load,
        compareExchange,
        exchange,
        notify,
        wait,
        waitTimeout,
        waitAsync,
        waitTimeoutAsync
    });
}


/***/ }),

/***/ "./src/cheap/thread/cond.ts":
/*!**********************************!*\
  !*** ./src/cheap/thread/cond.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cond: () => (/* binding */ Cond),
/* harmony export */   broadcast: () => (/* binding */ broadcast),
/* harmony export */   destroy: () => (/* binding */ destroy),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   signal: () => (/* binding */ signal),
/* harmony export */   timedWait: () => (/* binding */ timedWait),
/* harmony export */   wait: () => (/* binding */ wait)
/* harmony export */ });
/* unused harmony exports waitAsync, timedwaitAsync */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _mutex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");



/**
 *  https://github.com/mozilla-spidermonkey/js-lock-and-condition
 */


class Cond {
    atomic;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(Cond.prototype);
/**
 * 
 */
function init(cond, attr) {
    _atomics__WEBPACK_IMPORTED_MODULE_4__.store(cond, 0, 16, 2);
    return 0;
}
/**
 * 
 */
function destroy(cond) {
    _atomics__WEBPACK_IMPORTED_MODULE_4__.store(cond, 0, 16, 2);
    return 0;
}
/**
 * 
 *
 * @param cond
 */
function signal(cond) {
    _atomics__WEBPACK_IMPORTED_MODULE_4__.add(cond, 1, 16, 2);
    _atomics__WEBPACK_IMPORTED_MODULE_4__.notify(cond, 1);
    return 0;
}
/**
 * 
 *
 * @param cond
 */
function broadcast(cond) {
    _atomics__WEBPACK_IMPORTED_MODULE_4__.add(cond, 1, 16, 2);
    _atomics__WEBPACK_IMPORTED_MODULE_4__.notify(cond, 1073741824);
    return 0;
}
/**
 * 
 *
 * @param cond
 * @param mutex
 * @returns
 */
function wait(cond, mutex) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_4__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    _atomics__WEBPACK_IMPORTED_MODULE_4__.wait(cond, c);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.lock(mutex);
    return 0;
}
/**
 * 
 *
 * @param cond
 * @param mutex
 */
async function waitAsync(cond, mutex) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_4__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    await _atomics__WEBPACK_IMPORTED_MODULE_4__.waitAsync(cond, c);
    await _mutex__WEBPACK_IMPORTED_MODULE_3__.lockAsync(mutex);
    return 0;
}
/**
 * 
 *
 * @param cond
 * @param mutex
 * @param timeout 
 */
function timedWait(cond, mutex, timeout) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_4__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    let ret = _atomics__WEBPACK_IMPORTED_MODULE_4__.waitTimeout(cond, c, timeout);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.lock(mutex);
    return ret === 2 ? 110 : 0;
}
/**
 * 
 *
 * @param cond
 * @param mutex
 * @param timeout 
 */
async function timedwaitAsync(cond, mutex, timeout) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_4__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    let ret = await _atomics__WEBPACK_IMPORTED_MODULE_4__.waitTimeoutAsync(cond, c, timeout);
    await _mutex__WEBPACK_IMPORTED_MODULE_3__.lockAsync(mutex);
    return ret === 2 ? 110 : 0;
}


/***/ }),

/***/ "./src/cheap/thread/initClass.ts":
/*!***************************************!*\
  !*** ./src/cheap/thread/initClass.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_network_NodeIPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/NodeIPCPort */ "./src/common/network/NodeIPCPort.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");




let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF;
function init(run) {
    let ipc;
    let target;
    function initIPC(port) {
        ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](port);
        ipc.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.REQUEST, async (data) => {
            const method = data.method;
            const params = data.params;
            if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.func(target[method])) {
                try {
                    if (!target[method].transfer) {
                        target[method].transfer = [];
                    }
                    const result = await target[method](...params.params);
                    ipc.reply(data, result, null, target[method].transfer);
                    target[method].transfer.length = 0;
                }
                catch (error) {
                    ipc.reply(data, -2097152 /* CHeapError.REQUEST_ERROR */, {
                        message: error.message
                    });
                }
            }
        });
    }
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        switch (type) {
            case 'init':
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.CHeap.initThread && common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.CHeap.Config.USE_THREADS) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.CHeap.initThread(data).then(() => {
                        parentPort.postMessage({
                            type: 'ready'
                        });
                    });
                    return;
                }
                parentPort.postMessage({
                    type: 'ready'
                });
                break;
            case 'run':
                parentPort.postMessage({
                    type: 'running'
                });
                target = run(data.params);
                initIPC(data.port);
                break;
            case 'stop':
                if (ipc) {
                    ipc.destroy();
                }
                // @ts-ignore
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.__freeSmartPtr__) {
                    // @ts-ignore
                    common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.__freeSmartPtr__();
                }
                parentPort.postMessage({
                    type: 'stopped'
                });
                break;
            default:
                break;
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/thread/initFunction.ts":
/*!******************************************!*\
  !*** ./src/cheap/thread/initFunction.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");

let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF;
function init(run) {
    let retval;
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        switch (type) {
            case 'init':
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread && common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.Config.USE_THREADS) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread(data).then(() => {
                        parentPort.postMessage({
                            type: 'ready'
                        });
                    });
                    return;
                }
                parentPort.postMessage({
                    type: 'ready'
                });
                break;
            case 'run':
                retval = run(data.params);
                break;
            case 'stop':
                if (retval && retval.then) {
                    retval.then((res) => {
                        // @ts-ignore
                        if (common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.__freeSmartPtr__) {
                            // @ts-ignore
                            common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.__freeSmartPtr__();
                        }
                        parentPort.postMessage({
                            type: 'stopped',
                            data: res
                        });
                    });
                }
                else {
                    // @ts-ignore
                    if (common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.__freeSmartPtr__) {
                        // @ts-ignore
                        common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.__freeSmartPtr__();
                    }
                    parentPort.postMessage({
                        type: 'stopped',
                        data: retval
                    });
                }
                break;
            default:
                break;
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/thread/initModule.ts":
/*!****************************************!*\
  !*** ./src/cheap/thread/initModule.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_network_NodeIPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/NodeIPCPort */ "./src/common/network/NodeIPCPort.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");




let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF;
function init(module) {
    let ipc;
    function initIPC(port) {
        ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](port);
        ipc.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.REQUEST, async (data) => {
            const method = data.method;
            const params = data.params;
            if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.func(module[method])) {
                try {
                    if (!module[method].transfer) {
                        module[method].transfer = [];
                    }
                    const result = await module[method](...params.params);
                    ipc.reply(data, result, null, module[method].transfer);
                    module[method].transfer.length = 0;
                }
                catch (error) {
                    ipc.reply(data, -2097152 /* CHeapError.REQUEST_ERROR */, {
                        message: error.message
                    });
                }
            }
        });
    }
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        switch (type) {
            case 'init':
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.CHeap.initThread && common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.CHeap.Config.USE_THREADS) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.CHeap.initThread(data).then(() => {
                        parentPort.postMessage({
                            type: 'ready'
                        });
                    });
                    return;
                }
                parentPort.postMessage({
                    type: 'ready'
                });
                break;
            case 'run':
                parentPort.postMessage({
                    type: 'running'
                });
                initIPC(data.port);
                break;
            case 'stop':
                if (ipc) {
                    ipc.destroy();
                }
                // @ts-ignore
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.__freeSmartPtr__) {
                    // @ts-ignore
                    common_util_constant__WEBPACK_IMPORTED_MODULE_2__.SELF.__freeSmartPtr__();
                }
                parentPort.postMessage({
                    type: 'stopped'
                });
                break;
            default:
                break;
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/thread/mutex.ts":
/*!***********************************!*\
  !*** ./src/cheap/thread/mutex.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mutex: () => (/* binding */ Mutex),
/* harmony export */   destroy: () => (/* binding */ destroy),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   lock: () => (/* binding */ lock),
/* harmony export */   lockAsync: () => (/* binding */ lockAsync),
/* harmony export */   tryLock: () => (/* binding */ tryLock),
/* harmony export */   unlock: () => (/* binding */ unlock)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");





class Mutex {
    atomic;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(Mutex.prototype);
/**
 * 
 *
 * @param mutex
 * @returns
 */
function init(mutex) {
    _atomics__WEBPACK_IMPORTED_MODULE_3__.store(mutex, 0 /* STATUS.UNLOCK */, 16, 2);
    return 0;
}
/**
 * 
 *
 * @param mutex
 * @param spin 
 */
function lock(mutex, spin = false) {
    let status;
    //  UNLOCK LOCKED 
    if ((status = _atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 1 /* STATUS.LOCKED */, 16, 2)) !== 0 /* STATUS.UNLOCK */) {
        do {
            //  WAITED 
            if (status == 2 /* STATUS.WAITED */
                || _atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(mutex, 1 /* STATUS.LOCKED */, 2 /* STATUS.WAITED */, 16, 2) !== 0 /* STATUS.UNLOCK */) {
                //  wait cpu 
                if (!spin && (0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_4__["default"])()) {
                    _atomics__WEBPACK_IMPORTED_MODULE_3__.wait(mutex, 2 /* STATUS.WAITED */);
                }
            }
        } 
        // 
        while ((status = _atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 2 /* STATUS.WAITED */, 16, 2)) !== 0 /* STATUS.UNLOCK */);
    }
    return 0;
}
/**
 * 
 *
 * @param mutex
 */
function tryLock(mutex) {
    if (_atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 1 /* STATUS.LOCKED */, 16, 2) === 0 /* STATUS.UNLOCK */) {
        return 0;
    }
    // EBUSY
    return 16 /* POSIXError.EBUSY */;
}
/**
 * 
 *
 * @param mutex
 */
async function lockAsync(mutex) {
    let status;
    //  UNLOCK LOCKED 
    if ((status = _atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 1 /* STATUS.LOCKED */, 16, 2)) !== 0 /* STATUS.UNLOCK */) {
        do {
            //  WAITED 
            if (status == 2 /* STATUS.WAITED */
                || _atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(mutex, 1 /* STATUS.LOCKED */, 2 /* STATUS.WAITED */, 16, 2) !== 0 /* STATUS.UNLOCK */) {
                await _atomics__WEBPACK_IMPORTED_MODULE_3__.waitAsync(mutex, 2 /* STATUS.WAITED */);
            }
        } 
        // 
        while ((status = _atomics__WEBPACK_IMPORTED_MODULE_3__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 2 /* STATUS.WAITED */, 16, 2)) !== 0 /* STATUS.UNLOCK */);
    }
    return 0;
}
/**
 * 
 *
 * @param mutex
 */
function unlock(mutex) {
    let status = _atomics__WEBPACK_IMPORTED_MODULE_3__.sub(mutex, 1, 16, 2);
    //  LOCKED  WAITED
    if (status !== 1 /* STATUS.LOCKED */) {
        // 
        _atomics__WEBPACK_IMPORTED_MODULE_3__.store(mutex, 0 /* STATUS.UNLOCK */, 16, 2);
        //  wait 
        _atomics__WEBPACK_IMPORTED_MODULE_3__.notify(mutex, 1);
    }
    return 0;
}
/**
 * 
 *
 * @param mutex
 * @returns
 */
function destroy(mutex) {
    _atomics__WEBPACK_IMPORTED_MODULE_3__.store(mutex, 0 /* STATUS.UNLOCK */, 16, 2);
    return 0;
}


/***/ }),

/***/ "./src/cheap/thread/semaphore.ts":
/*!***************************************!*\
  !*** ./src/cheap/thread/semaphore.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   destroy: () => (/* binding */ destroy),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   post: () => (/* binding */ post),
/* harmony export */   timedWait: () => (/* binding */ timedWait),
/* harmony export */   tryWait: () => (/* binding */ tryWait),
/* harmony export */   wait: () => (/* binding */ wait)
/* harmony export */ });
/* unused harmony exports Sem, waitAsync, timedWaitAsync, set, get */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _mutex_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");








class Sem {
    atomic;
    mutex;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("mutex", { 0: _mutex_ts__WEBPACK_IMPORTED_MODULE_2__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(Sem.prototype);
/**
 * 
 *
 * @param sem
 * @param value 
 */
function init(sem, value) {
    _atomics__WEBPACK_IMPORTED_MODULE_6__.store(sem, (value >> 0), 16, 2);
    _mutex_ts__WEBPACK_IMPORTED_MODULE_2__.init(sem + 4);
    return 0;
}
function destroy(sem) {
    _mutex_ts__WEBPACK_IMPORTED_MODULE_2__.destroy(sem + 4);
    return 0;
}
/**
 * 
 *
 * @param sem
 */
function post(sem) {
    _atomics__WEBPACK_IMPORTED_MODULE_6__.add(sem, 1, 16, 2);
    _atomics__WEBPACK_IMPORTED_MODULE_6__.notify(sem, 1);
    return 0;
}
/**
 * 
 *
 * @param sem
 */
function wait(sem) {
    while (true) {
        _atomics__WEBPACK_IMPORTED_MODULE_6__.wait(sem, 0);
        let old = _atomics__WEBPACK_IMPORTED_MODULE_6__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 
            _atomics__WEBPACK_IMPORTED_MODULE_6__.add(sem, 1, 16, 2);
        }
        else {
            break;
        }
    }
    return 0;
}
/**
 * 
 *
 * @param sem
 */
function tryWait(sem) {
    _mutex_ts__WEBPACK_IMPORTED_MODULE_2__.lock(sem + 4);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[16](sem) > 0) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[16](sem, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[16](sem) - 1);
        _mutex_ts__WEBPACK_IMPORTED_MODULE_2__.unlock(sem + 4);
        return 0;
    }
    _mutex_ts__WEBPACK_IMPORTED_MODULE_2__.unlock(sem + 4);
    return 11;
}
/**
 * 
 *
 * @param sem
 * @param timeout 
 * @returns
 */
function timedWait(sem, timeout) {
    let ret = _atomics__WEBPACK_IMPORTED_MODULE_6__.waitTimeout(sem, 0, timeout);
    if (ret !== 2) {
        let old = _atomics__WEBPACK_IMPORTED_MODULE_6__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 
            _atomics__WEBPACK_IMPORTED_MODULE_6__.add(sem, 1, 16, 2);
            // ETIMEDOUT
            return 110;
        }
    }
    return 0;
}
/**
 * 
 *
 * @param sem
 */
async function waitAsync(sem) {
    while (true) {
        await _atomics__WEBPACK_IMPORTED_MODULE_6__.waitAsync(sem, 0);
        let old = _atomics__WEBPACK_IMPORTED_MODULE_6__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 
            _atomics__WEBPACK_IMPORTED_MODULE_6__.add(sem, 1, 16, 2);
        }
        else {
            break;
        }
    }
    return 0;
}
/**
 * 
 *
 * @param sem
 * @param timeout 
 */
async function timedWaitAsync(sem, timeout) {
    let ret = await _atomics__WEBPACK_IMPORTED_MODULE_6__.waitTimeoutAsync(sem, 0, timeout);
    if (ret !== 2) {
        let old = _atomics__WEBPACK_IMPORTED_MODULE_6__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 
            _atomics__WEBPACK_IMPORTED_MODULE_6__.add(sem, 1, 16, 2);
            // ETIMEDOUT
            return 110;
        }
    }
    return 0;
}
function set(sem, value) {
    _atomics__WEBPACK_IMPORTED_MODULE_6__.store(sem, value, 16, 2);
    return 0;
}
function get(sem) {
    return _atomics__WEBPACK_IMPORTED_MODULE_6__.load(sem, 16, 2);
}


/***/ }),

/***/ "./src/cheap/thread/thread.ts":
/*!************************************!*\
  !*** ./src/cheap/thread/thread.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   closeThread: () => (/* binding */ closeThread),
/* harmony export */   createThreadFromClass: () => (/* binding */ createThreadFromClass),
/* harmony export */   joinThread: () => (/* binding */ joinThread)
/* harmony export */ });
/* unused harmony exports createThreadFromFunction, createThreadFromModule */
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../heap */ "./src/cheap/heap.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_network_NodeIPCPort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/network/NodeIPCPort */ "./src/common/network/NodeIPCPort.ts");
/* harmony import */ var common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/function/sourceLoad */ "./src/common/function/sourceLoad.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var common_function_generateUUID__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/function/generateUUID */ "./src/common/function/generateUUID.ts");
/* harmony import */ var common_function_toString__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/function/toString */ "./src/common/function/toString.ts");










// @ts-ignore
let Worker = common_util_constant__WEBPACK_IMPORTED_MODULE_6__.SELF.Worker;
// @ts-ignore
let MessageChannel = common_util_constant__WEBPACK_IMPORTED_MODULE_6__.SELF.MessageChannel;
{
    // 
    __webpack_require__(/*! ./initClass */ "./src/cheap/thread/initClass.ts");
    __webpack_require__(/*! ./initFunction */ "./src/cheap/thread/initFunction.ts");
    __webpack_require__(/*! ./initModule */ "./src/cheap/thread/initModule.ts");
}
const initClass =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_3__["default"])(/*require.resolve*/(/*! ./initClass */ "./src/cheap/thread/initClass.ts"), {
    varName: 'init'
}) : 0;
const initFunction =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_3__["default"])(/*require.resolve*/(/*! ./initFunction */ "./src/cheap/thread/initFunction.ts"), {
    varName: 'init'
}) : 0;
const initModule =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_3__["default"])(/*require.resolve*/(/*! ./initModule */ "./src/cheap/thread/initModule.ts"), {
    varName: 'init'
}) : 0;
const symbolRevoke = Symbol('revoke');
const caches = new Map();
function getCacheKey(moduleId, type) {
    return `${moduleId}_${type}`;
}
function createThreadFromClass(entity, options = {}, moduleId) {
    let transferData = [];
    let runInWorker;
    {
        runInWorker = (...args) => {
            let worker;
            if (moduleId instanceof Worker) {
                worker = moduleId;
            }
            else {
                let workerUrl;
                const cacheKey = getCacheKey(moduleId, 'class');
                if (caches.has(cacheKey)) {
                    workerUrl = caches.get(cacheKey).url;
                    caches.get(cacheKey).refCount++;
                }
                else {
                    const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_3__["default"])(moduleId, {
                        varName: `__module_${entity.name}__`,
                        exportName: `__${entity.name}__`,
                        pointName: entity.name,
                        exportIsClass: true
                    });
                    const source = `
            self.CHEAP_DISABLE_THREAD = ${common_util_constant__WEBPACK_IMPORTED_MODULE_6__.SELF.CHEAP_DISABLE_THREAD}
            self.CHEAP_HEAP_INITIAL = ${common_util_constant__WEBPACK_IMPORTED_MODULE_6__.SELF.CHEAP_HEAP_INITIAL}
            self.CHEAP_HEAP_MAXIMUM = ${common_util_constant__WEBPACK_IMPORTED_MODULE_6__.SELF.CHEAP_HEAP_MAXIMUM}
            ${module}
            function run(params) {
              params.unshift(null)
              return new (Function.prototype.bind.apply(__module_${entity.name}__.__${entity.name}__, params))()
            }
            ${initClass}
            init.default(run);
          `;
                    {
                        const blob = new Blob([source], { type: 'text/javascript' });
                        workerUrl = URL.createObjectURL(blob);
                    }
                    caches.set(cacheKey, {
                        url: workerUrl,
                        refCount: 1
                    });
                }
                worker = new Worker(workerUrl);
            }
            const channel = new MessageChannel();
            return new Promise((resolve, reject) => {
                const stackPointer = _config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS ? cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT, options.stackSize
                    ? ((options.stackSize + _config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT) & ~_config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT)
                    : _config__WEBPACK_IMPORTED_MODULE_4__.STACK_SIZE) : 0;
                function running() {
                    const ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](channel.port1);
                    const obj = {
                        $worker: worker,
                        $ipc: ipc,
                        $channel: channel,
                        $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_8__["default"])(moduleId),
                        $stackPointer: stackPointer,
                        $type: 'class'
                    };
                    const { proxy, revoke } = Proxy.revocable(obj, {
                        get(target, propertyKey, receiver) {
                            if (target[propertyKey]) {
                                return obj[propertyKey];
                            }
                            if (propertyKey in entity.prototype && typeof entity.prototype[propertyKey] === 'function') {
                                const call = async function (...args) {
                                    return ipc.request(propertyKey, {
                                        params: args
                                    });
                                };
                                call.transfer = function (...transfer) {
                                    return {
                                        invoke: async function (...args) {
                                            return ipc.request(propertyKey, {
                                                params: args
                                            }, transfer);
                                        }
                                    };
                                };
                                target[propertyKey] = call;
                            }
                            return target[propertyKey];
                        }
                    });
                    obj[symbolRevoke] = revoke;
                    resolve(proxy);
                }
                const handler = (message) => {
                    const origin =  false ? 0 : message.data;
                    const type = origin.type;
                    const data = origin.data;
                    switch (type) {
                        case 'ready':
                            worker.postMessage({
                                type: 'run',
                                data: {
                                    port: channel.port2,
                                    params: args
                                }
                            }, [channel.port2, ...transferData]);
                            break;
                        case 'running':
                            running();
                            break;
                        default:
                            break;
                    }
                };
                {
                    worker.onmessage = handler;
                }
                worker.onmessage = handler;
                worker.postMessage({
                    type: 'init',
                    data: {
                        memory: _config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS ? cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory : null,
                        name: options.name || entity.name,
                        stackPointer,
                        stackSize: options.stackSize ?? _config__WEBPACK_IMPORTED_MODULE_4__.STACK_SIZE
                    }
                });
            });
        };
    }
    function runInMain(...args) {
        const worker = new entity(...args);
        return new Promise((resolve) => {
            const obj = {
                $worker: null,
                $ipc: null,
                $channel: null,
                $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_8__["default"])(moduleId),
                $stackPointer: 0,
                $instance: worker,
                $type: 'class'
            };
            const { proxy, revoke } = Proxy.revocable(obj, {
                get(target, propertyKey, receiver) {
                    if (target[propertyKey]) {
                        return obj[propertyKey];
                    }
                    if (propertyKey in entity.prototype && typeof entity.prototype[propertyKey] === 'function') {
                        const call = function (...args) {
                            return worker[propertyKey](...args);
                        };
                        call.transfer = function (...transfer) {
                            return {
                                invoke: function (...args) {
                                    return worker[propertyKey](...args);
                                }
                            };
                        };
                        target[propertyKey] = call;
                    }
                    return target[propertyKey];
                }
            });
            obj[symbolRevoke] = revoke;
            resolve(proxy);
        });
    }
    function transfer(...transfer) {
        transferData = transfer;
        return {
            run:  true && ((_config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS || options.dispatchToWorker) && !options.disableWorker) ? runInWorker : runInMain
        };
    }
    return {
        run:  true && ((_config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS || options.dispatchToWorker) && !options.disableWorker) ? runInWorker : runInMain,
        transfer
    };
}
function createThreadFromFunction(entity, options = {}, moduleId) {
    let transferData = [];
    let runInWorker;
    {
        runInWorker = (...args) => {
            let worker;
            if (moduleId instanceof Worker) {
                worker = moduleId;
            }
            else {
                let workerUrl;
                const cacheKey = getCacheKey(moduleId, 'function');
                if (caches.has(cacheKey)) {
                    workerUrl = caches.get(cacheKey).url;
                    caches.get(cacheKey).refCount++;
                }
                else {
                    const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_3__["default"])(moduleId, {
                        varName: `__module_${entity.name}__`,
                        exportName: `__${entity.name}__`,
                        pointName: entity.name
                    });
                    const source = `
            self.CHEAP_DISABLE_THREAD = ${common_util_constant__WEBPACK_IMPORTED_MODULE_6__.SELF.CHEAP_DISABLE_THREAD}
            self.CHEAP_HEAP_INITIAL = ${common_util_constant__WEBPACK_IMPORTED_MODULE_6__.SELF.CHEAP_HEAP_INITIAL}
            self.CHEAP_HEAP_MAXIMUM = ${common_util_constant__WEBPACK_IMPORTED_MODULE_6__.SELF.CHEAP_HEAP_MAXIMUM}
            ${module}
            function run(params) {
              return __module_${entity.name}__.__${entity.name}__.apply(${ false ? 0 : 'self'}, params)
            }
            ${initFunction}
            init.default(run);
          `;
                    {
                        const blob = new Blob([source], { type: 'text/javascript' });
                        workerUrl = URL.createObjectURL(blob);
                    }
                    caches.set(cacheKey, {
                        url: workerUrl,
                        refCount: 1
                    });
                }
                worker = new Worker(workerUrl);
            }
            return new Promise((resolve, reject) => {
                const stackPointer = _config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS ? cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT, options.stackSize
                    ? ((options.stackSize + _config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT) & ~_config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT)
                    : _config__WEBPACK_IMPORTED_MODULE_4__.STACK_SIZE) : 0;
                function running() {
                    const obj = {
                        $worker: worker,
                        $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_8__["default"])(moduleId),
                        $stackPointer: stackPointer,
                        $type: 'function'
                    };
                    resolve(obj);
                }
                const handler = (message) => {
                    const origin =  false ? 0 : message.data;
                    const type = origin.type;
                    const data = origin.data;
                    switch (type) {
                        case 'ready':
                            worker.postMessage({
                                type: 'run',
                                data: {
                                    params: args
                                }
                            }, transferData);
                            running();
                            break;
                        default:
                            break;
                    }
                };
                {
                    worker.onmessage = handler;
                }
                worker.onmessage = handler;
                worker.postMessage({
                    type: 'init',
                    data: {
                        memory: _config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS ? cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory : null,
                        name: options.name || entity.name,
                        stackPointer,
                        stackSize: options.stackSize ?? _config__WEBPACK_IMPORTED_MODULE_4__.STACK_SIZE
                    }
                });
            });
        };
    }
    function runInMain(...args) {
        return new Promise((resolve, reject) => {
            const obj = {
                $worker: null,
                $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_8__["default"])(moduleId),
                $stackPointer: null,
                $type: 'function'
            };
            resolve(obj);
            obj.$retval = new Promise((resolve) => {
                resolve(entity(...args));
            });
        });
    }
    function transfer(...transfer) {
        transferData = transfer;
        return {
            run:  true && ((_config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS || options.dispatchToWorker) && !options.disableWorker) ? runInWorker : runInMain
        };
    }
    return {
        run:  true && ((_config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS || options.dispatchToWorker) && !options.disableWorker) ? runInWorker : runInMain,
        transfer
    };
}
function createThreadFromModule(entity, options = {}, moduleId) {
    let runInWorker;
    {
        runInWorker = () => {
            let worker;
            let moduleName = `__module_${moduleId}__`.replace(/\.|\//g, '_');
            if (moduleId instanceof Worker) {
                worker = moduleId;
            }
            else {
                let workerUrl;
                const cacheKey = getCacheKey(moduleId, 'module');
                if (caches.has(cacheKey)) {
                    workerUrl = caches.get(cacheKey).url;
                    caches.get(cacheKey).refCount++;
                }
                else {
                    const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_3__["default"])(moduleId, {
                        varName: moduleName
                    });
                    const source = `
            self.CHEAP_DISABLE_THREAD = ${common_util_constant__WEBPACK_IMPORTED_MODULE_6__.SELF.CHEAP_DISABLE_THREAD}
            self.CHEAP_HEAP_INITIAL = ${common_util_constant__WEBPACK_IMPORTED_MODULE_6__.SELF.CHEAP_HEAP_INITIAL}
            self.CHEAP_HEAP_MAXIMUM = ${common_util_constant__WEBPACK_IMPORTED_MODULE_6__.SELF.CHEAP_HEAP_MAXIMUM}
            ${module}
            ${initModule}
            init.default(${moduleName});
          `;
                    {
                        const blob = new Blob([source], { type: 'text/javascript' });
                        workerUrl = URL.createObjectURL(blob);
                    }
                    caches.set(cacheKey, {
                        url: workerUrl,
                        refCount: 1
                    });
                }
                worker = new Worker(workerUrl);
            }
            const channel = new MessageChannel();
            return new Promise((resolve, reject) => {
                const stackPointer = _config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS ? cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT, options.stackSize
                    ? ((options.stackSize + _config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT) & ~_config__WEBPACK_IMPORTED_MODULE_4__.STACK_ALIGNMENT)
                    : _config__WEBPACK_IMPORTED_MODULE_4__.STACK_SIZE) : 0;
                function running() {
                    const ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](channel.port1);
                    const obj = {
                        $worker: worker,
                        $ipc: ipc,
                        $channel: channel,
                        $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_8__["default"])(moduleId),
                        $stackPointer: stackPointer,
                        $type: 'module'
                    };
                    const { proxy, revoke } = Proxy.revocable(obj, {
                        get(target, propertyKey, receiver) {
                            if (target[propertyKey]) {
                                return obj[propertyKey];
                            }
                            if (propertyKey in entity && typeof entity[propertyKey] === 'function') {
                                const call = async function (...args) {
                                    return ipc.request(propertyKey, {
                                        params: args
                                    });
                                };
                                call.transfer = function (...transfer) {
                                    return {
                                        invoke: async function (...args) {
                                            return ipc.request(propertyKey, {
                                                params: args
                                            }, transfer);
                                        }
                                    };
                                };
                                target[propertyKey] = call;
                            }
                            return target[propertyKey];
                        }
                    });
                    obj[symbolRevoke] = revoke;
                    resolve(proxy);
                }
                const handler = (message) => {
                    const origin =  false ? 0 : message.data;
                    const type = origin.type;
                    const data = origin.data;
                    switch (type) {
                        case 'ready':
                            worker.postMessage({
                                type: 'run',
                                data: {
                                    port: channel.port2
                                }
                            }, [channel.port2]);
                            break;
                        case 'running':
                            running();
                            break;
                        default:
                            break;
                    }
                };
                {
                    worker.onmessage = handler;
                }
                worker.onmessage = handler;
                worker.postMessage({
                    type: 'init',
                    data: {
                        memory: _config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS ? cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory : null,
                        name: options.name || moduleName,
                        stackPointer,
                        stackSize: options.stackSize ?? _config__WEBPACK_IMPORTED_MODULE_4__.STACK_SIZE
                    }
                });
            });
        };
    }
    function runInMain() {
        return new Promise((resolve, reject) => {
            const obj = {
                $worker: null,
                $ipc: null,
                $channel: null,
                $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_8__["default"])(moduleId),
                $stackPointer: 0,
                $instance: entity,
                $type: 'module'
            };
            const { proxy, revoke } = Proxy.revocable(obj, {
                get(target, propertyKey, receiver) {
                    if (target[propertyKey]) {
                        return obj[propertyKey];
                    }
                    if (propertyKey in entity && typeof entity[propertyKey] === 'function') {
                        const call = function (...args) {
                            return entity[propertyKey](...args);
                        };
                        call.transfer = function (...transfer) {
                            return {
                                invoke: function (...args) {
                                    return entity[propertyKey](...args);
                                }
                            };
                        };
                        target[propertyKey] = call;
                    }
                    return target[propertyKey];
                }
            });
            obj[symbolRevoke] = revoke;
            resolve(proxy);
        });
    }
    return {
        run:  true && ((_config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS || options.dispatchToWorker) && !options.disableWorker) ? runInWorker : runInMain,
    };
}
function closeThread(thread) {
    if (thread.$worker) {
        thread.$worker.terminate();
        thread.$worker = null;
    }
    if (thread.$moduleId) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.string(thread.$moduleId)) {
            const cacheKey = getCacheKey(thread.$moduleId, thread.$type);
            if (caches.has(cacheKey)) {
                caches.get(cacheKey).refCount--;
                if (caches.get(cacheKey).refCount === 0) {
                    {
                        URL.revokeObjectURL(caches.get(cacheKey).url);
                    }
                    caches.delete(cacheKey);
                }
            }
        }
        thread.$moduleId = null;
    }
    if (thread.$ipc) {
        thread.$ipc.destroy();
        thread.$ipc = null;
    }
    if (thread.$stackPointer) {
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(thread.$stackPointer);
        thread.$stackPointer = 0;
    }
    thread.$channel = null;
    thread.$instance = null;
    if (thread[symbolRevoke]) {
        const revoke = thread[symbolRevoke];
        thread[symbolRevoke] = null;
        revoke();
    }
}
async function joinThread(thread) {
    if (thread.$worker) {
        return new Promise((resolve) => {
            function handler(message) {
                const origin =  false ? 0 : message.data;
                const type = origin.type;
                const data = origin.data;
                switch (type) {
                    case 'stopped':
                        closeThread(thread);
                        resolve(data);
                        break;
                    default:
                        break;
                }
            }
            {
                thread.$worker.onmessage = handler;
            }
            thread.$worker.postMessage({
                type: 'stop'
            });
        });
    }
    else if (thread.$retval) {
        return thread.$retval;
    }
}


/***/ }),

/***/ "./src/cheap/typedef.ts":
/*!******************************!*\
  !*** ./src/cheap/typedef.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CTypeEnum2Bytes: () => (/* binding */ CTypeEnum2Bytes),
/* harmony export */   CTypeEnumPointerShiftMap: () => (/* binding */ CTypeEnumPointerShiftMap)
/* harmony export */ });
const CTypeEnum2Bytes = {
    [2 /* CTypeEnum.uint8 */]: 1,
    [3 /* CTypeEnum.atomic_uint8 */]: 1,
    [4 /* CTypeEnum.char */]: 1,
    [5 /* CTypeEnum.atomic_char */]: 1,
    [6 /* CTypeEnum.uint16 */]: 2,
    [7 /* CTypeEnum.atomic_uint16 */]: 2,
    [8 /* CTypeEnum.uint32 */]: 4,
    [9 /* CTypeEnum.atomic_uint32 */]: 4,
    [10 /* CTypeEnum.uint64 */]: 8,
    [11 /* CTypeEnum.int8 */]: 1,
    [12 /* CTypeEnum.atomic_int8 */]: 1,
    [13 /* CTypeEnum.int16 */]: 2,
    [14 /* CTypeEnum.atomic_int16 */]: 2,
    [15 /* CTypeEnum.int32 */]: 4,
    [16 /* CTypeEnum.atomic_int32 */]: 4,
    [17 /* CTypeEnum.int64 */]: 8,
    [18 /* CTypeEnum.float */]: 4,
    [19 /* CTypeEnum.double */]: 8,
    [20 /* CTypeEnum.pointer */]: 4,
    [0 /* CTypeEnum.null */]: 4,
    [1 /* CTypeEnum.void */]: 4,
    [22 /* CTypeEnum.atomic_uint64 */]: 8,
    [21 /* CTypeEnum.atomic_int64 */]: 8,
    [23 /* CTypeEnum.bool */]: 1,
    [24 /* CTypeEnum.atomic_bool */]: 1
};
const CTypeEnumPointerShiftMap = {
    [2 /* CTypeEnum.uint8 */]: 0,
    [3 /* CTypeEnum.atomic_uint8 */]: 0,
    [4 /* CTypeEnum.char */]: 0,
    [5 /* CTypeEnum.atomic_char */]: 0,
    [6 /* CTypeEnum.uint16 */]: 1,
    [7 /* CTypeEnum.atomic_uint16 */]: 1,
    [8 /* CTypeEnum.uint32 */]: 2,
    [9 /* CTypeEnum.atomic_uint32 */]: 2,
    [10 /* CTypeEnum.uint64 */]: 4,
    [11 /* CTypeEnum.int8 */]: 0,
    [12 /* CTypeEnum.atomic_int8 */]: 0,
    [13 /* CTypeEnum.int16 */]: 1,
    [14 /* CTypeEnum.atomic_int16 */]: 1,
    [15 /* CTypeEnum.int32 */]: 2,
    [16 /* CTypeEnum.atomic_int32 */]: 2,
    [17 /* CTypeEnum.int64 */]: 4,
    [18 /* CTypeEnum.float */]: 2,
    [19 /* CTypeEnum.double */]: 4,
    [20 /* CTypeEnum.pointer */]: 2,
    [1 /* CTypeEnum.void */]: 2,
    [0 /* CTypeEnum.null */]: 2,
    [22 /* CTypeEnum.atomic_uint64 */]: 4,
    [21 /* CTypeEnum.atomic_int64 */]: 4,
    [23 /* CTypeEnum.bool */]: 0,
    [24 /* CTypeEnum.atomic_bool */]: 0
};


/***/ }),

/***/ "./src/cheap/webassembly/ThreadPool.ts":
/*!*********************************************!*\
  !*** ./src/cheap/webassembly/ThreadPool.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ThreadPool)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _thread_cond_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../thread/cond */ "./src/cheap/thread/cond.ts");
/* harmony import */ var _thread__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./thread */ "./src/cheap/webassembly/thread.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");
/* harmony import */ var _std_memory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _thread_atomics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../thread/atomics */ "./src/cheap/thread/atomics.ts");













class ThreadPool {
    count;
    url;
    childThreads;
    constructor(count, url) {
        this.count = count;
        this.url = url;
        this.childThreads = [];
    }
    async createTheadPoolEntry(options) {
        return new Promise((resolve, reject) => {
            const worker = new Worker(this.url);
            const stackPointer = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_7__.STACK_ALIGNMENT, _config__WEBPACK_IMPORTED_MODULE_7__.STACK_SIZE);
            const threadDescriptor = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(8);
            (0,_std_memory__WEBPACK_IMPORTED_MODULE_8__.memset)(threadDescriptor, 0, 8);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](threadDescriptor + 4, 0 /* PthreadStatus.STOP */);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](threadDescriptor, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](threadDescriptor) | 2 /* PthreadFlags.POOL */);
            const id = (0,cheap_heap__WEBPACK_IMPORTED_MODULE_0__.allocThreadId)();
            worker.onmessage = (message) => {
                const origin = message.data;
                const type = origin.type;
                switch (type) {
                    case 'ready':
                        const wait = stackPointer;
                        (0,_std_memory__WEBPACK_IMPORTED_MODULE_8__.memset)(wait, 0, 20);
                        _thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.init(wait + 16);
                        _thread_cond_ts__WEBPACK_IMPORTED_MODULE_5__.init(wait + 12);
                        worker.postMessage({
                            type: 'wait'
                        });
                        resolve({
                            id,
                            thread: {
                                thread: 0,
                                worker,
                                stackPointer,
                                threadDescriptor
                            },
                            threadWait: wait
                        });
                        break;
                }
            };
            worker.postMessage({
                type: 'ready',
                data: {
                    cheap: {
                        memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory,
                        stackPointer,
                        stackSize: _config__WEBPACK_IMPORTED_MODULE_7__.STACK_SIZE,
                        id
                    },
                    runner: {
                        resource: {
                            tableSize: options.tableSize,
                            module: options.module,
                            initFuncs: options.initFuncs
                        },
                        options: {
                            memoryBase: options.memoryBase,
                            tableBase: options.tableBase,
                            threadDescriptor,
                            childImports: options.childImports
                        },
                        imports: options.childImports
                    }
                }
            });
        });
    }
    async ready(options) {
        this.childThreads = await Promise.all(new Array(this.count).fill(0).map(() => {
            return this.createTheadPoolEntry(options);
        }));
    }
    hasFree() {
        for (let i = 0; i < this.childThreads.length; i++) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](this.childThreads[i].thread.threadDescriptor + 4) === 0 /* PthreadStatus.STOP */) {
                return true;
            }
        }
        return false;
    }
    isPoolThread(thread) {
        for (let i = 0; i < this.childThreads.length; i++) {
            if (this.childThreads[i].thread.thread === thread) {
                return true;
            }
        }
        return false;
    }
    createThread(thread, attr, func, args) {
        for (let i = 0; i < this.childThreads.length; i++) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](this.childThreads[i].thread.threadDescriptor + 4) === 0 /* PthreadStatus.STOP */) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](this.childThreads[i].thread.threadDescriptor + 4, 1 /* PthreadStatus.RUN */);
                this.childThreads[i].thread.thread = thread;
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](thread + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](thread + 8) | 2 /* PthreadFlags.POOL */);
                _thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.lock(this.childThreads[i].threadWait + 16);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](this.childThreads[i].threadWait, thread);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](this.childThreads[i].threadWait + 4, func);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](this.childThreads[i].threadWait + 8, args);
                _thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.unlock(this.childThreads[i].threadWait + 16);
                _thread_cond_ts__WEBPACK_IMPORTED_MODULE_5__.signal(this.childThreads[i].threadWait + 12);
                return;
            }
        }
    }
    joinThread(thread, retval) {
        let entry;
        for (let i = 0; i < this.childThreads.length; i++) {
            if (this.childThreads[i].thread.thread === thread) {
                entry = this.childThreads[i];
                break;
            }
        }
        if (!entry) {
            return -1;
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](thread + 8) & 1 /* PthreadFlags.DETACH */) {
            return 0;
        }
        // 
        _thread_atomics__WEBPACK_IMPORTED_MODULE_9__.wait(thread + 12, 1 /* PthreadStatus.RUN */);
        if (retval !== 0) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](retval, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](thread + 4));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](entry.thread.threadDescriptor + 4, 0 /* PthreadStatus.STOP */);
        return 0;
    }
    detachThread(thread) {
        let entry;
        for (let i = 0; i < this.childThreads.length; i++) {
            if (this.childThreads[i].thread.thread === thread) {
                entry = this.childThreads[i];
                break;
            }
        }
        if (!entry) {
            return -1;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](entry.thread.threadDescriptor, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](entry.thread.threadDescriptor) | 1 /* PthreadFlags.DETACH */);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](thread + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](thread + 8) | 1 /* PthreadFlags.DETACH */);
        return 0;
    }
    destroy() {
        for (let i = 0; i < this.childThreads.length; i++) {
            // 
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.childThreads[i].thread.stackPointer);
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.childThreads[i].thread.threadDescriptor);
            this.childThreads[i].thread.worker.terminate();
        }
        this.childThreads = [];
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/WebAssemblyRunner.ts":
/*!****************************************************!*\
  !*** ./src/cheap/webassembly/WebAssemblyRunner.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebAssemblyRunner)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../heap */ "./src/cheap/heap.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _std_memory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _runtime_clib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./runtime/clib */ "./src/cheap/webassembly/runtime/clib.ts");
/* harmony import */ var _runtime_atomic__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./runtime/atomic */ "./src/cheap/webassembly/runtime/atomic.ts");
/* harmony import */ var _runtime_pthread__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./runtime/pthread */ "./src/cheap/webassembly/runtime/pthread.ts");
/* harmony import */ var _runtime_semaphore__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./runtime/semaphore */ "./src/cheap/webassembly/runtime/semaphore.ts");
/* harmony import */ var common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/function/sourceLoad */ "./src/common/function/sourceLoad.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");
/* harmony import */ var _thread_atomics__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../thread/asm/atomics */ "./src/cheap/thread/asm/atomics.ts");
/* harmony import */ var _runtime_asm_libc__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./runtime/asm/libc */ "./src/cheap/webassembly/runtime/asm/libc.ts");
/* harmony import */ var _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./runtime/asm/thread */ "./src/cheap/webassembly/runtime/asm/thread.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var _thread__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./thread */ "./src/cheap/webassembly/thread.ts");
/* harmony import */ var _ThreadPool__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./ThreadPool */ "./src/cheap/webassembly/ThreadPool.ts");
/* harmony import */ var _thread_cond__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../thread/cond */ "./src/cheap/thread/cond.ts");
/* harmony import */ var _thread_mutex__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
var cheap__fileName__3 = "src\\cheap\\webassembly\\WebAssemblyRunner.ts";



/* eslint-disable camelcase */























{
    // 
    __webpack_require__(/*! ./runThread */ "./src/cheap/webassembly/runThread.ts");
}
const runThread =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_12__["default"])(/*require.resolve*/(/*! ./runThread */ "./src/cheap/webassembly/runThread.ts"), {
    varName: 'init'
}) : 0;
function emptyFunction() { }
let atomicAsmOverride = false;
class WebAssemblyRunner {
    static getTable() {
        return cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Table;
    }
    static mutexLock(mux) {
        _thread_mutex__WEBPACK_IMPORTED_MODULE_22__.lock(mux);
    }
    static mutexUnlock(mux) {
        _thread_mutex__WEBPACK_IMPORTED_MODULE_22__.unlock(mux);
    }
    static condWait(cnd, mux) {
        _thread_cond__WEBPACK_IMPORTED_MODULE_21__.wait(cnd, mux);
    }
    static readPointer(p) {
        return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](p);
    }
    static writePointer(p, v) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](p, v);
    }
    resource;
    /**
     * WebAssembly runtime 
     */
    instance;
    /**
     * 
     */
    options;
    builtinMalloc;
    memoryBase;
    tableBase;
    childImports;
    childUrl;
    childBlob;
    childThreads;
    imports;
    childReadyPromises;
    threadPool;
    initCalling;
    promisingMap;
    constructor(resource, options = {}) {
        this.resource = resource;
        this.builtinMalloc = [];
        this.initCalling = false;
        this.childThreads = new Map();
        this.childReadyPromises = [];
        this.promisingMap = new Map();
        if (common_util_is__WEBPACK_IMPORTED_MODULE_6__.string(options.childImports)) {
            this.childImports = options.childImports;
        }
        else if (common_util_is__WEBPACK_IMPORTED_MODULE_6__.object(options.childImports) && options.childImports instanceof Blob) {
            this.childImports = URL.createObjectURL(options.childImports);
        }
        this.memoryBase = resource.dataSize ? cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc(resource.dataSize) : 0;
        //  tableBase 
        if (options.thread && options.tableBase) {
            if (cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Table.getPointer() !== options.tableBase) {
                cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Table.alloc(options.tableBase - cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Table.getPointer());
            }
        }
        this.tableBase = resource.tableSize ? cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Table.alloc(resource.tableSize) : 0;
        this.options = options;
        this.imports = {
            env: {
                memory: cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Memory,
                __stack_pointer: cheap_heap__WEBPACK_IMPORTED_MODULE_2__.StackPointer,
                __indirect_function_table: cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Table.table,
                clock_time_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.clock_time_get,
                clock_res_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.clock_res_get,
                random_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.random_get,
                abort: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.abort,
                proc_exit: function (exitCode) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`wasm module exit, code: ${exitCode}`, cheap__fileName__3, 156);
                },
                __syscall_renameat: emptyFunction,
                __syscall_unlinkat: emptyFunction,
                environ_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.environ_get,
                environ_sizes_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.environ_sizes_get,
                fd_close: emptyFunction,
                fd_fdstat_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.fd_fdstat_get,
                fd_read: emptyFunction,
                fd_seek: emptyFunction,
                fd_write: _runtime_clib__WEBPACK_IMPORTED_MODULE_8__.fd_write,
                emscripten_builtin_malloc: (size) => {
                    const p = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc(size);
                    this.builtinMalloc.push(p);
                    return p;
                },
                emscripten_builtin_free: (pointer) => {
                    cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(pointer);
                },
                emscripten_builtin_memalign: (memptr, alignment, size) => {
                    const address = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.alignedAlloc(alignment, size);
                    if (address !== 0) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](memptr, address);
                        this.builtinMalloc.push(address);
                        return 0;
                    }
                    return -1;
                },
                emscripten_memcpy_big: function (dest, src, num) {
                    (0,_std_memory__WEBPACK_IMPORTED_MODULE_7__.memcpy)(dest, src, num);
                },
                __libc_malloc: function (size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc(size);
                },
                __libc_free: (pointer) => {
                    cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(pointer);
                },
                malloc: (size) => {
                    if (this.initCalling === true) {
                        const p = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc(size);
                        this.builtinMalloc.push(p);
                        return p;
                    }
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc(size);
                },
                calloc: function (num, size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.calloc(num, size);
                },
                realloc: function (pointer, size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.realloc(pointer, size);
                },
                aligned_alloc(alignment, size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.alignedAlloc(alignment, size);
                },
                free: function (pointer) {
                    cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(pointer);
                },
                posix_memalign: function (memptr, alignment, size) {
                    const address = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.alignedAlloc(alignment, size);
                    if (address !== 0) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](memptr, address);
                        return 0;
                    }
                    return -1;
                },
                memalign: function (alignment, size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.alignedAlloc(alignment, size);
                }
            },
            'GOT.func': {
                malloc: new WebAssembly.Global({ mutable: true, value: 'i32' }, 2 /* BuiltinTableSlot.MALLOC */),
                calloc: new WebAssembly.Global({ mutable: true, value: 'i32' }, 3 /* BuiltinTableSlot.CALLOC */),
                realloc: new WebAssembly.Global({ mutable: true, value: 'i32' }, 4 /* BuiltinTableSlot.REALLOC */),
                aligned_alloc: new WebAssembly.Global({ mutable: true, value: 'i32' }, 5 /* BuiltinTableSlot.ALIGNED_ALLOC */),
                free: new WebAssembly.Global({ mutable: true, value: 'i32' }, 1 /* BuiltinTableSlot.FREE */)
            }
        };
        {
            const createPthread = (thread, attr, func, args) => {
                if (this.threadPool && this.threadPool.hasFree()) {
                    this.threadPool.createThread(thread, attr, func, args);
                    return 0;
                }
                if (!this.childUrl) {
                    this.createChildUrl();
                }
                const worker = new Worker(this.childUrl);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](thread, (0,cheap_heap__WEBPACK_IMPORTED_MODULE_2__.allocThreadId)());
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[16](thread + 12, 1 /* PthreadStatus.RUN */);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](thread + 8, 0);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](thread + 4, 0);
                const stackPointer = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_13__.STACK_ALIGNMENT, _config__WEBPACK_IMPORTED_MODULE_13__.STACK_SIZE);
                const threadDescriptor = cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.malloc(8);
                (0,_std_memory__WEBPACK_IMPORTED_MODULE_7__.memset)(threadDescriptor, 0, 8);
                this.childThreads.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread), {
                    thread,
                    worker,
                    stackPointer,
                    threadDescriptor
                });
                let resolve;
                const promise = new Promise((r) => {
                    resolve = r;
                });
                if (!common_util_support__WEBPACK_IMPORTED_MODULE_23__["default"].jspi) {
                    this.childReadyPromises.push(promise);
                }
                worker.onmessage = (message) => {
                    const origin = message.data;
                    const type = origin.type;
                    const data = origin.data;
                    switch (type) {
                        case 'run':
                            resolve(0);
                            break;
                    }
                };
                /**
                 * postMessage 
                 * 
                 *  childReadyPromises  Promise  resolve 
                 */
                worker.postMessage({
                    type: 'run',
                    data: {
                        cheap: {
                            memory: cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Memory,
                            stackPointer,
                            stackSize: _config__WEBPACK_IMPORTED_MODULE_13__.STACK_SIZE,
                            id: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread)
                        },
                        runner: {
                            resource: {
                                tableSize: this.resource.tableSize,
                                module: this.resource.threadModule.module,
                                initFuncs: this.resource.threadModule.initFuncs
                            },
                            options: {
                                memoryBase: this.options.memoryBase || this.memoryBase,
                                tableBase: this.tableBase,
                                thread,
                                threadDescriptor,
                                childImports: this.childImports
                            },
                            func,
                            args,
                            imports: this.childImports,
                            thread
                        }
                    }
                });
                return common_util_support__WEBPACK_IMPORTED_MODULE_23__["default"].jspi ? promise : 0;
            };
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, {
                // @ts-ignore
                wasm_pthread_create: common_util_support__WEBPACK_IMPORTED_MODULE_23__["default"].jspi ? new WebAssembly.Suspending(createPthread) : createPthread,
                wasm_pthread_join2: (thread, retval) => {
                    if (this.threadPool && this.threadPool.isPoolThread(thread)) {
                        this.threadPool.joinThread(thread, retval);
                        return 0;
                    }
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread + 8) & 1 /* PthreadFlags.DETACH */) {
                        this.childThreads.delete(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread));
                        return 0;
                    }
                    // 
                    _thread_atomics__WEBPACK_IMPORTED_MODULE_14__.wait(thread + 12, 1 /* PthreadStatus.RUN */);
                    if (retval !== 0) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](retval, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](thread + 4));
                    }
                    const child = this.childThreads.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread));
                    // 
                    cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(child.stackPointer);
                    cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(child.threadDescriptor);
                    child.worker.terminate();
                    this.childThreads.delete(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread));
                    (0,_std_memory__WEBPACK_IMPORTED_MODULE_7__.memset)(thread, 0, 16);
                    return 0;
                },
                wasm_pthread_detach2: (thread) => {
                    if (this.threadPool && this.threadPool.isPoolThread(thread)) {
                        this.threadPool.detachThread(thread);
                        return 0;
                    }
                    const child = this.childThreads.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread));
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](child.threadDescriptor, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](child.threadDescriptor) | 1 /* PthreadFlags.DETACH */);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](thread + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread + 8) | 1 /* PthreadFlags.DETACH */);
                }
            });
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, _runtime_atomic__WEBPACK_IMPORTED_MODULE_9__);
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, _runtime_pthread__WEBPACK_IMPORTED_MODULE_10__);
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, _runtime_semaphore__WEBPACK_IMPORTED_MODULE_11__);
        }
        if (this.memoryBase) {
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, {
                __memory_base: this.memoryBase
            });
        }
        //  memoryBase
        else if (options.memoryBase) {
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, {
                __memory_base: options.memoryBase
            });
        }
        if (this.tableBase) {
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, {
                __table_base: this.tableBase
            });
        }
        if (options.imports?.env) {
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, options.imports.env);
            if (options.envKey && options.importMap) {
                const env = {};
                common_util_object__WEBPACK_IMPORTED_MODULE_3__.each(this.imports.env, (value, key) => {
                    if (options.importMap[key]) {
                        env[options.importMap[key]] = value;
                    }
                });
                this.imports[options.envKey] = env;
            }
        }
        this.imports['wasi_snapshot_preview1'] = this.imports.env;
    }
    createChildUrl() {
        const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_12__["default"])(/*require.resolve*/(/*! ./WebAssemblyRunner.ts */ "./src/cheap/webassembly/WebAssemblyRunner.ts"), {
            varName: '__WebAssemblyRunner__',
            exportName: '__WebAssemblyRunner__',
            pointName: WebAssemblyRunner.name,
            exportIsClass: true
        });
        const source = `
      ${module}
      ${runThread}
      var preRun;
      ${this.childImports ? `
      preRun = import('${this.childImports}')
      ` : ''}
      init.default(preRun);
    `;
        this.childBlob = new Blob([source], { type: 'text/javascript' });
        this.childUrl = URL.createObjectURL(this.childBlob);
    }
    overrideAtomic() {
        _runtime_atomic__WEBPACK_IMPORTED_MODULE_9__.override({
            atomic_add_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.add8,
            atomic_sub_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.sub8,
            atomic_and_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.and8,
            atomic_or_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.or8,
            atomic_xor_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.xor8,
            atomic_store_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.store8,
            atomic_load_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.load8,
            atomic_compare_exchange_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.compare_exchange8,
            atomic_exchange_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.exchange8,
            atomic_add_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.add16,
            atomic_sub_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.sub16,
            atomic_and_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.and16,
            atomic_or_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.or16,
            atomic_xor_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.xor16,
            atomic_store_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.store16,
            atomic_load_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.load16,
            atomic_compare_exchange_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.compare_exchange16,
            atomic_exchange_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.exchange16,
            atomic_add_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.add32,
            atomic_sub_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.sub32,
            atomic_and_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.and32,
            atomic_or_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.or32,
            atomic_xor_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.xor32,
            atomic_store_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.store32,
            atomic_load_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.load32,
            atomic_compare_exchange_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.compare_exchange32,
            atomic_exchange_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.exchange32,
            atomic_add_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.add64,
            atomic_sub_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.sub64,
            atomic_and_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.and64,
            atomic_or_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.or64,
            atomic_xor_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.xor64,
            atomic_store_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.store64,
            atomic_load_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.load64,
            atomic_compare_exchange_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.compare_exchange64,
            atomic_exchange_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.exchange64,
            atomics_notify: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.notify,
            atomics_wait: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.instance.exports.wait
        });
        common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, _runtime_atomic__WEBPACK_IMPORTED_MODULE_9__);
    }
    /**
     *  wasm 
     */
    async run(imports, threadPoolCount) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_6__.object(imports)) {
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.options.imports, imports);
        }
        if ( true
            && (0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_18__["default"])()
            && !_runtime_asm_thread__WEBPACK_IMPORTED_MODULE_17__.wasmThreadProxy
            && _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_17__.isSupport()
            && this.resource.threadModule) {
            await _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_17__.init(cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Memory, _runtime_pthread__WEBPACK_IMPORTED_MODULE_10__.override);
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, _runtime_pthread__WEBPACK_IMPORTED_MODULE_10__);
        }
        if (!_runtime_asm_libc__WEBPACK_IMPORTED_MODULE_16__.wasmThreadProxy
            && _runtime_asm_libc__WEBPACK_IMPORTED_MODULE_16__.isSupport()) {
            await _runtime_asm_libc__WEBPACK_IMPORTED_MODULE_16__.init(cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Memory);
        }
        if (!atomicAsmOverride && _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.isSupport()) {
            atomicAsmOverride = true;
            this.overrideAtomic();
        }
        this.instance = await WebAssembly.instantiate(this.resource.module, this.imports);
        this.initRunTime();
        if ( true && this.resource.threadModule
            && this.resource.enableThreadPool
            && threadPoolCount > 0
            && !common_util_support__WEBPACK_IMPORTED_MODULE_23__["default"].jspi) {
            if (!this.childUrl) {
                this.createChildUrl();
            }
            let count = threadPoolCount;
            if (this.resource.enableThreadCountRate) {
                count *= this.resource.enableThreadCountRate;
            }
            this.threadPool = new _ThreadPool__WEBPACK_IMPORTED_MODULE_20__["default"](count, this.childUrl);
            await this.threadPool.ready({
                tableSize: this.resource.tableSize,
                module: this.resource.threadModule.module,
                initFuncs: this.resource.threadModule.initFuncs,
                memoryBase: this.options.memoryBase || this.memoryBase,
                tableBase: this.tableBase,
                childImports: this.childImports
            });
        }
    }
    async runAsChild(imports) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_6__.object(imports)) {
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.options.imports, imports);
        }
        if ( true && !_runtime_asm_thread__WEBPACK_IMPORTED_MODULE_17__.wasmThreadProxy && _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_17__.isSupport()) {
            await _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_17__.init(cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Memory, _runtime_pthread__WEBPACK_IMPORTED_MODULE_10__.override);
            common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend(this.imports.env, _runtime_pthread__WEBPACK_IMPORTED_MODULE_10__);
        }
        if (!atomicAsmOverride && _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_15__.isSupport()) {
            atomicAsmOverride = true;
            this.overrideAtomic();
        }
        this.instance = new WebAssembly.Instance(this.resource.module, this.imports);
        this.initRunTime();
    }
    async childrenThreadReady() {
        if (!this.childReadyPromises.length) {
            return;
        }
        const promise = this.childReadyPromises;
        this.childReadyPromises = [];
        await Promise.all(promise);
    }
    initRunTime() {
        this.builtinMalloc = [];
        this.initCalling = true;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_6__.array(this.resource.initFuncs)) {
            common_util_array__WEBPACK_IMPORTED_MODULE_4__.each(this.resource.initFuncs, (func) => {
                let call;
                if (this.asm[func]) {
                    call = this.asm[func];
                }
                if (call) {
                    return call();
                }
            });
        }
        this.initCalling = false;
    }
    /**
     *  wasm 
     *
     * @param func 
     * @param args  number  bigint(   64  
     */
    call(func, ...args) {
        if (!this.asm) {
            return -1;
        }
        let call;
        if (this.asm[func]) {
            call = this.asm[func];
        }
        else if (this.options.exportMap && this.options.exportMap[func] && this.asm[this.options.exportMap[func]]) {
            call = this.asm[this.options.exportMap[func]];
        }
        if (call) {
            return call.apply(null, args);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`the wasm module has not function ${func} to call`, cheap__fileName__3, 597);
        }
    }
    /**
     *  wasm 
     *
     *  wasm  js 
     *
     *  JSPI
     *
     * @param func 
     * @param args  number  bigint(   64  
     */
    async callAsync(func, ...args) {
        if (!this.asm) {
            return -1;
        }
        if (!common_util_support__WEBPACK_IMPORTED_MODULE_23__["default"].jspi) {
            return this.call(func, ...args);
        }
        let call;
        if (this.promisingMap.has(func)) {
            call = this.promisingMap.get(func);
        }
        else {
            if (this.asm[func]) {
                call = this.asm[func];
            }
            else if (this.options.exportMap && this.options.exportMap[func] && this.asm[this.options.exportMap[func]]) {
                call = this.asm[this.options.exportMap[func]];
            }
            // @ts-ignore
            call = WebAssembly.promising(call);
            this.promisingMap.set(func, call);
        }
        if (call) {
            return call.apply(null, args);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`the wasm module has not function ${func} to call`, cheap__fileName__3, 639);
        }
    }
    get asm() {
        return this.instance && this.instance.exports;
    }
    getInstance() {
        return this.instance;
    }
    destroy() {
        if (this.builtinMalloc?.length) {
            common_util_array__WEBPACK_IMPORTED_MODULE_4__.each(this.builtinMalloc, (pointer) => {
                cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(pointer);
            });
            this.builtinMalloc.length = 0;
        }
        if (this.memoryBase) {
            cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(this.memoryBase);
            this.memoryBase = null;
        }
        if (this.tableBase) {
            cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Table.free(this.tableBase);
            this.tableBase = null;
        }
        if (this.childImports) {
            URL.revokeObjectURL(this.childImports);
            this.childImports = null;
        }
        if (this.childUrl) {
            URL.revokeObjectURL(this.childUrl);
            this.childUrl = null;
        }
        this.childBlob = null;
        this.childReadyPromises.length = 0;
        if (this.childThreads.size) {
            this.childThreads.forEach((thread, id) => {
                if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread.threadDescriptor) & 1 /* PthreadFlags.DETACH */)) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_5__.warn('has child thread running, maybe resource leakage', cheap__fileName__3, 684);
                    thread.worker.terminate();
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[16](thread.thread + 12, 0 /* PthreadStatus.STOP */);
                    if (thread.stackPointer) {
                        cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(thread.stackPointer);
                    }
                    cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(thread.threadDescriptor);
                    this.childThreads.delete(id);
                }
            });
        }
        this.builtinMalloc = null;
        this.instance = null;
        if (this.options.thread) {
            if (this.options.threadDescriptor) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.options.threadDescriptor + 4, 0 /* PthreadStatus.STOP */);
            }
            if (this.options.threadDescriptor
                && ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.threadDescriptor) & 1 /* PthreadFlags.DETACH */)
                    || (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.thread + 8) & 4 /* PthreadFlags.EXIT */))) {
                if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.options.threadDescriptor) & 2 /* PthreadFlags.POOL */)) {
                    if (cheap_heap__WEBPACK_IMPORTED_MODULE_2__.StackTop) {
                        cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(cheap_heap__WEBPACK_IMPORTED_MODULE_2__.StackTop);
                    }
                    cheap_heap__WEBPACK_IMPORTED_MODULE_2__.Allocator.free(this.options.threadDescriptor);
                    (0,_std_memory__WEBPACK_IMPORTED_MODULE_7__.memset)(this.options.thread, 0, 16);
                    self.close();
                }
            }
            else {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[16](this.options.thread + 12, 0 /* PthreadStatus.STOP */
                // 
                );
                // 
                _thread_atomics__WEBPACK_IMPORTED_MODULE_14__.notify(this.options.thread + 12, 1);
            }
        }
        {
            if (this.threadPool) {
                this.threadPool.destroy();
            }
            this.threadPool = null;
        }
        if (this.promisingMap) {
            this.promisingMap.clear();
            this.promisingMap = null;
        }
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/compiler.ts":
/*!*******************************************!*\
  !*** ./src/cheap/webassembly/compiler.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ compile)
/* harmony export */ });
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_io_IOReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/IOReader */ "./src/common/io/IOReader.ts");
/* harmony import */ var common_io_IOWriter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/io/IOWriter */ "./src/common/io/IOWriter.ts");
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
/* harmony import */ var common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/function/concatTypeArray */ "./src/common/function/concatTypeArray.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var common_util_os__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/os */ "./src/common/util/os.ts");









async function process(context) {
    try {
        // `\0asm`
        await context.ioWriter.writeUint32(await context.ioReader.readUint32());
        // Version
        await context.ioWriter.writeUint32(await context.ioReader.readUint32());
        while (true) {
            if (context.compileStopped) {
                if (context.abortController) {
                    context.abortController.abort();
                }
                break;
            }
            const sectionId = await context.ioReader.readUint8();
            if (context.options.child) {
                if (sectionId === 11 /* SectionId.Data */) {
                    await context.ioWriter.writeUint8(sectionId);
                    // size
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, 7);
                    // count
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, 1);
                    // index
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, 0);
                    // init_expr i32_const 0
                    await context.ioWriter.writeUint8(0x41);
                    await context.ioWriter.writeUint8(0x00);
                    await context.ioWriter.writeUint8(0x0b);
                    // size
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, 1);
                    await context.ioWriter.writeUint8(0x00);
                    const size = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                    await context.ioReader.skip(size);
                    continue;
                }
            }
            await context.ioWriter.writeUint8(sectionId);
            const size = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, size);
            const now = context.ioReader.getPos();
            if (sectionId === 11 /* SectionId.Data */) {
                /**
                 * - count: varuint32
                 * - entries: data_segment*
                 *   - index varuint32 the linear memory index (0 in the MVP)
                 *   - offset init_expr
                 *   - size varuint32
                 *   - data bytes
                 */
                const count = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, count);
                if (count) {
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader));
                    while (true) {
                        const byte = await context.ioReader.readUint8();
                        await context.ioWriter.writeUint8(byte);
                        if (byte === 0x0b) {
                            break;
                        }
                    }
                    context.data.dataSize = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, context.data.dataSize);
                }
            }
            else if (sectionId === 2 /* SectionId.Import */) {
                /**
                 * - count: varuint32
                 * - entries: import_entry*
                 *   - module_len varuint32
                 *   - module_str bytes
                 *   - field_len varuint32
                 *   - field_str bytes
                 *   - external_kind
                 */
                let count = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, count);
                let counter = 0;
                while (count--) {
                    const moduleLen = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, moduleLen);
                    await context.ioWriter.writeBuffer(await context.ioReader.readBuffer(moduleLen));
                    const fieldLen = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, fieldLen);
                    await context.ioWriter.writeBuffer(await context.ioReader.readBuffer(fieldLen));
                    const externalKind = await context.ioReader.readUint8();
                    await context.ioWriter.writeUint8(externalKind);
                    switch (externalKind) {
                        case 0 /* ExternalKind.Function */: {
                            // type index of the function signature
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader));
                            break;
                        }
                        case 3 /* ExternalKind.Global */: {
                            // content_type
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeSleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readSLeb128Async)(context.ioReader));
                            // mutability
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader));
                            break;
                        }
                        case 2 /* ExternalKind.Memory */: {
                            let flags = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                            if (context.options.enableThread) {
                                flags |= 2;
                            }
                            else {
                                flags &= ~2;
                            }
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, flags);
                            // initial
                            const initial = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, _config__WEBPACK_IMPORTED_MODULE_6__.HEAP_INITIAL || initial);
                            if (flags & 0x01) {
                                let max = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                                if (!(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].safari && common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].ios && !common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '17', true)) || !context.options.enableThread) {
                                    // ios safari 16  max 
                                    // 
                                    max = _config__WEBPACK_IMPORTED_MODULE_6__.HEAP_MAXIMUM;
                                }
                                // maximum
                                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, max);
                            }
                            counter++;
                            break;
                        }
                        case 1 /* ExternalKind.Table */: {
                            // elem_type
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeSleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readSLeb128Async)(context.ioReader));
                            const flags = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, flags);
                            const initial = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader);
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, initial);
                            context.data.tableSize = initial;
                            if (flags & 0x01) {
                                // maximum
                                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.readULeb128Async)(context.ioReader));
                            }
                            counter++;
                            break;
                        }
                    }
                    if (counter === 2) {
                        break;
                    }
                }
            }
            const remainingLength = size - Number(context.ioReader.getPos() - now);
            if (remainingLength) {
                await context.ioReader.pipe(context.ioWriter, size - Number(context.ioReader.getPos() - now));
            }
        }
    }
    catch (e) {
        if (context.ioReader.error === -1048576 /* IOError.END */) {
            context.bufferEnded = true;
        }
        else {
            context.error = e;
        }
        if (context.ioReader.remainingLength()) {
            await context.ioWriter.writeBuffer(await context.ioReader.readBuffer(context.ioReader.remainingLength()));
        }
        await context.ioWriter.flush();
    }
}
async function compile(source, options = {}) {
    let module;
    let tableSize;
    let dataSize;
    let buffer;
    options = common_util_object__WEBPACK_IMPORTED_MODULE_5__.extend({
        enableThread: _config__WEBPACK_IMPORTED_MODULE_6__.USE_THREADS,
        initFuncs: options.child ? [] : ['__wasm_apply_data_relocs', '_initialize']
    }, options);
    if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.number(source.dataSize) && common_util_is__WEBPACK_IMPORTED_MODULE_0__.number(source.tableSize)) {
        tableSize = source.dataSize;
        dataSize = source.dataSize;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.string(source.source)) {
            const params = {
                method: 'GET',
                headers: {},
                mode: 'cors',
                cache: 'default',
                referrerPolicy: 'no-referrer-when-downgrade'
            };
            if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.func(WebAssembly.compileStreaming)) {
                module = await WebAssembly.compileStreaming(fetch(source.source, params));
            }
            else {
                const response = await fetch(source.source, params);
                buffer = await response.arrayBuffer();
                module = await WebAssembly.compile(buffer);
            }
        }
        else {
            module = await WebAssembly.compile(source.source);
            buffer = common_util_is__WEBPACK_IMPORTED_MODULE_0__.arrayBuffer(source.source) ? source.source : source.source.buffer;
        }
    }
    else {
        const context = {
            ioReader: new common_io_IOReader__WEBPACK_IMPORTED_MODULE_1__["default"](1048576),
            ioWriter: new common_io_IOWriter__WEBPACK_IMPORTED_MODULE_2__["default"](1048576),
            bufferEnded: false,
            compileStopped: false,
            error: '',
            abortController: null,
            pullResolve: null,
            bufferResolve: null,
            buffers: [],
            data: {},
            options
        };
        const response = new Response(new ReadableStream({
            async start(controller) {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.string(source.source)) {
                    if (AbortController) {
                        context.abortController = new AbortController();
                    }
                    const params = {
                        method: 'GET',
                        headers: {},
                        mode: 'cors',
                        cache: 'default',
                        referrerPolicy: 'no-referrer-when-downgrade',
                        signal: context.abortController?.signal
                    };
                    const res = await fetch(source.source, params);
                    let reader;
                    if (res.ok && (res.status >= 200 && res.status <= 299)) {
                        reader = res.body.getReader();
                    }
                    else {
                        controller.error(`Http code invalid, ${res.status} ${res.statusText}`);
                    }
                    const buffers = [];
                    context.ioReader.onFlush = async (buffer) => {
                        let pos = 0;
                        while (buffers.length && pos < buffer.length) {
                            const cache = buffers.shift();
                            if (cache.length > buffer.length - pos) {
                                buffer.set(cache.subarray(0, buffer.length - pos), pos);
                                buffers.unshift(cache.subarray(buffer.length - pos));
                                pos = buffer.length;
                            }
                            else {
                                buffer.set(cache, pos);
                                pos += cache.length;
                            }
                        }
                        if (pos >= buffer.length) {
                            return buffer.length;
                        }
                        const { value, done } = await reader.read();
                        if (done) {
                            return pos > 0 ? pos : -1048576 /* IOError.END */;
                        }
                        else {
                            context.buffers.push(value);
                            if (value.length > buffer.length - pos) {
                                buffer.set(value.subarray(0, buffer.length - pos), pos);
                                buffers.push(value.subarray(buffer.length - pos));
                                return buffer.length;
                            }
                            else {
                                buffer.set(value, pos);
                                pos += value.length;
                                return pos;
                            }
                        }
                    };
                }
                else {
                    let readPos = 0;
                    let readFileLength = source.source.byteLength;
                    const wasm = common_util_is__WEBPACK_IMPORTED_MODULE_0__.arrayBuffer(source.source) ? new Uint8Array(source.source) : source.source;
                    context.ioReader.onFlush = async (buffer) => {
                        if (readPos >= readFileLength) {
                            return -1048576 /* IOError.END */;
                        }
                        const len = Math.min(buffer.length, readFileLength - readPos);
                        buffer.set(wasm.subarray(readPos, readPos + len), 0);
                        readPos += len;
                        return len;
                    };
                }
                context.ioWriter.onFlush = async (buffer) => {
                    if (context.pullResolve) {
                        context.pullResolve(buffer.slice());
                        context.pullResolve = null;
                        return 0;
                    }
                    (await new Promise((resolve, reject) => {
                        context.bufferResolve = resolve;
                    })).enqueue(buffer.slice());
                    return 0;
                };
                process(context);
            },
            async pull(controller) {
                if (context.error) {
                    controller.close();
                    return;
                }
                if (context.bufferResolve) {
                    context.bufferResolve(controller);
                    context.bufferResolve = null;
                    return;
                }
                controller.enqueue(await new Promise((resolve, reject) => {
                    context.pullResolve = resolve;
                }));
                if (context.bufferEnded) {
                    controller.close();
                }
                else if (context.error) {
                    controller.error(context.error);
                }
            },
            cancel(reason) {
                context.compileStopped = true;
            }
        }), {
            headers: {
                'Content-Type': 'application/wasm'
            }
        });
        if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.func(WebAssembly.compileStreaming)) {
            module = await WebAssembly.compileStreaming(response);
        }
        else {
            module = await WebAssembly.compile(await response.arrayBuffer());
        }
        buffer = common_util_is__WEBPACK_IMPORTED_MODULE_0__.string(source.source)
            ? (0,common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_4__["default"])(Uint8Array, context.buffers).buffer
            : (common_util_is__WEBPACK_IMPORTED_MODULE_0__.arrayBuffer(source.source) ? source.source : source.source.buffer);
        tableSize = context.data.tableSize;
        dataSize = context.data.dataSize;
    }
    if (options.child) {
        return {
            module,
            initFuncs: options.initFuncs || []
        };
    }
    return {
        module,
        tableSize,
        dataSize,
        initFuncs: options.initFuncs || [],
        buffer: buffer
    };
}


/***/ }),

/***/ "./src/cheap/webassembly/runThread.ts":
/*!********************************************!*\
  !*** ./src/cheap/webassembly/runThread.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var _thread_mutex_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./..\thread\mutex.ts */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _thread_cond_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./..\thread\cond.ts */ "./src/cheap/thread/cond.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");





// @ts-ignore
common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.imports = {
    env: {}
};
let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF;
let runner;
let runnerData;
let waitData = 0;
function init(preRun) {
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        switch (type) {
            case 'run': {
                parentPort.postMessage({
                    type: 'run'
                });
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.initThread) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.initThread(data.cheap).then(() => {
                        function run() {
                            common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.__SELF_THREAD__ = data.runner.thread;
                            // @ts-ignore
                            data.runner.options.imports = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.imports;
                            // @ts-ignore
                            runner = new __WebAssemblyRunner__.__WebAssemblyRunner__(data.runner.resource, data.runner.options);
                            runner.runAsChild().then(() => {
                                // @ts-ignore
                                __WebAssemblyRunner__.__WebAssemblyRunner__.getTable().get(data.runner.func)(data.runner.args);
                                runner.destroy();
                            });
                        }
                        if (preRun) {
                            preRun.then(() => {
                                run();
                            });
                        }
                        else {
                            run();
                        }
                    });
                }
                break;
            }
            case 'ready': {
                runnerData = data.runner;
                waitData = data.cheap.stackPointer;
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.initThread) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.CHeap.initThread(data.cheap).then(() => {
                        if (preRun) {
                            preRun.then(() => {
                                parentPort.postMessage({
                                    type: 'ready'
                                });
                            });
                        }
                        else {
                            parentPort.postMessage({
                                type: 'ready'
                            });
                        }
                    });
                }
                break;
            }
            case 'wait': {
                async function run() {
                    while (true) {
                        // @ts-ignore
                        __WebAssemblyRunner__.__WebAssemblyRunner__.mutexLock(waitData + 16);
                        // @ts-ignore
                        while (__WebAssemblyRunner__.__WebAssemblyRunner__.readPointer(waitData) === 0) {
                            // @ts-ignore
                            __WebAssemblyRunner__.__WebAssemblyRunner__.condWait(waitData + 12, waitData + 16);
                        }
                        // @ts-ignore
                        common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.__SELF_THREAD__ = __WebAssemblyRunner__.__WebAssemblyRunner__.readPointer(waitData), runnerData.options.thread = __WebAssemblyRunner__.__WebAssemblyRunner__.readPointer(waitData), runnerData.thread = __WebAssemblyRunner__.__WebAssemblyRunner__.readPointer(waitData);
                        // @ts-ignore
                        runnerData.func = __WebAssemblyRunner__.__WebAssemblyRunner__.readPointer(waitData + 4);
                        // @ts-ignore
                        runnerData.args = __WebAssemblyRunner__.__WebAssemblyRunner__.readPointer(waitData + 8);
                        // @ts-ignore
                        runner = new __WebAssemblyRunner__.__WebAssemblyRunner__(runnerData.resource, runnerData.options);
                        await runner.runAsChild();
                        // @ts-ignore
                        __WebAssemblyRunner__.__WebAssemblyRunner__.getTable().get(runnerData.func)(runnerData.args);
                        runner.destroy();
                        // @ts-ignore
                        __WebAssemblyRunner__.__WebAssemblyRunner__.writePointer(waitData, 0);
                        // @ts-ignore
                        __WebAssemblyRunner__.__WebAssemblyRunner__.mutexUnlock(waitData + 16);
                    }
                }
                // @ts-ignore
                runnerData.options.imports = common_util_constant__WEBPACK_IMPORTED_MODULE_4__.SELF.imports;
                run();
                break;
            }
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/asm/libc.ts":
/*!***************************************************!*\
  !*** ./src/cheap/webassembly/runtime/asm/libc.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   isSupport: () => (/* binding */ isSupport),
/* harmony export */   wasmThreadProxy: () => (/* binding */ wasmThreadProxy)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../heap */ "./src/cheap/heap.ts");
/* harmony import */ var common_util_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/base64 */ "./src/common/util/base64.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _libc_asm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libc.asm */ "./src/cheap/webassembly/runtime/asm/libc.asm");
/* harmony import */ var _libc_asm__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_libc_asm__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
var cheap__fileName__5 = "src\\cheap\\webassembly\\runtime\\asm\\libc.ts";

/* eslint-disable camelcase */





/**
 * WebAssembly runtime 
 */
let wasmThreadProxy;
let support = true;
function isSupport() {
    return support;
}
async function init(memory) {
    try {
        if (typeof SharedArrayBuffer === 'function' && memory.buffer instanceof SharedArrayBuffer) {
            const wasm = (0,common_util_base64__WEBPACK_IMPORTED_MODULE_1__.base64ToUint8Array)((_libc_asm__WEBPACK_IMPORTED_MODULE_3___default()));
            common_util_wasm__WEBPACK_IMPORTED_MODULE_4__.setMemoryShared(wasm, true);
            wasmThreadProxy = (await WebAssembly.instantiate(wasm, {
                env: {
                    memory,
                    malloc: function (size) {
                        return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(size);
                    },
                    calloc: function (num, size) {
                        return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.calloc(num, size);
                    },
                    realloc: function (pointer, size) {
                        return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.realloc(pointer, size);
                    },
                    aligned_alloc(alignment, size) {
                        return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(alignment, size);
                    },
                    free: function (pointer) {
                        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(pointer);
                    }
                }
            })).instance;
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.set(2 /* BuiltinTableSlot.MALLOC */, wasmThreadProxy.exports.malloc);
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.set(1 /* BuiltinTableSlot.FREE */, wasmThreadProxy.exports.free);
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.set(3 /* BuiltinTableSlot.CALLOC */, wasmThreadProxy.exports.calloc);
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.set(4 /* BuiltinTableSlot.REALLOC */, wasmThreadProxy.exports.realloc);
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.set(5 /* BuiltinTableSlot.ALIGNED_ALLOC */, wasmThreadProxy.exports.alignedAlloc);
        }
        else {
            support = false;
            return;
        }
    }
    catch (error) {
        support = false;
        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.warn('thread asm not support, cannot use asm thread function', cheap__fileName__5, 64);
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/asm/thread.ts":
/*!*****************************************************!*\
  !*** ./src/cheap/webassembly/runtime/asm/thread.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   isSupport: () => (/* binding */ isSupport),
/* harmony export */   wasmThreadProxy: () => (/* binding */ wasmThreadProxy)
/* harmony export */ });
/* harmony import */ var common_util_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/base64 */ "./src/common/util/base64.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _thread_asm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./thread.asm */ "./src/cheap/webassembly/runtime/asm/thread.asm");
/* harmony import */ var _thread_asm__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_thread_asm__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
var cheap__fileName__0 = "src\\cheap\\webassembly\\runtime\\asm\\thread.ts";
/* eslint-disable camelcase */




/**
 * WebAssembly runtime 
 */
let wasmThreadProxy;
let support = true;
function isSupport() {
    return support;
}
async function init(memory, override) {
    try {
        if (typeof SharedArrayBuffer === 'function' && memory.buffer instanceof SharedArrayBuffer) {
            const wasm = (0,common_util_base64__WEBPACK_IMPORTED_MODULE_0__.base64ToUint8Array)((_thread_asm__WEBPACK_IMPORTED_MODULE_2___default()));
            common_util_wasm__WEBPACK_IMPORTED_MODULE_3__.setMemoryShared(wasm, true);
            wasmThreadProxy = (await WebAssembly.instantiate(wasm, {
                env: {
                    memory
                }
            })).instance;
        }
        else {
            support = false;
            return;
        }
        override({
            wasm_pthread_mutex_lock: wasmThreadProxy.exports.lock,
            wasm_pthread_mutex_trylock: wasmThreadProxy.exports.trylock,
            wasm_pthread_mutex_unlock: wasmThreadProxy.exports.unlock,
            wasm_pthread_cond_wait: wasmThreadProxy.exports.wait,
            wasm_pthread_cond_timedwait: wasmThreadProxy.exports.timedwait,
            wasm_pthread_cond_signal: wasmThreadProxy.exports.signal,
            wasm_pthread_cond_broadcast: wasmThreadProxy.exports.broadcast
        });
    }
    catch (error) {
        support = false;
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.warn('thread asm not support, cannot use asm thread function', cheap__fileName__0, 67);
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/atomic.ts":
/*!*************************************************!*\
  !*** ./src/cheap/webassembly/runtime/atomic.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   atomic_add_i16: () => (/* binding */ atomic_add_i16),
/* harmony export */   atomic_add_i32: () => (/* binding */ atomic_add_i32),
/* harmony export */   atomic_add_i64: () => (/* binding */ atomic_add_i64),
/* harmony export */   atomic_add_i8: () => (/* binding */ atomic_add_i8),
/* harmony export */   atomic_and_i16: () => (/* binding */ atomic_and_i16),
/* harmony export */   atomic_and_i32: () => (/* binding */ atomic_and_i32),
/* harmony export */   atomic_and_i64: () => (/* binding */ atomic_and_i64),
/* harmony export */   atomic_and_i8: () => (/* binding */ atomic_and_i8),
/* harmony export */   atomic_compare_exchange_i16: () => (/* binding */ atomic_compare_exchange_i16),
/* harmony export */   atomic_compare_exchange_i32: () => (/* binding */ atomic_compare_exchange_i32),
/* harmony export */   atomic_compare_exchange_i64: () => (/* binding */ atomic_compare_exchange_i64),
/* harmony export */   atomic_compare_exchange_i8: () => (/* binding */ atomic_compare_exchange_i8),
/* harmony export */   atomic_exchange_i16: () => (/* binding */ atomic_exchange_i16),
/* harmony export */   atomic_exchange_i32: () => (/* binding */ atomic_exchange_i32),
/* harmony export */   atomic_exchange_i64: () => (/* binding */ atomic_exchange_i64),
/* harmony export */   atomic_exchange_i8: () => (/* binding */ atomic_exchange_i8),
/* harmony export */   atomic_load_i16: () => (/* binding */ atomic_load_i16),
/* harmony export */   atomic_load_i32: () => (/* binding */ atomic_load_i32),
/* harmony export */   atomic_load_i64: () => (/* binding */ atomic_load_i64),
/* harmony export */   atomic_load_i8: () => (/* binding */ atomic_load_i8),
/* harmony export */   atomic_or_i16: () => (/* binding */ atomic_or_i16),
/* harmony export */   atomic_or_i32: () => (/* binding */ atomic_or_i32),
/* harmony export */   atomic_or_i64: () => (/* binding */ atomic_or_i64),
/* harmony export */   atomic_or_i8: () => (/* binding */ atomic_or_i8),
/* harmony export */   atomic_store_i16: () => (/* binding */ atomic_store_i16),
/* harmony export */   atomic_store_i32: () => (/* binding */ atomic_store_i32),
/* harmony export */   atomic_store_i64: () => (/* binding */ atomic_store_i64),
/* harmony export */   atomic_store_i8: () => (/* binding */ atomic_store_i8),
/* harmony export */   atomic_sub_i16: () => (/* binding */ atomic_sub_i16),
/* harmony export */   atomic_sub_i32: () => (/* binding */ atomic_sub_i32),
/* harmony export */   atomic_sub_i64: () => (/* binding */ atomic_sub_i64),
/* harmony export */   atomic_sub_i8: () => (/* binding */ atomic_sub_i8),
/* harmony export */   atomic_xor_i16: () => (/* binding */ atomic_xor_i16),
/* harmony export */   atomic_xor_i32: () => (/* binding */ atomic_xor_i32),
/* harmony export */   atomic_xor_i64: () => (/* binding */ atomic_xor_i64),
/* harmony export */   atomic_xor_i8: () => (/* binding */ atomic_xor_i8),
/* harmony export */   atomics_notify: () => (/* binding */ atomics_notify),
/* harmony export */   atomics_wait: () => (/* binding */ atomics_wait),
/* harmony export */   atomics_wait_timeout: () => (/* binding */ atomics_wait_timeout),
/* harmony export */   override: () => (/* binding */ override)
/* harmony export */ });
/* harmony import */ var _thread_atomics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../typedef */ "./src/cheap/typedef.ts");
/* eslint-disable camelcase */


let atomic_add_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_sub_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_and_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_or_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_xor_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_store_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_load_i8 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_compare_exchange_i8 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_exchange_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_add_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_sub_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_and_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_or_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_xor_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_store_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_load_i16 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_compare_exchange_i16 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_exchange_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_add_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_sub_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_and_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_or_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_xor_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_store_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_load_i32 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_compare_exchange_i32 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_exchange_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_add_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_sub_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_and_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_or_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_xor_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_store_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_load_i64 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_compare_exchange_i64 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_exchange_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomics_notify = function (p, count) {
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.notify(p, count);
};
let atomics_wait = function (p, value) {
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.wait(p, value);
};
let atomics_wait_timeout = function (p, value, timeout) {
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.waitTimeout(p, value, Number(BigInt.asIntN(32, timeout)));
};
function override(data) {
    if (data.atomic_add_i8) {
        atomic_add_i8 = data.atomic_add_i8;
    }
    if (data.atomic_sub_i8) {
        atomic_sub_i8 = data.atomic_sub_i8;
    }
    if (data.atomic_and_i8) {
        atomic_and_i8 = data.atomic_and_i8;
    }
    if (data.atomic_or_i8) {
        atomic_or_i8 = data.atomic_or_i8;
    }
    if (data.atomic_xor_i8) {
        atomic_xor_i8 = data.atomic_xor_i8;
    }
    if (data.atomic_store_i8) {
        atomic_store_i8 = data.atomic_store_i8;
    }
    if (data.atomic_load_i8) {
        atomic_load_i8 = data.atomic_load_i8;
    }
    if (data.atomic_compare_exchange_i8) {
        atomic_compare_exchange_i8 = data.atomic_compare_exchange_i8;
    }
    if (data.atomic_exchange_i8) {
        atomic_exchange_i8 = data.atomic_exchange_i8;
    }
    if (data.atomic_add_i16) {
        atomic_add_i16 = data.atomic_add_i16;
    }
    if (data.atomic_sub_i16) {
        atomic_sub_i16 = data.atomic_sub_i16;
    }
    if (data.atomic_and_i16) {
        atomic_and_i16 = data.atomic_and_i16;
    }
    if (data.atomic_or_i16) {
        atomic_or_i16 = data.atomic_or_i16;
    }
    if (data.atomic_xor_i16) {
        atomic_xor_i16 = data.atomic_xor_i16;
    }
    if (data.atomic_store_i16) {
        atomic_store_i16 = data.atomic_store_i16;
    }
    if (data.atomic_load_i16) {
        atomic_load_i16 = data.atomic_load_i16;
    }
    if (data.atomic_compare_exchange_i16) {
        atomic_compare_exchange_i16 = data.atomic_compare_exchange_i16;
    }
    if (data.atomic_exchange_i16) {
        atomic_exchange_i16 = data.atomic_exchange_i16;
    }
    if (data.atomic_add_i32) {
        atomic_add_i32 = data.atomic_add_i32;
    }
    if (data.atomic_sub_i32) {
        atomic_sub_i32 = data.atomic_sub_i32;
    }
    if (data.atomic_and_i32) {
        atomic_and_i32 = data.atomic_and_i32;
    }
    if (data.atomic_or_i32) {
        atomic_or_i32 = data.atomic_or_i32;
    }
    if (data.atomic_xor_i32) {
        atomic_xor_i32 = data.atomic_xor_i32;
    }
    if (data.atomic_store_i32) {
        atomic_store_i32 = data.atomic_store_i32;
    }
    if (data.atomic_load_i32) {
        atomic_load_i32 = data.atomic_load_i32;
    }
    if (data.atomic_compare_exchange_i32) {
        atomic_compare_exchange_i32 = data.atomic_compare_exchange_i32;
    }
    if (data.atomic_exchange_i32) {
        atomic_exchange_i32 = data.atomic_exchange_i32;
    }
    if (data.atomic_add_i64) {
        atomic_add_i64 = data.atomic_add_i64;
    }
    if (data.atomic_sub_i64) {
        atomic_sub_i64 = data.atomic_sub_i64;
    }
    if (data.atomic_and_i64) {
        atomic_and_i64 = data.atomic_and_i64;
    }
    if (data.atomic_or_i64) {
        atomic_or_i64 = data.atomic_or_i64;
    }
    if (data.atomic_xor_i64) {
        atomic_xor_i64 = data.atomic_xor_i64;
    }
    if (data.atomic_store_i64) {
        atomic_store_i64 = data.atomic_store_i64;
    }
    if (data.atomic_load_i64) {
        atomic_load_i64 = data.atomic_load_i64;
    }
    if (data.atomic_compare_exchange_i64) {
        atomic_compare_exchange_i64 = data.atomic_compare_exchange_i64;
    }
    if (data.atomic_exchange_i64) {
        atomic_exchange_i64 = data.atomic_exchange_i64;
    }
    if (data.atomics_notify) {
        atomics_notify = data.atomics_notify;
    }
    if (data.atomics_wait) {
        atomics_wait = data.atomics_wait;
    }
    if (data.atomics_wait_timeout) {
        atomics_wait_timeout = data.atomics_wait_timeout;
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/clib.ts":
/*!***********************************************!*\
  !*** ./src/cheap/webassembly/runtime/clib.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abort: () => (/* binding */ abort),
/* harmony export */   clock_res_get: () => (/* binding */ clock_res_get),
/* harmony export */   clock_time_get: () => (/* binding */ clock_time_get),
/* harmony export */   environ_get: () => (/* binding */ environ_get),
/* harmony export */   environ_sizes_get: () => (/* binding */ environ_sizes_get),
/* harmony export */   fd_fdstat_get: () => (/* binding */ fd_fdstat_get),
/* harmony export */   fd_write: () => (/* binding */ fd_write),
/* harmony export */   random_get: () => (/* binding */ random_get)
/* harmony export */ });
/* unused harmony exports printChar, writeAsciiToMemory, fd_read, fd_seek, fd_close */
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _std_memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");


/* eslint-disable camelcase */


const buffers = [null, [], []];
const WASI_ERRNO_SUCCESS = 0;
const WASI_ERRNO_NOSYS = 52;
const WASI_ERRNO_INVAL = 28;
function printChar(stream, curr) {
    const buffer = buffers[stream];
    if (curr === 0 || curr === 10) {
        (stream === 1 ? console.log.bind(console) : console.log.bind(console))(common_util_text__WEBPACK_IMPORTED_MODULE_3__.decode(buffer));
        buffer.length = 0;
    }
    else {
        buffer.push(curr);
    }
}
function writeAsciiToMemory(str, buffer, doNotAddNull) {
    for (let i = 0; i < str.length; ++i) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[4](buffer, (((((str.charCodeAt(i)) >> 0) & 0xff) & 0x80) ? -(0x100 - (((str.charCodeAt(i)) >> 0) & 0xff)) : (((str.charCodeAt(i)) >> 0) & 0xff)));
        buffer = buffer + 1;
    }
    if (!doNotAddNull) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[4](buffer, (( false) ? 0 : (0 & 0xff)));
    }
}
const ENV = {};
let thisProgram = './this.program';
let getEnvStringsStrings;
function getExecutableName() {
    return thisProgram || './this.program';
}
function getEnvStrings() {
    if (!getEnvStringsStrings) {
        const lang = (typeof navigator === 'object' && navigator.languages && navigator.languages[0] || 'C').replace('-', '_') + '.UTF-8';
        const env = {
            'USER': 'web_user',
            'LOGNAME': 'web_user',
            'PATH': '/',
            'PWD': '/',
            'HOME': '/home/web_user',
            'LANG': lang,
            '_': getExecutableName()
        };
        for (let x in ENV) {
            env[x] = ENV[x];
        }
        const strings = [];
        for (let x in env) {
            strings.push(x + '=' + env[x]);
        }
        getEnvStringsStrings = strings;
    }
    return getEnvStringsStrings;
}
function environ_get(environ, environBuf) {
    let bufSize = 0;
    getEnvStrings().forEach(function (string, i) {
        const ptr = environBuf + bufSize;
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[8](environ + (i * 4), ptr);
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
    });
    return 0;
}
function environ_sizes_get(penvironCount, penvironBufSize) {
    const strings = getEnvStrings();
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[8](penvironCount, (((strings.length) >> 0) >>> 0));
    let bufSize = 0;
    strings.forEach(function (string) {
        bufSize += string.length + 1;
    });
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[8](penvironBufSize, (((bufSize) >> 0) >>> 0));
    return 0;
}
function fd_fdstat_get(fd, pBuf) {
    let rightsBase = 0;
    if (fd == 0) {
        rightsBase = 2;
    }
    else if (fd == 1 || fd == 2) {
        rightsBase = 64;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[11](pBuf, (( false) ? 0 : (2 & 0xff)));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[13](pBuf + 2, (( false) ? 0 : (1 & 0xffff)));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](pBuf + 8, ((rightsBase) >> 0));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](pBuf + 12, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[17](pBuf + 16, BigInt(0));
    return WASI_ERRNO_SUCCESS;
}
function fd_read(fd, iov, iovCnt, pNum) {
    return WASI_ERRNO_NOSYS;
}
function fd_seek(fd, offsetLow, offsetHigh, whence, newOffset) {
    return WASI_ERRNO_NOSYS;
}
function fd_write(fd, iov, iovCnt, pNum) {
    let num = 0;
    for (let i = 0; i < iovCnt; i++) {
        let ptr = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[8](iov);
        let len = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[8](iov + 4);
        iov = iov + 8;
        for (let j = 0; j < len; j++) {
            printChar(fd, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[4](ptr + j));
        }
        num += len;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[8](pNum, (((num) >> 0) >>> 0));
    return WASI_ERRNO_SUCCESS;
}
function fd_close(fd) {
    return WASI_ERRNO_NOSYS;
}
function abort(what) {
    what += '';
    what = `abort(${what}). Build with -s ASSERTIONS=1 for more info.`;
    throw new WebAssembly.RuntimeError(what);
}
function clock_time_get(id, precision, timeOut) {
    if (id !== 0) {
        return WASI_ERRNO_INVAL;
    }
    const now = new Date().getTime();
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[10](timeOut, BigInt(now) * BigInt(1000000));
    return WASI_ERRNO_SUCCESS;
}
function clock_res_get(id, resOut) {
    if (id !== 0) {
        return WASI_ERRNO_INVAL;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[10](resOut, BigInt(1000000));
    return WASI_ERRNO_SUCCESS;
}
function random_get(pointer, size) {
    const buffer = (0,_std_memory__WEBPACK_IMPORTED_MODULE_2__.mapUint8Array)(pointer, size);
    {
        crypto.getRandomValues(buffer);
    }
    return WASI_ERRNO_SUCCESS;
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/pthread.ts":
/*!**************************************************!*\
  !*** ./src/cheap/webassembly/runtime/pthread.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   override: () => (/* binding */ override),
/* harmony export */   wasm_cpu_core_count: () => (/* binding */ wasm_cpu_core_count),
/* harmony export */   wasm_pthread_cond_broadcast: () => (/* binding */ wasm_pthread_cond_broadcast),
/* harmony export */   wasm_pthread_cond_destroy: () => (/* binding */ wasm_pthread_cond_destroy),
/* harmony export */   wasm_pthread_cond_init: () => (/* binding */ wasm_pthread_cond_init),
/* harmony export */   wasm_pthread_cond_signal: () => (/* binding */ wasm_pthread_cond_signal),
/* harmony export */   wasm_pthread_cond_timedwait: () => (/* binding */ wasm_pthread_cond_timedwait),
/* harmony export */   wasm_pthread_cond_wait: () => (/* binding */ wasm_pthread_cond_wait),
/* harmony export */   wasm_pthread_equal2: () => (/* binding */ wasm_pthread_equal2),
/* harmony export */   wasm_pthread_exit: () => (/* binding */ wasm_pthread_exit),
/* harmony export */   wasm_pthread_mutex_destroy: () => (/* binding */ wasm_pthread_mutex_destroy),
/* harmony export */   wasm_pthread_mutex_init: () => (/* binding */ wasm_pthread_mutex_init),
/* harmony export */   wasm_pthread_mutex_lock: () => (/* binding */ wasm_pthread_mutex_lock),
/* harmony export */   wasm_pthread_mutex_trylock: () => (/* binding */ wasm_pthread_mutex_trylock),
/* harmony export */   wasm_pthread_mutex_unlock: () => (/* binding */ wasm_pthread_mutex_unlock),
/* harmony export */   wasm_pthread_once: () => (/* binding */ wasm_pthread_once),
/* harmony export */   wasm_pthread_self2: () => (/* binding */ wasm_pthread_self2),
/* harmony export */   wasm_pthread_support: () => (/* binding */ wasm_pthread_support),
/* harmony export */   wasm_threw_error: () => (/* binding */ wasm_threw_error)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _thread_mutex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _thread_cond__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../thread/cond */ "./src/cheap/thread/cond.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../config */ "./src/cheap/config.ts");
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../heap */ "./src/cheap/heap.ts");
/* harmony import */ var _thread_atomics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var _std_memory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../std/memory */ "./src/cheap/std/memory.ts");


/* eslint-disable camelcase */







let wasm_pthread_mutex_init;
let wasm_pthread_mutex_destroy;
let wasm_pthread_mutex_lock;
let wasm_pthread_mutex_trylock;
let wasm_pthread_mutex_unlock;
let wasm_pthread_cond_init;
let wasm_pthread_cond_destroy;
let wasm_pthread_cond_wait;
let wasm_pthread_cond_timedwait;
let wasm_pthread_cond_signal;
let wasm_pthread_cond_broadcast;
let wasm_pthread_once;
function wasm_pthread_self2() {
    return common_util_constant__WEBPACK_IMPORTED_MODULE_7__.SELF.__SELF_THREAD__;
}
function wasm_pthread_exit(retval) {
    const thread = common_util_constant__WEBPACK_IMPORTED_MODULE_7__.SELF.__SELF_THREAD__;
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](thread + 4, retval);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](thread + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](thread + 8) | 4 /* PthreadFlags.EXIT */);
}
function wasm_pthread_equal2(t1, t2) {
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](t1) === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](t2) ? 1 : 0;
}
function wasm_pthread_support() {
    return _config__WEBPACK_IMPORTED_MODULE_4__.USE_THREADS ? 1 : 0;
}
function wasm_cpu_core_count() {
    return navigator.hardwareConcurrency;
}
function wasm_threw_error(code, msg) {
    throw new Error((0,_std_memory__WEBPACK_IMPORTED_MODULE_8__.readCString)(msg));
}
wasm_pthread_mutex_init = function (mutex, attr) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_2__.init(mutex);
};
wasm_pthread_mutex_destroy = function (mutex) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_2__.destroy(mutex);
};
wasm_pthread_mutex_lock = function (mutex) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_2__.lock(mutex);
};
wasm_pthread_mutex_trylock = function (mutex) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_2__.tryLock(mutex);
};
wasm_pthread_mutex_unlock = function (mutex) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_2__.unlock(mutex);
};
wasm_pthread_cond_init = function (cond, attr) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_3__.init(cond, attr);
};
wasm_pthread_cond_destroy = function (cond) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_3__.destroy(cond);
};
wasm_pthread_cond_wait = function (cond, mutex) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_3__.wait(cond, mutex);
};
wasm_pthread_cond_timedwait = function (cond, mutex, abstime) {
    let timeout = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](abstime)) * 1000 + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](abstime + 8) / 1000000;
    return _thread_cond__WEBPACK_IMPORTED_MODULE_3__.timedWait(cond, mutex, timeout);
};
wasm_pthread_cond_signal = function (cond) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_3__.signal(cond);
};
wasm_pthread_cond_broadcast = function (cond) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_3__.broadcast(cond);
};
wasm_pthread_once = function (control, func) {
    if (_thread_atomics__WEBPACK_IMPORTED_MODULE_6__.add(control, 1, 16, 2) === 0) {
        _heap__WEBPACK_IMPORTED_MODULE_5__.Table.get(func)();
    }
    return 0;
};
function override(data) {
    if (data.wasm_pthread_mutex_lock) {
        wasm_pthread_mutex_lock = data.wasm_pthread_mutex_lock;
    }
    if (data.wasm_pthread_mutex_trylock) {
        wasm_pthread_mutex_trylock = data.wasm_pthread_mutex_trylock;
    }
    if (data.wasm_pthread_mutex_unlock) {
        wasm_pthread_mutex_unlock = data.wasm_pthread_mutex_unlock;
    }
    if (data.wasm_pthread_cond_wait) {
        wasm_pthread_cond_wait = data.wasm_pthread_cond_wait;
    }
    if (data.wasm_pthread_cond_timedwait) {
        wasm_pthread_cond_timedwait = data.wasm_pthread_cond_timedwait;
    }
    if (data.wasm_pthread_cond_signal) {
        wasm_pthread_cond_signal = data.wasm_pthread_cond_signal;
    }
    if (data.wasm_pthread_cond_broadcast) {
        wasm_pthread_cond_broadcast = data.wasm_pthread_cond_broadcast;
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/semaphore.ts":
/*!****************************************************!*\
  !*** ./src/cheap/webassembly/runtime/semaphore.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timespec: () => (/* binding */ Timespec),
/* harmony export */   wasm_sem_destroy: () => (/* binding */ wasm_sem_destroy),
/* harmony export */   wasm_sem_init: () => (/* binding */ wasm_sem_init),
/* harmony export */   wasm_sem_post: () => (/* binding */ wasm_sem_post),
/* harmony export */   wasm_sem_timedwait: () => (/* binding */ wasm_sem_timedwait),
/* harmony export */   wasm_sem_trywait: () => (/* binding */ wasm_sem_trywait),
/* harmony export */   wasm_sem_wait: () => (/* binding */ wasm_sem_wait)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _thread_semaphore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../thread/semaphore */ "./src/cheap/thread/semaphore.ts");



/* eslint-disable camelcase */

class Timespec {
    tvSec;
    tvNSec;
}
(function (prototype) {
    var map = new Map();
    map.set("tvSec", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("tvNSec", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 16);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(Timespec.prototype);
function wasm_sem_init(sem, pshared, value) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_3__.init(sem, value);
}
function wasm_sem_destroy(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_3__.destroy(sem);
}
function wasm_sem_wait(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_3__.wait(sem);
}
function wasm_sem_trywait(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_3__.tryWait(sem);
}
function wasm_sem_timedwait(sem, abstime) {
    let timeout = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](abstime)) * 1000 + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](abstime + 8) / 1000000;
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_3__.timedWait(sem, timeout);
}
function wasm_sem_post(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_3__.post(sem);
}


/***/ }),

/***/ "./src/cheap/webassembly/thread.ts":
/*!*****************************************!*\
  !*** ./src/cheap/webassembly/thread.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports PthreadOnce, Pthread, ThreadDescriptor, ThreadWait */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _thread_cond_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./..\thread\cond.ts */ "./src/cheap/thread/cond.ts");
/* harmony import */ var _thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./..\thread\mutex.ts */ "./src/cheap/thread/mutex.ts");




class PthreadOnce {
    atomic;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(PthreadOnce.prototype);
class Pthread {
    id;
    retval;
    flags;
    status;
}
(function (prototype) {
    var map = new Map();
    map.set("id", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("retval", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("status", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 16);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(Pthread.prototype);
class ThreadDescriptor {
    flags;
    status;
}
(function (prototype) {
    var map = new Map();
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("status", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(ThreadDescriptor.prototype);
class ThreadWait {
    thread;
    func;
    args;
    cond;
    mutex;
}
(function (prototype) {
    var map = new Map();
    map.set("thread", { 0: Pthread, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("func", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("args", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("cond", { 0: _thread_cond_ts__WEBPACK_IMPORTED_MODULE_2__.Cond, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("mutex", { 0: _thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructLength, 20);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta, map);
})(ThreadWait.prototype);


/***/ }),

/***/ "./src/common/event/CustomEvent.ts":
/*!*****************************************!*\
  !*** ./src/common/event/CustomEvent.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CustomEvent)
/* harmony export */ });
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * https://github.com/yoxjs/yox-common/blob/master/src/util/CustomEvent.ts
 * MIT License
 *
 * @file 
 */

class CustomEvent {
    static PHASE_CURRENT = 0;
    static PHASE_UPWARD = 1;
    static PHASE_DOWNWARD = _util_constant__WEBPACK_IMPORTED_MODULE_0__.MINUS_ONE;
    // 
    type;
    // 
    phase;
    // 
    ns;
    // 
    target;
    //  DOM 
    originalEvent;
    // 
    isPrevented;
    // 
    isStopped;
    //  listener 
    listener;
    /**
     * 
     *
     * 
     */
    constructor(type, originalEvent) {
        /*
         * 
         *  Emitter  true
         * CustomEvent 
         */
        this.type = type;
        this.phase = CustomEvent.PHASE_CURRENT;
        if (originalEvent) {
            this.originalEvent = originalEvent;
        }
    }
    /**
     * 
     */
    preventDefault() {
        const instance = this;
        if (!instance.isPrevented) {
            const { originalEvent } = instance;
            if (originalEvent) {
                originalEvent.preventDefault();
            }
            instance.isPrevented = _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE;
        }
        return instance;
    }
    /**
     * 
     */
    stopPropagation() {
        const instance = this;
        if (!instance.isStopped) {
            const { originalEvent } = instance;
            if (originalEvent) {
                originalEvent.stopPropagation();
            }
            instance.isStopped = _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE;
        }
        return instance;
    }
    prevent() {
        return this.preventDefault();
    }
    stop() {
        return this.stopPropagation();
    }
}


/***/ }),

/***/ "./src/common/event/Emitter.ts":
/*!*************************************!*\
  !*** ./src/common/event/Emitter.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Emitter)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _CustomEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CustomEvent */ "./src/common/event/CustomEvent.ts");
/* harmony import */ var _util_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/object */ "./src/common/util/object.ts");
/* harmony import */ var _util_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/string */ "./src/common/util/string.ts");
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _function_execute__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../function/execute */ "./src/common/function/execute.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
var cheap__fileName__0 = "src\\common\\event\\Emitter.ts";
/**
 * https://github.com/yoxjs/yox-common/blob/master/src/util/Emitter.ts
 * MIT License
 *
 * @file 
 */








class Emitter {
    /**
     * 
     */
    ns;
    /**
     * 
     */
    listeners;
    /**
     *  listener
     */
    nativeListeners;
    constructor(ns) {
        this.ns = ns || _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE;
        this.listeners = {};
    }
    /**
     * 
     *
     * @param type 
     * @param args 
     * @param filter 
     */
    fire(type, args, filter) {
        let instance = this, namespace = _util_is__WEBPACK_IMPORTED_MODULE_0__.string(type) ? instance.parse(type) : type, list = instance.listeners[namespace.type], isComplete = _util_constant__WEBPACK_IMPORTED_MODULE_7__.TRUE;
        if (list) {
            // 
            list = _util_object__WEBPACK_IMPORTED_MODULE_3__.copy(list);
            /*
             * 
             *  args  CustomEvent 
             *  (event, data)
             */
            const event = args && args[0] instanceof _CustomEvent__WEBPACK_IMPORTED_MODULE_2__["default"]
                ? args[0]
                : _util_constant__WEBPACK_IMPORTED_MODULE_7__.UNDEFINED;
            _util_array__WEBPACK_IMPORTED_MODULE_1__.each(list, function (options) {
                // 
                if (!matchNamespace(namespace.ns, options, _util_constant__WEBPACK_IMPORTED_MODULE_7__.TRUE)
                    //  fire 
                    || !_util_array__WEBPACK_IMPORTED_MODULE_1__.has(list, options)
                    //  filter filter  options
                    || (filter && !filter(namespace, args, options))) {
                    return;
                }
                /*
                 *  event  listener
                 * 
                 *  on('xx', function)  listener
                 *  listener  listener 
                 *  var listener = function
                 *  on('xx', listener) 
                 */
                if (event) {
                    event.listener = options.fn;
                }
                let result = (0,_function_execute__WEBPACK_IMPORTED_MODULE_6__["default"])(options.fn, options.ctx, args);
                if (event) {
                    event.listener = _util_constant__WEBPACK_IMPORTED_MODULE_7__.UNDEFINED;
                }
                // 
                options.num = options.num ? (options.num + 1) : 1;
                //  listener 
                if (options.num === options.max) {
                    instance.off(namespace, options.fn);
                }
                //  false event.stop  false
                if (event) {
                    if (result === _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE) {
                        event.prevent().stop();
                    }
                    else if (event.isStopped) {
                        result = _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE;
                    }
                }
                if (result === _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE) {
                    return isComplete = _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE;
                }
            });
        }
        return isComplete;
    }
    /**
     * 
     *
     * @param type
     * @param listener
     */
    on(type, listener) {
        const instance = this, listeners = instance.listeners, options = _util_is__WEBPACK_IMPORTED_MODULE_0__.func(listener)
            ? { fn: listener }
            : listener;
        if (_util_is__WEBPACK_IMPORTED_MODULE_0__.object(options) && _util_is__WEBPACK_IMPORTED_MODULE_0__.func(options.fn)) {
            const namespace = _util_is__WEBPACK_IMPORTED_MODULE_0__.string(type) ? instance.parse(type) : type;
            options.ns = namespace.ns;
            _util_array__WEBPACK_IMPORTED_MODULE_1__.push(listeners[namespace.type] || (listeners[namespace.type] = []), options);
        }
        else if (true) {
            _util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal('emitter.on(type, listener) invoke failed\n\n"listener" is expected to be a Function or an EmitterOptions.\n', cheap__fileName__0, 196);
        }
        return this;
    }
    one(type, listener) {
        if (_util_is__WEBPACK_IMPORTED_MODULE_0__.func(listener)) {
            listener = {
                fn: listener,
                max: 1
            };
        }
        else {
            listener.max = 1;
        }
        return this.on(type, listener);
    }
    /**
     * 
     *
     * @param type
     * @param listener
     */
    off(type, listener) {
        const instance = this, listeners = instance.listeners;
        if (type) {
            const namespace = _util_is__WEBPACK_IMPORTED_MODULE_0__.string(type) ? instance.parse(type) : type, name = namespace.type, ns = namespace.ns, matchListener = createMatchListener(listener), each = function (list, name) {
                _util_array__WEBPACK_IMPORTED_MODULE_1__.each(list, function (options, index) {
                    if (matchListener(options)) {
                        list.splice(index, 1);
                    }
                }, _util_constant__WEBPACK_IMPORTED_MODULE_7__.TRUE);
                if (!list.length) {
                    delete listeners[name];
                }
            }, eachNS = function (list, name) {
                _util_array__WEBPACK_IMPORTED_MODULE_1__.each(list, function (options, index) {
                    if (matchNamespace(ns, options)) {
                        list.splice(index, 1);
                    }
                }, _util_constant__WEBPACK_IMPORTED_MODULE_7__.TRUE);
                if (!list.length) {
                    delete listeners[name];
                }
            };
            if (name) {
                if (listeners[name]) {
                    each(listeners[name], name);
                }
            }
            else if (ns) {
                _util_object__WEBPACK_IMPORTED_MODULE_3__.each(listeners, eachNS);
            }
            /*
             *  listener listener 
             * 
             */
            if (true) {
                if (arguments.length > 1 && listener == _util_constant__WEBPACK_IMPORTED_MODULE_7__.NULL) {
                    _util_logger__WEBPACK_IMPORTED_MODULE_5__.warn(`emitter.off(type, listener) is invoked, but "listener" is ${listener}.`, cheap__fileName__0, 288);
                }
            }
        }
        else {
            // 
            instance.listeners = {};
            /*
             *  type type 
             * 
             */
            if (true) {
                if (arguments.length > 0) {
                    _util_logger__WEBPACK_IMPORTED_MODULE_5__.warn(`emitter.off(type) is invoked, but "type" is ${type}.`, cheap__fileName__0, 302);
                }
            }
        }
    }
    /**
     * 
     *
     * @param type
     * @param listener
     */
    has(type, listener) {
        let instance = this, listeners = instance.listeners, namespace = _util_is__WEBPACK_IMPORTED_MODULE_0__.string(type) ? instance.parse(type) : type, name = namespace.type, ns = namespace.ns, result = _util_constant__WEBPACK_IMPORTED_MODULE_7__.TRUE, matchListener = createMatchListener(listener), each = function (list) {
            _util_array__WEBPACK_IMPORTED_MODULE_1__.each(list, function (options) {
                if (matchListener(options)) {
                    return result = _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE;
                }
            });
            return result;
        }, eachNS = function (list) {
            _util_array__WEBPACK_IMPORTED_MODULE_1__.each(list, function (options) {
                if (matchNamespace(ns, options)) {
                    return result = _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE;
                }
            });
            return result;
        };
        if (name) {
            if (listeners[name]) {
                each(listeners[name]);
            }
        }
        else if (ns) {
            _util_object__WEBPACK_IMPORTED_MODULE_3__.each(listeners, eachNS);
        }
        return !result;
    }
    /**
     * 
     *
     * @param type
     */
    parse(type) {
        /*
         *  ns 
         *  event 
         */
        const result = {
            type,
            ns: _util_constant__WEBPACK_IMPORTED_MODULE_7__.EMPTY_STRING,
        };
        // 
        if (this.ns) {
            const index = _util_string__WEBPACK_IMPORTED_MODULE_4__.indexOf(type, _util_constant__WEBPACK_IMPORTED_MODULE_7__.RAW_DOT);
            if (index >= 0) {
                result.type = _util_string__WEBPACK_IMPORTED_MODULE_4__.slice(type, 0, index);
                result.ns = _util_string__WEBPACK_IMPORTED_MODULE_4__.slice(type, index + 1);
            }
        }
        return result;
    }
}
function matchTrue() {
    return _util_constant__WEBPACK_IMPORTED_MODULE_7__.TRUE;
}
/**
 *  Function  EmitterOptions  
 *
 * 
 *
 *  EmitterOptions
 *
 *  Function
 *
 *  true
 *
 * @param listener
 */
function createMatchListener(listener) {
    return _util_is__WEBPACK_IMPORTED_MODULE_0__.func(listener)
        ? function (options) {
            return listener === options.fn;
        }
        : matchTrue;
}
/**
 *  options 
 *
 *  namespace  options.ns 
 *
 * 
 *
 * @param namespace
 * @param options
 */
function matchNamespace(namespace, options, isFire) {
    const { ns } = options;
    return ns && namespace
        ? ns === namespace
        : (isFire ? _util_constant__WEBPACK_IMPORTED_MODULE_7__.TRUE : _util_constant__WEBPACK_IMPORTED_MODULE_7__.FALSE);
}


/***/ }),

/***/ "./src/common/function/checkVersion.ts":
/*!*********************************************!*\
  !*** ./src/common/function/checkVersion.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ checkVersion)
/* harmony export */ });
/* harmony import */ var _toNumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toNumber */ "./src/common/function/toNumber.ts");
/**
 * @file 
 */

/**
 * 
 *
 * @param version 
 * @param checkVersion 
 * @param equal 
 *
 * @returns 
 */
function checkVersion(version, checkVersion, equal = false) {
    const checkVersionArr = checkVersion.split('.');
    const versionArr = version.split('.');
    for (let i = 0; i < versionArr.length; i++) {
        if (equal && i == (versionArr.length - 1) && (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(versionArr[i]) >= (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(checkVersionArr[i])) {
            return versionArr.length >= checkVersionArr.length;
        }
        if ((0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(versionArr[i]) > (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(checkVersionArr[i])) {
            return true;
        }
        else if ((0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(versionArr[i]) < (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(checkVersionArr[i])) {
            return false;
        }
        if (i === checkVersionArr.length - 1 && i === versionArr.length - 1) {
            return equal;
        }
        if (i === checkVersionArr.length - 1) {
            return true;
        }
        else if (i === versionArr.length - 1) {
            return false;
        }
    }
    return true;
}


/***/ }),

/***/ "./src/common/function/concatTypeArray.ts":
/*!************************************************!*\
  !*** ./src/common/function/concatTypeArray.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ concatTypeArray)
/* harmony export */ });
/**
 * @file  TypeArray
 */
function concatTypeArray(constructor, arrays) {
    if (!arrays.length) {
        return null;
    }
    if (arrays.length === 1) {
        return arrays[0];
    }
    let totalLength = 0;
    let array;
    for (array of arrays) {
        totalLength += array.length;
    }
    let result = new constructor(totalLength);
    let offset = 0;
    for (array of arrays) {
        result.set(array, offset);
        offset += array.length;
    }
    return result;
}


/***/ }),

/***/ "./src/common/function/debounce.ts":
/*!*****************************************!*\
  !*** ./src/common/function/debounce.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ debounce)
/* harmony export */ });
/* harmony import */ var _execute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./execute */ "./src/common/function/execute.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 
 */



/**
 * 
 *
 * @param fn 
 * @param delay 
 * @param immediate 
 * @return 
 */
function debounce(fn, delay, immediate, last = false) {
    let timer;
    let args;
    return function () {
        let context = this;
        if (last) {
            args = _util_array__WEBPACK_IMPORTED_MODULE_1__.toArray(arguments);
        }
        if (!timer) {
            if (!last) {
                args = _util_array__WEBPACK_IMPORTED_MODULE_1__.toArray(arguments);
            }
            if (immediate) {
                (0,_execute__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, context, args);
            }
            timer = setTimeout(function () {
                timer = _util_constant__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED;
                if (!immediate) {
                    (0,_execute__WEBPACK_IMPORTED_MODULE_0__["default"])(fn, context, args);
                }
            }, delay);
        }
    };
}


/***/ }),

/***/ "./src/common/function/execute.ts":
/*!****************************************!*\
  !*** ./src/common/function/execute.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ execute)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 
 */


/**
 * 
 *
 * @param fn 
 * @param context  this 
 * @param args 
 * @return 
 */
function execute(fn, context, args) {
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.func(fn)) {
        return _util_is__WEBPACK_IMPORTED_MODULE_0__.array(args)
            ? fn.apply(context, args)
            : context !== _util_constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED
                ? fn.call(context, args)
                : args !== _util_constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED
                    ? fn(args)
                    : fn();
    }
}


/***/ }),

/***/ "./src/common/function/generateUUID.ts":
/*!*********************************************!*\
  !*** ./src/common/function/generateUUID.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ generateUUID)
/* harmony export */ });
/**
 *  id
 *
 * @internal
 * @returns id
 */
function generateUUID() {
    let d = new Date().getTime();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        let r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
}


/***/ }),

/***/ "./src/common/function/getTimestamp.ts":
/*!*********************************************!*\
  !*** ./src/common/function/getTimestamp.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getTimestamp)
/* harmony export */ });
function getTimestamp() {
    return Date.now();
}


/***/ }),

/***/ "./src/common/function/isAudioWorklet.ts":
/*!***********************************************!*\
  !*** ./src/common/function/isAudioWorklet.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isAudioWorklet)
/* harmony export */ });
function isAudioWorklet() {
    // @ts-ignore
    return typeof registerProcessor === 'function' && typeof sampleRate === 'number' && typeof currentFrame === 'number' && typeof currentTime === 'number';
}


/***/ }),

/***/ "./src/common/function/isDef.ts":
/*!**************************************!*\
  !*** ./src/common/function/isDef.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isDef)
/* harmony export */ });
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 
 */

/**
 * 
 *
 * @param target 
 */
function isDef(target) {
    return target !== _util_constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED;
}


/***/ }),

/***/ "./src/common/function/isLittleEndian.ts":
/*!***********************************************!*\
  !*** ./src/common/function/isLittleEndian.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isLittleEndian)
/* harmony export */ });
/* harmony import */ var _isDef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isDef */ "./src/common/function/isDef.ts");

let _isLittleEndian;
function isLittleEndian() {
    if ((0,_isDef__WEBPACK_IMPORTED_MODULE_0__["default"])(_isLittleEndian)) {
        return _isLittleEndian;
    }
    const buf = new ArrayBuffer(2);
    const view = new DataView(buf);
    // little-endian write
    view.setInt16(0, 256, true);
    // platform-spec read, if equal then LE
    _isLittleEndian = (new Int16Array(buf))[0] === 256;
    return _isLittleEndian;
}


/***/ }),

/***/ "./src/common/function/isNative.ts":
/*!*****************************************!*\
  !*** ./src/common/function/isNative.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isNative)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toString */ "./src/common/function/toString.ts");
/* harmony import */ var _util_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/string */ "./src/common/util/string.ts");
/**
 * @file  native 
 */



/**
 *  native 
 *
 * @param target 
 */
function isNative(target) {
    return _util_is__WEBPACK_IMPORTED_MODULE_0__.func(target) && _util_string__WEBPACK_IMPORTED_MODULE_2__.has((0,_toString__WEBPACK_IMPORTED_MODULE_1__["default"])(target), '[native code]');
}


/***/ }),

/***/ "./src/common/function/isWorker.ts":
/*!*****************************************!*\
  !*** ./src/common/function/isWorker.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isWorker)
/* harmony export */ });
/* harmony import */ var _isDef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isDef */ "./src/common/function/isDef.ts");
/* harmony import */ var _isAudioWorklet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isAudioWorklet */ "./src/common/function/isAudioWorklet.ts");


function isWorker() {
    return !(typeof window === 'object' && (0,_isDef__WEBPACK_IMPORTED_MODULE_0__["default"])(window.document)) && !(0,_isAudioWorklet__WEBPACK_IMPORTED_MODULE_1__["default"])();
}


/***/ }),

/***/ "./src/common/function/nextTick.ts":
/*!*****************************************!*\
  !*** ./src/common/function/nextTick.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isNative__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isNative */ "./src/common/function/isNative.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 
 */


let nextTick;
// IE (10+)  node
if (typeof setImmediate === _util_constant__WEBPACK_IMPORTED_MODULE_1__.RAW_FUNCTION && (0,_isNative__WEBPACK_IMPORTED_MODULE_0__["default"])(setImmediate)) {
    nextTick = setImmediate;
}
/*
 *  MessageChannel  setImmediate  polyfill
 *  message  dom events 
 *  IE10+ 
 */
if (typeof MessageChannel === _util_constant__WEBPACK_IMPORTED_MODULE_1__.RAW_FUNCTION && (0,_isNative__WEBPACK_IMPORTED_MODULE_0__["default"])(MessageChannel)) {
    nextTick = function (fn) {
        const channel = new MessageChannel();
        channel.port1.onmessage = fn;
        channel.port2.postMessage(1);
    };
}
else if (typeof setTimeout === 'function') {
    nextTick = setTimeout;
}
//  setTimeout  WorkletGlobalScope
else {
    nextTick = function (fn) {
        setTimeout(fn);
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nextTick);


/***/ }),

/***/ "./src/common/function/restrain.ts":
/*!*****************************************!*\
  !*** ./src/common/function/restrain.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ restrain)
/* harmony export */ });
/**
 * @file 
 */
/**
 * 
 *
 * @param value 
 * @param min 
 * @param max 
 *
 * @returns 
 */
function restrain(value, min, max) {
    if (value < min) {
        value = min;
    }
    else if (value > max) {
        value = max;
    }
    return value;
}


/***/ }),

/***/ "./src/common/function/sourceLoad.ts":
/*!*******************************************!*\
  !*** ./src/common/function/sourceLoad.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Webpack 
 */
const webpackBootstrapFunc = `
function webpackBootstrapFunc (modules) {
  var installedModules = {};
  function __webpack_require__(moduleId) {
    if(installedModules[moduleId])
    return installedModules[moduleId].exports;
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: false,
      exports: {}
    };
    if (!modules[moduleId]) {
      console.log('can not found module:', moduleId)
    }
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    module.l = true;
    return module.exports;
  }
  __webpack_require__.m = modules;
  __webpack_require__.c = installedModules;
  __webpack_require__.i = function(value) { return value; };
  __webpack_require__.d = function(exports, definition, getter) {
    if (typeof definition === 'string') {
      if(!__webpack_require__.o(exports, definition)) {
        Object.defineProperty(exports, definition, {
          enumerable: true,
          get: getter
        });
      }
    }
    else {
      for(var key in definition) {
        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          });
        }
      }
    }
  };
  __webpack_require__.r = function(exports) {
    if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    	Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
    }
    Object.defineProperty(exports, '__esModule', { value: true });
  };
  __webpack_require__.f = {};
  __webpack_require__.e = function(chunkId) {
    return Promise.all(Object.keys(__webpack_require__.f).reduce(function (promises, key) {
      __webpack_require__.f[key](chunkId, promises);
        return promises;
    	}, []));
	};
  __webpack_require__.u = function(chunkId) {
    return chunkId + "LIB_NAME";
  };
  __webpack_require__.n = function(module) {
    var getter = module && module.__esModule ?
      function getDefault() { return module['default']; } :
      function getModuleExports() { return module; };
    __webpack_require__.d(getter, 'a', getter);
    return getter;
  };
  (function() {
    var installedChunks = {
      "main": 0
    };
    __webpack_require__.f.j = function(chunkId, promises) {
      var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
      if (installedChunkData !== 0) {
        if(installedChunkData) {
          promises.push(installedChunkData[2]);
        } else {
          if (true) {
            var promise = new Promise(function(resolve, reject){installedChunkData = installedChunks[chunkId] = [resolve, reject]});
            promises.push(installedChunkData[2] = promise);
            var url = __webpack_require__.p + __webpack_require__.u(chunkId);
            var error = new Error();
            var loadingEnded = function(event) {
              if(__webpack_require__.o(installedChunks, chunkId)) {
                installedChunkData = installedChunks[chunkId];
                if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
                if(installedChunkData) {
                  var errorType = event && (event.type === 'load' ? 'missing' : event.type);
                  var realSrc = url;
                  error.message = "Loading chunk " + chunkId + " failed.\\n(" + errorType + ": " + realSrc + ")";
                  error.name = "ChunkLoadError";
                  error.type = errorType;
                  error.request = realSrc;
                  installedChunkData[1](error);
                }
              }
            };
            __webpack_require__.l(url, loadingEnded);
          }
        }
      }
    };
    var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
    var [chunkIds, moreModules, runtime] = data;
    var moduleId, chunkId, i = 0;
    if (chunkIds.some(function(id){return installedChunks[id] !== 0})) {
      for(moduleId in moreModules) {
        if(__webpack_require__.o(moreModules, moduleId)) {
          __webpack_require__.m[moduleId] = moreModules[moduleId];
        }
      }
      if(runtime) runtime(__webpack_require__);
    }
    if (parentChunkLoadingFunction) parentChunkLoadingFunction(data);
      for (;i < chunkIds.length; i++) {
        chunkId = chunkIds[i];
        if (__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
          installedChunks[chunkId][0]();
        }
        installedChunks[chunkId] = 0;
      }
    }
    var self = typeof globalThis !== undefined ? globalThis : self
    var exportName = 'LIBRARY_EXPORT_NAME'
    var chunkLoadingGlobal = self["webpackChunk" + exportName] = self["webpackChunk" + exportName] || [];
    chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
    chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
  })();
  (function() {
    var inProgress = {};
    __webpack_require__.l = function(url, done) {
      if (inProgress[url]) { inProgress[url].push(done); return; }
        inProgress[url] = [done];
        var onComplete = function(event) {
          clearTimeout(timeout);
          var doneFns = inProgress[url];
          delete inProgress[url];
          doneFns && doneFns.forEach(function(fn){fn(event)});
        }
        var timeout = setTimeout(onComplete.bind(null, undefined, { type: "timeout" }), 120000);
      import(url).then(function() {
        onComplete({
          type: "load"
        })
      }, function (error) {
        onComplete({
          type: "missing"
        })
      });
    };
  })();
  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  __webpack_require__.p = "ROOT_URL";
  __webpack_require__.oe = function(err) { console.error(err); throw err; };
  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE);
  return f;
}
`;
const moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@|!]+';
// additional chars when output.path info is true
const dependencyRegExp = '\\(\\s*(\/\\*.*?\\*\/)?\\s*.*?(' + moduleNameReqExp + ').*?\\)';
// http://stackoverflow.com/a/2593661/130442
function quoteRegExp(str) {
    return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}
function isNumeric(n) {
    // 1 * n converts integers, integers as string ("123"), 1e3 and "1e3" to integers and strings to NaN
    return !isNaN(n);
}
function getModuleDependencies(sources, module, queueName, requiredModules) {
    const retval = {};
    retval[queueName] = [];
    let fnString = module.toString();
    const wrapperSignature = fnString.match(/^(function)?\s?\w*\(\w+,\s*(\w+),\s*(\w+)\)/);
    if (!wrapperSignature) {
        return retval;
    }
    const webpackRequireName = wrapperSignature[3];
    if (!requiredModules.__webpack_exports_process__) {
        requiredModules.__webpack_require__ = webpackRequireName;
        requiredModules.__webpack_exports__ = wrapperSignature[2];
        requiredModules.__webpack_exports_process__ = true;
    }
    // main bundle deps
    let re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g');
    let match;
    while ((match = re.exec(fnString))) {
        if (match[3] === 'dll-reference') {
            continue;
        }
        retval[queueName].push(match[3]);
    }
    // dll deps
    re = new RegExp('\\(' + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, 'g');
    while ((match = re.exec(fnString))) {
        if (!sources[match[2]]) {
            retval[queueName].push(match[1]);
            // @ts-ignore
            sources[match[2]] = __webpack_require__(match[1]).m;
        }
        retval[match[2]] = retval[match[2]] || [];
        retval[match[2]].push(match[4]);
    }
    // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3
    const keys = Object.keys(retval);
    for (let i = 0; i < keys.length; i++) {
        for (let j = 0; j < retval[keys[i]].length; j++) {
            if (isNumeric(+retval[keys[i]][j])) {
                retval[keys[i]][j] = +retval[keys[i]][j];
            }
        }
    }
    return retval;
}
function hasValuesInQueues(queues) {
    const keys = Object.keys(queues);
    return keys.reduce(function (hasValues, key) {
        return hasValues || queues[key].length > 0;
    }, false);
}
function getRequiredModules(sources, moduleId) {
    const modulesQueue = {
        main: [moduleId]
    };
    const requiredModules = {
        main: [],
        __webpack_exports__: '__webpack_exports__',
        __webpack_require__: '__webpack_require__',
        __webpack_exports_process__: false
    };
    const seenModules = {
        main: {}
    };
    while (hasValuesInQueues(modulesQueue)) {
        const queues = Object.keys(modulesQueue);
        for (let i = 0; i < queues.length; i++) {
            let queueName = queues[i];
            let queue = modulesQueue[queueName];
            let moduleToCheck = queue.pop();
            seenModules[queueName] = seenModules[queueName] || {};
            if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) {
                continue;
            }
            seenModules[queueName][moduleToCheck] = true;
            requiredModules[queueName] = requiredModules[queueName] || [];
            requiredModules[queueName].push(moduleToCheck);
            let newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName, requiredModules);
            let newModulesKeys = Object.keys(newModules);
            for (let j = 0; j < newModulesKeys.length; j++) {
                modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || [];
                modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]]);
            }
        }
    }
    return requiredModules;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(moduleId, options) {
    const sources = {
        // @ts-ignore
        main: __webpack_require__.m
    };
    const requiredModules = getRequiredModules(sources, moduleId);
    let src = '';
    let stringifyModuleId = JSON.stringify(moduleId);
    return src + 'var ' + options.varName + '=(' + webpackBootstrapFunc.replace('ENTRY_MODULE', stringifyModuleId)
        // @ts-ignore
        .replace('ROOT_URL', __webpack_require__.p || '')
        // @ts-ignore
        .replace('LIBRARY_EXPORT_NAME', 'AVPlayer')
        // @ts-ignore
        .replace('LIB_NAME', __webpack_require__.u && __webpack_require__.u('') || '')
        + ')({' + requiredModules.main.map(function (id) {
        const stringifyId = JSON.stringify(id);
        let source = '' + stringifyId + ': ' + sources.main[id].toString();
        if (stringifyId === stringifyModuleId && options.exportName && options.pointName) {
            const line = `;${requiredModules.__webpack_require__}.d(
          ${requiredModules.__webpack_exports__},
          "${options.exportName}",
          function() {
            if (${options.exportIsClass}) {
              for (var key in ${requiredModules.__webpack_exports__}) {
                if (key === '${options.exportName}') {
                  continue;
                }
                var v = ${requiredModules.__webpack_exports__}[key];
                if (typeof v === 'function' && v.name === '${options.pointName}') {
                  return v;
                }
              }
            }
            return ${options.pointName};
          }
        );`;
            source = source.slice(0, source.length - 1) + line + '}';
        }
        return source;
    }).join(',') + '});';
}


/***/ }),

/***/ "./src/common/function/split.ts":
/*!**************************************!*\
  !*** ./src/common/function/split.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ split)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/**
 * @file  trim 
 */


/**
 *  trim 
 *
 * @param str 
 * @param sep 
 */
function split(str, sep) {
    const result = [];
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.number(str)) {
        str = str + '';
    }
    if (str && _util_is__WEBPACK_IMPORTED_MODULE_0__.string(str)) {
        _util_array__WEBPACK_IMPORTED_MODULE_1__.each(str.split(sep), (part, index) => {
            part = part.trim();
            if (part) {
                result.push(part);
            }
        });
    }
    return result;
}


/***/ }),

/***/ "./src/common/function/toNumber.ts":
/*!*****************************************!*\
  !*** ./src/common/function/toNumber.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toNumber)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file  number
 */


/**
 *  number
 *
 * @param target 
 * @param defaultValue 
 *
 * @returns 
 */
function toNumber(target, defaultValue) {
    return _util_is__WEBPACK_IMPORTED_MODULE_0__.numeric(target)
        ? +target
        : defaultValue !== _util_constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED
            ? defaultValue
            : 0;
}


/***/ }),

/***/ "./src/common/function/toString.ts":
/*!*****************************************!*\
  !*** ./src/common/function/toString.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toString)
/* harmony export */ });
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file  string
 */

/**
 *  string
 *
 * @param target 
 * @param defaultValue 
 * @returns 
 */
function toString(target, defaultValue) {
    return target != _util_constant__WEBPACK_IMPORTED_MODULE_0__.NULL && target.toString
        ? target.toString()
        : defaultValue !== _util_constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED
            ? defaultValue
            : _util_constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STRING;
}


/***/ }),

/***/ "./src/common/helper/CommandQueue.ts":
/*!*******************************************!*\
  !*** ./src/common/helper/CommandQueue.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CommandQueue)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/**
 * 
 */


class CommandQueue {
    queue;
    constructor() {
        this.queue = [];
    }
    async execute(command) {
        try {
            const result = await command.task();
            command.resolve(result);
        }
        catch (error) {
            command.reject(error);
        }
    }
    async next() {
        if (this.queue.length) {
            const command = this.queue[0];
            if (command.error) {
                command.reject(command.error);
            }
            else {
                await this.execute(command);
            }
            this.queue.shift();
            if (this.queue.length) {
                this.next();
            }
        }
    }
    async push(task) {
        if (!_util_is__WEBPACK_IMPORTED_MODULE_0__.func(task)) {
            throw new TypeError('task must be a function');
        }
        return new Promise((resolve, reject) => {
            const command = {
                task,
                resolve,
                reject
            };
            this.queue.push(command);
            if (this.queue.length === 1) {
                this.next();
            }
        });
    }
    clear(error) {
        _util_array__WEBPACK_IMPORTED_MODULE_1__.each(this.queue, (command) => {
            command.error = error || new Error('command queue clear');
        });
    }
    clearPadding() {
        this.queue.length = 0;
    }
    get length() {
        return this.queue.length;
    }
}


/***/ }),

/***/ "./src/common/helper/IntervalQueueTask.ts":
/*!************************************************!*\
  !*** ./src/common/helper/IntervalQueueTask.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IntervalQueueTask)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _timer_Timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../timer/Timer */ "./src/common/timer/Timer.ts");
/* harmony import */ var _function_getTimestamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/**
 * 
 */



class IntervalQueueTask {
    queue;
    timer;
    ended;
    onEnd;
    lastTime;
    interval;
    constructor(interval, timeout = 0) {
        this.queue = [];
        this.interval = interval;
        this.timer = new _timer_Timer__WEBPACK_IMPORTED_MODULE_1__["default"](() => {
            if (this.queue.length) {
                this.queue.shift()();
            }
            else if (this.ended) {
                if (this.onEnd) {
                    this.onEnd();
                }
                this.timer.stop();
            }
            else {
                this.lastTime = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_2__["default"])();
            }
        }, timeout, interval);
    }
    push(task) {
        if (!_util_is__WEBPACK_IMPORTED_MODULE_0__.func(task)) {
            throw new TypeError('task must be a function');
        }
        this.ended = false;
        const now = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_2__["default"])();
        if (this.timer.isStarted() && !this.queue.length && (now - this.lastTime > this.interval)) {
            task();
            this.lastTime = now;
        }
        else {
            this.queue.push(task);
            if (this.queue.length === 1 && !this.timer.isStarted()) {
                this.timer.start();
            }
        }
    }
    end() {
        this.ended = true;
    }
    reset() {
        this.timer.stop();
        this.queue.length = 0;
    }
}


/***/ }),

/***/ "./src/common/interface/ArrayLike.ts":
/*!*******************************************!*\
  !*** ./src/common/interface/ArrayLike.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ArrayLike)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");

class ArrayLike {
    proxy;
    constructor() {
        this.proxy = new Proxy(this, {
            get(target, p, receiver) {
                if (_util_is__WEBPACK_IMPORTED_MODULE_0__.numeric(p)) {
                    return target.getIndexValue(+p);
                }
                else {
                    return target[p];
                }
            },
            set(target, p, newValue, receiver) {
                if (_util_is__WEBPACK_IMPORTED_MODULE_0__.numeric(p)) {
                    target.setIndexValue(+p, newValue);
                }
                else {
                    target[p] = newValue;
                }
                return true;
            }
        });
    }
}


/***/ }),

/***/ "./src/common/io/BitReader.ts":
/*!************************************!*\
  !*** ./src/common/io/BitReader.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BitReader)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\common\\io\\BitReader.ts";

class BitReader {
    buffer;
    pointer;
    bitsLeft;
    size;
    endPointer;
    pos;
    error;
    onFlush;
    /**
     * @param data 
     * @param bigEndian 
     */
    constructor(size = 1048576) {
        this.pointer = 0;
        this.bitsLeft = 8;
        this.pos = BigInt(0);
        this.size = size;
        this.endPointer = 0;
        this.error = 0;
        this.buffer = new Uint8Array(this.size);
    }
    /**
     *  1 
     */
    peekU1() {
        let result = 0;
        if (this.remainingLength() < 1 || this.remainingLength() === 1 && this.bitsLeft === 0) {
            this.flush();
        }
        let pointer = this.pointer;
        let bitsLeft = this.bitsLeft;
        if (bitsLeft === 0) {
            pointer++;
            bitsLeft = 8;
        }
        result = (this.buffer[pointer] >> (bitsLeft - 1)) & 0x01;
        return result;
    }
    /**
     *  1 
     */
    readU1() {
        let result = 0;
        if (this.remainingLength() < 1 || this.remainingLength() === 1 && this.bitsLeft === 0) {
            this.flush();
        }
        this.bitsLeft--;
        result = (this.buffer[this.pointer] >> this.bitsLeft) & 0x01;
        if (this.bitsLeft === 0) {
            this.pointer++;
            this.bitsLeft = 8;
            this.pos++;
        }
        return result;
    }
    /**
     *  n 
     *
     * @param n
     */
    readU(n) {
        let result = 0;
        for (let i = 0; i < n; i++) {
            result |= (this.readU1() << (n - i - 1));
        }
        return result;
    }
    /**
     *  n 
     *
     * @param n
     */
    peekU(n) {
        const pointer = this.pointer;
        const bitsLeft = this.bitsLeft;
        const pos = this.pos;
        const result = this.readU(n);
        this.pointer = pointer;
        this.bitsLeft = bitsLeft;
        this.pos = pos;
        return result;
    }
    /**
     * 
     *
     * @returns
     */
    remainingLength() {
        return this.endPointer - this.pointer;
    }
    /**
     *  bit 
     *
     * @returns
     */
    getBitLeft() {
        return this.bitsLeft;
    }
    /**
     * 
     *
     * @returns
     */
    getPointer() {
        return this.pointer;
    }
    /**
     * 
     *
     * @param pointer
     */
    setPointer(pointer) {
        this.pointer = pointer;
    }
    /**
     * 
     *
     * @returns
     */
    getPos() {
        return this.pos;
    }
    /**
     *  bit 
     *
     * @param n
     */
    skip(n) {
        const byte = (n - (n % 8)) / 8;
        this.pointer += byte;
        this.pos += BigInt(byte);
        const bitsLeft = n % 8;
        if (this.bitsLeft <= bitsLeft) {
            this.pointer++;
            this.pos++;
            this.bitsLeft = 8 - (bitsLeft - this.bitsLeft);
        }
        else {
            this.bitsLeft -= bitsLeft;
        }
    }
    /**
     * 
     */
    flush() {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOReader error, flush failed because of no flush callback');
        }
        if (this.bitsLeft === 0) {
            this.pointer++;
            this.pos++;
        }
        if (this.size - this.remainingLength() <= 0) {
            return;
        }
        if (this.pointer < this.endPointer) {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            const len = this.onFlush(this.buffer.subarray(this.endPointer - this.pointer, this.size));
            if (len < 0) {
                this.error = len;
                throw Error('IOReader error, flush failed');
            }
            this.endPointer = this.endPointer - this.pointer + len;
            this.pointer = 0;
        }
        else {
            const len = this.onFlush(this.buffer);
            this.endPointer = len;
            this.pointer = 0;
            this.bitsLeft = 8;
            if (len < 0) {
                this.error = len;
                throw Error('IOReader error, flush failed');
            }
        }
    }
    /**
     * 
     *
     * @returns
     */
    getBuffer() {
        return this.buffer;
    }
    appendBuffer(buffer) {
        if (this.size - this.endPointer >= buffer.length) {
            this.buffer.set(buffer, this.endPointer);
            this.endPointer += buffer.length;
        }
        else {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            this.endPointer = this.endPointer - this.pointer;
            this.pointer = 0;
            if (this.size - this.endPointer >= buffer.length) {
                this.buffer.set(buffer, this.endPointer);
                this.endPointer += buffer.length;
            }
            else {
                const len = Math.min(this.size - this.endPointer, buffer.length);
                this.buffer.set(buffer.subarray(0, len), this.endPointer);
                this.endPointer += len;
                _util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('BSReader, call appendBuffer but the buffer\'s size is lagger then the remaining size', cheap__fileName__0, 257);
            }
        }
    }
    /**
     * 
     */
    reset() {
        this.pointer = this.endPointer = 0;
        this.bitsLeft = 8;
        this.error = 0;
        this.pos = BigInt(0);
    }
    /**
     *  bit 
     */
    skipPadding() {
        if (this.bitsLeft < 8) {
            this.bitsLeft = 8;
            this.pointer++;
            this.pos++;
        }
    }
}


/***/ }),

/***/ "./src/common/io/BitWriter.ts":
/*!************************************!*\
  !*** ./src/common/io/BitWriter.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BitWriter)
/* harmony export */ });
/**
 * bit 
 */
/**
 * 
 */
class BitWriter {
    buffer;
    pointer;
    pos;
    bitPointer;
    size;
    error;
    onFlush;
    /**
     * @param data  Uint8Array
     */
    constructor(size = 1048576) {
        this.pointer = 0;
        this.bitPointer = 0;
        this.size = size;
        this.error = 0;
        this.pos = BigInt(0);
        this.buffer = new Uint8Array(this.size);
    }
    /**
     *  bit
     *
     * @param bit
     */
    writeU1(bit) {
        if (this.remainingLength() < 1 || this.remainingLength() === 1 && this.bitPointer >= 8) {
            this.flush();
        }
        if (bit & 0x01) {
            this.buffer[this.pointer] |= (1 << (7 - this.bitPointer));
        }
        else {
            this.buffer[this.pointer] &= ~(1 << (7 - this.bitPointer));
        }
        this.bitPointer++;
        if (this.bitPointer === 8) {
            this.pointer++;
            this.pos++;
            this.bitPointer = 0;
        }
    }
    /**
     *  n 
     *
     * @param n
     */
    writeU(n, v) {
        for (let i = 0; i < n; i++) {
            this.writeU1(v >> (n - i - 1) & 0x01);
        }
    }
    /**
     * 
     *
     * @returns
     */
    remainingLength() {
        return this.size - this.pointer;
    }
    /**
     * 
     */
    flush() {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('BSWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            if (this.bitPointer && this.pointer > 1) {
                const ret = this.onFlush(this.buffer.subarray(0, this.pointer - 1));
                if (ret !== 0) {
                    this.error = ret;
                    throw Error('BSWriter error, flush failed');
                }
                this.buffer[0] = this.buffer[this.pointer];
            }
            else if (this.bitPointer === 0) {
                const ret = this.onFlush(this.buffer.subarray(0, this.pointer));
                if (ret !== 0) {
                    this.error = ret;
                    throw Error('BSWriter error, flush failed');
                }
            }
        }
        this.pointer = 0;
    }
    /**
     *  bit  0 
     */
    padding() {
        while (this.bitPointer !== 0) {
            this.writeU1(0);
        }
    }
    /**
     * 
     */
    reset() {
        this.pointer = 0;
        this.bitPointer = 0;
        this.error = 0;
        this.pos = BigInt(0);
    }
    /**
     * 
     *
     * @returns
     */
    getBuffer() {
        return this.buffer;
    }
    /**
     * 
     *
     * @returns
     */
    getPointer() {
        return this.pointer;
    }
    /**
     * 
     *
     * @returns
     */
    getPos() {
        return this.pos;
    }
}


/***/ }),

/***/ "./src/common/io/BufferReader.ts":
/*!***************************************!*\
  !*** ./src/common/io/BufferReader.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BufferReader)
/* harmony export */ });
/* harmony import */ var _function_concatTypeArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function/concatTypeArray */ "./src/common/function/concatTypeArray.ts");
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/**
 * 
 */


class BufferReader {
    data;
    buffer;
    byteStart;
    pos;
    size;
    littleEndian;
    /**
     * @param data 
     * @param bigEndian 
     */
    constructor(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
    /**
     *  8 
     *
     * @returns
     */
    readUint8() {
        return this.data.getUint8(this.pos++ + this.byteStart);
    }
    /**
     *  16 
     *
     * @returns
     */
    readUint16() {
        const value = this.data.getUint16(this.pos + this.byteStart, this.littleEndian);
        this.pos += 2;
        return value;
    }
    /**
     *  24 
     *
     * @returns
     */
    readUint24() {
        const high = this.readUint16();
        const low = this.readUint8();
        return this.littleEndian ? (low << 16 | high) : (high << 8 | low);
    }
    /**
     *  32 
     *
     * @returns
     */
    readUint32() {
        const value = this.data.getUint32(this.pos + this.byteStart, this.littleEndian);
        this.pos += 4;
        return value;
    }
    /**
     *  64 
     *
     * @returns
     */
    readUint64() {
        const high = BigInt(this.readUint32());
        const low = BigInt(this.readUint32());
        if (this.littleEndian) {
            return low << BigInt(32) | high;
        }
        else {
            return high << BigInt(32) | low;
        }
    }
    /**
     *  8 
     *
     * @returns
     */
    readInt8() {
        return this.data.getInt8(this.pos++ + this.byteStart);
    }
    /**
     *  16 
     *
     * @returns
     */
    readInt16() {
        const value = this.data.getInt16(this.pos + this.byteStart, this.littleEndian);
        this.pos += 2;
        return value;
    }
    /**
     *  24 
     *
     * @returns
     */
    readInt24() {
        const value = this.readUint24();
        return (value & 0x800000) ? (value - 0x1000000) : value;
    }
    /**
     *  32 
     *
     * @returns
     */
    readInt32() {
        const value = this.data.getInt32(this.pos + this.byteStart, this.littleEndian);
        this.pos += 4;
        return value;
    }
    /**
     *  64 
     *
     * @returns
     */
    readInt64() {
        const high = BigInt(this.readInt32());
        const low = BigInt(this.readInt32());
        if (this.littleEndian) {
            return low << BigInt(32) | high;
        }
        else {
            return high << BigInt(32) | low;
        }
    }
    /**
     * 
     *
     * @returns
     */
    readFloat() {
        const value = this.data.getFloat32(this.pos + this.byteStart, this.littleEndian);
        this.pos += 4;
        return value;
    }
    /**
     * 
     *
     * @returns
     */
    readDouble() {
        const value = this.data.getFloat64(this.pos + this.byteStart, this.littleEndian);
        this.pos += 8;
        return value;
    }
    /**
     *  16 
     *
     * @param length  1
     * @returns
     */
    readHex(length = 1) {
        let hexStr = '';
        for (let i = 0; i < length; i++) {
            const hex = this.readUint8().toString(16);
            hexStr += (hex.length === 1 ? '0' + hex : hex);
        }
        return hexStr;
    }
    /**
     * 
     *
     * @param length  1
     * @returns
     */
    readString(length = 1) {
        let str = '';
        if (length) {
            let start = this.pos;
            for (let i = 0; i < length; i++) {
                if (this.buffer[this.pos + i] === 0) {
                    start++;
                }
                else {
                    break;
                }
            }
            str = _util_text__WEBPACK_IMPORTED_MODULE_1__.decode(this.buffer.subarray(start, start + length));
        }
        this.pos += length;
        return str;
    }
    /**
     * 
     */
    readLine() {
        let str = '';
        for (let i = this.pos; i < this.size; i++) {
            if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                str += this.readString(i - this.pos);
                break;
            }
        }
        for (let i = this.pos; i < this.size; i++) {
            if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                this.readUint8();
            }
            else {
                break;
            }
        }
        return str;
    }
    /**
     * 
     *
     * @returns
     */
    getPos() {
        return BigInt(this.pos);
    }
    /**
     * seek 
     *
     * @param pos
     */
    seek(pos) {
        if (pos > this.size) {
            pos = this.size;
        }
        this.pos = Math.max(0, pos);
    }
    /**
     * 
     *
     * @param length
     */
    skip(length) {
        this.seek(this.pos + length);
    }
    /**
     * 
     *
     * @param length
     */
    back(length) {
        this.seek(this.pos - length);
    }
    /**
     * 
     *
     * @returns
     */
    remainingSize() {
        return this.size - this.pos;
    }
    /**
     *  buffer 
     *
     * @param length
     * @returns
     */
    readBuffer(length) {
        length = Math.min(length, this.remainingSize());
        const buffer = this.buffer.slice(this.pos, this.pos + length);
        this.pos += length;
        return buffer;
    }
    /**
     *  buffer
     *
     * @param buffer
     */
    appendBuffer(buffer) {
        this.buffer = (0,_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_0__["default"])(Uint8Array, [
            this.buffer.slice(),
            buffer.slice()
        ]);
        this.data = new DataView(this.buffer.buffer);
        this.size += buffer.byteLength;
        this.byteStart = 0;
    }
    /**
     * 
     *
     * @param data
     * @param bigEndian
     */
    resetBuffer(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
}


/***/ }),

/***/ "./src/common/io/BufferWriter.ts":
/*!***************************************!*\
  !*** ./src/common/io/BufferWriter.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BufferWriter)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
var cheap__fileName__0 = "src\\common\\io\\BufferWriter.ts";
/**
 * 
 */


class BufferWriter {
    data;
    buffer;
    byteStart;
    pos;
    size;
    littleEndian;
    /**
     * @param data  Uint8Array
     * @param bigEndian 
     */
    constructor(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
    /**
     *  8 
     */
    writeUint8(value) {
        this.data.setUint8(this.pos++ + this.byteStart, value);
    }
    /**
     *  16 
     */
    writeUint16(value) {
        this.data.setUint16(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 2;
    }
    /**
     *  24 
     */
    writeUint24(value) {
        const high = value & 0xf00;
        const middle = value & 0x0f0;
        const low = value & 0x00f;
        if (this.littleEndian) {
            this.writeUint8(low);
            this.writeUint8(middle);
            this.writeUint8(high);
        }
        else {
            this.writeUint8(high);
            this.writeUint8(middle);
            this.writeUint8(low);
        }
    }
    /**
     *  32 
     */
    writeUint32(value) {
        this.data.setUint32(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 4;
    }
    /**
     *  64 
     */
    writeUint64(value) {
        const low = value & BigInt(0xffffffff);
        const high = (value & (BigInt(0xffffffff) << BigInt(32))) >> BigInt(32);
        if (this.littleEndian) {
            this.writeUint32(Number(low));
            this.writeUint32(Number(high));
        }
        else {
            this.writeUint32(Number(high));
            this.writeUint32(Number(low));
        }
    }
    /**
     *  8 
     *
     * @returns
     */
    writeInt8(value) {
        this.data.setInt8(this.pos++ + this.byteStart, value);
    }
    /**
     *  16 
     */
    writeInt16(value) {
        this.data.setInt16(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 2;
    }
    /**
     *  24 
     */
    writeInt24(value) {
        this.writeUint24(value < 0 ? (value + 0x1000000) : value);
    }
    /**
     *  32 
     */
    writeInt32(value) {
        this.data.setInt32(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 4;
    }
    /**
     *  64 
     */
    writeInt64(value) {
        const low = value & BigInt(0xffffffff);
        const high = (value & (BigInt(0xffffffff) << BigInt(32))) >> BigInt(32);
        if (this.littleEndian) {
            this.writeInt32(Number(low));
            this.writeInt32(Number(high));
        }
        else {
            this.writeInt32(Number(high));
            this.writeInt32(Number(low));
        }
    }
    /**
     * 
     *
     * @returns
     */
    writeFloat(value) {
        this.data.setFloat32(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 4;
    }
    /**
     * 
     */
    writeDouble(value) {
        this.data.setFloat64(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 8;
    }
    /**
     * 
     *
     * @returns
     */
    getPos() {
        return this.pos;
    }
    /**
     * seek 
     *
     * @param pos
     */
    seek(pos) {
        if (pos > this.size) {
            pos = this.size;
        }
        this.pos = Math.max(0, pos);
    }
    /**
     * 
     *
     * @param length
     */
    skip(length) {
        this.seek(this.pos + length);
    }
    /**
     * 
     *
     * @param length
     */
    back(length) {
        this.seek(this.pos - length);
    }
    /**
     * 
     *
     * @returns
     */
    remainingSize() {
        return this.size - this.pos;
    }
    /**
     *  buffer 
     *
     * @param length
     * @returns
     */
    writeBuffer(buffer) {
        let length = buffer.length;
        if (this.remainingSize() < length) {
            length = this.remainingSize();
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.warn(`the remaining buffer size is smaller then the wrote buffer, hope set ${buffer.length}, but set ${length}`, cheap__fileName__0, 218);
        }
        this.buffer.set(buffer, this.pos);
        this.pos += buffer.length;
    }
    /**
     * 
     */
    writeString(str) {
        const buffer = _util_text__WEBPACK_IMPORTED_MODULE_1__.encode(str);
        this.writeBuffer(buffer);
        return buffer.length;
    }
    /**
     * 
     *
     * @returns
     */
    getWroteBuffer() {
        return this.buffer.subarray(0, this.pos);
    }
    /**
     * 
     *
     * @param data
     * @param bigEndian
     */
    resetBuffer(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
}


/***/ }),

/***/ "./src/common/io/IOReader.ts":
/*!***********************************!*\
  !*** ./src/common/io/IOReader.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOReader)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/* harmony import */ var _timer_Sleep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../timer/Sleep */ "./src/common/timer/Sleep.ts");
var cheap__fileName__0 = "src\\common\\io\\IOReader.ts";



class IOReader {
    data;
    buffer;
    pointer;
    endPointer;
    pos;
    size;
    littleEndian;
    fileSize_;
    error;
    onFlush;
    onSeek;
    onSize;
    flags;
    /**
     * @param data 
     * @param bigEndian 
     */
    constructor(size = 1048576, bigEndian = true, map) {
        this.pos = BigInt(0);
        this.pointer = 0;
        this.error = 0;
        this.endPointer = 0;
        this.littleEndian = !bigEndian;
        this.flags = 0;
        if (map && map.view) {
            this.size = map.length;
            this.buffer = map;
            this.data = map.view;
        }
        else if (map && !map.byteOffset) {
            this.size = map.length;
            this.buffer = map;
            this.data = new DataView(this.buffer.buffer);
        }
        else {
            if (map) {
                throw new Error('not support subarray of ArrayBuffer');
            }
            this.size = Math.max(size, 102400);
            this.buffer = new Uint8Array(this.size);
            this.data = new DataView(this.buffer.buffer);
        }
    }
    /**
     *  8 
     *
     * @returns
     */
    async readUint8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        const value = this.data.getUint8(this.pointer);
        this.pointer++;
        this.pos++;
        return value;
    }
    /**
     *  8 
     *
     * @returns
     */
    async peekUint8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        return this.data.getUint8(this.pointer);
    }
    /**
     *  16 
     *
     * @returns
     */
    async readUint16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        const value = this.data.getUint16(this.pointer, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
        return value;
    }
    /**
     *  16 
     *
     * @returns
     */
    async peekUint16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        return this.data.getUint16(this.pointer, this.littleEndian);
    }
    /**
     *  24 
     *
     * @returns
     */
    async readUint24() {
        if (this.remainingLength() < 3) {
            await this.flush(3);
        }
        const high = await this.readUint16();
        const low = await this.readUint8();
        return this.littleEndian ? (low << 16 | high) : (high << 8 | low);
    }
    /**
     *  24 
     *
     * @returns
     */
    async peekUint24() {
        if (this.remainingLength() < 3) {
            await this.flush(3);
        }
        const pointer = this.pointer;
        const pos = this.pos;
        const high = await this.readUint16();
        const low = await this.readUint8();
        const value = this.littleEndian ? (low << 16 | high) : (high << 8 | low);
        this.pointer = pointer;
        this.pos = pos;
        return value;
    }
    /**
     *  32 
     *
     * @returns
     */
    async readUint32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        const value = this.data.getUint32(this.pointer, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
        return value;
    }
    /**
     *  32 
     *
     * @returns
     */
    async peekUint32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        return this.data.getUint32(this.pointer, this.littleEndian);
    }
    /**
     *  64 
     *
     * @returns
     */
    async readUint64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        const value = this.data.getBigUint64(this.pointer, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
        return value;
    }
    /**
     *  64 
     *
     * @returns
     */
    async peekUint64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        return this.data.getBigUint64(this.pointer, this.littleEndian);
    }
    /**
     *  8 
     *
     * @returns
     */
    async readInt8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        const value = this.data.getInt8(this.pointer);
        this.pointer++;
        this.pos++;
        return value;
    }
    /**
     *  8 
     *
     * @returns
     */
    async peekInt8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        return this.data.getInt8(this.pointer);
    }
    /**
     *  16 
     *
     * @returns
     */
    async readInt16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        const value = this.data.getInt16(this.pointer, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
        return value;
    }
    /**
     *  16 
     *
     * @returns
     */
    async peekInt16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        return this.data.getInt16(this.pointer, this.littleEndian);
    }
    /**
     *  24 
     *
     * @returns
     */
    async readInt24() {
        const value = await this.readUint24();
        return (value & 0x800000) ? (value - 0x1000000) : value;
    }
    /**
     *  24 
     *
     * @returns
     */
    async peekInt24() {
        const value = await this.peekUint24();
        return (value & 0x800000) ? (value - 0x1000000) : value;
    }
    /**
     *  32 
     *
     * @returns
     */
    async readInt32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        const value = this.data.getInt32(this.pointer, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
        return value;
    }
    /**
     *  32 
     *
     * @returns
     */
    async peekInt32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        return this.data.getInt32(this.pointer, this.littleEndian);
    }
    /**
     *  64 
     *
     * @returns
     */
    async readInt64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        const value = this.data.getBigInt64(this.pointer, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
        return value;
    }
    /**
     *  64 
     *
     * @returns
     */
    async peekInt64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        return this.data.getBigInt64(this.pointer, this.littleEndian);
    }
    /**
     * 
     *
     * @returns
     */
    async readFloat() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        const value = this.data.getFloat32(this.pointer, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
        return value;
    }
    /**
     * 
     *
     * @returns
     */
    async peekFloat() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        return this.data.getFloat32(this.pointer, this.littleEndian);
    }
    /**
     * 
     *
     * @returns
     */
    async readDouble() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        const value = this.data.getFloat64(this.pointer, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
        return value;
    }
    /**
     * 
     *
     * @returns
     */
    async peekDouble() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        return this.data.getFloat64(this.pointer, this.littleEndian);
    }
    /**
     *  16 
     *
     * @param length  1
     * @returns
     */
    async readHex(length = 1) {
        let hexStr = '';
        for (let i = 0; i < length; i++) {
            const hex = (await this.readUint8()).toString(16);
            hexStr += (hex.length === 1 ? '0' + hex : hex);
        }
        return hexStr;
    }
    /**
     *  16 
     *
     * @param length  1
     * @returns
     */
    async peekHex(length = 1) {
        if (length > this.size) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('peekHex, length too large', cheap__fileName__0, 414);
        }
        if (this.remainingLength() < length) {
            await this.flush(length);
        }
        const pointer = this.pointer;
        const pos = this.pos;
        let hexStr = '';
        for (let i = 0; i < length; i++) {
            const hex = (await this.readUint8()).toString(16);
            hexStr += (hex.length === 1 ? '0' + hex : hex);
        }
        this.pointer = pointer;
        this.pos = pos;
        return hexStr;
    }
    async readBuffer(length, buffer) {
        if (!buffer) {
            buffer = new Uint8Array(length);
        }
        if (this.remainingLength() < length) {
            let index = 0;
            if (this.remainingLength() > 0) {
                const len = this.remainingLength();
                buffer.set(this.buffer.subarray(this.pointer, this.pointer + len), index);
                index += len;
                this.pointer += len;
                this.pos += BigInt(len);
                length -= len;
            }
            while (length > 0) {
                await this.flush();
                const len = Math.min(this.endPointer - this.pointer, length);
                buffer.set(this.buffer.subarray(this.pointer, this.pointer + len), index);
                index += len;
                this.pointer += len;
                this.pos += BigInt(len);
                length -= len;
            }
        }
        else {
            buffer.set(this.buffer.subarray(this.pointer, this.pointer + length), 0);
            this.pointer += length;
            this.pos += BigInt(length);
        }
        return buffer;
    }
    async peekBuffer(length, buffer) {
        if (length > this.size) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('peekBuffer, length too large', cheap__fileName__0, 499);
        }
        if (this.remainingLength() < length) {
            await this.flush(length);
        }
        if (!buffer) {
            buffer = new Uint8Array(length);
        }
        buffer.set(this.buffer.subarray(this.pointer, this.pointer + length), 0);
        return buffer;
    }
    /**
     *  length  buffer
     *
     * @param length
     * @param buffer
     * @returns
     */
    async readToBuffer(length, buffer) {
        if (this.remainingLength() < length) {
            let index = 0;
            if (this.remainingLength() > 0) {
                const len = this.remainingLength();
                buffer.set(this.buffer.subarray(this.pointer, this.pointer + len), index);
                index += len;
                this.pointer += len;
                this.pos += BigInt(len);
                length -= len;
            }
            while (length > 0) {
                try {
                    await this.flush();
                }
                catch (error) {
                    if (this.error === -1048576 /* IOError.END */ && index) {
                        return index;
                    }
                    else {
                        throw error;
                    }
                }
                const len = Math.min(this.endPointer - this.pointer, length);
                buffer.set(this.buffer.subarray(this.pointer, this.pointer + len), index);
                index += len;
                this.pointer += len;
                this.pos += BigInt(len);
                length -= len;
            }
            return index;
        }
        else {
            buffer.set(this.buffer.subarray(this.pointer, this.pointer + length), 0);
            this.pointer += length;
            this.pos += BigInt(length);
            return length;
        }
    }
    /**
     * 
     *
     * @param length  1
     * @returns
     */
    async readString(length = 1) {
        const buffer = await this.readBuffer(length);
        return _util_text__WEBPACK_IMPORTED_MODULE_1__.decode(buffer);
    }
    /**
     * 
     *
     * @param length  1
     * @returns
     */
    async peekString(length = 1) {
        const buffer = await this.peekBuffer(length);
        return _util_text__WEBPACK_IMPORTED_MODULE_1__.decode(buffer);
    }
    /**
     * 
     */
    async readLine() {
        let str = '';
        while (true) {
            let got = false;
            for (let i = this.pointer; i < this.endPointer; i++) {
                if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                    if (i !== this.pointer) {
                        str += await this.readString(i - this.pointer);
                    }
                    got = true;
                    break;
                }
            }
            if (!got) {
                str += await this.readString(this.remainingLength());
                await this.flush();
            }
            else {
                break;
            }
        }
        let next = await this.peekUint8();
        if (next === 0x0a || next === 0x0d) {
            this.pointer++;
            if (next === 0x0d) {
                next = await this.peekUint8();
                // \r\n
                if (next === 0x0a) {
                    this.pointer++;
                }
            }
        }
        return str;
    }
    /**
     * 
     */
    async peekLine() {
        if (this.remainingLength() < this.size) {
            try {
                await this.flush();
            }
            catch (error) {
                if (this.error !== -1048576 /* IOError.END */) {
                    throw error;
                }
            }
        }
        let str = '';
        let got = false;
        for (let i = this.pointer; i < this.endPointer; i++) {
            if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                str += await this.peekString(i - this.pointer);
                got = true;
                break;
            }
        }
        if (!got) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('peekLine, out of buffer', cheap__fileName__0, 657);
        }
        return str;
    }
    /**
     * 
     *
     * @returns
     */
    getPointer() {
        return this.pointer;
    }
    /**
     * 
     *
     * @returns
     */
    getPos() {
        return this.pos;
    }
    /**
     * 
     *
     * @param length
     */
    async skip(length) {
        const backup = length;
        while (this.remainingLength() < length) {
            length -= this.remainingLength();
            this.pointer = this.endPointer;
            await this.flush();
        }
        if (this.remainingLength() >= length) {
            this.pointer += length;
        }
        this.pos += BigInt(backup);
    }
    /**
     * 
     *
     * @returns
     */
    remainingLength() {
        return this.endPointer - this.pointer;
    }
    async flush_(buffer) {
        while (true) {
            const len = await this.onFlush(buffer);
            if (len !== -1048575 /* IOError.AGAIN */) {
                return len;
            }
            await new _timer_Sleep__WEBPACK_IMPORTED_MODULE_2__["default"](0);
        }
    }
    /**
     * 
     *
     * @param need
     * @returns
     */
    async flush(need = 0) {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('IOReader error, flush failed because of no flush callback', cheap__fileName__0, 731);
        }
        if (this.size - this.remainingLength() <= 0) {
            return;
        }
        need = Math.min(need, this.size);
        if (this.pointer < this.endPointer) {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            this.endPointer = this.endPointer - this.pointer;
        }
        else {
            this.endPointer = 0;
        }
        this.pointer = 0;
        if (need) {
            while (this.remainingLength() < need) {
                const len = await this.flush_(this.buffer.subarray(this.endPointer));
                if (len < 0) {
                    this.error = len;
                    throw new Error(`IOReader error, flush ${len === -1048576 /* IOError.END */ ? 'ended' : 'failed'}, ret: ${len}`);
                }
                this.endPointer += len;
            }
        }
        else {
            const len = await this.flush_(this.buffer.subarray(this.endPointer));
            if (len < 0) {
                this.error = len;
                throw new Error(`IOReader error, flush ${len === -1048576 /* IOError.END */ ? 'ended' : 'failed'}, ret: ${len}`);
            }
            this.endPointer += len;
        }
        this.error = 0;
    }
    /**
     *
     * seek 
     *
     * @param pos
     * @param force false  seek false
     * @param flush  seek  seek  true
     * @returns
     */
    async seek(pos, force = false, flush = true) {
        if (!force) {
            const len = Number(pos - this.pos);
            //  seek
            if (len < 0 && Math.abs(len) < this.pointer) {
                this.pointer += len;
                this.pos = pos;
                return;
            }
            //  seek
            else if (len > 0 && this.pointer + len < this.endPointer) {
                this.pointer += len;
                this.pos = pos;
                return;
            }
            else if (len === 0) {
                return;
            }
        }
        if (!this.onSeek) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('IOReader error, seek failed because of no seek callback', cheap__fileName__0, 802);
        }
        this.pointer = this.endPointer = 0;
        this.pos = pos;
        const ret = await this.onSeek(pos);
        if (ret !== 0) {
            this.error = ret;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('IOReader error, seek failed', cheap__fileName__0, 811);
        }
        if (flush) {
            await this.flush();
        }
    }
    /**
     * 
     */
    getBuffer() {
        return this.buffer;
    }
    /**
     * 
     *
     * @param buffer
     */
    appendBuffer(buffer) {
        if (this.size - this.endPointer >= buffer.length) {
            this.buffer.set(buffer, this.endPointer);
            this.endPointer += buffer.length;
        }
        else {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            this.endPointer = this.endPointer - this.pointer;
            this.pointer = 0;
            if (this.size - this.endPointer >= buffer.length) {
                this.buffer.set(buffer, this.endPointer);
                this.endPointer += buffer.length;
            }
            else {
                const len = Math.min(this.size - this.endPointer, buffer.length);
                this.buffer.set(buffer.subarray(0, len), this.endPointer);
                this.endPointer += len;
                _util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('IOReader, call appendBuffer but the buffer\'s size is lagger then the remaining size', cheap__fileName__0, 849);
            }
        }
    }
    /**
     *  reader
     */
    reset() {
        this.pointer = this.endPointer = 0;
        this.pos = BigInt(0);
        this.error = 0;
    }
    /**
     * 
     *
     * @param bigEndian
     */
    setEndian(bigEndian) {
        this.littleEndian = !bigEndian;
    }
    /**
     * 
     *
     * @returns
     */
    async fileSize() {
        if (this.fileSize_) {
            return this.fileSize_;
        }
        if (!this.onSize) {
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('IOReader error, fileSize failed because of no onSize callback', cheap__fileName__0, 882);
            return BigInt(0);
        }
        try {
            this.fileSize_ = await this.onSize();
        }
        catch (error) {
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.warn(`IOReader error, call fileSize failed: ${error}`, cheap__fileName__0, 889);
            this.fileSize_ = BigInt(0);
        }
        return this.fileSize_;
    }
    /**
     * 
     *
     * @returns
     */
    getBufferSize() {
        return this.size;
    }
    /**
     *  ioWriter
     *
     * @param ioWriter
     * @param length
     */
    async pipe(ioWriter, length) {
        if (length) {
            if (this.remainingLength() < length) {
                if (this.remainingLength() > 0) {
                    const len = this.remainingLength();
                    await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                    this.pointer += len;
                    this.pos += BigInt(len);
                    length -= len;
                }
                while (length > 0) {
                    await this.flush();
                    const len = Math.min(this.remainingLength(), length);
                    await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                    this.pointer += len;
                    this.pos += BigInt(len);
                    length -= len;
                }
            }
            else {
                await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + length));
                this.pointer += length;
                this.pos += BigInt(length);
            }
        }
        else {
            if (this.remainingLength() > 0) {
                const len = this.remainingLength();
                await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                this.pointer += len;
                this.pos += BigInt(len);
            }
            while (await this.flush_(this.buffer.subarray(0)) > 0) {
                const len = this.remainingLength();
                await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                this.pointer += len;
                this.pos += BigInt(len);
            }
        }
    }
}


/***/ }),

/***/ "./src/common/io/IOWriter.ts":
/*!***********************************!*\
  !*** ./src/common/io/IOWriter.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOWriter)
/* harmony export */ });
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/**
 * 
 */

class IOWriter {
    data;
    buffer;
    pointer;
    pos;
    size;
    littleEndian;
    error;
    onFlush;
    onSeek;
    /**
     * @param data  Uint8Array
     * @param bigEndian 
     */
    constructor(size = 1048576, bigEndian = true, map) {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.size = size;
        this.littleEndian = !bigEndian;
        this.error = 0;
        if (map && map.view) {
            this.size = map.length;
            this.buffer = map;
            this.data = map.view;
        }
        else if (map && !map.byteOffset) {
            this.size = map.length;
            this.buffer = map;
            this.data = new DataView(this.buffer.buffer);
        }
        else {
            if (map) {
                throw new Error('not support subarray of ArrayBuffer');
            }
            this.buffer = new Uint8Array(this.size);
            this.data = new DataView(this.buffer.buffer);
        }
    }
    /**
     *  8 
     */
    async writeUint8(value) {
        if (this.remainingLength() < 1) {
            await this.flush();
        }
        this.data.setUint8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     *  16 
     */
    async writeUint16(value) {
        if (this.remainingLength() < 2) {
            await this.flush();
        }
        this.data.setUint16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     *  24 
     */
    async writeUint24(value) {
        if (this.remainingLength() < 3) {
            await this.flush();
        }
        const high = (value & 0xff0000) >> 16;
        const middle = (value & 0x00ff00) >> 8;
        const low = value & 0x0000ff;
        if (this.littleEndian) {
            await this.writeUint8(low);
            await this.writeUint8(middle);
            await this.writeUint8(high);
        }
        else {
            await this.writeUint8(high);
            await this.writeUint8(middle);
            await this.writeUint8(low);
        }
    }
    /**
     *  32 
     */
    async writeUint32(value) {
        if (this.remainingLength() < 4) {
            await this.flush();
        }
        this.data.setUint32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     *  64 
     */
    async writeUint64(value) {
        if (this.remainingLength() < 8) {
            await this.flush();
        }
        this.data.setBigUint64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     *  8 
     *
     * @returns
     */
    async writeInt8(value) {
        if (this.remainingLength() < 1) {
            await this.flush();
        }
        this.data.setInt8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     *  16 
     */
    async writeInt16(value) {
        if (this.remainingLength() < 2) {
            await this.flush();
        }
        this.data.setInt16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     *  24 
     */
    async writeInt24(value) {
        await this.writeUint24(value < 0 ? (value + 0x1000000) : value);
    }
    /**
     *  32 
     */
    async writeInt32(value) {
        if (this.remainingLength() < 4) {
            await this.flush();
        }
        this.data.setInt32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     *  64 
     */
    async writeInt64(value) {
        if (this.remainingLength() < 8) {
            await this.flush();
        }
        this.data.setBigInt64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 
     *
     * @returns
     */
    async writeFloat(value) {
        if (this.remainingLength() < 4) {
            await this.flush();
        }
        this.data.setFloat32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 
     */
    async writeDouble(value) {
        if (this.remainingLength() < 8) {
            await this.flush();
        }
        this.data.setFloat64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 
     *
     * @returns
     */
    getPointer() {
        return this.pointer;
    }
    getPos() {
        return this.pos;
    }
    /**
     * 
     *
     * @returns
     */
    remainingLength() {
        return this.size - this.pointer;
    }
    /**
     *  buffer 
     *
     * @param length
     * @returns
     */
    async writeBuffer(buffer) {
        if (!buffer.length) {
            return;
        }
        let length = buffer.length;
        if (this.remainingLength() < length) {
            let index = 0;
            while (length > 0) {
                await this.flush();
                const len = Math.min(this.size, length);
                this.buffer.set(buffer.subarray(index, index + len), this.pointer);
                this.pointer += len;
                this.pos += BigInt(len);
                index += len;
                length -= len;
            }
        }
        else {
            this.buffer.set(buffer, this.pointer);
            this.pointer += length;
            this.pos += BigInt(length);
        }
    }
    /**
     * 
     */
    async writeString(str) {
        const buffer = _util_text__WEBPACK_IMPORTED_MODULE_0__.encode(str);
        await this.writeBuffer(buffer);
        return buffer.length;
    }
    /**
     * 
     */
    async flush() {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = await this.onFlush(this.buffer.subarray(0, this.pointer));
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    /**
     * 
     *
     * @param pos
     */
    async flushToPos(pos) {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = await this.onFlush(this.buffer.subarray(0, this.pointer), pos);
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    /**
     * seek 
     *
     * @param pos
     */
    async seek(pos) {
        if (!this.onSeek) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, seek failed because of no seek callback');
        }
        await this.flush();
        const ret = await this.onSeek(pos);
        if (ret !== 0) {
            this.error = ret;
            throw Error('IOWriter error, seek failed');
        }
        this.pos = pos;
    }
    /**
     *  seek
     *
     * @param pos
     */
    seekInline(pos) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, Math.min(this.size, pos));
        this.pos += BigInt(this.pointer - pointer);
    }
    /**
     * 
     *
     * @param length
     */
    skip(length) {
        const pointer = this.pointer;
        this.pointer = Math.min(this.size, this.pointer + length);
        this.pos += BigInt(this.pointer - pointer);
    }
    /**
     *  pointer 
     *
     * @param length
     */
    back(length) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, this.pointer - length);
        this.pos += BigInt(this.pointer - pointer);
    }
    /**
     * 
     *
     * @returns
     */
    getBuffer() {
        return this.buffer.subarray(0, this.pointer);
    }
    /**
     * 
     *
     * @param bigEndian
     */
    setEndian(bigEndian) {
        this.littleEndian = !bigEndian;
    }
    /**
     *  writer
     */
    reset() {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.error = 0;
    }
    /**
     * 
     *
     * @returns
     */
    getBufferSize() {
        return this.size;
    }
}


/***/ }),

/***/ "./src/common/io/IOWriterSync.ts":
/*!***************************************!*\
  !*** ./src/common/io/IOWriterSync.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOWriterSync)
/* harmony export */ });
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/**
 * 
 */

class IOWriterSync {
    data;
    buffer;
    pointer;
    pos;
    size;
    littleEndian;
    error;
    onFlush;
    onSeek;
    /**
     * @param data  Uint8Array
     * @param bigEndian 
     */
    constructor(size = 1048576, bigEndian = true, map) {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.size = size;
        this.littleEndian = !bigEndian;
        this.error = 0;
        if (map && map.view) {
            this.size = map.length;
            this.buffer = map;
            this.data = map.view;
        }
        else if (map && !map.byteOffset) {
            this.size = map.length;
            this.buffer = map;
            this.data = new DataView(this.buffer.buffer);
        }
        else {
            if (map) {
                throw new Error('not support subarray of ArrayBuffer');
            }
            this.buffer = new Uint8Array(this.size);
            this.data = new DataView(this.buffer.buffer);
        }
    }
    /**
     *  8 
     */
    writeUint8(value) {
        if (this.remainingLength() < 1) {
            this.flush();
        }
        this.data.setUint8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     *  16 
     */
    writeUint16(value) {
        if (this.remainingLength() < 2) {
            this.flush();
        }
        this.data.setUint16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     *  24 
     */
    writeUint24(value) {
        if (this.remainingLength() < 3) {
            this.flush();
        }
        const high = (value & 0xff0000) >> 16;
        const middle = (value & 0x00ff00) >> 8;
        const low = value & 0x0000ff;
        if (this.littleEndian) {
            this.writeUint8(low);
            this.writeUint8(middle);
            this.writeUint8(high);
        }
        else {
            this.writeUint8(high);
            this.writeUint8(middle);
            this.writeUint8(low);
        }
    }
    /**
     *  32 
     */
    writeUint32(value) {
        if (this.remainingLength() < 4) {
            this.flush();
        }
        this.data.setUint32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     *  64 
     */
    writeUint64(value) {
        if (this.remainingLength() < 8) {
            this.flush();
        }
        this.data.setBigUint64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     *  8 
     *
     * @returns
     */
    writeInt8(value) {
        if (this.remainingLength() < 1) {
            this.flush();
        }
        this.data.setInt8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     *  16 
     */
    writeInt16(value) {
        if (this.remainingLength() < 2) {
            this.flush();
        }
        this.data.setInt16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     *  24 
     */
    writeInt24(value) {
        this.writeUint24(value < 0 ? (value + 0x1000000) : value);
    }
    /**
     *  32 
     */
    writeInt32(value) {
        if (this.remainingLength() < 4) {
            this.flush();
        }
        this.data.setInt32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     *  64 
     */
    writeInt64(value) {
        if (this.remainingLength() < 8) {
            this.flush();
        }
        this.data.setBigInt64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 
     *
     * @returns
     */
    writeFloat(value) {
        if (this.remainingLength() < 4) {
            this.flush();
        }
        this.data.setFloat32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 
     */
    writeDouble(value) {
        if (this.remainingLength() < 8) {
            this.flush();
        }
        this.data.setFloat64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 
     *
     * @returns
     */
    getPointer() {
        return this.pointer;
    }
    getPos() {
        return this.pos;
    }
    /**
     * 
     *
     * @returns
     */
    remainingLength() {
        return this.size - this.pointer;
    }
    /**
     *  buffer 
     *
     * @param length
     * @returns
     */
    writeBuffer(buffer) {
        if (!buffer.length) {
            return;
        }
        let length = buffer.length;
        if (this.remainingLength() < length) {
            let index = 0;
            while (length > 0) {
                this.flush();
                const len = Math.min(this.size, length);
                this.buffer.set(buffer.subarray(index, index + len), this.pointer);
                this.pointer += len;
                this.pos += BigInt(len);
                index += len;
                length -= len;
            }
        }
        else {
            this.buffer.set(buffer, this.pointer);
            this.pointer += length;
            this.pos += BigInt(length);
        }
    }
    /**
     * 
     */
    writeString(str) {
        const buffer = _util_text__WEBPACK_IMPORTED_MODULE_0__.encode(str);
        this.writeBuffer(buffer);
        return buffer.length;
    }
    /**
     * 
     */
    flush() {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = this.onFlush(this.buffer.subarray(0, this.pointer));
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    /**
     * 
     *
     * @param pos
     */
    flushToPos(pos) {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = this.onFlush(this.buffer.subarray(0, this.pointer), pos);
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    /**
     * seek 
     *
     * @param pos
     */
    seek(pos) {
        if (!this.onSeek) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, seek failed because of no seek callback');
        }
        this.flush();
        const ret = this.onSeek(pos);
        if (ret !== 0) {
            this.error = ret;
            throw Error('IOWriter error, seek failed');
        }
        this.pos = pos;
    }
    /**
     *  seek
     *
     * @param pos
     */
    seekInline(pos) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, Math.min(this.size, pos));
        this.pos += BigInt(this.pointer - pointer);
    }
    /**
     * 
     *
     * @param length
     */
    skip(length) {
        const pointer = this.pointer;
        this.pointer = Math.min(this.size, this.pointer + length);
        this.pos += BigInt(this.pointer - pointer);
    }
    /**
     *  pointer 
     *
     * @param length
     */
    back(length) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, this.pointer - length);
        this.pos += BigInt(this.pointer - pointer);
    }
    /**
     * 
     *
     * @returns
     */
    getBuffer() {
        return this.buffer.subarray(0, this.pointer);
    }
    /**
     * 
     *
     * @param bigEndian
     */
    setEndian(bigEndian) {
        this.littleEndian = !bigEndian;
    }
    /**
     *  writer
     */
    reset() {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.error = 0;
    }
    /**
     * 
     *
     * @returns
     */
    getBufferSize() {
        return this.size;
    }
}


/***/ }),

/***/ "./src/common/io/SeekableWriteBuffer.ts":
/*!**********************************************!*\
  !*** ./src/common/io/SeekableWriteBuffer.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SeekableWriteBuffer)
/* harmony export */ });
/* harmony import */ var _function_concatTypeArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function/concatTypeArray */ "./src/common/function/concatTypeArray.ts");

/**
 *  seek  Buffer
 */
class SeekableWriteBuffer {
    queue;
    pos;
    startPos;
    endPos;
    index;
    offset;
    constructor() {
        this.queue = [];
        this.startPos = BigInt(0);
        this.endPos = BigInt(0);
        this.pos = BigInt(0);
    }
    /**
     * 
     *
     * @param buffer
     */
    write(buffer) {
        if (this.pos === this.endPos) {
            this.queue.push(buffer);
            this.endPos += BigInt(buffer.length);
            this.pos += BigInt(buffer.length);
        }
        else {
            if (buffer.length < this.queue[this.index].length - this.offset) {
                this.queue[this.index].set(buffer, this.offset);
                this.offset += buffer.length;
                this.pos += BigInt(buffer.length);
                if (this.offset === this.queue[this.index].length) {
                    this.index++;
                    this.offset = 0;
                }
                if (this.index === this.queue.length) {
                    this.index = -1;
                    this.offset = -1;
                    this.pos = this.endPos;
                }
            }
            else {
                let offset = 0;
                while (offset < buffer.length) {
                    const length = Math.min(this.queue[this.index].length - this.offset, buffer.length - offset);
                    this.queue[this.index].set(buffer.subarray(offset, offset + length), this.offset);
                    offset += length;
                    this.offset += length;
                    this.pos += BigInt(length);
                    if (this.offset === this.queue[this.index].length) {
                        if (this.index + 1 === this.queue.length) {
                            if (offset < buffer.length) {
                                const remain = buffer.subarray(buffer.length - offset);
                                this.queue.push(remain);
                                this.endPos += BigInt(remain.length);
                            }
                            this.pos = this.endPos;
                            this.index = -1;
                            this.offset = -1;
                            break;
                        }
                        else {
                            this.index++;
                            this.offset = 0;
                        }
                    }
                }
            }
        }
    }
    /**
     * seek 
     *
     * @param pos
     * @returns
     */
    seek(pos) {
        if (pos < this.startPos || pos > this.endPos) {
            return false;
        }
        this.pos = pos;
        this.index = -1;
        this.offset = -1;
        let now = this.startPos;
        for (let i = 0; i < this.queue.length; i++) {
            if (pos <= now + BigInt(this.queue[i].length)) {
                this.index = i;
                this.offset = Number(pos - now);
                break;
            }
            now += BigInt(this.queue[i].length);
        }
        if (this.index < 0) {
            this.pos = this.endPos;
        }
        return true;
    }
    /**
     * 
     *
     * @returns
     */
    flush() {
        this.startPos = this.endPos;
        this.pos = this.endPos;
        this.index = -1;
        this.offset = -1;
        const buffer = (0,_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_0__["default"])(Uint8Array, this.queue);
        this.queue.length = 0;
        return buffer;
    }
    /**
     * 
     */
    get size() {
        return this.queue.length;
    }
}


/***/ }),

/***/ "./src/common/math/Matrix3.ts":
/*!************************************!*\
  !*** ./src/common/math/Matrix3.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Matrix3)
/* harmony export */ });
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\common\\math\\Matrix3.ts";


class Matrix3 {
    element;
    static RowMajor(matrix) {
        return new Matrix3([
            matrix[0], matrix[3], matrix[6],
            matrix[1], matrix[4], matrix[7],
            matrix[2], matrix[5], matrix[8],
        ]);
    }
    static ColMajor(matrix) {
        return new Matrix3(matrix);
    }
    constructor(matrix) {
        if (matrix) {
            this.element = new Float32Array(9);
            this.set(matrix);
        }
        else {
            this.element = new Float32Array([
                1, 0, 0,
                0, 1, 0,
                0, 0, 1,
            ]);
        }
    }
    rc(r, c) {
        return this.getValue(c * 3 + r);
    }
    setRC(r, c, value) {
        this.setValue(c * 3 + r, value);
    }
    getValue(index) {
        if (index >= 0 && index < 9) {
            return this.element[index];
        }
        else {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.error('index out of Matrix4\'s rang [0 - 9]', cheap__fileName__0, 47);
        }
    }
    setValue(index, value) {
        if (index >= 0 && index < 9) {
            this.element[index] = value;
        }
        else {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.error('index out of Matrix4\'s rang [0 - 9]', cheap__fileName__0, 56);
        }
    }
    /**
     * 
     */
    setIdentity() {
        this.element = new Float32Array([
            1, 0, 0,
            0, 1, 0,
            0, 0, 1,
        ]);
        return this;
    }
    /**
     * 
     * @param matrix
     */
    set(matrix) {
        _util_array__WEBPACK_IMPORTED_MODULE_0__.each(matrix, (value, index) => {
            this.element[index] = value;
        });
        return this;
    }
    invert() {
        const te = this.element, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) {
            return this.set([0, 0, 0, 0, 0, 0, 0, 0, 0]);
        }
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
    }
    toArray() {
        let result = [];
        for (let i = 0; i < 9; i++) {
            result[i] = this.element[i];
        }
        return result;
    }
    copy() {
        return new Matrix3().set(this.toArray());
    }
}


/***/ }),

/***/ "./src/common/math/Matrix4.ts":
/*!************************************!*\
  !*** ./src/common/math/Matrix4.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Matrix4)
/* harmony export */ });
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vector3 */ "./src/common/math/Vector3.ts");
var cheap__fileName__0 = "src\\common\\math\\Matrix4.ts";



let shared;
class Matrix4 {
    /**
     * 
     */
    static shared() {
        return shared || (shared = new Matrix4());
    }
    static RowMajor(matrix) {
        return new Matrix4([
            matrix[0], matrix[4], matrix[8], matrix[12],
            matrix[1], matrix[5], matrix[9], matrix[13],
            matrix[2], matrix[6], matrix[10], matrix[14],
            matrix[3], matrix[7], matrix[11], matrix[15]
        ]);
    }
    static ColMajor(matrix) {
        return new Matrix4(matrix);
    }
    element;
    constructor(matrix) {
        if (matrix) {
            this.element = new Float32Array(16);
            this.set(matrix);
        }
        else {
            this.element = new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
        }
    }
    rc(r, c) {
        return this.getValue(c * 4 + r);
    }
    setRC(r, c, value) {
        this.setValue(c * 4 + r, value);
    }
    getValue(index) {
        if (index >= 0 && index <= 15) {
            return this.element[index];
        }
        else {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.error('index out of Matrix4\'s rang [0 - 15]', cheap__fileName__0, 58);
        }
    }
    setValue(index, value) {
        if (index >= 0 && index <= 15) {
            this.element[index] = value;
        }
        else {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.error('index out of Matrix4\'s rang [0 - 15]', cheap__fileName__0, 67);
        }
    }
    /**
     * 
     */
    setIdentity() {
        this.element = new Float32Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ]);
        return this;
    }
    /**
     * 
     * @param matrix
     */
    set(matrix) {
        _util_array__WEBPACK_IMPORTED_MODULE_0__.each(matrix, (value, index) => {
            this.element[index] = value;
        });
        return this;
    }
    /**
     * 
     * @param matrix
     */
    multiply(matrix) {
        let i, a, b, e, ai0, ai1, ai2, ai3;
        e = a = this.element;
        b = matrix.element;
        if (e === b) {
            b = new Float32Array(16);
            for (i = 0; i < 16; i++) {
                b[i] = e[i];
            }
        }
        for (i = 0; i < 4; i++) {
            ai0 = a[i];
            ai1 = a[i + 4];
            ai2 = a[i + 8];
            ai3 = a[i + 12];
            e[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
            e[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
            e[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
            e[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
        }
        return this;
    }
    /**
     *  3 
     * @param vector3
     */
    multiplyVector3(vector3) {
        let e = this.element;
        let p = vector3.element;
        return new _Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector3([
            p[0] * e[0] + p[1] * e[4] + p[2] * e[8] + e[12],
            p[0] * e[1] + p[1] * e[5] + p[2] * e[9] + e[13],
            p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + e[14]
        ]);
    }
    /**
     *  4 
     * @param vector4
     */
    multiplyVector4(vector4) {
        let e = this.element;
        let p = vector4.element;
        return new _Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector4([
            p[0] * e[0] + p[1] * e[4] + p[2] * e[8] + p[3] * e[12],
            p[0] * e[1] + p[1] * e[5] + p[2] * e[9] + p[3] * e[13],
            p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + p[3] * e[14],
            p[0] * e[3] + p[1] * e[7] + p[2] * e[11] + p[3] * e[15]
        ]);
    }
    /**
     * 
     */
    transpose() {
        let e, t;
        e = this.element;
        t = e[1], e[1] = e[4], e[4] = t;
        t = e[2], e[2] = e[8], e[8] = t;
        t = e[3], e[3] = e[12], e[12] = t;
        t = e[6], e[6] = e[9], e[9] = t;
        t = e[7], e[7] = e[13], e[13] = t;
        t = e[11], e[11] = e[14], e[14] = t;
        return this;
    }
    /**
     * 
     * @param matrix
     */
    setInverseOf(matrix) {
        let i, s, d, inv, det;
        s = matrix.element;
        d = this.element;
        inv = new Float32Array(16);
        inv[0] = s[5] * s[10] * s[15] - s[5] * s[11] * s[14] - s[9] * s[6] * s[15] + s[9] * s[7] * s[14] + s[13] * s[6] * s[11] - s[13] * s[7] * s[10];
        inv[1] = -s[1] * s[10] * s[15] + s[1] * s[11] * s[14] + s[9] * s[2] * s[15] - s[9] * s[3] * s[14] - s[13] * s[2] * s[11] + s[13] * s[3] * s[10];
        inv[2] = s[1] * s[6] * s[15] - s[1] * s[7] * s[14] - s[5] * s[2] * s[15] + s[5] * s[3] * s[14] + s[13] * s[2] * s[7] - s[13] * s[3] * s[6];
        inv[3] = -s[1] * s[6] * s[11] + s[1] * s[7] * s[10] + s[5] * s[2] * s[11] - s[5] * s[3] * s[10] - s[9] * s[2] * s[7] + s[9] * s[3] * s[6];
        inv[4] = -s[4] * s[10] * s[15] + s[4] * s[11] * s[14] + s[8] * s[6] * s[15] - s[8] * s[7] * s[14] - s[12] * s[6] * s[11] + s[12] * s[7] * s[10];
        inv[5] = s[0] * s[10] * s[15] - s[0] * s[11] * s[14] - s[8] * s[2] * s[15] + s[8] * s[3] * s[14] + s[12] * s[2] * s[11] - s[12] * s[3] * s[10];
        inv[6] = -s[0] * s[6] * s[15] + s[0] * s[7] * s[14] + s[4] * s[2] * s[15] - s[4] * s[3] * s[14] - s[12] * s[2] * s[7] + s[12] * s[3] * s[6];
        inv[7] = s[0] * s[6] * s[11] - s[0] * s[7] * s[10] - s[4] * s[2] * s[11] + s[4] * s[3] * s[10] + s[8] * s[2] * s[7] - s[8] * s[3] * s[6];
        inv[8] = s[4] * s[9] * s[15] - s[4] * s[11] * s[13] - s[8] * s[5] * s[15] + s[8] * s[7] * s[13] + s[12] * s[5] * s[11] - s[12] * s[7] * s[9];
        inv[9] = -s[0] * s[9] * s[15] + s[0] * s[11] * s[13] + s[8] * s[1] * s[15] - s[8] * s[3] * s[13] - s[12] * s[1] * s[11] + s[12] * s[3] * s[9];
        inv[10] = s[0] * s[5] * s[15] - s[0] * s[7] * s[13] - s[4] * s[1] * s[15] + s[4] * s[3] * s[13] + s[12] * s[1] * s[7] - s[12] * s[3] * s[5];
        inv[11] = -s[0] * s[5] * s[11] + s[0] * s[7] * s[9] + s[4] * s[1] * s[11] - s[4] * s[3] * s[9] - s[8] * s[1] * s[7] + s[8] * s[3] * s[5];
        inv[12] = -s[4] * s[9] * s[14] + s[4] * s[10] * s[13] + s[8] * s[5] * s[14] - s[8] * s[6] * s[13] - s[12] * s[5] * s[10] + s[12] * s[6] * s[9];
        inv[13] = s[0] * s[9] * s[14] - s[0] * s[10] * s[13] - s[8] * s[1] * s[14] + s[8] * s[2] * s[13] + s[12] * s[1] * s[10] - s[12] * s[2] * s[9];
        inv[14] = -s[0] * s[5] * s[14] + s[0] * s[6] * s[13] + s[4] * s[1] * s[14] - s[4] * s[2] * s[13] - s[12] * s[1] * s[6] + s[12] * s[2] * s[5];
        inv[15] = s[0] * s[5] * s[10] - s[0] * s[6] * s[9] - s[4] * s[1] * s[10] + s[4] * s[2] * s[9] + s[8] * s[1] * s[6] - s[8] * s[2] * s[5];
        det = s[0] * inv[0] + s[1] * inv[4] + s[2] * inv[8] + s[3] * inv[12];
        if (det === 0) {
            return this;
        }
        det = 1 / det;
        for (i = 0; i < 16; i++) {
            d[i] = inv[i] * det;
        }
        return this;
    }
    /**
     * 
     */
    invert() {
        this.setInverseOf(this);
        return this;
    }
    /**
     * 
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    setOrtho(left, right, bottom, top, near, far) {
        let rw, rh, rd;
        if (left === right || bottom === top || near === far) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('null frustum', cheap__fileName__0, 240);
        }
        rw = 1 / (right - left);
        rh = 1 / (top - bottom);
        rd = 1 / (far - near);
        this.set([
            2 * rw, 0, 0, 0,
            0, 2 * rh, 0, 0,
            0, 0, -2 * rd, 0,
            -(right + left) * rw, -(top + bottom) * rh, -(far + near) * rd, 1
        ]);
        return this;
    }
    /**
     * 
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    ortho(left, right, bottom, top, near, far) {
        return this.multiply(new Matrix4().setOrtho(left, right, bottom, top, near, far));
    }
    /**
     * 
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    setFrustum(left, right, bottom, top, near, far) {
        let rw, rh, rd;
        if (left === right || bottom === top || near === far) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.error('null frustum', cheap__fileName__0, 281);
        }
        if (near <= 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('near <= 0', cheap__fileName__0, 284);
        }
        if (far <= 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('far <= 0', cheap__fileName__0, 287);
        }
        rw = 1 / (right - left);
        rh = 1 / (top - bottom);
        rd = 1 / (far - near);
        this.set([
            2 * near * rw, 0, 0, 0,
            0, 2 * near * rh, 0, 0,
            (right + left) * rw, (top + bottom) * rh, -(far + near) * rd, -1,
            0, 0, -2 * near * far * rd, 0
        ]);
        return this;
    }
    /**
     * 
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    frustum(left, right, bottom, top, near, far) {
        return this.multiply(new Matrix4().setOrtho(left, right, bottom, top, near, far));
    }
    /**
     * 
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    setPerspective(fovy, aspect, near, far) {
        let rd, s, ct;
        if (near === far || aspect === 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('null frustum', cheap__fileName__0, 328);
        }
        if (near <= 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('near <= 0', cheap__fileName__0, 331);
        }
        if (far <= 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('far <= 0', cheap__fileName__0, 334);
        }
        fovy = Math.PI * fovy / 180 / 2;
        s = Math.sin(fovy);
        if (s === 0) {
            _util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('null frustum', cheap__fileName__0, 342);
        }
        rd = 1 / (far - near);
        ct = Math.cos(fovy) / s;
        this.set([
            ct / aspect, 0, 0, 0,
            0, ct, 0, 0,
            0, 0, -(far + near) * rd, -1,
            0, 0, -2 * near * far * rd, 0
        ]);
        return this;
    }
    /**
     * 
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    perspective(fovy, aspect, near, far) {
        return this.multiply(new Matrix4().setPerspective(fovy, aspect, near, far));
    }
    /**
     *  Matrix4 
     * @param vector3 
     */
    setScale(vector3) {
        this.set([
            vector3.x, 0, 0, 0,
            0, vector3.y, 0, 0,
            0, 0, vector3.z, 0,
            0, 0, 0, 1
        ]);
        return this;
    }
    /**
     * 
     * @param vector3 
     */
    scale(vector3) {
        let e = this.element;
        e[0] *= vector3.x, e[1] *= vector3.x, e[2] *= vector3.x, e[3] *= vector3.x;
        e[4] *= vector3.y, e[5] *= vector3.y, e[6] *= vector3.y, e[7] *= vector3.y;
        e[8] *= vector3.z, e[9] *= vector3.z, e[10] *= vector3.z, e[11] *= vector3.z;
        return this;
    }
    /**
     *  Matrix4 
     * @param vector3 
     */
    setTranslate(vector3) {
        this.set([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            vector3.x, vector3.y, vector3.z, 1
        ]);
        return this;
    }
    /**
     * 
     * @param vector3 
     */
    preTranslate(vector3) {
        let e = this.element;
        e[12] += e[0] * vector3.x + e[4] * vector3.y + e[8] * vector3.z;
        e[13] += e[1] * vector3.x + e[5] * vector3.y + e[9] * vector3.z;
        e[14] += e[2] * vector3.x + e[6] * vector3.y + e[10] * vector3.z;
        e[15] += e[3] * vector3.x + e[7] * vector3.y + e[11] * vector3.z;
        return this;
    }
    /**
     * 
     * @param vector3 
     */
    postTranslate(vector3) {
        let e = this.element;
        e[0] += vector3.x * e[3];
        e[1] += vector3.y * e[3];
        e[2] += vector3.z * e[3];
        e[4] += vector3.x * e[7];
        e[5] += vector3.y * e[7];
        e[6] += vector3.z * e[7];
        e[8] += vector3.x * e[11];
        e[9] += vector3.y * e[11];
        e[10] += vector3.z * e[11];
        e[12] += vector3.x * e[15];
        e[13] += vector3.y * e[15];
        e[14] += vector3.z * e[15];
        return this;
    }
    /**
     *  Matrix4  
     * @param angle  0-360
     * @param vector3 
     */
    setRotate(angle, vector3) {
        let x, y, z, s, c, len, rlen, nc, xy, yz, zx, xs, ys, zs;
        angle = Math.PI * angle / 180;
        x = vector3.x;
        y = vector3.y;
        z = vector3.z;
        s = Math.sin(angle);
        c = Math.cos(angle);
        if (0 !== vector3.x && 0 === vector3.y && 0 === vector3.z) {
            // Rotation around X axis
            if (vector3.x < 0) {
                s = -s;
            }
            this.set([
                1, 0, 0, 0,
                0, c, -s, 0,
                0, s, c, 0,
                0, 0, 0, 1
            ]);
        }
        else if (0 === vector3.x && 0 !== vector3.y && 0 === vector3.z) {
            // Rotation around Y axis
            if (vector3.y < 0) {
                s = -s;
            }
            this.set([
                c, 0, s, 0,
                0, 1, 0, 0,
                -s, 0, c, 0,
                0, 0, 0, 1
            ]);
        }
        else if (0 === vector3.x && 0 === vector3.y && 0 !== vector3.z) {
            // Rotation around Z axis
            if (vector3.z < 0) {
                s = -s;
            }
            this.set([
                c, -s, 0, 0,
                s, c, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
        }
        else {
            // Rotation around another axis
            len = vector3.magnitude;
            if (len !== 1) {
                rlen = 1 / len;
                x *= rlen;
                y *= rlen;
                z *= rlen;
            }
            nc = 1 - c;
            xy = x * y;
            yz = y * z;
            zx = z * x;
            xs = x * s;
            ys = y * s;
            zs = z * s;
            this.set([
                x * x * nc + c, xy * nc + zs, zx * nc - ys, 0,
                xy * nc - zs, y * y * nc + c, yz * nc + xs, 0,
                zx * nc + ys, yz * nc - xs, z * z * nc + c, 0,
                0, 0, 0, 1
            ]);
        }
        return this;
    }
    /**
     * 
     * @param angle  0-360
     * @param vector3 
     */
    rotate(angle, vector3) {
        this.multiply(new Matrix4().setRotate(angle, vector3));
        return this;
    }
    /**
     * 
     * @param eye 
     * @param center 
     * @param up 
     */
    setLookAt(eye, center, up) {
        let fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;
        fx = center.x - eye.x;
        fy = center.y - eye.y;
        fz = center.z - eye.z;
        // Normalize f.
        rlf = 1 / Math.sqrt(fx * fx + fy * fy + fz * fz);
        fx *= rlf;
        fy *= rlf;
        fz *= rlf;
        // Calculate cross product of f and up.
        sx = fy * up.z - fz * up.y;
        sy = fz * up.x - fx * up.z;
        sz = fx * up.y - fy * up.x;
        // Normalize s.
        rls = 1 / Math.sqrt(sx * sx + sy * sy + sz * sz);
        sx *= rls;
        sy *= rls;
        sz *= rls;
        // Calculate cross product of s and f.
        ux = sy * fz - sz * fy;
        uy = sz * fx - sx * fz;
        uz = sx * fy - sy * fx;
        this.set([
            sx, ux, -fx, 0,
            sy, uy, -fy, 0,
            sz, uz, -fz, 0,
            0, 0, 0, 1
        ]);
        // Translate.
        return this.preTranslate(new _Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector3([-eye.x, -eye.y, -eye.z]));
    }
    /**
     * 
     * @param eye 
     * @param center 
     * @param up 
     */
    lookAt(eye, center, up) {
        return this.multiply(new Matrix4().setLookAt(eye, center, up));
    }
    toArray() {
        let result = [];
        for (let i = 0; i < 16; i++) {
            result[i] = this.element[i];
        }
        return result;
    }
    copy() {
        return new Matrix4().set(this.toArray());
    }
}


/***/ }),

/***/ "./src/common/math/Vector3.ts":
/*!************************************!*\
  !*** ./src/common/math/Vector3.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Vector3: () => (/* binding */ Vector3),
/* harmony export */   Vector4: () => (/* binding */ Vector4)
/* harmony export */ });
class Vector3 {
    element;
    constructor(vector) {
        this.element = new Float32Array(3);
        if (vector) {
            this.element[0] = vector[0];
            this.element[1] = vector[1];
            this.element[2] = vector[2];
        }
    }
    /**
     * 
     */
    normalize() {
        let c = this.x, d = this.y, e = this.z, g = this.magnitude;
        if (g) {
            if (g === 1) {
                return this;
            }
            else {
                g = 1 / g;
                this.x = c * g;
                this.y = d * g;
                this.z = e * g;
                return this;
            }
        }
        else {
            this.x = this.y = this.z = 0;
            return this;
        }
    }
    toArray() {
        return [this.x, this.y, this.z];
    }
    get magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    get sqrMagnitude() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    get x() {
        return this.element[0];
    }
    set x(value) {
        this.element[0] = value;
    }
    get y() {
        return this.element[1];
    }
    set y(value) {
        this.element[1] = value;
    }
    get z() {
        return this.element[2];
    }
    set z(value) {
        this.element[2] = value;
    }
}
class Vector4 {
    element;
    constructor(vector) {
        this.element = new Float32Array(4);
        if (vector) {
            this.element[0] = vector[0];
            this.element[1] = vector[1];
            this.element[2] = vector[2];
            this.element[4] = vector[3];
        }
    }
}


/***/ }),

/***/ "./src/common/math/align.ts":
/*!**********************************!*\
  !*** ./src/common/math/align.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ align)
/* harmony export */ });
function align(value, alignment) {
    return (value + (alignment - 1)) & ~(alignment - 1);
}


/***/ }),

/***/ "./src/common/math/gcd.ts":
/*!********************************!*\
  !*** ./src/common/math/gcd.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ gcd)
/* harmony export */ });
/**
 * // GCD
 *
 * @param a
 * @param b
 * @returns
 */
function gcd(a, b) {
    while (b !== 0) {
        [a, b] = [b, a % b];
    }
    return a;
}


/***/ }),

/***/ "./src/common/math/matrix.ts":
/*!***********************************!*\
  !*** ./src/common/math/matrix.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concat3x3: () => (/* binding */ concat3x3)
/* harmony export */ });
/* unused harmony export concat4x4 */
/* harmony import */ var _Matrix3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix3 */ "./src/common/math/Matrix3.ts");
/* harmony import */ var _Matrix4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Matrix4 */ "./src/common/math/Matrix4.ts");


function concat3x3(a, b) {
    const m = new _Matrix3__WEBPACK_IMPORTED_MODULE_0__["default"]([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
            let value = a.rc(r, 0) * b.rc(0, c) + a.rc(r, 1) * b.rc(1, c) + a.rc(r, 2) * b.rc(2, c);
            m.setRC(r, c, value);
        }
    }
    return m;
}
function concat4x4(a, b) {
    const m = new _Matrix4__WEBPACK_IMPORTED_MODULE_1__["default"]([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
            let value = a.rc(r, 0) * b.rc(0, c) + a.rc(r, 1) * b.rc(1, c) + a.rc(r, 2) * b.rc(2, c) + a.rc(r, 3) * b.rc(3, c);
            m.setRC(r, c, value);
        }
    }
    return m;
}


/***/ }),

/***/ "./src/common/math/vector.ts":
/*!***********************************!*\
  !*** ./src/common/math/vector.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mvMul: () => (/* binding */ mvMul)
/* harmony export */ });
/* unused harmony exports add, minus, scalarProduct, dotProduct, crossProduct, rotate, vertical, angleCos, angle, extendPoint */
/* harmony import */ var _Matrix4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix4 */ "./src/common/math/Matrix4.ts");
/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector3 */ "./src/common/math/Vector3.ts");


/**
 * 
 */
function add(a, b) {
    return new _Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([
        a.x + b.x,
        a.y + b.y,
        a.z + b.z
    ]);
}
/**
 * 
 */
function minus(a, b) {
    return new _Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([
        a.x - b.x,
        a.y - b.y,
        a.z - b.z
    ]);
}
/**
 * 
 */
function scalarProduct(vector, scalar) {
    return new _Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([
        vector.x * scalar,
        vector.y * scalar,
        vector.z * scalar
    ]);
}
/**
 * 
 */
function dotProduct(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}
/**
 * 
 */
function crossProduct(a, b) {
    return new _Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([
        a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    ]);
}
/**
 * 
 */
function rotate(vector, angle, axis) {
    return new _Matrix4__WEBPACK_IMPORTED_MODULE_0__["default"]().setRotate(angle, axis).multiplyVector3(vector);
}
/**
 * 
 */
function vertical(a, b) {
    return crossProduct(a, b).normalize();
}
/**
 * 
 */
function angleCos(a, b) {
    return dotProduct(a, b) / (a.magnitude * b.magnitude);
}
/**
 * 
 */
function angle(a, b) {
    return Math.acos(angleCos(a, b));
}
/**
 * 
 */
function extendPoint(a, b) {
    let sum = add(a, b);
    //  a  b  a  b  0
    if (sum.magnitude === 0) {
        sum = a;
    }
    return crossProduct(sum, new _Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([0, 0, 1])).normalize();
}
/**
 * 
 */
function mvMul(m, v) {
    const dst = new _Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3([0, 0, 0]);
    for (let row = 0; row < 3; row++) {
        dst.element[row] = m.rc(row, 0) * v.x + m.rc(row, 1) * v.y + m.rc(row, 2) * v.z;
    }
    return dst;
}


/***/ }),

/***/ "./src/common/network/FakeMessageChannel.ts":
/*!**************************************************!*\
  !*** ./src/common/network/FakeMessageChannel.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FakeMessageChannel)
/* harmony export */ });
class FakeMessageChannelPort extends EventTarget {
    peer;
    postMessage(message, transfer) {
        if (this.peer?.onmessage) {
            this.peer.onmessage({
                data: message
            });
        }
    }
    onmessage;
    onmessageerror;
    close() {
        this.peer = null;
    }
    start() {
    }
}
class FakeMessageChannel {
    port1;
    port2;
    constructor() {
        this.port1 = new FakeMessageChannelPort();
        this.port2 = new FakeMessageChannelPort();
        this.port1.peer = this.port2;
        this.port2.peer = this.port1;
    }
}


/***/ }),

/***/ "./src/common/network/IPCPort.ts":
/*!***************************************!*\
  !*** ./src/common/network/IPCPort.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NOTIFY: () => (/* binding */ NOTIFY),
/* harmony export */   REQUEST: () => (/* binding */ REQUEST),
/* harmony export */   "default": () => (/* binding */ IPCPort)
/* harmony export */ });
/* harmony import */ var _event_Emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../event/Emitter */ "./src/common/event/Emitter.ts");
/* harmony import */ var _function_isDef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/isDef */ "./src/common/function/isDef.ts");


const NOTIFY = 'notify';
const REQUEST = 'request';
class IPCPort extends _event_Emitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
    port;
    requestMap;
    seq;
    closed;
    constructor(port) {
        super(true);
        this.port = port;
        this.port.onmessage = this.handle.bind(this);
        this.seq = 0;
        this.requestMap = new Map();
        this.port.start();
        this.closed = false;
    }
    handle(event) {
        const origin = event.data;
        const type = origin.type;
        const data = origin.data;
        if (type === 'notify') {
            this.fire(NOTIFY, data);
        }
        else if (type === 'reply') {
            const request = this.requestMap.get(data.seq);
            if (request) {
                if ((0,_function_isDef__WEBPACK_IMPORTED_MODULE_1__["default"])(data.result)) {
                    request.resolve(data.result);
                }
                else if (data.error) {
                    request.reject(data.error);
                }
                else {
                    request.resolve(undefined);
                }
                this.requestMap.delete(data.seq);
            }
        }
        else if (type === 'request') {
            this.fire(REQUEST, data);
        }
    }
    notify(method, params = {}, transfer = []) {
        this.port.postMessage({
            type: 'notify',
            data: {
                method,
                params
            }
        }, transfer);
    }
    async request(method, params = {}, transfer = []) {
        return new Promise((resolve, reject) => {
            const id = this.seq++;
            this.requestMap.set(id, {
                resolve,
                reject
            });
            this.port.postMessage({
                type: 'request',
                data: {
                    seq: id,
                    method,
                    params
                }
            }, transfer);
        });
    }
    reply(request, result, error, transfer = []) {
        const data = {
            seq: request.seq
        };
        if ((0,_function_isDef__WEBPACK_IMPORTED_MODULE_1__["default"])(result)) {
            data.result = result;
        }
        else if (error) {
            data.error = error;
        }
        if (transfer?.length) {
            this.port.postMessage({
                type: 'reply',
                data
            }, transfer);
        }
        else {
            this.port.postMessage({
                type: 'reply',
                data
            });
        }
    }
    getPort() {
        return this.port;
    }
    destroy() {
        if (this.requestMap.size) {
            this.requestMap.forEach((req) => {
                req.reject('ipc port close');
            });
            this.requestMap.clear();
        }
        if (this.port) {
            this.port.close();
            this.port = null;
        }
        this.closed = true;
    }
}


/***/ }),

/***/ "./src/common/network/NodeIPCPort.ts":
/*!*******************************************!*\
  !*** ./src/common/network/NodeIPCPort.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IPCPort */ "./src/common/network/IPCPort.ts");

class NodeIPCPort extends _IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(port) {
        super(port);
        // @ts-ignore
        this.port.on('message', this.handle.bind(this));
    }
}


/***/ }),

/***/ "./src/common/timer/Clock.ts":
/*!***********************************!*\
  !*** ./src/common/timer/Clock.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Clock)
/* harmony export */ });
/* harmony import */ var _function_isWorker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var _function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var _WorkerSetTimeout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WorkerSetTimeout */ "./src/common/timer/WorkerSetTimeout.ts");
/* harmony import */ var _function_debounce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../function/debounce */ "./src/common/function/debounce.ts");




let workerSetTimeout;
let workerSetTimeoutCounter = 0;
function createWorkerSetTimeout() {
    if (workerSetTimeout) {
        workerSetTimeoutCounter++;
        return workerSetTimeout;
    }
    workerSetTimeout = new _WorkerSetTimeout__WEBPACK_IMPORTED_MODULE_2__["default"]();
    workerSetTimeoutCounter = 1;
    return workerSetTimeout;
}
function deleteWorkerSetTimeout() {
    if (workerSetTimeoutCounter === 0) {
        return;
    }
    workerSetTimeoutCounter--;
    if (workerSetTimeoutCounter === 0) {
        workerSetTimeout.destroy();
        workerSetTimeout = null;
    }
}
class Clock {
    messageChannel;
    interval;
    started;
    timer;
    workerTimer;
    workerSetTimeout;
    onClock;
    nextTick;
    /**
     * messageChannel  0.2
     */
    a;
    /**
     * setTimeout  4
     */
    b;
    /**
     * 50   messageChannel 
     */
    beta;
    /**
     * 50   setTimeout 
     */
    alpha;
    count;
    /**
     * 
     */
    equivalent;
    timestamp;
    onVisibilityChange;
    timeoutNext;
    running;
    highPerformance;
    constructor(interval, highPerformance = true) {
        this.started = false;
        this.interval = interval;
        this.highPerformance = highPerformance;
        this.a = 0.2;
        this.b = 4;
        this.equivalent = 50;
        this.timestamp = 0;
        this.nextTick = () => {
            if (!this.started || this.running) {
                return;
            }
            this.running = true;
            if (this.interval >= 4 || !this.highPerformance) {
                this.timeoutTick();
            }
            else if (this.interval <= 0) {
                this.messageChannel.port1.postMessage(null);
            }
            else {
                const now = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
                if (now - this.timestamp > this.equivalent) {
                    this.count = 0;
                    this.timestamp = now;
                }
                if (this.count < this.beta) {
                    this.messageChannel.port1.postMessage(null);
                }
                else {
                    this.timeoutTick();
                }
            }
        };
        this.compute();
        this.messageChannel = new MessageChannel();
        this.handleEvent();
        this.timeoutNext = (worker) => {
            if (worker) {
                this.workerTimer = null;
            }
            else {
                this.timer = null;
            }
            this.running = false;
            this.count++;
            if (this.onClock) {
                this.onClock(this.nextTick);
            }
            else {
                this.nextTick();
            }
        };
        if (!(0,_function_isWorker__WEBPACK_IMPORTED_MODULE_0__["default"])() && document.visibilityState === 'hidden') {
            this.workerSetTimeout = createWorkerSetTimeout();
        }
        this.running = false;
    }
    compute(clear = true) {
        if (this.interval > 0) {
            this.beta = Math.ceil(this.equivalent * (1 - this.b / this.interval) / (this.a - this.b));
            this.alpha = Math.floor(this.equivalent / this.interval - this.beta);
            if (clear) {
                this.count = 0;
            }
        }
    }
    timeoutTick() {
        if (this.workerSetTimeout
            && document.visibilityState === 'hidden'
            && this.interval < 1000) {
            this.workerTimer = this.workerSetTimeout.setTimeout(this.timeoutNext, this.interval);
        }
        else {
            this.timer = setTimeout(this.timeoutNext, this.interval);
        }
    }
    start() {
        if (this.started) {
            return;
        }
        this.started = true;
        this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
        this.nextTick();
    }
    stop() {
        this.started = false;
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        if (this.workerTimer && this.workerSetTimeout) {
            this.workerSetTimeout.clearTimeout(this.workerTimer);
        }
        this.running = false;
    }
    isStarted() {
        return this.started;
    }
    setInterval(interval) {
        this.interval = Math.max(interval, 0);
        this.compute();
    }
    getInterval() {
        return this.interval;
    }
    isZeroTimeout() {
        return this.interval < 4;
    }
    destroy() {
        this.stop();
        if (this.workerSetTimeout) {
            deleteWorkerSetTimeout();
            this.workerSetTimeout = null;
        }
        if (this.onVisibilityChange) {
            document.removeEventListener('visibilitychange', this.onVisibilityChange);
            this.onVisibilityChange = null;
        }
    }
    handleEvent() {
        this.messageChannel.port2.onmessage = () => {
            if (!this.started) {
                return;
            }
            this.running = false;
            this.count++;
            if (this.onClock) {
                this.onClock(this.nextTick);
            }
            else {
                this.nextTick();
            }
        };
        if (!(0,_function_isWorker__WEBPACK_IMPORTED_MODULE_0__["default"])()) {
            this.onVisibilityChange = (0,_function_debounce__WEBPACK_IMPORTED_MODULE_3__["default"])((event) => {
                if (document.visibilityState === 'hidden') {
                    this.workerSetTimeout = createWorkerSetTimeout();
                    if (this.timer) {
                        clearTimeout(this.timer);
                        this.timer = null;
                        this.running = false;
                    }
                    this.nextTick();
                }
                else {
                    if (this.workerTimer) {
                        this.workerSetTimeout.clearTimeout(this.workerTimer);
                        this.workerTimer = null;
                        this.running = false;
                    }
                    if (this.timer) {
                        clearTimeout(this.timer);
                        this.timer = null;
                        this.running = false;
                    }
                    deleteWorkerSetTimeout();
                    this.workerSetTimeout = null;
                    this.nextTick();
                }
            }, 20);
            document.addEventListener('visibilitychange', this.onVisibilityChange);
        }
    }
}


/***/ }),

/***/ "./src/common/timer/LoopTask.ts":
/*!**************************************!*\
  !*** ./src/common/timer/LoopTask.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LoopTask)
/* harmony export */ });
/* harmony import */ var _Clock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Clock */ "./src/common/timer/Clock.ts");
/* harmony import */ var _function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/**
 * @file 
 */


class LoopTask {
    task;
    count;
    emptyCount;
    started;
    clock;
    timestamp;
    timeout;
    interval;
    startTimer;
    autoInterval;
    sync;
    tickAfter;
    processing;
    constructor(task, timeout = 0, interval = 0, autoInterval = true, sync = true) {
        this.task = task;
        this.timeout = timeout;
        this.interval = interval;
        this.autoInterval = autoInterval;
        this.sync = sync;
        this.count = 0;
        this.emptyCount = 0;
        this.timestamp = 0;
        this.started = false;
        this.processing = false;
        this.clock = new _Clock__WEBPACK_IMPORTED_MODULE_0__["default"](this.interval);
        this.clock.onClock = (next) => {
            if (!this.started) {
                return;
            }
            this.count++;
            if (this.sync) {
                if (this.tickAfter) {
                    this.tickAfter();
                    this.tickAfter = null;
                }
                if (this.task() === false) {
                    this.stop();
                }
                else {
                    this.next(next);
                }
            }
            else {
                if (this.processing) {
                    return;
                }
                this.processing = true;
                this.task().then((result) => {
                    this.processing = false;
                    if (this.tickAfter) {
                        this.tickAfter();
                        this.tickAfter = null;
                    }
                    if (result === false) {
                        this.stop();
                    }
                    else {
                        this.next(next);
                    }
                });
            }
        };
    }
    next(next) {
        if (!this.started) {
            return;
        }
        const now = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
        if (this.autoInterval && now - this.timestamp > 50) {
            const load = this.emptyCount / this.count;
            /**
             * 1000  10%
             *  0
             */
            if (this.emptyCount === 0) {
                this.clock.setInterval(Math.max(this.clock.getInterval() >> 1, this.interval));
            }
            else if (load < 0.1) {
                this.clock.setInterval(this.clock.getInterval() - 1);
            }
            else if (load > 0.2) {
                this.clock.setInterval(Math.min(this.clock.getInterval() + 1, 20));
            }
            else if (load > 0.5) {
                this.clock.setInterval(this.clock.getInterval() << 1);
            }
            this.count = 0;
            this.emptyCount = 0;
            this.timestamp = now;
        }
        next();
    }
    start() {
        this.started = true;
        if (this.timeout) {
            this.startTimer = setTimeout(() => {
                this.count = 0;
                this.emptyCount = 0;
                this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
                this.clock.start();
                this.startTimer = null;
            }, this.timeout);
        }
        else {
            this.count = 0;
            this.emptyCount = 0;
            this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
            this.clock.start();
        }
    }
    stop() {
        this.started = false;
        this.processing = false;
        if (this.startTimer) {
            clearTimeout(this.startTimer);
            this.startTimer = null;
        }
        this.clock.stop();
    }
    async stopBeforeNextTick() {
        if (this.startTimer) {
            clearTimeout(this.startTimer);
            this.startTimer = null;
        }
        if (!this.clock.isStarted()) {
            return;
        }
        if (this.sync) {
            this.started = false;
            this.processing = false;
            this.clock.stop();
        }
        else {
            return new Promise((resolve) => {
                this.tickAfter = () => {
                    this.started = false;
                    this.processing = false;
                    this.clock.stop();
                    resolve();
                };
            });
        }
    }
    isStarted() {
        return this.started;
    }
    emptyTask() {
        this.emptyCount++;
    }
    isZeroTimeout() {
        return this.clock?.isZeroTimeout();
    }
    restart() {
        if (this.clock) {
            this.stop();
            this.clock.setInterval(this.interval);
            this.start();
        }
    }
    resetInterval() {
        this.clock.setInterval(Math.max(this.clock.getInterval() >> 1, this.interval));
        this.emptyCount = 0;
        this.count = 0;
        this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
    }
    destroy() {
        this.stop();
        this.task = null;
        this.timeout = null;
        this.interval = null;
    }
}


/***/ }),

/***/ "./src/common/timer/Sleep.ts":
/*!***********************************!*\
  !*** ./src/common/timer/Sleep.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Sleep)
/* harmony export */ });
/**
 * @file sleep
 */
class Sleep {
    timeout;
    timer;
    resolve;
    reject;
    startTime;
    /**
     *
     * @param timeout 
     */
    constructor(timeout) {
        this.timeout = timeout;
    }
    then(res, rej) {
        this.resolve = res;
        this.reject = rej;
        this.startTime = Date.now();
        this.timer = setTimeout(() => {
            this.resolve(Date.now() - this.startTime);
            this.timer = null;
        }, this.timeout * 1000);
    }
    stop(resolve = true) {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
            if (this.resolve && resolve) {
                this.resolve(Date.now() - this.startTime);
            }
            else if (this.reject && !resolve) {
                this.reject(Date.now() - this.startTime);
            }
        }
    }
    reset(timeout) {
        if (timeout) {
            this.timeout = timeout;
        }
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = setTimeout(() => {
                this.resolve(Date.now() - this.startTime);
                this.timer = null;
            }, this.timeout * 1000);
        }
    }
}


/***/ }),

/***/ "./src/common/timer/Timer.ts":
/*!***********************************!*\
  !*** ./src/common/timer/Timer.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Timer)
/* harmony export */ });
/**
 * @file 
 */
class Timer {
    task;
    timeout;
    interval;
    timer;
    /**
     *
     * @param task 
     * @param timeout 
     * @param interval 
     */
    constructor(task, timeout, interval) {
        this.task = task;
        this.timeout = timeout;
        this.interval = interval;
    }
    /**
     * 
     */
    start() {
        const me = this;
        me.stop();
        let timeout = me.timeout;
        const interval = me.interval;
        const next = function () {
            if (me.task() !== false
                && me.timer) {
                me.timer = setTimeout(next, me.interval);
            }
            else {
                me.stop();
            }
        };
        if (timeout == null) {
            timeout = interval;
        }
        me.timer = setTimeout(next, timeout);
    }
    /**
     * 
     */
    stop() {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    }
    updateInterval(interval) {
        this.interval = interval;
    }
    /**
     * 
     */
    isStarted() {
        return !!this.timer;
    }
    /**
     * 
     */
    destroy() {
        this.stop();
        this.task = this.timeout = this.interval = null;
    }
}


/***/ }),

/***/ "./src/common/timer/WorkerSetTimeout.ts":
/*!**********************************************!*\
  !*** ./src/common/timer/WorkerSetTimeout.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerSetTimeout)
/* harmony export */ });
/* harmony import */ var _function_sourceLoad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function/sourceLoad */ "./src/common/function/sourceLoad.ts");

__webpack_require__(/*! ./workerSetTimeoutTask */ "./src/common/timer/workerSetTimeoutTask.ts");
class WorkerSetTimeout {
    worker;
    workerUrl;
    taskMap;
    id;
    constructor() {
        this.id = 0;
        this.taskMap = new Map();
        const workerSource = `
      ${(0,_function_sourceLoad__WEBPACK_IMPORTED_MODULE_0__["default"])(/*require.resolve*/(/*! ./workerSetTimeoutTask */ "./src/common/timer/workerSetTimeoutTask.ts"), { varName: 'workerSetTimeoutTask' })}
      workerSetTimeoutTask.default(self)
    `;
        const blob = new Blob([workerSource], { type: 'text/javascript' });
        this.workerUrl = URL.createObjectURL(blob);
        this.worker = new Worker(this.workerUrl);
        this.worker.addEventListener('message', (message) => {
            const origin = message.data;
            const type = origin.type;
            const id = origin.id;
            switch (type) {
                case 'pong':
                    const task = this.taskMap.get(id);
                    if (task) {
                        task(true);
                    }
                    break;
            }
        });
    }
    setTimeout(task, timeout = 0) {
        const id = this.id++;
        this.taskMap.set(id, task);
        this.worker.postMessage({
            type: 'ping',
            data: {
                timeout,
                id
            }
        });
        return id;
    }
    clearTimeout(id) {
        this.taskMap.delete(id);
    }
    destroy() {
        if (this.worker) {
            this.worker.terminate();
            this.worker = null;
        }
        if (this.workerUrl) {
            URL.revokeObjectURL(this.workerUrl);
            this.workerUrl = null;
        }
        if (this.taskMap) {
            this.taskMap.clear();
            this.taskMap = null;
        }
    }
}


/***/ }),

/***/ "./src/common/timer/WorkerTimer.ts":
/*!*****************************************!*\
  !*** ./src/common/timer/WorkerTimer.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerTimer)
/* harmony export */ });
/* harmony import */ var _Clock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Clock */ "./src/common/timer/Clock.ts");
/**
 * @file worker  settimeout  1s 
 */

class WorkerTimer {
    task;
    timeout;
    interval;
    clock;
    started;
    timer;
    constructor(task, timeout, interval) {
        this.task = task;
        this.timeout = timeout;
        this.interval = interval;
        this.started = false;
        this.clock = new _Clock__WEBPACK_IMPORTED_MODULE_0__["default"](this.interval, false);
        this.clock.onClock = (next) => {
            if (this.started && this.task() === false) {
                this.stop();
            }
            else {
                next();
            }
        };
    }
    start() {
        this.started = true;
        if (this.timeout > 0) {
            this.timer = setTimeout(() => {
                this.timer = null;
                this.clock.start();
            }, this.timeout);
        }
        else {
            this.clock.start();
        }
    }
    stop() {
        this.started = false;
        this.clock.stop();
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    }
    isStarted() {
        return this.started;
    }
    updateInterval(interval) {
        this.interval = interval;
        this.clock.setInterval(interval);
    }
    destroy() {
        if (this.clock) {
            this.stop();
            this.clock.destroy();
            this.clock = null;
        }
        this.started = false;
        this.task = this.timeout = this.interval = null;
    }
}


/***/ }),

/***/ "./src/common/timer/workerSetTimeoutTask.ts":
/*!**************************************************!*\
  !*** ./src/common/timer/workerSetTimeoutTask.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ run)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src\\common\\timer\\workerSetTimeoutTask.ts";

class WorkerSetTimeout {
    worker;
    constructor(self) {
        this.worker = self;
        this.handleEvents();
    }
    handleEvents() {
        this.worker.addEventListener('message', (message) => {
            const origin = message.data;
            let data = origin.data;
            setTimeout(() => {
                this.worker.postMessage({
                    type: 'pong',
                    id: data.id
                });
            }, Math.max(data.timeout ?? 0, 4));
        });
    }
}
function run(self) {
    try {
        new WorkerSetTimeout(self);
    }
    catch (error) {
        _util_logger__WEBPACK_IMPORTED_MODULE_0__.error('new WorkerSetTimeout failed', cheap__fileName__0, 32);
    }
}


/***/ }),

/***/ "./src/common/util/array.ts":
/*!**********************************!*\
  !*** ./src/common/util/array.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   binarySearch: () => (/* binding */ binarySearch),
/* harmony export */   each: () => (/* binding */ each),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   indexOf: () => (/* binding */ indexOf),
/* harmony export */   push: () => (/* binding */ push),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   sortInsert: () => (/* binding */ sortInsert),
/* harmony export */   toArray: () => (/* binding */ toArray)
/* harmony export */ });
/* unused harmony exports unshift, last, pop, toObject, join, falsy, exclude */
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _function_execute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/execute */ "./src/common/function/execute.ts");
/**
 * @file 
 */



/**
 * 
 *
 * @param array
 * @param callback  false 
 * @param reversed 
 */
function each(array, callback, reversed) {
    if (!array) {
        return;
    }
    const { length } = array;
    if (length) {
        if (reversed) {
            for (let i = length - 1; i >= 0; i--) {
                if (callback(array[i], i) === _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE) {
                    break;
                }
            }
        }
        else {
            for (let i = 0; i < length; i++) {
                if (callback(array[i], i) === _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE) {
                    break;
                }
            }
        }
    }
}
function nativePush(array, item) {
    array[array.length] = item;
}
function nativeUnshift(array, item) {
    array.unshift(item);
}
/**
 * 
 *
 * @param array
 * @param value
 * @param action
 */
function addItem(array, value, action) {
    if (_is__WEBPACK_IMPORTED_MODULE_0__.array(value)) {
        each(value, function (item) {
            action(array, item);
        });
    }
    else {
        action(array, value);
    }
}
/**
 * 
 *
 * @param array
 * @param target
 */
function push(array, target) {
    addItem(array, target, nativePush);
}
/**
 * 
 *
 * @param array
 * @param target
 */
function unshift(array, target) {
    addItem(array, target, nativeUnshift);
}
/**
 * 
 *
 * @param array 
 * @param target 
 * @param strict 
 * @return  -1
 */
function indexOf(array, target, strict) {
    let result = _constant__WEBPACK_IMPORTED_MODULE_1__.MINUS_ONE;
    each(array, function (item, index) {
        if (strict === _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE ? item == target : item === target) {
            result = index;
            return _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE;
        }
    });
    return result;
}
/**
 * 
 *
 * @param array 
 * @return
 */
function last(array) {
    const { length } = array;
    if (length > 0) {
        return array[length - 1];
    }
}
/**
 * 
 *
 * 
 *
 * @param array 
 * @return 
 */
function pop(array) {
    const { length } = array;
    if (length > 0) {
        return array.pop();
    }
}
/**
 * 
 *
 * @param array 
 * @param item 
 * @param strict 
 * @return 
 */
function remove(array, target, strict) {
    let result = 0;
    each(array, function (item, index) {
        if (strict === _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE ? item == target : item === target) {
            array.splice(index, 1);
            result++;
        }
    }, _constant__WEBPACK_IMPORTED_MODULE_1__.TRUE);
    return result;
}
/**
 *  item
 *
 * @param array 
 * @param target 
 * @param strict 
 * @return
 */
function has(array, target, strict) {
    return indexOf(array, target, strict) >= 0;
}
/**
 * 
 *
 * @param array 
 * @return
 */
function toArray(array) {
    return _is__WEBPACK_IMPORTED_MODULE_0__.array(array)
        ? array
        : (0,_function_execute__WEBPACK_IMPORTED_MODULE_2__["default"])(_constant__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY.slice, array);
}
/**
 * 
 *
 * @param array 
 * @param key 
 * @param value
 * @return
 */
function toObject(array, key, value) {
    let result = {};
    each(array, function (item) {
        result[key ? item[key] : item] = value || item;
    });
    return result;
}
/**
 * 
 *
 * @param array
 * @param separator
 * @return
 */
function join(array, separator) {
    return array.join(separator);
}
/**
 *  0 
 *
 * @param array
 * @return
 */
function falsy(array) {
    return !_is__WEBPACK_IMPORTED_MODULE_0__.array(array) || !array.length;
}
/**
 * 
 *
 * @param source
 * @param exc
 * @returns
 */
function exclude(source, exc) {
    const items = [];
    each(source, (item, index) => {
        if (!has(exc, item)) {
            items.push(item);
        }
    });
    return items;
}
/**
 * 
 *
 * @param array
 * @param callback  0  -1  1
 * @returns
 */
function binarySearch(array, callback) {
    let left = 0;
    let right = array.length - 1;
    let index = -1;
    while (left <= right) {
        let mid = ((left + right) / 2) >>> 0;
        const ret = callback(array[mid]);
        if (ret === 0) {
            index = mid;
            break;
        }
        else if (ret === 1) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
            index = mid;
        }
    }
    return index;
}
function sortInsert(array, item, callback) {
    const index = binarySearch(array, callback);
    if (index > -1) {
        array.splice(index, 0, item);
    }
    else {
        array.push(item);
    }
}


/***/ }),

/***/ "./src/common/util/base32.ts":
/*!***********************************!*\
  !*** ./src/common/util/base32.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   encode: () => (/* binding */ encode)
/* harmony export */ });
/* unused harmony export decode */
const base32 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
/**
 * base32 
 */
function decode(text) {
    text = text.toUpperCase().replace(/=+$/, '');
    let bits = 0;
    let value = 0;
    let index = 0;
    const output = new Uint8Array(((text.length * 5) / 8) | 0);
    for (let i = 0; i < length; i++) {
        value = (value << 5) | base32.indexOf(text[i]);
        bits += 5;
        if (bits >= 8) {
            output[index++] = (value >>> (bits - 8)) & 255;
            bits -= 8;
        }
    }
    return output;
}
/**
 * base32 
 */
function encode(buffer, padding = true) {
    const length = buffer.length;
    let bits = 0;
    let value = 0;
    let output = '';
    for (let i = 0; i < length; i++) {
        value = (value << 8) | buffer[i];
        bits += 8;
        while (bits >= 5) {
            output += base32[(value >>> (bits - 5)) & 31];
            bits -= 5;
        }
    }
    if (bits > 0) {
        output += base32[(value << (5 - bits)) & 31];
    }
    if (padding) {
        while (output.length % 8 !== 0) {
            output += '=';
        }
    }
    return output;
}


/***/ }),

/***/ "./src/common/util/base64.ts":
/*!***********************************!*\
  !*** ./src/common/util/base64.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base64ToUint8Array: () => (/* binding */ base64ToUint8Array)
/* harmony export */ });
/* unused harmony exports base64Decode, list, map */
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./src/common/util/array.ts");

const base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
/**
 * utf8 
 * @param text
 */
function utf8Decode(text) {
    let string = '', i = 0, c = 0, c1 = 0, c2 = 0, c3 = 0;
    while (i < text.length) {
        c = text.charCodeAt(i);
        if (c < 128) {
            string += String.fromCharCode(c);
            i++;
        }
        else if ((c > 191) && (c < 224)) {
            c2 = text.charCodeAt(i + 1);
            string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            i += 2;
        }
        else {
            c2 = text.charCodeAt(i + 1);
            c3 = text.charCodeAt(i + 2);
            string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            i += 3;
        }
    }
    return string;
}
/**
 * base64 
 */
function base64Decode(text) {
    let output = '';
    let chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
    text = text.replace(/[^A-Za-z0-9\+\/\=]/g, '');
    //  4  =
    while (text.length % 4) {
        text += '=';
    }
    while (i < text.length) {
        enc1 = base64.indexOf(text.charAt(i++));
        enc2 = base64.indexOf(text.charAt(i++));
        enc3 = base64.indexOf(text.charAt(i++));
        enc4 = base64.indexOf(text.charAt(i++));
        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;
        output += String.fromCharCode(chr1);
        if (enc3 !== 64) {
            output += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
            output += String.fromCharCode(chr3);
        }
    }
    return utf8Decode(output);
}
function atobCustom(encodedString) {
    function decodeBase64(char) {
        const index = base64.indexOf(char);
        return index === -1 ? 0 : index;
    }
    let decodedString = '';
    for (let i = 0; i < encodedString.length;) {
        const enc1 = decodeBase64(encodedString[i++]);
        const enc2 = decodeBase64(encodedString[i++]);
        const enc3 = decodeBase64(encodedString[i++]);
        const enc4 = decodeBase64(encodedString[i++]);
        const chr1 = (enc1 << 2) | (enc2 >> 4);
        const chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        const chr3 = ((enc3 & 3) << 6) | enc4;
        decodedString += String.fromCharCode(chr1);
        if (enc3 !== 64) {
            decodedString += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
            decodedString += String.fromCharCode(chr3);
        }
    }
    return decodedString;
}
function base64ToUint8Array(string) {
    const binaryData = typeof atob === 'function' ? atob(string) : atobCustom(string);
    const uint8Array = new Uint8Array(binaryData.length);
    for (let i = 0; i < binaryData.length; i++) {
        uint8Array[i] = binaryData.charCodeAt(i);
    }
    return uint8Array;
}
const list = [
    'A', 'B', 'C', 'D', 'E', 'F',
    'G', 'H', 'I', 'J', 'K', 'L',
    'M', 'N', 'O', 'P', 'Q', 'R',
    'S', 'T', 'U', 'V', 'W', 'X',
    'Y', 'Z', 'a', 'b', 'c', 'd',
    'e', 'f', 'g', 'h', 'i', 'j',
    'k', 'l', 'm', 'n', 'o', 'p',
    'q', 'r', 's', 't', 'u', 'v',
    'w', 'x', 'y', 'z', '0', '1',
    '2', '3', '4', '5', '6', '7',
    '8', '9', '+', '/'
];
const _map = {};
_array__WEBPACK_IMPORTED_MODULE_0__.each(list, (char, index) => {
    _map[char] = index;
});
const map = _map;


/***/ }),

/***/ "./src/common/util/bigint.ts":
/*!***********************************!*\
  !*** ./src/common/util/bigint.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min)
/* harmony export */ });
function abs(a) {
    return a > 0 ? a : -a;
}
function max(a, b) {
    return a > b ? a : b;
}
function min(a, b) {
    return a > b ? b : a;
}


/***/ }),

/***/ "./src/common/util/browser.ts":
/*!************************************!*\
  !*** ./src/common/util/browser.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _function_checkVersion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/checkVersion */ "./src/common/function/checkVersion.ts");
/**
 * @file browser
 */



function getMajorVersion(version) {
    if (!_is__WEBPACK_IMPORTED_MODULE_1__.string(version)) {
        return '';
    }
    return version.split('.').shift() || '';
}
/**
 * UA 
 *
 * 
 *
 * {
 *    name: 'ie',     //  name  switch
 *    ie: true,       //  if (ie) { ... }
 *    version: '8.0'  // string 
 * }
 *
 */
// http://www.fynas.com/ua/search
const list = [
    ["alipay" /* BrowserType.ALIPAY */, /alipay/],
    ["wechat" /* BrowserType.WECHAT */, /micromessenger/],
    ["dingtalk" /* BrowserType.DING_TALK */, /dingtalk[ \/]([\d_.]+)/],
    ["baiduApp" /* BrowserType.BAIDU_APP */, /baiduboxapp/],
    ["baidu" /* BrowserType.BAIDU */, /baidubrowser/],
    ["baidu" /* BrowserType.BAIDU */, /bdbrowser/],
    ["uc" /* BrowserType.UC */, /ucbrowser/],
    ["uc" /* BrowserType.UC */, /ucweb/],
    ["qq" /* BrowserType.QQ */, /qqbrowser/],
    ["qqApp" /* BrowserType.QQ_APP */, /qq/],
    ["ie" /* BrowserType.IE */, /iemobile[ \/]([\d_.]+)/],
    // IE10-  MSIE x.0
    ["ie" /* BrowserType.IE */, /msie[ \/]([\d_.]+)/],
    ["ie" /* BrowserType.IE */, /trident[ \/]([\d_.]+)/, 4],
    ["edge" /* BrowserType.EDGE */, /edge[ \/]([\d_.]+)/],
    ["newEdge" /* BrowserType.NEW_EDGE */, /edg[ \/]([\d_.]+)/],
    ["chrome" /* BrowserType.CHROME */, /chrome[ \/]([\d_.]+)/],
    ["firefox" /* BrowserType.FIREFOX */, /firefox[ \/]([\d_.]+)/],
    ["opera" /* BrowserType.OPERA */, /opera(?:.*version)?[ \/]([\d_.]+)/],
    ["safari" /* BrowserType.SAFARI */, /version[ \/]([\d_.]+) safari/],
    //  Safari UA
    ["safari" /* BrowserType.SAFARI */, /version[ \/]([\d_.]+) \S* safari/],
    ["safari" /* BrowserType.SAFARI */, /safari/]
];
const getMajorVersionMap = {};
const checkVersionMap = {};
/**
 *  UA 
 *
 * @inner
 * @param {string} ua
 * @return {Object}
 */
function parseUA(ua) {
    let name;
    let version;
    (0,_util_array__WEBPACK_IMPORTED_MODULE_0__.each)(list, (item) => {
        let match = item[1].exec(ua);
        if (match) {
            name = item[0];
            version = match[1];
            if (version) {
                version = version.replace(/_/g, '.');
                if (item[2]) {
                    version = (parseInt(version, 10) + item[2]) + '.0';
                }
            }
            return false;
        }
    });
    return {
        name: name || '',
        version: version || '',
        majorVersion: (getMajorVersionMap[name] || getMajorVersion)(version),
        checkVersion: checkVersionMap[name] || _function_checkVersion__WEBPACK_IMPORTED_MODULE_2__["default"]
    };
}
const browser = parseUA((typeof navigator === 'object' && navigator.userAgent || '').toLowerCase());
if (browser.name) {
    browser[browser.name] = true;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (browser);


/***/ }),

/***/ "./src/common/util/constant.ts":
/*!*************************************!*\
  !*** ./src/common/util/constant.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_ARRAY: () => (/* binding */ EMPTY_ARRAY),
/* harmony export */   EMPTY_FUNCTION: () => (/* binding */ EMPTY_FUNCTION),
/* harmony export */   EMPTY_STRING: () => (/* binding */ EMPTY_STRING),
/* harmony export */   FALSE: () => (/* binding */ FALSE),
/* harmony export */   GLOBAL: () => (/* binding */ GLOBAL),
/* harmony export */   MINUS_ONE: () => (/* binding */ MINUS_ONE),
/* harmony export */   NULL: () => (/* binding */ NULL),
/* harmony export */   RAW_DOT: () => (/* binding */ RAW_DOT),
/* harmony export */   RAW_FUNCTION: () => (/* binding */ RAW_FUNCTION),
/* harmony export */   RAW_UNDEFINED: () => (/* binding */ RAW_UNDEFINED),
/* harmony export */   RAW_WILDCARD: () => (/* binding */ RAW_WILDCARD),
/* harmony export */   SELF: () => (/* binding */ SELF),
/* harmony export */   TRUE: () => (/* binding */ TRUE),
/* harmony export */   UNDEFINED: () => (/* binding */ UNDEFINED),
/* harmony export */   WINDOW: () => (/* binding */ WINDOW)
/* harmony export */ });
/* unused harmony exports RAW_TRUE, RAW_FALSE, RAW_NULL, RAW_THIS, RAW_VALUE, RAW_LENGTH, RAW_SLASH, RAW_TAG, KEYPATH_PARENT, KEYPATH_CURRENT, DOCUMENT, EMPTY_OBJECT */
/**
 * @file 
 */
const TRUE = true;
const FALSE = false;
const NULL = null;
const UNDEFINED = void 0;
const MINUS_ONE = -1;
const RAW_TRUE = 'true';
const RAW_FALSE = 'false';
const RAW_NULL = 'null';
const RAW_UNDEFINED = 'undefined';
const RAW_THIS = 'this';
const RAW_VALUE = 'value';
const RAW_LENGTH = 'length';
const RAW_FUNCTION = 'function';
const RAW_WILDCARD = '*';
const RAW_DOT = '.';
const RAW_SLASH = '/';
const RAW_TAG = 'tag';
const KEYPATH_PARENT = '..';
const KEYPATH_CURRENT = RAW_THIS;
/**
 * Single instance for window in browser
 */
const WINDOW = typeof window !== RAW_UNDEFINED ? window : UNDEFINED;
/**
 * Single instance for document in browser
 */
const DOCUMENT = typeof document !== RAW_UNDEFINED ? document : UNDEFINED;
/**
 * Single instance for global in nodejs or browser
 */
// @ts-ignore
const GLOBAL = typeof globalThis !== RAW_UNDEFINED ? globalThis : (typeof __webpack_require__.g !== RAW_UNDEFINED ? __webpack_require__.g : WINDOW);
/**
 * Single instance for self in nodejs or browser
 */
// @ts-ignore
const SELF = typeof self !== RAW_UNDEFINED ? self : GLOBAL;
/**
 * Single instance for noop function
 */
const EMPTY_FUNCTION = function () {
    /** common */
};
/**
 *  `a || EMPTY_OBJECT` 
 */
const EMPTY_OBJECT = Object.freeze({});
/**
 * 
 */
const EMPTY_ARRAY = Object.freeze([]);
/**
 * 
 */
const EMPTY_STRING = '';


/***/ }),

/***/ "./src/common/util/is.ts":
/*!*******************************!*\
  !*** ./src/common/util/is.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   array: () => (/* binding */ array),
/* harmony export */   arrayBuffer: () => (/* binding */ arrayBuffer),
/* harmony export */   bigint: () => (/* binding */ bigint),
/* harmony export */   boolean: () => (/* binding */ boolean),
/* harmony export */   func: () => (/* binding */ func),
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),
/* harmony export */   number: () => (/* binding */ number),
/* harmony export */   numeric: () => (/* binding */ numeric),
/* harmony export */   object: () => (/* binding */ object),
/* harmony export */   string: () => (/* binding */ string)
/* harmony export */ });
/* unused harmony export range */
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/**
 * @file 
 */

/**
 * Check if value is a function.
 *
 * @param value
 * @return
 */
function func(value) {
    return typeof value === _constant__WEBPACK_IMPORTED_MODULE_0__.RAW_FUNCTION;
}
/**
 * Check if value is an array.
 *
 * @param value
 * @return
 */
function array(value) {
    return Array.isArray(value);
}
/**
 * Check if value is an object.
 *
 * @param value
 * @return
 */
function object(value) {
    //  IE  null  object
    return value !== _constant__WEBPACK_IMPORTED_MODULE_0__.NULL && typeof value === 'object';
}
/**
 * Check if value is a string.
 *
 * @param value
 * @return
 */
function string(value) {
    return typeof value === 'string';
}
/**
 * Check if value is a number.
 *
 * @param value
 * @return
 */
function number(value) {
    return typeof value === 'number' && !isNaN(value);
}
/**
 * Check if value is a bigint.
 *
 * @param value
 * @return
 */
function bigint(value) {
    return typeof value === 'bigint';
}
/**
 * Check if value is boolean.
 *
 * @param value
 * @return
 */
function boolean(value) {
    return typeof value === 'boolean';
}
/**
 * Check if value is numeric.
 *
 * @param value
 * @return
 */
function numeric(value) {
    return number(value)
        || (string(value) && !isNaN(parseFloat(value)) && isFinite(+value));
}
const hasOwn = {}.hasOwnProperty;
/**
 * 
 *
 * @param {*} target
 * @return {boolean}
 */
function isPlainObject(target) {
    if (!object(target) || target.nodeType || target === target.window) {
        return false;
    }
    if (target.constructor
        && !hasOwn.call(target, 'constructor')
        && !hasOwn.call(target.constructor.prototype || {}, 'isPrototypeOf')) {
        return false;
    }
    let key;
    for (key in target) {
        /* empty */
    }
    return key === undefined || hasOwn.call(target, key);
}
/**
 *  value 
 *
 * @param value 
 * @param min 
 * @param max 
 */
function range(value, min, max) {
    return value >= min && value <= max;
}
/**
 * Check if value is ArrayBuffer.
 *
 * @param value
 * @returns
 */
function arrayBuffer(value) {
    return value instanceof ArrayBuffer;
}


/***/ }),

/***/ "./src/common/util/keyboard.ts":
/*!*************************************!*\
  !*** ./src/common/util/keyboard.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   charKey: () => (/* binding */ charKey),
/* harmony export */   combinationKey: () => (/* binding */ combinationKey),
/* harmony export */   functionKey: () => (/* binding */ functionKey)
/* harmony export */ });
/* unused harmony exports deleteKey, keyChar, keyDelete, keyFunction, keyCombination, isCharKey, isDeleteKey, isFunctionKey, isCombinationKey */
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object */ "./src/common/util/object.ts");

/**
 * 
 */
const charKey = {
    // 
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    // 
    '0': 48,
    '1': 49,
    '2': 50,
    '3': 51,
    '4': 52,
    '5': 53,
    '6': 54,
    '7': 55,
    '8': 56,
    '9': 57,
    // 
    '`': 192,
    '+': 187,
    '-': 189,
    '=': 61,
    '[': 219,
    ']': 221,
    '\\': 220,
    ';': 59,
    '\'': 222,
    ',': 188,
    '.': 190,
    '/': 191,
    //  $
    '$0': 96,
    '$1': 97,
    '$2': 98,
    '$3': 99,
    '$4': 100,
    '$5': 101,
    '$6': 102,
    '$7': 103,
    '$8': 104,
    '$9': 105,
    '$.': 110,
    '$+': 107,
    '$-': 109,
    '$*': 106,
    '$/': 111,
    space: 32,
    tab: 9
};
/**
* 
*/
const deleteKey = {
    backspace: 8,
    'delete': 46
};
/**
* 
*/
const functionKey = {
    // F1 -> F12
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    // 
    enter: 13,
    esc: 27,
    capslock: 20,
    insert: 45,
    home: 36,
    end: 35,
    pageup: 33,
    pagedown: 34,
    // 
    left: 37,
    right: 39,
    up: 38,
    down: 40
};
/**
* 
*/
const combinationKey = {
    shift: 16,
    ctrl: 17,
    meta: 91,
    alt: 18
};
const keyChar = (0,_object__WEBPACK_IMPORTED_MODULE_0__.reverse)(charKey);
const keyDelete = (0,_object__WEBPACK_IMPORTED_MODULE_0__.reverse)(deleteKey);
const keyFunction = (0,_object__WEBPACK_IMPORTED_MODULE_0__.reverse)(functionKey);
const keyCombination = (0,_object__WEBPACK_IMPORTED_MODULE_0__.reverse)(combinationKey);
function isCharKey(keyCode) {
    return keyCode in keyChar;
}
function isDeleteKey(keyCode) {
    return keyCode in keyDelete;
}
function isFunctionKey(keyCode) {
    return keyCode in keyFunction;
}
function isCombinationKey(keyCode) {
    return keyCode in keyCombination;
}


/***/ }),

/***/ "./src/common/util/keypath.ts":
/*!************************************!*\
  !*** ./src/common/util/keypath.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   each: () => (/* binding */ each)
/* harmony export */ });
/* unused harmony exports match, join, isFuzzy, matchFuzzy, rootPath */
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./string */ "./src/common/util/string.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/**
 * @file 
 */


const dotPattern = /\./g, asteriskPattern = /\*/g, doubleAsteriskPattern = /\*\*/g, splitCache = {}, patternCache = {};
/**
 *  keypath  prefix  -1
 *
 * @param keypath
 * @param prefix
 * @return
 */
function match(keypath, prefix) {
    if (keypath === prefix) {
        return prefix.length;
    }
    prefix += _constant__WEBPACK_IMPORTED_MODULE_1__.RAW_DOT;
    return _string__WEBPACK_IMPORTED_MODULE_0__.startsWith(keypath, prefix)
        ? prefix.length
        : _constant__WEBPACK_IMPORTED_MODULE_1__.MINUS_ONE;
}
/**
 *  keypath 
 *
 * @param keypath
 * @param callback  false 
 */
function each(keypath, callback) {
    /*
     *  keypath  toString 
     * splitCache[keypath] 
     */
    const list = splitCache.hasOwnProperty(keypath)
        ? splitCache[keypath]
        : (splitCache[keypath] = keypath.split(_constant__WEBPACK_IMPORTED_MODULE_1__.RAW_DOT));
    for (let i = 0, lastIndex = list.length - 1; i <= lastIndex; i++) {
        if (callback(list[i], i === lastIndex) === _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE) {
            break;
        }
    }
}
/**
 * 
 *
 * @param keypath1
 * @param keypath2
 */
function join(keypath1, keypath2) {
    return keypath1 && keypath2
        ? keypath1 + _constant__WEBPACK_IMPORTED_MODULE_1__.RAW_DOT + keypath2
        : keypath1 || keypath2;
}
/**
 * 
 *
 * @param keypath
 */
function isFuzzy(keypath) {
    return _string__WEBPACK_IMPORTED_MODULE_0__.has(keypath, _constant__WEBPACK_IMPORTED_MODULE_1__.RAW_WILDCARD);
}
/**
 *  keypath
 *
 * @param keypath 
 * @param pattern 
 */
function matchFuzzy(keypath, pattern) {
    let cache = patternCache[pattern];
    if (!cache) {
        const str = pattern
            .replace(dotPattern, '\\.')
            .replace(asteriskPattern, '(\\w+)')
            .replace(doubleAsteriskPattern, '([\.\\w]+?)');
        cache = patternCache[pattern] = new RegExp(`^${str}$`);
    }
    const result = keypath.match(cache);
    if (result) {
        return result[1];
    }
}
/**
 *  keypath 
 *
 * @param keypath
 */
function rootPath(keypath) {
    return keypath && keypath.split(_constant__WEBPACK_IMPORTED_MODULE_1__.RAW_DOT).shift();
}


/***/ }),

/***/ "./src/common/util/logger.ts":
/*!***********************************!*\
  !*** ./src/common/util/logger.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   INFO: () => (/* binding */ INFO),
/* harmony export */   debug: () => (/* binding */ debug),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   fatal: () => (/* binding */ fatal),
/* harmony export */   info: () => (/* binding */ info),
/* harmony export */   setLevel: () => (/* binding */ setLevel),
/* harmony export */   warn: () => (/* binding */ warn)
/* harmony export */ });
/* unused harmony exports TRACE, DEBUG, WARN, ERROR, FATAL, trace, log, enableUploadLog, disableUploadLog, canUploadLog, setUploadLevel, getUploadLevel */
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _function_toString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/toString */ "./src/common/function/toString.ts");
/**
 * @file 
 */


const TRACE = 0;
const DEBUG = 1;
const INFO = 2;
const WARN = 3;
const ERROR = 4;
const FATAL = 5;
const nativeConsole = typeof console !== _constant__WEBPACK_IMPORTED_MODULE_0__.RAW_UNDEFINED ? console : _constant__WEBPACK_IMPORTED_MODULE_0__.NULL, 
/**
 * empty function 
 */
defaultLogLevel = /common/.test((0,_function_toString__WEBPACK_IMPORTED_MODULE_1__["default"])(_constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_FUNCTION)) ? INFO : WARN, 
/**
 * console 
 * ie  edge  console.log 
 */
stylePrefix = _constant__WEBPACK_IMPORTED_MODULE_0__.WINDOW && /edge|msie|trident/i.test(_constant__WEBPACK_IMPORTED_MODULE_0__.WINDOW.navigator.userAgent) || true
    ? _constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STRING
    : 0, 
/**
 * 
 */
printLog = nativeConsole
    ? stylePrefix
        ? function (tag, msg, style) {
            nativeConsole.log(stylePrefix + tag, style, msg);
        }
        : function (tag, msg) {
            nativeConsole.log(tag, msg);
        }
    : _constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_FUNCTION;
/**
 * 
 */
function getLogLevel() {
    if (_constant__WEBPACK_IMPORTED_MODULE_0__.GLOBAL) {
        const logLevel = _constant__WEBPACK_IMPORTED_MODULE_0__.SELF['COMMON_LOG_LEVEL'];
        if (logLevel >= TRACE && logLevel <= FATAL) {
            return logLevel;
        }
    }
    return defaultLogLevel;
}
/**
 * 
 *
 * @param level 
 */
function setLevel(level) {
    _constant__WEBPACK_IMPORTED_MODULE_0__.SELF['COMMON_LOG_LEVEL'] = level;
}
function getStyle(backgroundColor) {
    return `background-color:${backgroundColor};border-radius:12px;color:#fff;font-size:10px;padding:3px 6px;`;
}
function trace(msg, file, line) {
    if (getLogLevel() <= TRACE) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [trace]`, msg, getStyle('#999'));
    }
}
function debug(msg, file, line) {
    if (getLogLevel() <= DEBUG) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [debug]`, msg, getStyle('#999'));
    }
}
function info(msg, file, line) {
    if (getLogLevel() <= INFO) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [info]`, msg, getStyle('#2db7f5'));
    }
}
function warn(msg, file, line) {
    if (getLogLevel() <= WARN) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [warn]`, msg, getStyle('#f90'));
    }
}
function error(msg, file, line) {
    if (getLogLevel() <= ERROR) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [error]`, msg, getStyle('#ed4014'));
    }
}
function fatal(msg, file, line) {
    if (getLogLevel() <= FATAL) {
        error(msg, file, line);
        throw new Error(`[${arguments[1]}][line ${arguments[2]}] [fatal]: ${msg}`);
    }
}
function log(level, msg, file, line) {
    if (level === TRACE) {
        trace(msg, arguments[2], arguments[3]);
    }
    else if (level === DEBUG) {
        debug(msg, arguments[2], arguments[3]);
    }
    else if (level === INFO) {
        info(msg, arguments[2], arguments[3]);
    }
    else if (level === WARN) {
        warn(msg, arguments[2], arguments[3]);
    }
    else if (level === ERROR) {
        error(msg, arguments[2], arguments[3]);
    }
    else if (level === FATAL) {
        fatal(msg, arguments[2], arguments[3]);
    }
}
/**
 * @internal
 * 
 */
let enableUpload = true;
/**
 * @internal
 * 
 */
let uploadLevel = WARN;
/**
 * 
 *
 */
function enableUploadLog() {
    enableUpload = true;
}
/**
 * 
 */
function disableUploadLog() {
    enableUpload = false;
}
/**
 * 
 */
function canUploadLog() {
    return enableUpload;
}
/**
 * 
 */
function setUploadLevel(level) {
    uploadLevel = level;
}
/**
 * 
 */
function getUploadLevel() {
    return uploadLevel;
}


/***/ }),

/***/ "./src/common/util/object.ts":
/*!***********************************!*\
  !*** ./src/common/util/object.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   each: () => (/* binding */ each),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   keys: () => (/* binding */ keys),
/* harmony export */   param: () => (/* binding */ param),
/* harmony export */   reverse: () => (/* binding */ reverse)
/* harmony export */ });
/* unused harmony exports sort, clear, merge, get, set, has, falsy, diff, toArray, update */
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./src/common/util/array.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _keypath__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keypath */ "./src/common/util/keypath.ts");
/* harmony import */ var _function_isDef__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../function/isDef */ "./src/common/function/isDef.ts");
/**
 * @file 
 */





/**
 *  key 
 *
 * @param object
 * @return
 */
function keys(object) {
    if (!(0,_function_isDef__WEBPACK_IMPORTED_MODULE_4__["default"])(object)) {
        return [];
    }
    return Object.keys(object);
}
function sortKeyByAsc(a, b) {
    return a.length - b.length;
}
function sortKeyByDesc(a, b) {
    return b.length - a.length;
}
/**
 *  key
 *
 * @param object
 * @param desc 
 * @return
 */
function sort(object, desc) {
    return keys(object).sort(desc ? sortKeyByDesc : sortKeyByAsc);
}
/**
 * 
 *
 * @param object
 * @param callback  false 
 */
function each(object, callback) {
    for (let key in object) {
        if (callback(object[key], key) === _constant__WEBPACK_IMPORTED_MODULE_2__.FALSE) {
            break;
        }
    }
}
/**
 * 
 *
 * @param object
 */
function clear(object) {
    each(object, function (_, key) {
        delete object[key];
    });
}
function _extend(original, object) {
    if (!_is__WEBPACK_IMPORTED_MODULE_0__.object(original)) {
        return object;
    }
    else if (!_is__WEBPACK_IMPORTED_MODULE_0__.object(object)) {
        return original;
    }
    each(object, function (value, key) {
        original[key] = value;
    });
    return original;
}
/**
 * 
 *
 * @return
 */
function extend(original, object, object2) {
    return _extend(_extend(original, object), object2);
}
/**
 * 
 *
 * @return
 */
function merge(object1, object2) {
    return object1 && object2
        ? extend(extend({}, object1), object2)
        : object1 || object2;
}
/**
 * 
 *
 * @param object
 * @param deep 
 * @return
 */
function copy(object, deep) {
    let result = object;
    if (_is__WEBPACK_IMPORTED_MODULE_0__.array(object)) {
        if (deep) {
            result = [];
            _array__WEBPACK_IMPORTED_MODULE_1__.each(object, function (item, index) {
                result[index] = copy(item, deep);
            });
        }
        else {
            result = object.slice();
        }
    }
    else if (_is__WEBPACK_IMPORTED_MODULE_0__.object(object)) {
        result = {};
        each(object, function (value, key) {
            result[key] = deep ? copy(value, deep) : value;
        });
    }
    return result;
}
/**
 *  keypath
 *
 * 
 *
 * @param object
 * @param keypath
 * @return
 */
function get(object, keypath, defaultValue) {
    let result;
    _keypath__WEBPACK_IMPORTED_MODULE_3__.each(keypath, function (key, isLast) {
        if (object != _constant__WEBPACK_IMPORTED_MODULE_2__.NULL) {
            // 
            let value = object[key], 
            // 
            hasValue = value !== _constant__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED;
            if (isLast) {
                if (hasValue) {
                    result = value;
                }
                else {
                    result = _constant__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED;
                }
            }
            else {
                object = value;
            }
        }
        else {
            result = _constant__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED;
            return _constant__WEBPACK_IMPORTED_MODULE_2__.FALSE;
        }
    });
    // 
    if (result === _constant__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED) {
        result = defaultValue;
    }
    return result;
}
/**
 * 
 *
 * @param object
 * @param keypath
 * @param value
 * @param autofill 
 */
function set(object, keypath, value, autofill) {
    _keypath__WEBPACK_IMPORTED_MODULE_3__.each(keypath, function (key, isLast) {
        if (isLast) {
            object[key] = value;
        }
        else if (object[key]) {
            object = object[key];
        }
        else if (autofill) {
            object = object[key] = {};
        }
        else {
            return _constant__WEBPACK_IMPORTED_MODULE_2__.FALSE;
        }
    });
}
/**
 *  key
 *
 * @param object
 * @param key
 * @return
 */
function has(object, key) {
    //  hasOwnProperty
    return object[key] !== _constant__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED;
}
/**
 * 
 *
 * @param object
 * @return
 */
function falsy(object) {
    return !_is__WEBPACK_IMPORTED_MODULE_0__.object(object)
        || _is__WEBPACK_IMPORTED_MODULE_0__.array(object)
        || !keys(object).length;
}
/**
 *  value  key
 *
 * @param obj1
 * @param obj2
 */
function diff(obj1, obj2) {
    let differences = [];
    each(obj1, (value, key) => {
        if (_is__WEBPACK_IMPORTED_MODULE_0__.array(value) || _is__WEBPACK_IMPORTED_MODULE_0__.isPlainObject(value)) {
            if (obj2[key] == null || diff(value, obj2[key]).length > 0) {
                differences.push(key);
            }
        }
        else if (value !== obj2[key]) {
            differences.push(key);
        }
    });
    return differences;
}
/**
 * 
 *
 * @param data
 */
function param(data) {
    let result = [];
    const add = (key, value) => {
        value = _is__WEBPACK_IMPORTED_MODULE_0__.func(value) ? value() : (value == null ? '' : value);
        result[result.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
    };
    if (_is__WEBPACK_IMPORTED_MODULE_0__.array(data) || _is__WEBPACK_IMPORTED_MODULE_0__.isPlainObject(data)) {
        if (_is__WEBPACK_IMPORTED_MODULE_0__.array(data)) {
            _array__WEBPACK_IMPORTED_MODULE_1__.each(data, (value, key) => {
                add(key, value);
            });
        }
        else {
            each(data, (value, key) => {
                add(key, value);
            });
        }
    }
    return result.join('&').replace(/%20/g, '+');
}
/**
 *  object  value 
 */
function toArray(data) {
    const result = [];
    each(data, (value) => {
        result.push(value);
    });
    return result;
}
/**
 *
 * 
 *
 * @param obj1
 * @param obj2
 * @returns
 */
function update(obj1, obj2) {
    if (!_is__WEBPACK_IMPORTED_MODULE_0__.object(obj1) || !_is__WEBPACK_IMPORTED_MODULE_0__.object(obj2)) {
        return;
    }
    each(obj2, (value, key) => {
        if (_is__WEBPACK_IMPORTED_MODULE_0__.object(value) && _is__WEBPACK_IMPORTED_MODULE_0__.object(obj1[key])) {
            update(obj1[key], value);
        }
        else {
            obj1[key] = obj2[key];
        }
    });
    return obj1;
}
/**
 *  object  key value
 */
function reverse(obj) {
    const result = {};
    each(obj, (value, key) => {
        result[value] = key;
    });
    return result;
}


/***/ }),

/***/ "./src/common/util/os.ts":
/*!*******************************!*\
  !*** ./src/common/util/os.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/**
 * UA 
 *
 * 
 *
 * {
 *    name: 'mac',     //  name  switch
 *    mac: true,       //  if (mac) { ... }
 *    version: '8.0'   // string 
 * }
 *
 */

/**
 * linux  Linux 
 */
//  PC 
const list = [
    ['harmony', /harmonyos ([\d_.]+)/],
    ['harmony', /openharmony ([\d_.]+)/],
    ['iphone', /iphone os ([\d_.]+)/],
    ['ipad', /ipad; cpu os ([\d_.]+)/],
    ['itouch', /itouch; cpu os ([\d_.]+)/],
    ['android', /android ([\d_.]+)/],
    ['wp', /windows phone ([\d_.]+)/],
    ['windows', /windows nt ([\d_.]+)/],
    ['linux', /linux/],
    ['mac', /mac os x ([\d_.]+)/]
];
const iosMap = {
    iphone: 1,
    ipad: 1,
    itouch: 1
};
/**
 *  UA 
 *
 * @inner
 * @param {string} ua
 * @return {Object}
 */
function parseUA(ua) {
    let name;
    let version;
    (0,_util_array__WEBPACK_IMPORTED_MODULE_0__.each)(list, (item) => {
        let match = item[1].exec(ua);
        if (match) {
            name = item[0];
            version = match[1];
            if (version) {
                version = version.replace(/_/g, '.');
            }
            return false;
        }
    });
    return {
        name: name || '',
        version: version || '',
        mobile: ua.indexOf('mobile') > -1
    };
}
const os = parseUA((typeof navigator === 'object' && navigator.userAgent || '').toLowerCase());
if (os.name) {
    os[os.name] = true;
    if (iosMap[os.name]) {
        os.ios = true;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (os);


/***/ }),

/***/ "./src/common/util/string.ts":
/*!***********************************!*\
  !*** ./src/common/util/string.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   indexOf: () => (/* binding */ indexOf),
/* harmony export */   slice: () => (/* binding */ slice),
/* harmony export */   startsWith: () => (/* binding */ startsWith)
/* harmony export */ });
/* unused harmony exports capitalize, trim, lastIndexOf, endsWith, charAt, codeAt, upper, lower, falsy */
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _function_toString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/toString */ "./src/common/function/toString.ts");
/**
 * @file string 
 */



const capitalizePattern = /^[a-z]/, capitalizeCache = {};
/**
 * 
 *
 * @param str
 * @return
 */
function capitalize(str) {
    if (!capitalizeCache[str]) {
        capitalizeCache[str] = str.replace(capitalizePattern, upper);
    }
    return capitalizeCache[str];
}
/**
 * 
 *
 * @param str
 * @return 
 */
function trim(str) {
    return falsy(str)
        ? _constant__WEBPACK_IMPORTED_MODULE_1__.EMPTY_STRING
        : str.trim();
}
/**
 * 
 *
 * @param str
 * @param start
 * @param end
 * @return
 */
function slice(str, start, end) {
    return _is__WEBPACK_IMPORTED_MODULE_0__.number(end)
        ? start === end
            ? _constant__WEBPACK_IMPORTED_MODULE_1__.EMPTY_STRING
            : str.slice(start, end)
        : str.slice(start);
}
/**
 * 
 *
 * @param str
 * @param part
 * @param start
 * @return
 */
function indexOf(str, part, start) {
    return str.indexOf(part, start !== _constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED ? start : 0);
}
/**
 * 
 *
 * @param str
 * @param part
 * @param end
 * @return
 */
function lastIndexOf(str, part, end) {
    return str.lastIndexOf(part, end !== _constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED ? end : str.length);
}
/**
 * str  part 
 *
 * @param str
 * @param part
 * @return
 */
function startsWith(str, part) {
    return indexOf(str, part) === 0;
}
/**
 * str  part 
 *
 * @param str
 * @param part
 * @return
 */
function endsWith(str, part) {
    const offset = str.length - part.length;
    return offset >= 0 && lastIndexOf(str, part) === offset;
}
/**
 * 
 */
function charAt(str, index) {
    return str.charAt(index || 0);
}
/**
 * 
 */
function codeAt(str, index) {
    return str.charCodeAt(index || 0);
}
/**
 * 
 */
function upper(str) {
    return str.toUpperCase();
}
/**
 * 
 */
function lower(str) {
    return str.toLowerCase();
}
/**
 * str  part
 *
 * @param str
 * @param part
 * @return 
 */
function has(str, part) {
    return indexOf(str, part) >= 0;
}
/**
 *  0 
 *
 * @param str
 * @return
 */
function falsy(str) {
    return !_is__WEBPACK_IMPORTED_MODULE_0__.string(str) || !str.length;
}
/**
 * 
 *
 * @param string
 * @param args
 * @returns
 */
function format(string, ...args) {
    let i = 0;
    const length = args.length;
    return string.replace(/(%[sdvx%])|(%0(\d)+[dx])/g, (str) => {
        if (i >= length) {
            // missing argument
            return str;
        }
        const arg = args[i++];
        if (/%0(\d)+[dx]/g.test(str)) {
            const length = parseInt(str.substring(1));
            let result = str[str.length - 1] === 'd' ? (0,_function_toString__WEBPACK_IMPORTED_MODULE_2__["default"])(Number(arg)) : Number(arg).toString(16);
            if (length > result.length) {
                result = new Array(length - result.length).fill('0').join('') + result;
            }
            return result;
        }
        switch (str) {
            case '%%':
                return '%';
            case '%s':
                return String(arg);
            case '%d':
                return (0,_function_toString__WEBPACK_IMPORTED_MODULE_2__["default"])(Number(arg));
            case '%v':
                return '';
            case '%x':
                return Number(arg).toString(16);
        }
        return str;
    });
}


/***/ }),

/***/ "./src/common/util/support.ts":
/*!************************************!*\
  !*** ./src/common/util/support.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _function_isWorker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./browser */ "./src/common/util/browser.ts");


function supportedFeatures() {
    let blob = typeof Blob === 'function';
    let wasm = typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function';
    let fetchSupported = typeof fetch === 'function';
    let documentSupport = typeof document === 'object';
    let canvas = documentSupport && document.createElement('canvas');
    let webgl = canvas && !!canvas.getContext('webgl');
    let offscreenCanvas = typeof OffscreenCanvas === 'function';
    let worker = typeof Worker === 'function';
    let arrayBuffer = typeof ArrayBuffer === 'function';
    let atomics = typeof Atomics === 'object' && Atomics[Symbol.toStringTag] === 'Atomics';
    let audioContext = typeof AudioContext === 'function' || typeof webkitAudioContext === 'function';
    let audioWorklet = typeof AudioWorklet === 'function';
    let videoDecoder = typeof VideoDecoder === 'function';
    let videoEncoder = typeof VideoEncoder === 'function';
    let audioDecoder = typeof AudioDecoder === 'function';
    let audioEncoder = typeof AudioEncoder === 'function';
    let shareArrayBuffer = typeof SharedArrayBuffer === 'function';
    let mse = typeof MediaSource == 'function' || typeof ManagedMediaSource === 'function';
    let proxy = typeof Proxy === 'function';
    let thread = (worker || (0,_function_isWorker__WEBPACK_IMPORTED_MODULE_0__["default"])()) && shareArrayBuffer && atomics && proxy;
    let jspi = typeof WebAssembly.Suspending === 'function' && typeof WebAssembly.promising === 'function';
    // safari  11 
    if (_browser__WEBPACK_IMPORTED_MODULE_1__["default"].safari && !_browser__WEBPACK_IMPORTED_MODULE_1__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_1__["default"].majorVersion, '11', true)) {
        wasm = false;
    }
    // chrome 94  webcodec
    if (_browser__WEBPACK_IMPORTED_MODULE_1__["default"].chrome && !_browser__WEBPACK_IMPORTED_MODULE_1__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_1__["default"].majorVersion, '94', true)) {
        videoDecoder = false;
        audioDecoder = false;
    }
    // safari 17  VideoFrame 
    if (_browser__WEBPACK_IMPORTED_MODULE_1__["default"].safari && !_browser__WEBPACK_IMPORTED_MODULE_1__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_1__["default"].majorVersion, '17', true)) {
        videoDecoder = false;
    }
    let webgpu = typeof navigator === 'object' && typeof navigator.gpu === 'object';
    let workerMSE = typeof MediaSourceHandle === 'function';
    let webAssemblyGlobal = wasm && typeof WebAssembly.Global === 'function';
    return {
        browser: _browser__WEBPACK_IMPORTED_MODULE_1__["default"],
        blob,
        wasm,
        fetch: fetchSupported,
        webgl,
        worker,
        mse,
        arrayBuffer,
        audioContext,
        audioWorklet,
        videoDecoder,
        videoEncoder,
        audioDecoder,
        audioEncoder,
        atomics,
        shareArrayBuffer,
        thread,
        webgpu,
        offscreenCanvas,
        workerMSE,
        webAssemblyGlobal,
        jspi,
        proxy,
        simd: (_browser__WEBPACK_IMPORTED_MODULE_1__["default"].chrome || _browser__WEBPACK_IMPORTED_MODULE_1__["default"].newEdge) && _browser__WEBPACK_IMPORTED_MODULE_1__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_1__["default"].majorVersion, '91', true)
            || _browser__WEBPACK_IMPORTED_MODULE_1__["default"].firefox && _browser__WEBPACK_IMPORTED_MODULE_1__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_1__["default"].majorVersion, '89', true)
            || _browser__WEBPACK_IMPORTED_MODULE_1__["default"].safari && _browser__WEBPACK_IMPORTED_MODULE_1__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_1__["default"].version, '16.4', true),
        wasmBaseSupported: fetchSupported && wasm && webgl && audioContext && arrayBuffer && webAssemblyGlobal
    };
}
const support = supportedFeatures();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (support);


/***/ }),

/***/ "./src/common/util/text.ts":
/*!*********************************!*\
  !*** ./src/common/util/text.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   encode: () => (/* binding */ encode)
/* harmony export */ });
const encoder = typeof TextEncoder === 'function' ? new TextEncoder() : null;
const decoder = typeof TextDecoder === 'function' ? new TextDecoder() : null;
function encode(data) {
    if (encoder) {
        return encoder.encode(data);
    }
    const array = [];
    for (let i = 0; i < data.length; ++i) {
        let u = data.charCodeAt(i);
        if (u >= 55296 && u <= 57343) {
            let u1 = data.charCodeAt(++i);
            u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }
        if (u <= 127) {
            array.push(u);
        }
        else if (u <= 2047) {
            array.push(192 | u >> 6);
            array.push(128 | u & 63);
        }
        else if (u <= 65535) {
            array.push(224 | u >> 12);
            array.push(128 | u >> 6 & 63);
            array.push(128 | u & 63);
        }
        else {
            array.push(240 | u >> 18);
            array.push(128 | u >> 12 & 63);
            array.push(128 | u >> 6 & 63);
            array.push(128 | u & 63);
        }
    }
    return new Uint8Array(array);
}
function decodeJS(data) {
    let result = '';
    for (let i = 0; i < data.length;) {
        let u0 = data[i++ >>> 0];
        if (!(u0 & 128)) {
            result += String.fromCharCode(u0);
            continue;
        }
        let u1 = data[i++ >>> 0] & 63;
        if ((u0 & 224) == 192) {
            result += String.fromCharCode((u0 & 31) << 6 | u1);
            continue;
        }
        let u2 = data[i++ >>> 0] & 63;
        if ((u0 & 240) == 224) {
            u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        }
        else {
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | data[i++ >>> 0] & 63;
        }
        if (u0 < 65536) {
            result += String.fromCharCode(u0);
        }
        else {
            let ch = u0 - 65536;
            result += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
    }
    return result;
}
function decode(data) {
    if (data instanceof Uint8Array && decoder && !(typeof SharedArrayBuffer === 'function' && data.buffer instanceof SharedArrayBuffer)) {
        try {
            // chrome  data.buffer instanceof SharedArrayBuffer  false  SharedArrayBuffer 
            return decoder.decode(data);
        }
        catch (error) {
            return decodeJS(data);
        }
    }
    return decodeJS(data);
}


/***/ }),

/***/ "./src/common/util/time.ts":
/*!*********************************!*\
  !*** ./src/common/util/time.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hhColonDDColonSSCommaMill2Int64: () => (/* binding */ hhColonDDColonSSCommaMill2Int64),
/* harmony export */   hhColonDDColonSSDotMill2Int64: () => (/* binding */ hhColonDDColonSSDotMill2Int64)
/* harmony export */ });
function hhColonDDColonSSDotMill2Int64(time) {
    time = time.trim();
    if (!time) {
        return -BigInt(1);
    }
    let list = time.split(':');
    let ts = BigInt(0);
    if (list.length === 3) {
        ts += BigInt(+(list.shift().trim())) * BigInt(3600000);
    }
    ts += BigInt(+(list.shift().trim())) * BigInt(60000);
    list = list.shift().trim().split('.');
    ts += BigInt(+(list.shift().trim())) * BigInt(1000);
    ts += BigInt(+(list.shift().trim()));
    return ts;
}
function hhColonDDColonSSCommaMill2Int64(time) {
    time = time.trim();
    if (!time) {
        return -BigInt(1);
    }
    let list = time.split(':');
    let ts = BigInt(0);
    if (list.length === 3) {
        ts += BigInt(+(list.shift().trim())) * BigInt(3600000);
    }
    ts += BigInt(+(list.shift().trim())) * BigInt(60000);
    list = list.shift().trim().split(',');
    ts += BigInt(+(list.shift().trim())) * BigInt(1000);
    ts += BigInt(+(list.shift().trim()));
    return ts;
}


/***/ }),

/***/ "./src/common/util/url.ts":
/*!********************************!*\
  !*** ./src/common/util/url.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildAbsoluteURL: () => (/* binding */ buildAbsoluteURL),
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   parseQuery: () => (/* binding */ parseQuery)
/* harmony export */ });
/* unused harmony exports stringifyQuery, mixin, normalizePath */
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _function_split__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/split */ "./src/common/function/split.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/object */ "./src/common/util/object.ts");
/**
 * @file url 
 */




/**
 * 
 * @param queryStr
 */
function parseQuery(queryStr, separator = '&') {
    const result = {};
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.string(queryStr) && queryStr.indexOf('=') >= 0) {
        let firstChar = queryStr.charAt(0);
        let startIndex = (firstChar === '?' || firstChar === '#') ? 1 : 0;
        if (startIndex > 0) {
            queryStr = queryStr.substr(startIndex);
        }
        _util_array__WEBPACK_IMPORTED_MODULE_2__.each((0,_function_split__WEBPACK_IMPORTED_MODULE_1__["default"])(queryStr, separator), (item) => {
            let terms = item.split('=');
            if (terms.length === 2) {
                let key = terms[0]?.trim();
                if (key) {
                    result[key] = decodeURIComponent(terms[1]);
                }
            }
        });
    }
    return result;
}
/**
 * 
 *
 * @param query
 * @return
 */
function stringifyQuery(query, separator = '&') {
    const result = [];
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.isPlainObject(query)) {
        _util_object__WEBPACK_IMPORTED_MODULE_3__.each(query, (value, key) => {
            result.push(key + '=' + encodeURIComponent(_util_is__WEBPACK_IMPORTED_MODULE_0__.object(value) ? JSON.stringify(value) : value));
        });
    }
    return result.join(separator);
}
/**
 *  url location 
 *
 * @param url 
 */
function parse(url) {
    const key = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
    const parser = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    const result = {};
    const m = parser.exec(url);
    let i = 14;
    while (i--) {
        result[key[i]] = m[i] ?? '';
    }
    return {
        protocol: result.protocol,
        file: result.file,
        host: result.host,
        port: result.port,
        user: result.user,
        password: result.password,
        origin: `${result.protocol}://${result.authority}`,
        pathname: result.path,
        search: `?${result.query}`,
        hash: result.anchor ? `#${result.anchor}` : ''
    };
}
/**
 *  url
 *
 * @param query
 * @param url
 * @param applyHash
 */
function mixin(query, applyHash, url) {
    if (url == null) {
        url = document.URL;
    }
    let scheme = parse(url);
    let params = parseQuery(applyHash ? scheme.hash : scheme.search);
    _util_object__WEBPACK_IMPORTED_MODULE_3__.extend(params, query);
    let paramStr = _util_object__WEBPACK_IMPORTED_MODULE_3__.param(params);
    url = scheme.origin + scheme.pathname;
    if (applyHash) {
        url += scheme.search;
    }
    else if (paramStr) {
        url += '?' + paramStr;
    }
    if (!applyHash) {
        url += scheme.hash;
    }
    else if (paramStr) {
        url += '#' + paramStr;
    }
    return url;
}
const SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
const SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
const FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
const URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
function buildURLFromParts(parts) {
    return (parts.scheme +
        parts.netLoc +
        parts.path +
        parts.params +
        parts.query +
        parts.fragment);
}
function parseURL(url) {
    const parts = URL_REGEX.exec(url);
    if (!parts) {
        return null;
    }
    return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || ''
    };
}
function normalizePath(path) {
    // The following operations are
    // then applied, in order, to the new path:
    // 6a) All occurrences of "./", where "." is a complete path
    // segment, are removed.
    // 6b) If the path ends with "." as a complete path segment,
    // that "." is removed.
    path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
    // 6c) All occurrences of "<segment>/../", where <segment> is a
    // complete path segment not equal to "..", are removed.
    // Removal of these path segments is performed iteratively,
    // removing the leftmost matching pattern on each iteration,
    // until no matching pattern remains.
    // 6d) If the path ends with "<segment>/..", where <segment> is a
    // complete path segment not equal to "..", that
    // "<segment>/.." is removed.
    while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) { }
    return path.split('').reverse().join('');
}
/**
 * from https://github.com/tjenkinson/url-toolkit
 *
 */
function buildAbsoluteURL(baseURL, relativeURL, opts) {
    opts = opts || {};
    // remove any remaining space and CRLF
    baseURL = baseURL.trim();
    relativeURL = relativeURL.trim();
    if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
            return baseURL;
        }
        let basePartsForNormalize = parseURL(baseURL);
        if (!basePartsForNormalize) {
            throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalize.path = normalizePath(basePartsForNormalize.path);
        return buildURLFromParts(basePartsForNormalize);
    }
    let relativeParts = parseURL(relativeURL);
    if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
    }
    if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
            return relativeURL;
        }
        relativeParts.path = normalizePath(relativeParts.path);
        return buildURLFromParts(relativeParts);
    }
    let baseParts = parseURL(baseURL);
    if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
    }
    if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everything before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        let pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
    }
    if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
    }
    const builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment,
    };
    if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
            if (!relativeParts.path) {
                // 5) If the embedded URL path is empty (and not preceded by a
                // slash), then the embedded URL inherits the base URL path
                builtParts.path = baseParts.path;
                // 5a) if the embedded URL's <params> is non-empty, we skip to
                // step 7; otherwise, it inherits the <params> of the base
                // URL (if any) and
                if (!relativeParts.params) {
                    builtParts.params = baseParts.params;
                    // 5b) if the embedded URL's <query> is non-empty, we skip to
                    // step 7; otherwise, it inherits the <query> of the base
                    // URL (if any) and we skip to step 7.
                    if (!relativeParts.query) {
                        builtParts.query = baseParts.query;
                    }
                }
            }
            else {
                // 6) The last segment of the base URL's path (anything
                // following the rightmost slash "/", or the entire path if no
                // slash is present) is removed and the embedded URL's path is
                // appended in its place.
                let baseURLPath = baseParts.path;
                let newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +
                    relativeParts.path;
                builtParts.path = normalizePath(newPath);
            }
        }
    }
    if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize
            ? normalizePath(relativeParts.path)
            : relativeParts.path;
    }
    return buildURLFromParts(builtParts);
}


/***/ }),

/***/ "./src/common/util/wasm.ts":
/*!*********************************!*\
  !*** ./src/common/util/wasm.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readSLeb128Async: () => (/* binding */ readSLeb128Async),
/* harmony export */   readULeb128Async: () => (/* binding */ readULeb128Async),
/* harmony export */   setMemoryShared: () => (/* binding */ setMemoryShared),
/* harmony export */   writeSleb128Async: () => (/* binding */ writeSleb128Async),
/* harmony export */   writeUleb128Async: () => (/* binding */ writeUleb128Async)
/* harmony export */ });
/* unused harmony exports readULeb128, readSLeb128, writeSleb128, writeUleb128 */
/* harmony import */ var _io_BufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../io/BufferReader */ "./src/common/io/BufferReader.ts");

function readULeb128(reader) {
    let result = 0;
    let shift = 0;
    while (true) {
        const byte = reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    return result;
}
async function readULeb128Async(reader) {
    let result = 0;
    let shift = 0;
    while (true) {
        const byte = await reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    return result;
}
function readSLeb128(reader) {
    let result = 0;
    let shift = 0;
    let byte;
    while (true) {
        byte = reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    // 
    if (byte & 0x40) {
        //  1 1
        result |= (~0 << shift);
    }
    return result;
}
async function readSLeb128Async(reader) {
    let result = 0;
    let shift = 0;
    let byte;
    while (true) {
        byte = await reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    // 
    if (byte & 0x40) {
        //  1 1
        result |= (~0 << shift);
    }
    return result;
}
function writeSleb128(writer, value) {
    let more = true;
    while (more) {
        let byte = value & 0x7f;
        value >>= 7;
        //  1
        if ((value === 0 && (byte & 0x40) === 0) || (value === -1 && (byte & 0x40) !== 0)) {
            more = false;
        }
        else {
            byte |= 0x80;
        }
        writer.writeUint8(byte);
    }
}
async function writeSleb128Async(writer, value) {
    let more = true;
    while (more) {
        let byte = value & 0x7f;
        value >>= 7;
        //  1
        if ((value === 0 && (byte & 0x40) === 0) || (value === -1 && (byte & 0x40) !== 0)) {
            more = false;
        }
        else {
            byte |= 0x80;
        }
        await writer.writeUint8(byte);
    }
}
function writeUleb128(writer, value) {
    do {
        let byte = value & 0x7f;
        value >>= 7;
        //  1
        if (value !== 0) {
            byte |= 0x80;
        }
        writer.writeUint8(byte);
    } while (value !== 0);
}
async function writeUleb128Async(writer, value) {
    do {
        let byte = value & 0x7f;
        value >>= 7;
        //  1
        if (value !== 0) {
            byte |= 0x80;
        }
        await writer.writeUint8(byte);
    } while (value !== 0);
}
function setMemoryShared(wasm, shared) {
    const reader = new _io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](wasm, true);
    reader.skip(8);
    while (reader.remainingSize()) {
        const sectionId = reader.readUint8();
        const size = readULeb128(reader);
        if (sectionId === 2 /* SectionId.Import */) {
            let count = readULeb128(reader);
            while (count--) {
                const moduleLen = readULeb128(reader);
                reader.skip(moduleLen);
                const fieldLen = readULeb128(reader);
                reader.skip(fieldLen);
                const externalKind = reader.readUint8();
                switch (externalKind) {
                    case 0 /* ExternalKind.Function */: {
                        // type index of the function signature
                        readULeb128(reader);
                        break;
                    }
                    case 3 /* ExternalKind.Global */: {
                        // content_type
                        readSLeb128(reader);
                        // mutability
                        readULeb128(reader);
                        break;
                    }
                    case 2 /* ExternalKind.Memory */: {
                        const pos = Number(reader.getPos());
                        if (shared) {
                            wasm[pos] = wasm[pos] | 2;
                        }
                        else {
                            wasm[pos] = wasm[pos] & ~2;
                        }
                        return;
                    }
                    case 1 /* ExternalKind.Table */: {
                        // elem_type
                        readSLeb128(reader);
                        const flags = readULeb128(reader);
                        readULeb128(reader);
                        if (flags & 0x01) {
                            // maximum
                            readULeb128(reader);
                        }
                        break;
                    }
                }
            }
            return;
        }
        else {
            reader.skip(size);
        }
    }
}


/***/ }),

/***/ "./src/common/util/xml2Json.ts":
/*!*************************************!*\
  !*** ./src/common/util/xml2Json.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ xml2Json)
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./src/common/util/array.ts");

const defaultOptions = {
    aloneValueName: '_@attribute'
};
const splitChar = [' ', '/', '"', '\'', '<', '>'];
function xml2Json(xmlStr, options = defaultOptions) {
    // remove commented lines
    xmlStr = xmlStr.replace(/<!--[\s\S]*?-->/g, '');
    // replace special characters
    xmlStr = xmlStr.replace(/[\n\t\r]/g, '');
    // replace leading spaces and tabs between elements
    xmlStr = xmlStr.replace(/>[ \t]+</g, '><');
    // delete docType tags
    xmlStr = xmlStr.replace(/<\?[^>]*\?>/g, '');
    const stack = [];
    let pos = 0;
    function addData(key, value) {
        const item = stack[stack.length - 1];
        if (!item) {
            return;
        }
        if (key !== options.aloneValueName && item.obj[options.aloneValueName] != null) {
            item.obj[options.aloneValueName] = [item.obj[options.aloneValueName], {
                    tagName: key,
                    ...value
                }];
            return;
        }
        if (item.obj[key] == null) {
            item.obj[key] = value;
        }
        else if (Array.isArray(item.obj[key])) {
            item.obj[key].push(value);
        }
        else {
            item.obj[key] = [item.obj[key], value];
        }
    }
    function gotoToken(token) {
        while (pos < xmlStr.length) {
            if (xmlStr[pos] === token) {
                return true;
            }
            pos++;
        }
        return false;
    }
    function readIdentity() {
        skipSpace();
        let key = '';
        while (pos < xmlStr.length) {
            if (_array__WEBPACK_IMPORTED_MODULE_0__.has(splitChar, xmlStr[pos])) {
                break;
            }
            key += xmlStr[pos];
            pos++;
        }
        return key;
    }
    function skipSpace() {
        while (pos < xmlStr.length) {
            if (!/\s|\r|\n/.test(xmlStr[pos])) {
                break;
            }
            pos++;
        }
    }
    const emptyEndReg = /\s/;
    const singleQuotation = /'/;
    const doubleQuotation = /"/;
    function readAttrValue() {
        if (pos >= xmlStr.length) {
            return true;
        }
        skipSpace();
        // 
        let end = emptyEndReg;
        if (xmlStr[pos] === '"' || xmlStr[pos] == '\'') {
            // 
            end = xmlStr[pos] === '"' ? doubleQuotation : singleQuotation;
            pos++;
        }
        let value = '';
        while (pos < xmlStr.length) {
            if (end.test(xmlStr[pos])) {
                pos++;
                break;
            }
            value += xmlStr[pos];
            pos++;
        }
        return value;
    }
    function readAttr() {
        while (true) {
            skipSpace();
            // 
            if (xmlStr[pos] === '>' || xmlStr[pos] === '/') {
                break;
            }
            let key = readIdentity();
            if (!key) {
                break;
            }
            if (key[key.length - 1] === '=') {
                key = key.substring(0, key.length - 1);
            }
            else {
                gotoToken('=');
                pos++;
            }
            const value = readAttrValue();
            addData(key, value);
        }
    }
    // innerText  < 
    function readText() {
        skipSpace();
        let text = '';
        while (pos < xmlStr.length) {
            if (xmlStr[pos] === '<') {
                break;
            }
            text += xmlStr[pos];
            pos++;
        }
        return text;
    }
    function pop() {
        //  </>  tag
        //  <xx  
        while (xmlStr[pos] === '<') {
            const now = pos;
            pos++;
            skipSpace();
            if (xmlStr[pos] === '/') {
                pos++;
                const tag = readIdentity();
                if (tag === stack[stack.length - 1].tag) {
                    if (stack.length > 1) {
                        const item = stack.pop();
                        addData(item.tag, item.obj);
                    }
                    gotoToken('>');
                    pos++;
                    skipSpace();
                }
                else {
                    stack.pop();
                    gotoToken('>');
                    pos++;
                    skipSpace();
                }
            }
            else {
                pos = now;
                break;
            }
        }
    }
    function readTag() {
        if (pos >= xmlStr.length) {
            return;
        }
        let start = pos;
        skipSpace();
        // innerText  context 
        if (xmlStr[pos] !== '<') {
            pos = start;
            addData(options.aloneValueName, readText());
            pop();
            return readTag();
        }
        let has = gotoToken('<');
        if (!has) {
            return;
        }
        start = pos;
        pos++;
        const tag = readIdentity();
        stack.push({
            obj: {},
            tag,
            start
        });
        readAttr();
        skipSpace();
        //  tag
        if (xmlStr[pos] === '/') {
            pos++;
            if (stack.length > 1) {
                const item = stack.pop();
                addData(item.tag, item.obj);
            }
            gotoToken('>');
            pos++;
            pop();
            return readTag();
        }
        has = gotoToken('>');
        if (!has) {
            return;
        }
        pos++;
        skipSpace();
        //  innerText 
        if (xmlStr[pos] !== '<') {
            addData(options.aloneValueName, readText());
            skipSpace();
        }
        pop();
        readTag();
    }
    readTag();
    return {
        [stack[0].tag]: stack[0].obj
    };
}


/***/ }),

/***/ "./src/ui/avplayer/AVPlayer.ts":
/*!*************************************!*\
  !*** ./src/ui/avplayer/AVPlayer.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVPlayerUI)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avplayer_AVPlayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avplayer/AVPlayer */ "./src/avplayer/AVPlayer.ts");
/* harmony import */ var yox_dist_standard_runtime_yox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! yox/dist/standard/runtime/yox */ "./node_modules/yox/dist/standard/runtime/yox.js");
/* harmony import */ var yox_dist_standard_runtime_yox__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(yox_dist_standard_runtime_yox__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var avplayer_eventType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avplayer/eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_util_url__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/url */ "./src/common/util/url.ts");
/* harmony import */ var common_util_os__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/os */ "./src/common/util/os.ts");
/* harmony import */ var _components_progress_Progress__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/progress/Progress */ "./src/ui/avplayer/components/progress/Progress.ts");
/* harmony import */ var _components_control_play_Play__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/control/play/Play */ "./src/ui/avplayer/components/control/play/Play.ts");
/* harmony import */ var _components_control_volume_Volume__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/control/volume/Volume */ "./src/ui/avplayer/components/control/volume/Volume.ts");
/* harmony import */ var _components_control_timer_Timer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/control/timer/Timer */ "./src/ui/avplayer/components/control/timer/Timer.ts");
/* harmony import */ var _components_control_setting_Setting__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/control/setting/Setting */ "./src/ui/avplayer/components/control/setting/Setting.ts");
/* harmony import */ var _components_control_fullscreen_Fullscreen__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/control/fullscreen/Fullscreen */ "./src/ui/avplayer/components/control/fullscreen/Fullscreen.ts");
/* harmony import */ var _components_control_playrate_Playrate__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/control/playrate/Playrate */ "./src/ui/avplayer/components/control/playrate/Playrate.ts");
/* harmony import */ var _components_control_audioTrack_AudioTrack__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./components/control/audioTrack/AudioTrack */ "./src/ui/avplayer/components/control/audioTrack/AudioTrack.ts");
/* harmony import */ var _components_control_videoTrack_VideoTrack__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./components/control/videoTrack/VideoTrack */ "./src/ui/avplayer/components/control/videoTrack/VideoTrack.ts");
/* harmony import */ var _components_control_subtitleTrack_SubtitleTrack__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./components/control/subtitleTrack/SubtitleTrack */ "./src/ui/avplayer/components/control/subtitleTrack/SubtitleTrack.ts");
/* harmony import */ var _components_control_loop_Loop__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./components/control/loop/Loop */ "./src/ui/avplayer/components/control/loop/Loop.ts");
/* harmony import */ var _components_control_pip_Pip__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./components/control/pip/Pip */ "./src/ui/avplayer/components/control/pip/Pip.ts");
/* harmony import */ var _components_folder_Folder__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./components/folder/Folder */ "./src/ui/avplayer/components/folder/Folder.ts");
/* harmony import */ var _components_loading_Loading__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./components/loading/Loading */ "./src/ui/avplayer/components/loading/Loading.ts");
/* harmony import */ var _components_pcmVisualization_PcmVisualization__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./components/pcmVisualization/PcmVisualization */ "./src/ui/avplayer/components/pcmVisualization/PcmVisualization.ts");
/* harmony import */ var _components_loadingTip_LoadingTip__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./components/loadingTip/LoadingTip */ "./src/ui/avplayer/components/loadingTip/LoadingTip.ts");
/* harmony import */ var _components_info_Info__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./components/info/Info */ "./src/ui/avplayer/components/info/Info.ts");
/* harmony import */ var _components_settings_Settings__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./components/settings/Settings */ "./src/ui/avplayer/components/settings/Settings.ts");
/* harmony import */ var _AVPlayer_hbs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./AVPlayer.hbs */ "./src/ui/avplayer/AVPlayer.hbs");
/* harmony import */ var _AVPlayer_hbs__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(_AVPlayer_hbs__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var _AVPlayer_styl__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./AVPlayer.styl */ "./src/ui/avplayer/AVPlayer.styl");
/* harmony import */ var _AVPlayer_styl__WEBPACK_IMPORTED_MODULE_28___default = /*#__PURE__*/__webpack_require__.n(_AVPlayer_styl__WEBPACK_IMPORTED_MODULE_28__);
/* harmony import */ var _i18n_getLanguage__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./i18n/getLanguage */ "./src/ui/avplayer/i18n/getLanguage.ts");
/* harmony import */ var common_function_debounce__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! common/function/debounce */ "./src/common/function/debounce.ts");
/* harmony import */ var _Keyboard__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./Keyboard */ "./src/ui/avplayer/Keyboard.ts");
/* harmony import */ var _util_outside__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../util/outside */ "./src/ui/util/outside.ts");

































const AVPlayerUIComponentOptions = {
    name: 'AVPlayer',
    template: (_AVPlayer_hbs__WEBPACK_IMPORTED_MODULE_27___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        indicatorUrl: {
            type: 'string',
        },
        pauseStateUrl: {
            type: 'string',
        },
        errorStateUrl: {
            type: 'string'
        },
        fullscreenDom: {
            type: 'object'
        },
        hasFolder: {
            type: 'boolean',
            value: true
        },
        hasHeader: {
            type: 'boolean',
            value: true
        }
    },
    data: function () {
        const language = (0,_i18n_getLanguage__WEBPACK_IMPORTED_MODULE_29__["default"])();
        const menu = [
            {
                name: language.MENU_STATS,
                action: 0 /* MenuAction.STATS */
            }
        ];
        return {
            style: (_AVPlayer_styl__WEBPACK_IMPORTED_MODULE_28___default()),
            title: '',
            error: '',
            showBar: true,
            played: false,
            folded: false,
            loading: false,
            language,
            streams: [],
            isLive: false,
            menu,
            showMenu: false,
            menuTop: 0,
            menuLeft: 0,
            showInfo: false,
            showSettings: false
        };
    },
    events: {
        error: function (event, data) {
            console.log('error', data.message);
            this.set('error', data.message);
        },
        closeInfo: function () {
            this.set('showInfo', false);
        },
        openSettings: function () {
            this.set('showSettings', true);
        },
        closeSettings: function () {
            this.set('showSettings', false);
        }
    },
    watchers: {
        played: function (value) {
            if (value) {
                if (this.showBarTimer) {
                    clearTimeout(this.showBarTimer);
                }
                if (this.get('folded')) {
                    this.showBarTimer = setTimeout(() => {
                        this.set('showBar', false);
                        this.showBarTimer = null;
                    }, 5000);
                }
            }
        },
        folded: function (value) {
            if (value) {
                if (this.showBarTimer) {
                    clearTimeout(this.showBarTimer);
                }
                this.showBarTimer = setTimeout(() => {
                    this.set('showBar', false);
                    this.showBarTimer = null;
                }, 5000);
            }
        }
    },
    computed: {
        hasVideoTrack: function () {
            const streams = this.get('streams');
            return streams
                .filter((stream) => cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */)
                .filter((stream) => common_util_array__WEBPACK_IMPORTED_MODULE_6__.has(avplayer_AVPlayer__WEBPACK_IMPORTED_MODULE_1__.AVPlayerSupportedCodecs, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](stream.codecpar + 4)))
                .length > 1;
        },
        hasAudioTrack: function () {
            const streams = this.get('streams');
            return streams
                .filter((stream) => cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */)
                .filter((stream) => common_util_array__WEBPACK_IMPORTED_MODULE_6__.has(avplayer_AVPlayer__WEBPACK_IMPORTED_MODULE_1__.AVPlayerSupportedCodecs, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](stream.codecpar + 4)))
                .length > 1;
        },
        hasSubtitleTrack: function () {
            const streams = this.get('streams');
            const isLive = this.get('isLive');
            return !isLive && streams
                .filter((stream) => cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */)
                .filter((stream) => common_util_array__WEBPACK_IMPORTED_MODULE_6__.has(avplayer_AVPlayer__WEBPACK_IMPORTED_MODULE_1__.AVPlayerSupportedCodecs, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](stream.codecpar + 4)))
                .length > 0;
        },
        hasPip: function () {
            const streams = this.get('streams');
            return streams
                .filter((stream) => cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */)
                .filter((stream) => common_util_array__WEBPACK_IMPORTED_MODULE_6__.has(avplayer_AVPlayer__WEBPACK_IMPORTED_MODULE_1__.AVPlayerSupportedCodecs, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](stream.codecpar + 4)))
                .length > 0;
        },
        hasPcmVisualization: function () {
            const streams = this.get('streams');
            return streams
                .filter((stream) => cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */)
                .filter((stream) => common_util_array__WEBPACK_IMPORTED_MODULE_6__.has(avplayer_AVPlayer__WEBPACK_IMPORTED_MODULE_1__.AVPlayerSupportedCodecs, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](stream.codecpar + 4)))
                .length > 0
                && streams
                    .filter((stream) => cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */)
                    .filter((stream) => common_util_array__WEBPACK_IMPORTED_MODULE_6__.has(avplayer_AVPlayer__WEBPACK_IMPORTED_MODULE_1__.AVPlayerSupportedCodecs, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](stream.codecpar + 4)))
                    .length === 0;
        }
    },
    methods: {
        init(player) {
            const source = player.getSource();
            if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.string(source)) {
                this.set('title', common_util_url__WEBPACK_IMPORTED_MODULE_7__.parse(decodeURI(source)).file);
            }
            else {
                this.set('title', source.name);
            }
            this.set('streams', player.getStreams());
            this.set('isLive', player.isLive());
        },
        mousemove() {
            setTimeout(() => {
                this.set('showBar', true);
                if (this.showBarTimer) {
                    clearTimeout(this.showBarTimer);
                }
                if (this.get('played') && this.get('folded')) {
                    this.showBarTimer = setTimeout(() => {
                        this.set('showBar', false);
                        this.showBarTimer = null;
                    }, 5000);
                }
            });
        },
        playClick(container) {
            if (common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].ios || common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].android || common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].harmony && common_util_os__WEBPACK_IMPORTED_MODULE_8__["default"].mobile) {
                return;
            }
            if (this.$refs['play'] && ((!this.get('showMenu') && this.get('showBar')) || !container)) {
                this.$refs['play'].playClick();
            }
        },
        toggleFold() {
            this.set('folded', !this.get('folded'));
        },
        fold() {
            this.set('folded', true);
        },
        unfold() {
            this.set('folded', false);
        },
        menuAction(action) {
            if (action === 0 /* MenuAction.STATS */) {
                this.set('showInfo', true);
            }
            this.set('showMenu', false);
        },
        menuOutside() {
            this.set('showMenu', false);
        }
    },
    afterMount() {
        this.namespace = '.avplayer' + Math.random();
        const player = this.get('player');
        const container = this.$el.querySelectorAll('.avplayer-ui-player')[0];
        // @ts-ignore
        player.options.container = container;
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_4__.LOADING + this.namespace, () => {
            this.set('loading', true);
            this.set('error', '');
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_4__.LOADED + this.namespace, () => {
            this.init(player);
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_4__.PLAYED + this.namespace, () => {
            this.set('loading', false);
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_4__.STOPPED + this.namespace, () => {
            this.set('title', '');
            this.set('streams', []);
        });
        if (player.getStatus() >= 4 /* AVPlayerStatus.LOADED */) {
            this.init(player);
        }
        this.onresize = (0,common_function_debounce__WEBPACK_IMPORTED_MODULE_30__["default"])(() => {
            player.resize(container.offsetWidth, container.offsetHeight);
        }, 500);
        window.addEventListener('resize', this.onresize);
        this.oncontextmenu = (event) => {
            if (this.$refs['playerContainer'].contains(event.target)) {
                this.set('showMenu', true);
                this.set('menuTop', event.clientY);
                this.set('menuLeft', event.clientX);
                event.preventDefault();
            }
        };
        window.addEventListener('contextmenu', this.oncontextmenu);
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
        window.removeEventListener('resize', this.onresize);
        window.removeEventListener('contextmenu', this.oncontextmenu);
    },
    components: {
        Progress: _components_progress_Progress__WEBPACK_IMPORTED_MODULE_9__["default"],
        Play: _components_control_play_Play__WEBPACK_IMPORTED_MODULE_10__["default"],
        Volume: _components_control_volume_Volume__WEBPACK_IMPORTED_MODULE_11__["default"],
        Timer: _components_control_timer_Timer__WEBPACK_IMPORTED_MODULE_12__["default"],
        Setting: _components_control_setting_Setting__WEBPACK_IMPORTED_MODULE_13__["default"],
        Fullscreen: _components_control_fullscreen_Fullscreen__WEBPACK_IMPORTED_MODULE_14__["default"],
        Playrate: _components_control_playrate_Playrate__WEBPACK_IMPORTED_MODULE_15__["default"],
        AudioTrack: _components_control_audioTrack_AudioTrack__WEBPACK_IMPORTED_MODULE_16__["default"],
        VideoTrack: _components_control_videoTrack_VideoTrack__WEBPACK_IMPORTED_MODULE_17__["default"],
        SubtitleTrack: _components_control_subtitleTrack_SubtitleTrack__WEBPACK_IMPORTED_MODULE_18__["default"],
        Loop: _components_control_loop_Loop__WEBPACK_IMPORTED_MODULE_19__["default"],
        Pip: _components_control_pip_Pip__WEBPACK_IMPORTED_MODULE_20__["default"],
        Folder: _components_folder_Folder__WEBPACK_IMPORTED_MODULE_21__["default"],
        Loading: _components_loading_Loading__WEBPACK_IMPORTED_MODULE_22__["default"],
        PcmVisualization: _components_pcmVisualization_PcmVisualization__WEBPACK_IMPORTED_MODULE_23__["default"],
        LoadingTip: _components_loadingTip_LoadingTip__WEBPACK_IMPORTED_MODULE_24__["default"],
        Info: _components_info_Info__WEBPACK_IMPORTED_MODULE_25__["default"],
        Settings: _components_settings_Settings__WEBPACK_IMPORTED_MODULE_26__["default"]
    }
};
class AVPlayerUI extends avplayer_AVPlayer__WEBPACK_IMPORTED_MODULE_1__["default"] {
    ui;
    keyboard;
    constructor(options) {
        super(common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend({}, options, { container: null }));
        yox_dist_standard_runtime_yox__WEBPACK_IMPORTED_MODULE_2___default().dom.addSpecialEvent('outside', _util_outside__WEBPACK_IMPORTED_MODULE_32__["default"]);
        this.ui = new (yox_dist_standard_runtime_yox__WEBPACK_IMPORTED_MODULE_2___default())(common_util_object__WEBPACK_IMPORTED_MODULE_3__.extend({
            el: options.container,
            replace: false,
            props: {
                player: this,
                indicatorUrl: options.indicatorUrl,
                pauseStateUrl: options.pauseStateUrl,
                errorStateUrl: options.errorStateUrl,
                fullscreenDom: options.fullscreenDom,
                hasFolder: options.ui?.hasFolder,
                hasHeader: options.ui?.hasHeader
            }
        }, AVPlayerUIComponentOptions));
        this.keyboard = new _Keyboard__WEBPACK_IMPORTED_MODULE_31__["default"](this);
    }
    foldFolder() {
        // @ts-ignore
        this.ui.fold();
    }
    unfoldFolder() {
        // @ts-ignore
        this.ui.unfold();
    }
    async destroy() {
        await super.destroy();
        this.keyboard.destroy();
        // @ts-ignore
        this.ui.destroy();
    }
}


/***/ }),

/***/ "./src/ui/avplayer/Keyboard.ts":
/*!*************************************!*\
  !*** ./src/ui/avplayer/Keyboard.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Keyboard)
/* harmony export */ });
/* harmony import */ var common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/keyboard */ "./src/common/util/keyboard.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_helper_CommandQueue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/helper/CommandQueue */ "./src/common/helper/CommandQueue.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");






const DefaultKeyboardMap = {
    [16 /* KeyboardPlayerActionKey.SUBTITLE_DELAY_ADD */]: [
        {
            keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.charKey['+'],
            with: [common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.ctrl],
            action: 'up',
            playerStatus: [6 /* AVPlayerStatus.PLAYED */, 7 /* AVPlayerStatus.PAUSED */]
        },
        {
            keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.charKey['+'],
            with: [common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.ctrl, common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.shift],
            action: 'up',
            playerStatus: [6 /* AVPlayerStatus.PLAYED */, 7 /* AVPlayerStatus.PAUSED */]
        },
    ],
    [17 /* KeyboardPlayerActionKey.SUBTITLE_DELAY_SUB */]: [
        {
            keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.charKey['-'],
            with: [common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.ctrl],
            action: 'up',
            playerStatus: [6 /* AVPlayerStatus.PLAYED */, 7 /* AVPlayerStatus.PAUSED */]
        },
        {
            keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.charKey['-'],
            with: [common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.ctrl, common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.shift],
            action: 'up',
            playerStatus: [6 /* AVPlayerStatus.PLAYED */, 7 /* AVPlayerStatus.PAUSED */]
        },
    ],
    [1 /* KeyboardPlayerActionKey.PLAY_OR_PAUSE */]: {
        keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.charKey.space,
        with: [],
        action: 'up',
        playerStatus: [6 /* AVPlayerStatus.PLAYED */, 7 /* AVPlayerStatus.PAUSED */]
    },
    [3 /* KeyboardPlayerActionKey.SEEK_FORWARD */]: {
        keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.functionKey.right,
        with: [],
        action: 'up',
        playerStatus: [6 /* AVPlayerStatus.PLAYED */]
    },
    [2 /* KeyboardPlayerActionKey.SEEK_BACK */]: {
        keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.functionKey.left,
        with: [],
        action: 'up',
        playerStatus: [6 /* AVPlayerStatus.PLAYED */, 7 /* AVPlayerStatus.PAUSED */]
    },
    [4 /* KeyboardPlayerActionKey.UPPER_PLAYRATE */]: {
        keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.functionKey.right,
        with: [],
        action: 'longDown',
        playerStatus: [6 /* AVPlayerStatus.PLAYED */]
    },
    [5 /* KeyboardPlayerActionKey.STOP_UPPER_PLAYRATE */]: {
        keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.functionKey.right,
        with: [],
        action: 'up',
        playerStatus: [6 /* AVPlayerStatus.PLAYED */],
        longDownBefore: true
    },
    [6 /* KeyboardPlayerActionKey.NEXT_FILE */]: {
        keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.charKey.n,
        with: [common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.ctrl],
        action: 'up',
    },
    [7 /* KeyboardPlayerActionKey.PREV_FILE */]: {
        keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.charKey.p,
        with: [common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.ctrl],
        action: 'up',
    },
    [8 /* KeyboardPlayerActionKey.NEXT_FRAME */]: {
        keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.functionKey.right,
        with: [],
        action: 'up',
        playerStatus: [7 /* AVPlayerStatus.PAUSED */]
    },
    [9 /* KeyboardPlayerActionKey.SNAPSHOT */]: {
        keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.charKey.p,
        with: [common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.ctrl, common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.shift],
        action: 'up',
        playerStatus: [7 /* AVPlayerStatus.PAUSED */, 6 /* AVPlayerStatus.PLAYED */]
    },
    [10 /* KeyboardPlayerActionKey.STOP */]: {
        keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.charKey.s,
        with: [common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.ctrl],
        action: 'up',
        playerStatus: [7 /* AVPlayerStatus.PAUSED */, 6 /* AVPlayerStatus.PLAYED */]
    },
    [12 /* KeyboardPlayerActionKey.VOLUME_DOWN */]: {
        keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.functionKey.down,
        with: [],
        action: 'up'
    },
    [11 /* KeyboardPlayerActionKey.VOLUME_UP */]: {
        keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.functionKey.up,
        with: [],
        action: 'up'
    },
    [13 /* KeyboardPlayerActionKey.EXIT_FULLSCREEN */]: {
        keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.functionKey.esc,
        with: [],
        action: 'up'
    },
    [14 /* KeyboardPlayerActionKey.FOLD_FOLDER */]: {
        keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.charKey.f,
        with: [common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.ctrl],
        action: 'up'
    },
    [15 /* KeyboardPlayerActionKey.UNFOLD_FOLDER */]: {
        keyCode: common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.charKey.u,
        with: [common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.ctrl],
        action: 'up'
    }
};
class Keyboard {
    onKeyDown_;
    onKeyUp_;
    player;
    seekQueue;
    lastPlayrate;
    longDownTimer;
    longDownRunning;
    constructor(player) {
        this.player = player;
        this.longDownTimer = new Map();
        this.longDownRunning = new Map();
        this.seekQueue = new common_helper_CommandQueue__WEBPACK_IMPORTED_MODULE_3__["default"]();
        this.onKeyDown_ = (event) => {
            this.onKeyDown(event);
        };
        this.onKeyUp_ = (event) => {
            this.onKeyUp(event);
        };
        document.addEventListener('keydown', this.onKeyDown_);
        document.addEventListener('keyup', this.onKeyUp_);
    }
    actionPlayOrPause() {
        if (this.player.getStatus() === 7 /* AVPlayerStatus.PAUSED */) {
            this.player.play();
        }
        else {
            this.player.pause();
        }
    }
    actionSeekForward() {
        this.seekQueue.clearPadding();
        this.seekQueue.push(async () => {
            return this.player.seek(common_util_bigint__WEBPACK_IMPORTED_MODULE_4__.min(this.player.currentTime + BigInt(10000), this.player.getDuration() - BigInt(10000)));
        });
    }
    actionSeekBack() {
        this.seekQueue.clearPadding();
        this.seekQueue.push(async () => {
            return this.player.seek(common_util_bigint__WEBPACK_IMPORTED_MODULE_4__.max(this.player.currentTime - BigInt(10000), BigInt(0)));
        });
    }
    actionUpperPlayrate() {
        this.lastPlayrate = this.player.getPlaybackRate();
        this.player.setPlaybackRate(2);
    }
    actionStopUpperPlayrate() {
        this.player.setPlaybackRate(this.lastPlayrate);
    }
    actionNextFile() {
    }
    actionPrevFile() {
    }
    actionNextFrame() {
        this.player.playNextFrame();
    }
    actionSnapshot() {
        if (!this.player.hasVideo()) {
            return;
        }
        const base64Data = this.player.snapshot('png');
        const byteString = atob(base64Data.replace(/^data:image\/(png|jpeg|jpg);base64,/, ''));
        const mimeString = base64Data.split(',')[0].split(':')[1].split(';')[0];
        const ab = new ArrayBuffer(byteString.length);
        const ia = new Uint8Array(ab);
        for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
        }
        const blob = new Blob([ab], { type: mimeString });
        const aLink = document.createElement('a');
        let source = this.player.getSource();
        let fileName = '';
        if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.string(source)) {
            fileName = source;
        }
        else {
            fileName = source.name;
        }
        const list = fileName.split('.');
        list.pop();
        aLink.download = list.join('.') + '.png';
        aLink.href = URL.createObjectURL(blob);
        aLink.click();
    }
    actionStop() {
        this.player.stop();
    }
    actionVolumeUp() {
        this.player.setVolume(Math.min(this.player.getVolume() + 0.1, 1));
    }
    actionVolumeDown() {
        this.player.setVolume(Math.max(this.player.getVolume() - 0.1, 0));
    }
    actionExitFullscreen() {
        this.player.exitFullscreen();
    }
    actionFoldFolder() {
        this.player.foldFolder();
    }
    actionUnFoldFolder() {
        this.player.unfoldFolder();
    }
    actionSubtitleDelayAdd() {
        this.player.setSubtitleDelay(Math.min(5000, this.player.getSubtitleDelay() + 100));
    }
    actionSubtitleDelaySub() {
        this.player.setSubtitleDelay(Math.max(-5000, this.player.getSubtitleDelay() - 100));
    }
    runAction(key) {
        switch (key) {
            case 1 /* KeyboardPlayerActionKey.PLAY_OR_PAUSE */:
                this.actionPlayOrPause();
                break;
            case 8 /* KeyboardPlayerActionKey.NEXT_FRAME */:
                this.actionNextFrame();
                break;
            case 13 /* KeyboardPlayerActionKey.EXIT_FULLSCREEN */:
                this.actionExitFullscreen();
                break;
            case 6 /* KeyboardPlayerActionKey.NEXT_FILE */:
                this.actionNextFile();
                break;
            case 7 /* KeyboardPlayerActionKey.PREV_FILE */:
                this.actionPrevFile();
                break;
            case 2 /* KeyboardPlayerActionKey.SEEK_BACK */:
                this.actionSeekBack();
                break;
            case 3 /* KeyboardPlayerActionKey.SEEK_FORWARD */:
                this.actionSeekForward();
                break;
            case 9 /* KeyboardPlayerActionKey.SNAPSHOT */:
                this.actionSnapshot();
                break;
            case 10 /* KeyboardPlayerActionKey.STOP */:
                this.actionStop();
                break;
            case 14 /* KeyboardPlayerActionKey.FOLD_FOLDER */:
                this.actionFoldFolder();
                break;
            case 15 /* KeyboardPlayerActionKey.UNFOLD_FOLDER */:
                this.actionUnFoldFolder();
                break;
            case 4 /* KeyboardPlayerActionKey.UPPER_PLAYRATE */:
                this.actionUpperPlayrate();
                break;
            case 5 /* KeyboardPlayerActionKey.STOP_UPPER_PLAYRATE */:
                this.actionStopUpperPlayrate();
                break;
            case 12 /* KeyboardPlayerActionKey.VOLUME_DOWN */:
                this.actionVolumeDown();
                break;
            case 11 /* KeyboardPlayerActionKey.VOLUME_UP */:
                this.actionVolumeUp();
                break;
            case 16 /* KeyboardPlayerActionKey.SUBTITLE_DELAY_ADD */:
                this.actionSubtitleDelayAdd();
                break;
            case 17 /* KeyboardPlayerActionKey.SUBTITLE_DELAY_SUB */:
                this.actionSubtitleDelaySub();
                break;
        }
    }
    longDownAction(key, action) {
        if (this.longDownTimer.has(action.keyCode)) {
            return;
        }
        this.longDownTimer.set(action.keyCode, setTimeout(() => {
            this.longDownTimer.delete(action.keyCode);
            this.runAction(key);
            this.longDownRunning.set(action.keyCode, key);
        }, 1000));
    }
    getActionKeys(event, type, longDownBefore = false) {
        let resultKey;
        let resultAction;
        common_util_object__WEBPACK_IMPORTED_MODULE_1__.each(DefaultKeyboardMap, ((action, key_) => {
            const isAction = (action) => {
                if (action.keyCode === event.keyCode
                    && type === action.action
                    && (!action.playerStatus || common_util_array__WEBPACK_IMPORTED_MODULE_2__.has(action.playerStatus, this.player.getStatus()))
                    && (!longDownBefore || action.longDownBefore)) {
                    const combinationKey = [];
                    if (event.shiftKey) {
                        combinationKey.push(common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.shift);
                    }
                    if (event.ctrlKey) {
                        combinationKey.push(common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.ctrl);
                    }
                    if (event.metaKey) {
                        combinationKey.push(common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.meta);
                    }
                    if (event.altKey) {
                        combinationKey.push(common_util_keyboard__WEBPACK_IMPORTED_MODULE_0__.combinationKey.alt);
                    }
                    if (combinationKey.length === action.with.length) {
                        let checked = true;
                        for (let i = 0; i < combinationKey.length; i++) {
                            if (!common_util_array__WEBPACK_IMPORTED_MODULE_2__.has(action.with, combinationKey[i])) {
                                checked = false;
                                break;
                            }
                        }
                        if (checked) {
                            resultKey = +key_;
                            resultAction = action;
                            return true;
                        }
                    }
                }
            };
            if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.array(action)) {
                let got = false;
                common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(action, (item) => {
                    if (isAction(item)) {
                        got = true;
                        return false;
                    }
                });
                if (got) {
                    return false;
                }
            }
            else {
                return !isAction(action);
            }
        }));
        if (resultAction) {
            return {
                key: resultKey,
                action: resultAction
            };
        }
    }
    onKeyDown(event) {
        let result = this.getActionKeys(event, 'down');
        if (result) {
            this.runAction(result.key);
            return;
        }
        result = this.getActionKeys(event, 'longDown');
        if (result && !this.longDownRunning.has(result.action.keyCode)) {
            this.longDownAction(result.key, result.action);
        }
    }
    onKeyUp(event) {
        if (this.longDownTimer.has(event.keyCode)) {
            clearTimeout(this.longDownTimer.get(event.keyCode));
            this.longDownTimer.delete(event.keyCode);
        }
        let result = this.getActionKeys(event, 'up', this.longDownRunning.has(event.keyCode));
        if (result) {
            if (!result.action.longDownBefore || this.longDownRunning.has(event.keyCode)) {
                this.runAction(result.key);
            }
        }
        this.longDownRunning.delete(event.keyCode);
    }
    destroy() {
        document.removeEventListener('keydown', this.onKeyDown_);
        document.removeEventListener('keyup', this.onKeyUp_);
    }
}


/***/ }),

/***/ "./src/ui/avplayer/components/control/audioTrack/AudioTrack.ts":
/*!*********************************************************************!*\
  !*** ./src/ui/avplayer/components/control/audioTrack/AudioTrack.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avplayer_eventType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avplayer/eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var _AudioTrack_hbs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AudioTrack.hbs */ "./src/ui/avplayer/components/control/audioTrack/AudioTrack.hbs");
/* harmony import */ var _AudioTrack_hbs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_AudioTrack_hbs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _AudioTrack_styl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AudioTrack.styl */ "./src/ui/avplayer/components/control/audioTrack/AudioTrack.styl");
/* harmony import */ var _AudioTrack_styl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_AudioTrack_styl__WEBPACK_IMPORTED_MODULE_3__);




const AudioTrack = {
    name: 'AudioTrack',
    template: (_AudioTrack_hbs__WEBPACK_IMPORTED_MODULE_2___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        }
    },
    data: function () {
        return {
            streams: [],
            audioInfo: null,
            selectIndex: 0,
            style: (_AudioTrack_styl__WEBPACK_IMPORTED_MODULE_3___default())
        };
    },
    computed: {
        list: function () {
            const player = this.get('player');
            const stream = this.get('streams');
            const audioInfo = this.get('audioInfo');
            if (audioInfo) {
                if (audioInfo.list.length) {
                    const codecs = audioInfo.list[audioInfo.selectedIndex].codecs;
                    const list = audioInfo.list
                        .map((item, index) => {
                        return {
                            value: index,
                            name: item.lang,
                            codecs: item.codecs
                        };
                    })
                        .filter((item) => {
                        return item.codecs === codecs;
                    });
                    list.forEach((item, index) => {
                        if (item.value === audioInfo.selectedIndex) {
                            this.set('selectIndex', index);
                        }
                    });
                }
            }
            else {
                return stream.map((item, index) => {
                    if (item.id === player.getSelectedAudioStreamId()) {
                        this.set('selectIndex', index);
                    }
                    return {
                        value: item.id,
                        name: item.metadata['title'] || item.metadata['languageString'] || item.metadata['language'] || item.metadata['name'] || 'default'
                    };
                });
            }
            return [];
        }
    },
    methods: {
        change: function (index) {
            const old = this.get('selectIndex');
            if (old !== index) {
                const player = this.get('player');
                player.selectAudio(this.get('list')[index].value).then(() => {
                    this.set('selectIndex', index);
                });
            }
        },
        init: function (player) {
            if (player.isDash() || player.isHls()) {
                this.set('audioInfo', player.getAudioList());
            }
            else {
                this.set('streams', player.getStreams().filter((stream) => cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */));
            }
        }
    },
    afterMount() {
        this.namespace = '.component_control_audio_track' + Math.random();
        const player = this.get('player');
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_1__.LOADED + this.namespace, () => {
            this.init(player);
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_1__.STREAM_UPDATE + this.namespace, () => {
            this.init(player);
        });
        if (player.getStatus() >= 4 /* AVPlayerStatus.LOADED */) {
            this.init(player);
        }
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AudioTrack);


/***/ }),

/***/ "./src/ui/avplayer/components/control/fullscreen/Fullscreen.ts":
/*!*********************************************************************!*\
  !*** ./src/ui/avplayer/components/control/fullscreen/Fullscreen.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Fullscreen_hbs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Fullscreen.hbs */ "./src/ui/avplayer/components/control/fullscreen/Fullscreen.hbs");
/* harmony import */ var _Fullscreen_hbs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Fullscreen_hbs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Fullscreen_styl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Fullscreen.styl */ "./src/ui/avplayer/components/control/fullscreen/Fullscreen.styl");
/* harmony import */ var _Fullscreen_styl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Fullscreen_styl__WEBPACK_IMPORTED_MODULE_1__);


const Fullscreen = {
    name: 'Fullscreen',
    template: (_Fullscreen_hbs__WEBPACK_IMPORTED_MODULE_0___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        },
        dom: {
            type: 'object'
        }
    },
    data: function () {
        return {
            style: (_Fullscreen_styl__WEBPACK_IMPORTED_MODULE_1___default()),
            fullscreen: false
        };
    },
    methods: {
        init(player) {
        },
        fullscreenClick() {
            const player = this.get('player');
            if (this.get('fullscreen')) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
                else if (document.mozExitFullScreen) {
                    document.mozExitFullScreen();
                }
                else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            }
            else {
                const element = this.get('dom') || player.getOptions().container.parentElement;
                if (element.requestFullscreen) {
                    element.requestFullscreen();
                }
                else if (element.mozRequestFullScreen) {
                    element.mozRequestFullScreen();
                }
                else if (element.webkitRequestFullscreen) {
                    element.webkitRequestFullscreen();
                }
                else if (element.msRequestFullscreen) {
                    element.msRequestFullscreen();
                }
            }
        }
    },
    afterMount() {
        this.namespace = '.component_control_fullscreen' + Math.random();
        const player = this.get('player');
        this.onfullscreenchange = () => {
            if (document.fullscreenElement == null) {
                const container = player.getOptions().container;
                player.resize(container.offsetWidth, container.offsetHeight);
                this.set('fullscreen', false);
            }
            else {
                player.resize(screen.width, screen.height);
                this.set('fullscreen', true);
            }
        };
        document.addEventListener('fullscreenchange', this.onfullscreenchange);
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
        document.removeEventListener('fullscreenchange', this.onfullscreenchange);
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Fullscreen);


/***/ }),

/***/ "./src/ui/avplayer/components/control/loop/Loop.ts":
/*!*********************************************************!*\
  !*** ./src/ui/avplayer/components/control/loop/Loop.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../util/storage */ "./src/ui/util/storage.ts");
/* harmony import */ var _Loop_hbs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loop.hbs */ "./src/ui/avplayer/components/control/loop/Loop.hbs");
/* harmony import */ var _Loop_hbs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Loop_hbs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Loop_styl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Loop.styl */ "./src/ui/avplayer/components/control/loop/Loop.styl");
/* harmony import */ var _Loop_styl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Loop_styl__WEBPACK_IMPORTED_MODULE_2__);



const Loop = {
    name: 'Loop',
    template: (_Loop_hbs__WEBPACK_IMPORTED_MODULE_1___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        }
    },
    data: function () {
        return {
            style: (_Loop_styl__WEBPACK_IMPORTED_MODULE_2___default()),
            loop: !!(+_util_storage__WEBPACK_IMPORTED_MODULE_0__.get(_util_storage__WEBPACK_IMPORTED_MODULE_0__.LOCAL_STORAGE_KEY_LOOP, 0))
        };
    },
    watchers: {
        loop: function (value) {
            const player = this.get('player');
            player.setLoop(value);
            _util_storage__WEBPACK_IMPORTED_MODULE_0__.set(_util_storage__WEBPACK_IMPORTED_MODULE_0__.LOCAL_STORAGE_KEY_LOOP, value ? 1 : 0);
        }
    },
    methods: {
        init(player) {
        },
        change() {
            this.set('loop', !this.get('loop'));
        }
    },
    afterMount() {
        this.namespace = '.component_control_loop' + Math.random();
        const player = this.get('player');
        player.setLoop(this.get('loop'));
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Loop);


/***/ }),

/***/ "./src/ui/avplayer/components/control/pip/Pip.ts":
/*!*******************************************************!*\
  !*** ./src/ui/avplayer/components/control/pip/Pip.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Pip_hbs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pip.hbs */ "./src/ui/avplayer/components/control/pip/Pip.hbs");
/* harmony import */ var _Pip_hbs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Pip_hbs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Pip_styl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Pip.styl */ "./src/ui/avplayer/components/control/pip/Pip.styl");
/* harmony import */ var _Pip_styl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Pip_styl__WEBPACK_IMPORTED_MODULE_1__);


const Pip = {
    name: 'Pip',
    template: (_Pip_hbs__WEBPACK_IMPORTED_MODULE_0___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        }
    },
    data: function () {
        return {
            style: (_Pip_styl__WEBPACK_IMPORTED_MODULE_1___default()),
            pip: false
        };
    },
    methods: {
        init(player) {
        },
        async pipClick() {
            const player = this.get('player');
            if (this.get('pip')) {
                this.set('pip', false);
                if (player.isMSE()) {
                    document.exitPictureInPicture();
                }
                else {
                    const pipPlayer = this.pipWindow.document.body.children[0];
                    if (pipPlayer) {
                        this.playerContainer.prepend(pipPlayer);
                        player.resize(pipPlayer.offsetWidth, pipPlayer.offsetHeight);
                    }
                    this.pipWindow.close();
                }
            }
            else {
                if (player.isMSE()) {
                    // @ts-ignore
                    player.video.requestPictureInPicture();
                }
                else {
                    this.playerContainer = player.getOptions().container.parentElement;
                    this.pipWindow = await documentPictureInPicture.requestWindow({
                        disallowReturnToOpener: true,
                        width: 320,
                        height: 180
                    });
                    this.pipWindow.addEventListener('pagehide', (event) => {
                        if (this.get('pip')) {
                            const pipPlayer = event.target.body.children[0];
                            if (pipPlayer) {
                                this.playerContainer.prepend(pipPlayer);
                                player.resize(pipPlayer.offsetWidth, pipPlayer.offsetHeight);
                            }
                            this.set('pip', false);
                        }
                    });
                    this.pipWindow.addEventListener('resize', (event) => {
                        if (this.pipWindow.document) {
                            const pipPlayer = this.pipWindow.document.children[0];
                            player.resize(pipPlayer.offsetWidth, pipPlayer.offsetHeight);
                        }
                    });
                    [...document.styleSheets].forEach((styleSheet) => {
                        try {
                            const cssRules = [...styleSheet.cssRules].map((rule) => rule.cssText).join('');
                            const style = document.createElement('style');
                            style.textContent = cssRules;
                            this.pipWindow.document.head.appendChild(style);
                        }
                        catch (e) {
                            const link = document.createElement('link');
                            link.rel = 'stylesheet';
                            link.type = styleSheet.type;
                            link.media = styleSheet.media;
                            link.href = styleSheet.href;
                            this.pipWindow.document.head.appendChild(link);
                        }
                    });
                    this.pipWindow.document.body.append(player.getOptions().container);
                }
            }
        }
    },
    afterMount() {
        this.namespace = '.component_control_pip' + Math.random();
        this.onenter = (event) => {
            this.pipWindow = event.window;
            this.set('pip', true);
        };
        // @ts-ignore
        if (typeof documentPictureInPicture === 'object') {
            // @ts-ignore
            documentPictureInPicture.addEventListener('enter', this.onenter);
        }
    },
    beforeDestroy() {
        const player = this.get('player');
        // @ts-ignore
        if (typeof documentPictureInPicture === 'object') {
            // @ts-ignore
            documentPictureInPicture.removeEventListener('enter', this.onenter);
        }
        if (this.namespace) {
            player.off(this.namespace);
        }
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pip);


/***/ }),

/***/ "./src/ui/avplayer/components/control/play/Play.ts":
/*!*********************************************************!*\
  !*** ./src/ui/avplayer/components/control/play/Play.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avplayer/eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var _Play_hbs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Play.hbs */ "./src/ui/avplayer/components/control/play/Play.hbs");
/* harmony import */ var _Play_hbs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Play_hbs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Play_styl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Play.styl */ "./src/ui/avplayer/components/control/play/Play.styl");
/* harmony import */ var _Play_styl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Play_styl__WEBPACK_IMPORTED_MODULE_2__);



const Play = {
    name: 'Play',
    model: 'played',
    template: (_Play_hbs__WEBPACK_IMPORTED_MODULE_1___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        },
        played: {
            type: 'boolean',
            required: true
        }
    },
    data: function () {
        return {
            style: (_Play_styl__WEBPACK_IMPORTED_MODULE_2___default())
        };
    },
    methods: {
        playClick() {
            const player = this.get('player');
            if (!player.getSource()) {
                return;
            }
            if (this.get('played')) {
                if (player.isLive()) {
                    return;
                }
                player.pause();
            }
            else {
                if (player.getStatus() === 0 /* AVPlayerStatus.STOPPED */) {
                    player.load(player.getSource(), player.getExternalSubtitle()).then(() => {
                        player.play();
                    });
                }
                else {
                    player.play();
                }
            }
            this.set('played', !this.get('played'));
        },
        init(player) {
            this.set('played', player.getStatus() === 6 /* AVPlayerStatus.PLAYED */);
        }
    },
    afterMount() {
        this.namespace = '.component_control_play' + Math.random();
        const player = this.get('player');
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__.STOPPED + this.namespace, () => {
            this.set('played', false);
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__.PAUSED + this.namespace, () => {
            this.set('played', false);
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__.PLAYED + this.namespace, () => {
            this.set('played', true);
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__.LOADED + this.namespace, () => {
            this.init(player);
        });
        if (player.getStatus() >= 4 /* AVPlayerStatus.LOADED */) {
            this.init(player);
        }
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Play);


/***/ }),

/***/ "./src/ui/avplayer/components/control/playrate/Playrate.ts":
/*!*****************************************************************!*\
  !*** ./src/ui/avplayer/components/control/playrate/Playrate.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../util/storage */ "./src/ui/util/storage.ts");
/* harmony import */ var _Playrate_hbs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Playrate.hbs */ "./src/ui/avplayer/components/control/playrate/Playrate.hbs");
/* harmony import */ var _Playrate_hbs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Playrate_hbs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Playrate_styl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Playrate.styl */ "./src/ui/avplayer/components/control/playrate/Playrate.styl");
/* harmony import */ var _Playrate_styl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_Playrate_styl__WEBPACK_IMPORTED_MODULE_3__);




const Playrate = {
    name: 'Playrate',
    template: (_Playrate_hbs__WEBPACK_IMPORTED_MODULE_2___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        }
    },
    data: function () {
        const list = [2.0, 1.5, 1.25, 1.0, 0.75, 0.5];
        let index = common_util_array__WEBPACK_IMPORTED_MODULE_0__.indexOf(list, +_util_storage__WEBPACK_IMPORTED_MODULE_1__.get(_util_storage__WEBPACK_IMPORTED_MODULE_1__.LOCAL_STORAGE_KEY_PLAY_RATE, 1.0));
        if (index < 0) {
            index = 3;
        }
        return {
            list,
            index,
            style: (_Playrate_styl__WEBPACK_IMPORTED_MODULE_3___default())
        };
    },
    watchers: {
        index: function (value) {
            _util_storage__WEBPACK_IMPORTED_MODULE_1__.set(_util_storage__WEBPACK_IMPORTED_MODULE_1__.LOCAL_STORAGE_KEY_PLAY_RATE, this.get('list')[value]);
            const player = this.get('player');
            player.setPlaybackRate(this.get('list')[value]);
        }
    },
    methods: {
        change: function (index) {
            this.set('index', index);
        }
    },
    afterMount() {
        this.namespace = '.component_control_play_rate' + Math.random();
        const player = this.get('player');
        player.setPlaybackRate(this.get('list')[this.get('index')]);
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Playrate);


/***/ }),

/***/ "./src/ui/avplayer/components/control/setting/Setting.ts":
/*!***************************************************************!*\
  !*** ./src/ui/avplayer/components/control/setting/Setting.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Setting_hbs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Setting.hbs */ "./src/ui/avplayer/components/control/setting/Setting.hbs");
/* harmony import */ var _Setting_hbs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Setting_hbs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Setting_styl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Setting.styl */ "./src/ui/avplayer/components/control/setting/Setting.styl");
/* harmony import */ var _Setting_styl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Setting_styl__WEBPACK_IMPORTED_MODULE_1__);


const Setting = {
    name: 'Setting',
    template: (_Setting_hbs__WEBPACK_IMPORTED_MODULE_0___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        }
    },
    data: function () {
        return {
            style: (_Setting_styl__WEBPACK_IMPORTED_MODULE_1___default())
        };
    },
    methods: {
        init(player) {
        },
        click() {
            this.fire('openSettings');
        }
    },
    afterMount() {
        this.namespace = '.component_control_setting' + Math.random();
        const player = this.get('player');
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Setting);


/***/ }),

/***/ "./src/ui/avplayer/components/control/subtitleTrack/SubtitleTrack.ts":
/*!***************************************************************************!*\
  !*** ./src/ui/avplayer/components/control/subtitleTrack/SubtitleTrack.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avplayer_eventType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avplayer/eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var _SubtitleTrack_hbs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SubtitleTrack.hbs */ "./src/ui/avplayer/components/control/subtitleTrack/SubtitleTrack.hbs");
/* harmony import */ var _SubtitleTrack_hbs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_SubtitleTrack_hbs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _SubtitleTrack_styl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SubtitleTrack.styl */ "./src/ui/avplayer/components/control/subtitleTrack/SubtitleTrack.styl");
/* harmony import */ var _SubtitleTrack_styl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_SubtitleTrack_styl__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _folder_Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../folder/Node */ "./src/ui/avplayer/components/folder/Node.ts");





const SubtitleTrack = {
    name: 'SubtitleTrack',
    template: (_SubtitleTrack_hbs__WEBPACK_IMPORTED_MODULE_2___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        }
    },
    data: function () {
        return {
            streams: [],
            subtitleInfo: null,
            selectIndex: 0,
            style: (_SubtitleTrack_styl__WEBPACK_IMPORTED_MODULE_3___default()),
            accept: _folder_Node__WEBPACK_IMPORTED_MODULE_4__.subtitleExt.map((i) => '.' + i).join(', '),
            // @ts-ignore
            canUseFilePicker: typeof showOpenFilePicker === 'function'
        };
    },
    computed: {
        list: function () {
            const player = this.get('player');
            const stream = this.get('streams');
            const subtitleInfo = this.get('subtitleInfo');
            if (subtitleInfo) {
                if (subtitleInfo.list.length) {
                    const codecs = subtitleInfo.list[subtitleInfo.selectedIndex].codecs;
                    const list = subtitleInfo.list
                        .map((item, index) => {
                        return {
                            value: index,
                            name: item.lang,
                            codecs: item.codecs
                        };
                    })
                        .filter((item) => {
                        return item.codecs === codecs;
                    });
                    list.forEach((item, index) => {
                        if (item.value === subtitleInfo.selectedIndex) {
                            this.set('selectIndex', index);
                        }
                    });
                }
            }
            else {
                return stream.map((item, index) => {
                    if (item.id === player.getSelectedSubtitleStreamId()) {
                        this.set('selectIndex', index);
                    }
                    return {
                        value: item.id,
                        name: item.metadata['title'] || item.metadata['languageString'] || item.metadata['language'] || item.metadata['name'] || 'default'
                    };
                });
            }
            return [];
        }
    },
    methods: {
        change: function (index) {
            const old = this.get('selectIndex');
            if (old !== index) {
                const player = this.get('player');
                player.selectSubtitle(this.get('list')[index].value).then(() => {
                    this.set('selectIndex', index);
                });
            }
        },
        openFile() {
            const pickerOpts = {
                startIn: 'videos',
                types: [
                    {
                        description: 'Subtitles',
                        accept: {
                            'application/octet-stream': _folder_Node__WEBPACK_IMPORTED_MODULE_4__.subtitleExt.map((ext) => {
                                return '.' + ext;
                            })
                        },
                    }
                ],
                excludeAcceptAllOption: true,
                multiple: true
            };
            const player = this.get('player');
            // @ts-ignore
            showOpenFilePicker(pickerOpts).then(async (fileHandles) => {
                for (let i = 0; i < fileHandles.length; i++) {
                    const file = await fileHandles[i].getFile();
                    const nameList = file.name.split('.');
                    nameList.pop();
                    player.loadExternalSubtitle({
                        title: nameList.join('.'),
                        source: file
                    });
                }
            });
        },
        fileChange(event) {
            const file = event.originalEvent.target.files[0];
            const player = this.get('player');
            const nameList = file.name.split('.');
            nameList.pop();
            player.loadExternalSubtitle({
                title: nameList.join('.'),
                source: file
            });
        },
        init: function (player) {
            if (player.isDash() || player.isHls()) {
                this.set('subtitleInfo', player.getSubtitleList());
            }
            else {
                this.set('streams', player.getStreams().filter((stream) => cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](stream.codecpar) === 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */));
            }
        }
    },
    afterMount() {
        this.namespace = '.component_control_subtitle_track' + Math.random();
        const player = this.get('player');
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_1__.LOADED + this.namespace, () => {
            this.init(player);
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_1__.STREAM_UPDATE + this.namespace, () => {
            this.init(player);
        });
        if (player.getStatus() >= 4 /* AVPlayerStatus.LOADED */) {
            this.init(player);
        }
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SubtitleTrack);


/***/ }),

/***/ "./src/ui/avplayer/components/control/timer/Timer.ts":
/*!***********************************************************!*\
  !*** ./src/ui/avplayer/components/control/timer/Timer.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avplayer/eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var common_util_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/string */ "./src/common/util/string.ts");
/* harmony import */ var _Timer_hbs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Timer.hbs */ "./src/ui/avplayer/components/control/timer/Timer.hbs");
/* harmony import */ var _Timer_hbs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Timer_hbs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Timer_styl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Timer.styl */ "./src/ui/avplayer/components/control/timer/Timer.styl");
/* harmony import */ var _Timer_styl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_Timer_styl__WEBPACK_IMPORTED_MODULE_3__);




const Timer = {
    name: 'Time',
    template: (_Timer_hbs__WEBPACK_IMPORTED_MODULE_2___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        }
    },
    data: function () {
        return {
            totalTime: BigInt(0),
            currentTime: BigInt(0),
            style: (_Timer_styl__WEBPACK_IMPORTED_MODULE_3___default())
        };
    },
    filters: {
        formatTime(time) {
            if (time < 0) {
                time = BigInt(0);
            }
            const secs = Number(BigInt.asIntN(32, time / BigInt(1000) % BigInt(60)));
            const mins = Number(BigInt.asIntN(32, time / BigInt(1000) / BigInt(60) % BigInt(60)));
            const hours = Number(BigInt.asIntN(32, time / BigInt(1000) / BigInt(3600)));
            return common_util_string__WEBPACK_IMPORTED_MODULE_1__.format('%02d:%02d:%02d', hours, mins, secs);
        }
    },
    methods: {
        init(player) {
            this.set('currentTime', player.currentTime);
            this.set('totalTime', player.getDuration());
        }
    },
    afterMount() {
        this.namespace = '.component_control_timer' + Math.random();
        const player = this.get('player');
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__.LOADED + this.namespace, () => {
            this.init(player);
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__.TIME + this.namespace, (pts) => {
            this.set('currentTime', pts);
        });
        if (player.getStatus() >= 4 /* AVPlayerStatus.LOADED */) {
            this.init(player);
        }
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Timer);


/***/ }),

/***/ "./src/ui/avplayer/components/control/videoTrack/VideoTrack.ts":
/*!*********************************************************************!*\
  !*** ./src/ui/avplayer/components/control/videoTrack/VideoTrack.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avplayer_eventType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avplayer/eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var _VideoTrack_hbs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VideoTrack.hbs */ "./src/ui/avplayer/components/control/videoTrack/VideoTrack.hbs");
/* harmony import */ var _VideoTrack_hbs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_VideoTrack_hbs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _VideoTrack_styl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VideoTrack.styl */ "./src/ui/avplayer/components/control/videoTrack/VideoTrack.styl");
/* harmony import */ var _VideoTrack_styl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_VideoTrack_styl__WEBPACK_IMPORTED_MODULE_3__);




const VideoTrack = {
    name: 'VideoTrack',
    template: (_VideoTrack_hbs__WEBPACK_IMPORTED_MODULE_2___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        }
    },
    data: function () {
        return {
            streams: [],
            videoInfo: null,
            selectIndex: 0,
            style: (_VideoTrack_styl__WEBPACK_IMPORTED_MODULE_3___default())
        };
    },
    computed: {
        list: function () {
            const player = this.get('player');
            const stream = this.get('streams');
            const videoInfo = this.get('videoInfo');
            if (videoInfo) {
                if (videoInfo.list.length) {
                    const codecs = videoInfo.list[videoInfo.selectedIndex].codecs;
                    const list = videoInfo.list
                        .map((item, index) => {
                        return {
                            value: index,
                            name: `${item.width}*${item.height}${item.frameRate ? `@${item.frameRate}` : ''}`,
                            codecs: item.codecs
                        };
                    })
                        .filter((item) => {
                        return item.codecs === codecs;
                    });
                    list.forEach((item, index) => {
                        if (item.value === videoInfo.selectedIndex) {
                            this.set('selectIndex', index);
                        }
                    });
                }
            }
            else {
                return stream.map((item, index) => {
                    if (item.id === player.getSelectedVideoStreamId()) {
                        this.set('selectIndex', index);
                    }
                    return {
                        value: item.id,
                        name: item.metadata['title'] || item.metadata['languageString'] || item.metadata['language'] || item.metadata['name'] || 'default'
                    };
                });
            }
            return [];
        }
    },
    methods: {
        change: function (index) {
            const old = this.get('selectIndex');
            if (old !== index) {
                const player = this.get('player');
                player.selectVideo(this.get('list')[index].value).then(() => {
                    this.set('selectIndex', index);
                });
            }
        },
        init: function (player) {
            if (player.isDash() || player.isHls()) {
                this.set('videoInfo', player.getVideoList());
            }
            else {
                this.set('streams', player.getStreams().filter((stream) => cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */));
            }
        }
    },
    afterMount() {
        this.namespace = '.component_control_video_track' + Math.random();
        const player = this.get('player');
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_1__.LOADED + this.namespace, () => {
            this.init(player);
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_1__.STREAM_UPDATE + this.namespace, () => {
            this.init(player);
        });
        if (player.getStatus() >= 4 /* AVPlayerStatus.LOADED */) {
            this.init(player);
        }
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VideoTrack);


/***/ }),

/***/ "./src/ui/avplayer/components/control/volume/Volume.ts":
/*!*************************************************************!*\
  !*** ./src/ui/avplayer/components/control/volume/Volume.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../util/storage */ "./src/ui/util/storage.ts");
/* harmony import */ var _components_slider_Slider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../components/slider/Slider */ "./src/ui/components/slider/Slider.ts");
/* harmony import */ var avplayer_eventType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avplayer/eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var _Volume_hbs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Volume.hbs */ "./src/ui/avplayer/components/control/volume/Volume.hbs");
/* harmony import */ var _Volume_hbs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_Volume_hbs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Volume_styl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Volume.styl */ "./src/ui/avplayer/components/control/volume/Volume.styl");
/* harmony import */ var _Volume_styl__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_Volume_styl__WEBPACK_IMPORTED_MODULE_4__);





const Volume = {
    name: 'Volume',
    template: (_Volume_hbs__WEBPACK_IMPORTED_MODULE_3___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        }
    },
    data: function () {
        return {
            lastVolume: 50,
            volume: +_util_storage__WEBPACK_IMPORTED_MODULE_0__.get(_util_storage__WEBPACK_IMPORTED_MODULE_0__.LOCAL_STORAGE_KEY_VOLUME, 50),
            style: (_Volume_styl__WEBPACK_IMPORTED_MODULE_4___default())
        };
    },
    watchers: {
        volume: function (volume) {
            _util_storage__WEBPACK_IMPORTED_MODULE_0__.set(_util_storage__WEBPACK_IMPORTED_MODULE_0__.LOCAL_STORAGE_KEY_VOLUME, volume);
            const player = this.get('player');
            player.setVolume(volume / 100);
        },
    },
    methods: {
        volumeClick() {
            if (this.get('volume')) {
                this.set('lastVolume', this.get('volume'));
                this.set('volume', 0);
            }
            else {
                this.set('volume', this.get('lastVolume'));
            }
        }
    },
    afterMount() {
        this.namespace = '.component_control_volume' + Math.random();
        const player = this.get('player');
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_2__.VOLUME_CHANGE + this.namespace, (volume) => {
            this.set('volume', Math.floor(volume * 100));
        });
        player.setVolume(this.get('volume') / 100);
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
    },
    components: {
        Slider: _components_slider_Slider__WEBPACK_IMPORTED_MODULE_1__["default"]
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Volume);


/***/ }),

/***/ "./src/ui/avplayer/components/folder/Folder.ts":
/*!*****************************************************!*\
  !*** ./src/ui/avplayer/components/folder/Folder.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avplayer/eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var _Folder_hbs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Folder.hbs */ "./src/ui/avplayer/components/folder/Folder.hbs");
/* harmony import */ var _Folder_hbs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Folder_hbs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Folder_styl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Folder.styl */ "./src/ui/avplayer/components/folder/Folder.styl");
/* harmony import */ var _Folder_styl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Folder_styl__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Node */ "./src/ui/avplayer/components/folder/Node.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_db__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../util/db */ "./src/ui/util/db.ts");
/* harmony import */ var common_function_generateUUID__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/function/generateUUID */ "./src/common/function/generateUUID.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_url__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/url */ "./src/common/util/url.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
var cheap__fileName__0 = "src\\ui\\avplayer\\components\\folder\\Folder.ts";










const Folder = {
    name: 'Folder',
    template: (_Folder_hbs__WEBPACK_IMPORTED_MODULE_1___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        }
    },
    data: function () {
        return {
            style: (_Folder_styl__WEBPACK_IMPORTED_MODULE_2___default()),
            // @ts-ignore
            canOpenFolder: typeof showDirectoryPicker === 'function',
            // @ts-ignore
            canUseFilePicker: typeof showOpenFilePicker === 'function',
            tip: '',
            tipTop: 0,
            tipShow: false,
            root: [],
            accept: _Node__WEBPACK_IMPORTED_MODULE_3__.musicExt.concat(_Node__WEBPACK_IMPORTED_MODULE_3__.movExt).map((i) => '.' + i).join(', ')
        };
    },
    methods: {
        init(player) {
        },
        async addDir(dir) {
            let depth = 0;
            const stack = [];
            function pop() {
                stack.pop();
                depth--;
            }
            async function addFile(handle) {
                const file = await handle.getFile();
                const ext = file.name.split('.').pop();
                if (common_util_array__WEBPACK_IMPORTED_MODULE_4__.has(_Node__WEBPACK_IMPORTED_MODULE_3__.movExt, ext) || common_util_array__WEBPACK_IMPORTED_MODULE_4__.has(_Node__WEBPACK_IMPORTED_MODULE_3__.musicExt, ext)) {
                    const node = {
                        id: (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_6__["default"])(),
                        type: 'file',
                        name: file.name,
                        depth,
                        source: file,
                        handle,
                        played: false,
                        parent: stack.length ? stack[stack.length - 1] : null
                    };
                    stack[stack.length - 1].children.push(node);
                }
            }
            async function addDir(dir) {
                const node = {
                    id: (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_6__["default"])(),
                    type: 'folder',
                    name: dir.name,
                    depth,
                    children: [],
                    opened: false,
                    handle: dir,
                    played: false,
                    parent: stack.length ? stack[stack.length - 1] : null
                };
                if (stack.length) {
                    stack[stack.length - 1].children.push(node);
                }
                stack.push(node);
                depth++;
                // @ts-ignore
                for await (const handle of dir.values()) {
                    if (handle.kind === 'file') {
                        await addFile(handle);
                    }
                    else if (handle.kind === 'directory') {
                        await addDir(handle);
                        pop();
                    }
                }
            }
            await addDir(dir);
            this.append('root', stack.pop());
        },
        async addFile(handle) {
            const file = await handle.getFile();
            this.append('root', {
                id: (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_6__["default"])(),
                type: 'file',
                name: file.name,
                depth: 0,
                source: file,
                handle: handle
            });
        },
        addUrl(url, isLive) {
            const params = common_util_url__WEBPACK_IMPORTED_MODULE_8__.parse(url);
            this.append('root', {
                id: (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_6__["default"])(),
                type: 'file',
                name: params.file,
                depth: 0,
                source: url,
                isLive
            });
        },
        openDir() {
            // @ts-ignore
            showDirectoryPicker({
                mode: 'read',
                startIn: 'videos',
            }).then(async (dir) => {
                this.addDir(dir);
                this.root.push(dir);
                _util_db__WEBPACK_IMPORTED_MODULE_5__.store(_util_db__WEBPACK_IMPORTED_MODULE_5__.KEY_FOLDER_ROOT, this.root);
            });
        },
        openFile() {
            const pickerOpts = {
                startIn: 'videos',
                types: [
                    {
                        description: 'Audios & Videos',
                        accept: {
                            'application/octet-stream': _Node__WEBPACK_IMPORTED_MODULE_3__.musicExt.map((ext) => {
                                return '.' + ext;
                            }).concat(_Node__WEBPACK_IMPORTED_MODULE_3__.movExt.map((ext) => {
                                return '.' + ext;
                            }))
                        },
                    }
                ],
                excludeAcceptAllOption: true,
                multiple: true
            };
            // @ts-ignore
            showOpenFilePicker(pickerOpts).then(async (fileHandles) => {
                for (let i = 0; i < fileHandles.length; i++) {
                    this.addFile(fileHandles[i]);
                    this.root.push(fileHandles[i]);
                }
                _util_db__WEBPACK_IMPORTED_MODULE_5__.store(_util_db__WEBPACK_IMPORTED_MODULE_5__.KEY_FOLDER_ROOT, this.root);
            });
        },
        generateStoreUrl(url, isLive) {
            return `${isLive ? 'libmediaLive:' : ''}${url}`;
        },
        openUrl() {
            const url = this.$refs['url'].value;
            if (!url) {
                return;
            }
            const isLive = this.$refs['live'].checked;
            this.addUrl(url, isLive);
            this.root.push(this.generateStoreUrl(url, isLive));
            _util_db__WEBPACK_IMPORTED_MODULE_5__.store(_util_db__WEBPACK_IMPORTED_MODULE_5__.KEY_FOLDER_ROOT, this.root);
            this.$refs['url'].value = '';
            this.$refs['live'].checked = false;
        },
        fileChange(event) {
            const file = event.originalEvent.target.files[0];
            this.append('root', {
                id: (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_6__["default"])(),
                type: 'file',
                name: file.name,
                depth: 0,
                source: file
            });
        },
        findNodeById(id, root) {
            for (let i = 0; i < root.length; i++) {
                if (root[i].id === id) {
                    return root[i];
                }
                if (root[i].type === 'folder') {
                    let result = this.findNodeById(id, root[i].children);
                    if (result) {
                        return result;
                    }
                }
            }
        },
        async findSubtitle(node) {
            const parent = node.parent;
            const handle = node.handle;
            const subtitle = [];
            if (parent) {
                const file = await handle.getFile();
                let fileNameList = file.name.split('.');
                fileNameList.pop();
                let fileName = fileNameList.join('.');
                // @ts-ignore
                for await (const h of parent.handle.values()) {
                    if (h.kind === 'file') {
                        const target = await h.getFile();
                        const ext = target.name.split('.').pop();
                        let targetNameList = target.name.split('.');
                        targetNameList.pop();
                        let targetName = targetNameList.join('.');
                        if (common_util_array__WEBPACK_IMPORTED_MODULE_4__.has(_Node__WEBPACK_IMPORTED_MODULE_3__.subtitleExt, ext)
                            && fileName === targetName) {
                            subtitle.push({
                                title: targetName,
                                source: target
                            });
                        }
                    }
                }
                if (subtitle.length) {
                    const player = this.get('player');
                    subtitle.forEach((sub) => {
                        player.loadExternalSubtitle(sub);
                    });
                }
            }
        },
        preventDefault(event) {
            event.preventDefault();
        }
    },
    events: {
        play(event, node) {
            const player = this.get('player');
            if (node.get('node.id') === this.playNodeId) {
                if (player.getStatus() === 6 /* AVPlayerStatus.PLAYED */) {
                    player.pause();
                    node.set('node.paused', true);
                }
                else if (player.getStatus() === 7 /* AVPlayerStatus.PAUSED */) {
                    player.play();
                    node.set('node.paused', false);
                }
                return;
            }
            if (this.playNodeId) {
                let root = this.findNodeById(this.playNodeId, this.get('root'));
                while (root) {
                    if (root.ref) {
                        root.ref.set('node.played', false);
                    }
                    else {
                        root.played = false;
                    }
                    root = root.parent;
                }
                this.playNodeId = null;
            }
            let root = node;
            while (root !== this) {
                root.set('node.played', true);
                root = root.$parent;
            }
            if (player.getStatus() === 1 /* AVPlayerStatus.DESTROYING */
                || player.getStatus() === 2 /* AVPlayerStatus.DESTROYED */) {
                return;
            }
            if (player.getStatus() === 0 /* AVPlayerStatus.STOPPED */) {
                player.setIsLive(!!node.get('node.isLive'));
                player.load(node.get('node.source')).then(() => {
                    player.play()
                        .catch((error) => {
                        this.fire('error', {
                            message: `${error}`
                        });
                    });
                    node.set('node.paused', false);
                    this.findSubtitle(node.get('node'));
                })
                    .catch((error) => {
                    this.fire('error', {
                        message: `${error}`
                    });
                });
                this.playNodeId = node.get('node.id');
                this.fire('playNode', node.get('node'));
            }
            else {
                player.stop().then(() => {
                    player.setIsLive(!!node.get('node.isLive'));
                    player.load(node.get('node.source')).then(() => {
                        player.play()
                            .catch((error) => {
                            this.fire('error', {
                                message: `${error}`
                            });
                        });
                        node.set('node.paused', false);
                        this.findSubtitle(node.get('node'));
                    })
                        .catch((error) => {
                        this.fire('error', {
                            message: `${error}`
                        });
                    });
                    this.playNodeId = node.get('node.id');
                    this.fire('playNode', node.get('node'));
                });
            }
        },
        delete(event, node) {
            let index = -1;
            const root = this.get('root');
            for (let i = 0; i < root.length; i++) {
                if (root[i].id === node.id) {
                    index = i;
                    break;
                }
            }
            if (index > -1) {
                this.removeAt('root', index);
            }
            common_util_array__WEBPACK_IMPORTED_MODULE_4__.remove(this.root, node.handle || this.generateStoreUrl(node.source, node.isLive));
            _util_db__WEBPACK_IMPORTED_MODULE_5__.store(_util_db__WEBPACK_IMPORTED_MODULE_5__.KEY_FOLDER_ROOT, this.root);
        },
        tip(event, data) {
            if (data) {
                this.set('tipShow', true);
                this.set('tip', data.text);
                this.set('tipTop', data.top - this.$refs['scroll'].scrollTop + 90);
            }
            else {
                this.set('tipShow', false);
            }
        }
    },
    afterMount() {
        this.namespace = '.component_folder' + Math.random();
        if (this.get('canOpenFolder') || this.get('canUseFilePicker')) {
            _util_db__WEBPACK_IMPORTED_MODULE_5__.load(_util_db__WEBPACK_IMPORTED_MODULE_5__.KEY_FOLDER_ROOT).then(async (root) => {
                this.root = root || [];
                const list = [];
                for (let i = 0; i < this.root.length; i++) {
                    const handle = this.root[i];
                    try {
                        if (common_util_is__WEBPACK_IMPORTED_MODULE_9__.string(handle)) {
                            let url = handle;
                            const isLive = /^libmediaLive:/.test(url);
                            if (isLive) {
                                url = url.replace(/^libmediaLive:/, '');
                            }
                            this.addUrl(url, isLive);
                        }
                        else {
                            // @ts-ignore
                            let permission = await handle.queryPermission({
                                mode: 'read'
                            });
                            if (permission !== 'granted') {
                                // @ts-ignore
                                permission = await handle.requestPermission({
                                    mode: 'read'
                                });
                                if (permission !== 'granted') {
                                    throw new Error(`not has permission to access ${handle.name}`);
                                }
                            }
                            if (handle.kind === 'file') {
                                await this.addFile(handle);
                            }
                            else if (handle.kind === 'directory') {
                                await this.addDir(handle);
                            }
                        }
                        list.push(handle);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_7__.error('load file handle error, ignore it', cheap__fileName__0, 437);
                    }
                }
                if (list.length !== this.root.length) {
                    _util_db__WEBPACK_IMPORTED_MODULE_5__.store(_util_db__WEBPACK_IMPORTED_MODULE_5__.KEY_FOLDER_ROOT, list);
                }
            });
        }
        const player = this.get('player');
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__.STOPPED + this.namespace, () => {
            if (this.playNodeId) {
                let node = this.findNodeById(this.playNodeId, this.get('root'));
                if (node) {
                    if (node.ref) {
                        node.ref.set('node.paused', true);
                    }
                    else {
                        node.paused = true;
                    }
                    let root = node;
                    while (root) {
                        if (root.ref) {
                            root.ref.set('node.played', false);
                        }
                        else {
                            root.played = false;
                        }
                        root = root.parent;
                    }
                }
            }
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__.PAUSED + this.namespace, () => {
            if (this.playNodeId) {
                let node = this.findNodeById(this.playNodeId, this.get('root'));
                if (node) {
                    if (node.ref) {
                        node.ref.set('node.paused', true);
                    }
                    else {
                        node.paused = true;
                    }
                }
            }
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__.PLAYED + this.namespace, () => {
            if (this.playNodeId) {
                let node = this.findNodeById(this.playNodeId, this.get('root'));
                if (node) {
                    if (node.ref) {
                        node.ref.set('node.paused', false);
                    }
                    else {
                        node.paused = false;
                    }
                }
            }
        });
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
    },
    components: {
        FolderNode: _Node__WEBPACK_IMPORTED_MODULE_3__["default"]
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Folder);


/***/ }),

/***/ "./src/ui/avplayer/components/folder/Node.ts":
/*!***************************************************!*\
  !*** ./src/ui/avplayer/components/folder/Node.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   movExt: () => (/* binding */ movExt),
/* harmony export */   musicExt: () => (/* binding */ musicExt),
/* harmony export */   subtitleExt: () => (/* binding */ subtitleExt)
/* harmony export */ });
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var _Node_hbs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Node.hbs */ "./src/ui/avplayer/components/folder/Node.hbs");
/* harmony import */ var _Node_hbs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Node_hbs__WEBPACK_IMPORTED_MODULE_2__);



const musicExt = ['mp3', 'aac', 'flac', 'ogg', 'ogg', 'wav', 'm4a', 'mka', 'opus'];
const movExt = ['mp4', 'webm', 'mkv', 'flv', 'ts', 'mov', 'm4s', 'h264', '264', 'avc',
    'h265', '265', 'hevc', 'h266', '266', 'vvc', 'ivf', 'mpeg'
];
const subtitleExt = ['ass', 'ssa', 'vvt', 'srt', 'xml', 'ttml'];
const Node = {
    name: 'Node',
    template: (_Node_hbs__WEBPACK_IMPORTED_MODULE_2___default()),
    propTypes: {
        node: {
            type: 'object'
        },
        language: {
            type: 'object',
            required: true
        }
    },
    data: function () {
        return {};
    },
    filters: {
        isFolder: function (node) {
            return node.type === 'folder';
        },
        paddingStart: function (node) {
            return node.depth * 24;
        },
        isUrl: function (node) {
            return common_util_is__WEBPACK_IMPORTED_MODULE_0__.string(node.source);
        },
        isMusic: function (node) {
            const ext = node.source.name.split('.').pop();
            return common_util_array__WEBPACK_IMPORTED_MODULE_1__.has(musicExt, ext);
        }
    },
    methods: {
        toggle() {
            this.set('node.opened', !this.get('node.opened'));
        },
        play() {
            this.fire('play', this);
        },
        delete() {
            this.fire('delete', this.get('node'));
        },
        mouseenter() {
            if (this.$refs['name'].scrollWidth > this.$refs['name'].clientWidth) {
                this.fire('tip', {
                    top: this.$el.offsetTop,
                    text: common_util_is__WEBPACK_IMPORTED_MODULE_0__.string(this.get('node.source')) ? this.get('node.source') : this.get('node.name')
                });
            }
        },
        mouseleave() {
            this.fire('tip', '');
        }
    },
    afterMount() {
        this.get('node').ref = this;
    },
    beforeDestroy() {
        this.get('node').ref = null;
    },
    components: {}
};
Node.components['FolderNode'] = Node;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Node);


/***/ }),

/***/ "./src/ui/avplayer/components/info/Info.ts":
/*!*************************************************!*\
  !*** ./src/ui/avplayer/components/info/Info.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avplayer/eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _Info_hbs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Info.hbs */ "./src/ui/avplayer/components/info/Info.hbs");
/* harmony import */ var _Info_hbs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Info_hbs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Info_styl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Info.styl */ "./src/ui/avplayer/components/info/Info.styl");
/* harmony import */ var _Info_styl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_Info_styl__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var avformat_dump__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avformat/dump */ "./src/avformat/dump.ts");





const statsKeys = [
    'jitter',
    'bandwidth'
];
const audioStatsKeys = [
    'audioStutter',
    'audioBitrate',
    'audioEncodeFramerate',
    'audioDecodeFramerate',
    'audioRenderFramerate',
    'audioFrameDecodeIntervalMax',
    'audioFrameRenderIntervalMax',
];
const videoStatsKeys = [
    'videoStutter',
    'videoBitrate',
    'videoEncodeFramerate',
    'videoDecodeFramerate',
    'videoRenderFramerate',
    'keyFrameInterval',
    'videoFrameDecodeIntervalMax',
    'videoFrameRenderIntervalMax',
];
const Info = {
    name: 'Info',
    template: (_Info_hbs__WEBPACK_IMPORTED_MODULE_2___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        }
    },
    data: function () {
        return {
            style: (_Info_styl__WEBPACK_IMPORTED_MODULE_3___default()),
            info: '',
            list: []
        };
    },
    methods: {
        getStats: function (player) {
            const stats = player.getStats();
            this.set('list', []);
            let keys = statsKeys;
            if (player.hasVideo()) {
                keys = keys.concat(videoStatsKeys);
            }
            if (player.hasAudio()) {
                keys = keys.concat(audioStatsKeys);
            }
            keys.forEach((key) => {
                let value = stats[key];
                if (key === 'audioBitrate' || key === 'videoBitrate' || key === 'bandwidth') {
                    value = (value * 8 / 1000) + ' kbps';
                }
                this.append('list', {
                    key: key.replace(/([A-Z])/g, ' $1').replace(/^[a-z]/, (s) => s.toUpperCase()),
                    value
                });
            });
        },
        init(player) {
            const source = player.getSource();
            const info = (0,avformat_dump__WEBPACK_IMPORTED_MODULE_4__["default"])([player.getFormatContext()], [{
                    from: common_util_is__WEBPACK_IMPORTED_MODULE_1__.string(source) ? source : source.name,
                    tag: 'Input'
                }]);
            this.set('info', info.replace(/\n/g, '<br>').replace(/\s/g, '&nbsp;'));
            this.set('list', []);
            this.getStats(player);
            if (!this.timer) {
                this.timer = setInterval(() => {
                    this.getStats(player);
                }, 1000);
            }
        },
        close() {
            this.fire('closeInfo');
            return false;
        },
        preventDefault(event) {
            event.preventDefault();
        }
    },
    afterMount() {
        this.namespace = '.component_info' + Math.random();
        const player = this.get('player');
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__.LOADED + this.namespace, () => {
            this.init(player);
        });
        if (player.getStatus() >= 4 /* AVPlayerStatus.LOADED */) {
            this.init(player);
        }
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
        if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
        }
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Info);


/***/ }),

/***/ "./src/ui/avplayer/components/loadingTip/LoadingTip.ts":
/*!*************************************************************!*\
  !*** ./src/ui/avplayer/components/loadingTip/LoadingTip.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var avplayer_eventType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avplayer/eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var _LoadingTip_hbs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LoadingTip.hbs */ "./src/ui/avplayer/components/loadingTip/LoadingTip.hbs");
/* harmony import */ var _LoadingTip_hbs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_LoadingTip_hbs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _LoadingTip_styl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LoadingTip.styl */ "./src/ui/avplayer/components/loadingTip/LoadingTip.styl");
/* harmony import */ var _LoadingTip_styl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_LoadingTip_styl__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var avformat_dump__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avformat/dump */ "./src/avformat/dump.ts");
/* harmony import */ var common_helper_IntervalQueueTask__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/helper/IntervalQueueTask */ "./src/common/helper/IntervalQueueTask.ts");






const info = {
    [0 /* AVPlayerProgress.OPEN_FILE */]: 'LOADING_MESSAGE_OPEN_FILE',
    [1 /* AVPlayerProgress.ANALYZE_FILE */]: 'LOADING_MESSAGE_ANALYZE_FILE',
    [2 /* AVPlayerProgress.LOAD_AUDIO_DECODER */]: 'LOADING_MESSAGE_LOAD_AUDIO_DECODER',
    [3 /* AVPlayerProgress.LOAD_VIDEO_DECODER */]: 'LOADING_MESSAGE_LOAD_VIDEO_DECODER',
};
const LoadingTip = {
    name: 'LoadingTip',
    template: (_LoadingTip_hbs__WEBPACK_IMPORTED_MODULE_2___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        },
        error: {
            type: 'string'
        }
    },
    data: function () {
        return {
            style: (_LoadingTip_styl__WEBPACK_IMPORTED_MODULE_3___default()),
            messages: [],
            showMessage: false
        };
    },
    watchers: {
        error: function () {
            this.queue.push(() => {
                this.append('message', this.get('language.LOADING_MESSAGE_LOAD_FAILED'));
            });
        }
    },
    methods: {},
    afterMount() {
        this.namespace = '.component_loading' + Math.random();
        const player = this.get('player');
        this.queue = new common_helper_IntervalQueueTask__WEBPACK_IMPORTED_MODULE_5__["default"](100);
        this.queue.onEnd = () => {
            if (this.showTimer) {
                clearTimeout(this.showTimer);
            }
            this.showTimer = setTimeout(() => {
                this.set('showMessage', false);
                this.showTimer = null;
            }, 2000);
        };
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_1__.PLAYED + this.namespace, () => {
            this.queue.push(() => {
                this.append('message', this.get('language.LOADING_MESSAGE_LOAD_END'));
            });
            this.queue.end();
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_1__.LOADING + this.namespace, () => {
            if (this.showTimer) {
                clearTimeout(this.showTimer);
                this.showTimer = null;
            }
            this.queue.reset();
            this.set('message', []);
            this.set('showMessage', true);
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_1__.PROGRESS + this.namespace, (progress, data) => {
            let message = this.get('language.' + info[progress]);
            switch (progress) {
                case 1 /* AVPlayerProgress.ANALYZE_FILE */:
                    message = message.replace('${mux}', data);
                    break;
                case 2 /* AVPlayerProgress.LOAD_AUDIO_DECODER */:
                case 3 /* AVPlayerProgress.LOAD_VIDEO_DECODER */:
                    message = message.replace('${decoder}', (0,avformat_dump__WEBPACK_IMPORTED_MODULE_4__.dumpCodecName)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](data.codecpar), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](data.codecpar + 4)));
                    break;
            }
            this.queue.push(() => {
                this.append('message', message);
            });
        });
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LoadingTip);


/***/ }),

/***/ "./src/ui/avplayer/components/loading/Loading.ts":
/*!*******************************************************!*\
  !*** ./src/ui/avplayer/components/loading/Loading.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avplayer/eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var _Loading_hbs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loading.hbs */ "./src/ui/avplayer/components/loading/Loading.hbs");
/* harmony import */ var _Loading_hbs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Loading_hbs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Loading_styl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Loading.styl */ "./src/ui/avplayer/components/loading/Loading.styl");
/* harmony import */ var _Loading_styl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Loading_styl__WEBPACK_IMPORTED_MODULE_2__);



const Loading = {
    name: 'Loading',
    template: (_Loading_hbs__WEBPACK_IMPORTED_MODULE_1___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        }
    },
    data: function () {
        return {
            style: (_Loading_styl__WEBPACK_IMPORTED_MODULE_2___default()),
            loading: false
        };
    },
    methods: {},
    afterMount() {
        this.namespace = '.component_loading' + Math.random();
        const player = this.get('player');
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__.PLAYED + this.namespace, () => {
            if (this.timer) {
                clearTimeout(this.timer);
                this.timer = null;
            }
            this.set('loading', false);
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_0__.LOADING + this.namespace, () => {
            if (this.timer) {
                clearTimeout(this.timer);
            }
            this.timer = setTimeout(() => {
                this.set('loading', true);
                this.timer = null;
            }, 500);
        });
        this.set('loading', player.getStatus() === 3 /* AVPlayerStatus.LOADING */);
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Loading);


/***/ }),

/***/ "./src/ui/avplayer/components/pcmVisualization/PcmVisualization.ts":
/*!*************************************************************************!*\
  !*** ./src/ui/avplayer/components/pcmVisualization/PcmVisualization.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var avplayer_AVPlayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avplayer/AVPlayer */ "./src/avplayer/AVPlayer.ts");
/* harmony import */ var avplayer_eventType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avplayer/eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var _PcmVisualization_hbs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PcmVisualization.hbs */ "./src/ui/avplayer/components/pcmVisualization/PcmVisualization.hbs");
/* harmony import */ var _PcmVisualization_hbs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_PcmVisualization_hbs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _PcmVisualization_styl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PcmVisualization.styl */ "./src/ui/avplayer/components/pcmVisualization/PcmVisualization.styl");
/* harmony import */ var _PcmVisualization_styl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_PcmVisualization_styl__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var common_function_debounce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/function/debounce */ "./src/common/function/debounce.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");






//  RGB  HSL
function rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
        h = s = 0;
    }
    else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }
    return [h * 360, s, l];
}
//  HSL  RGB
function hslToRgb(h, s, l) {
    let r, g, b;
    if (s == 0) {
        r = g = b = l;
    }
    else {
        const hue2rgb = function (p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 0.16666666666666666) {
                return p + (q - p) * 6 * t;
            }
            if (t < 0.3333333333333333) {
                return q;
            }
            if (t < 0.5) {
                return p + (q - p) * (0.6666666666666666 - t) * 6;
            }
            return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        h /= 360;
        r = hue2rgb(p, q, h + 0.3333333333333333);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 0.3333333333333333);
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}
// 
function interpolateHue(hue, t) {
    let newHue = (hue + t) % 360;
    if (newHue < 0) {
        newHue += 360;
    }
    return newHue;
}
class Drawer {
    OUTER_MAX_HEIGHT = 0.4;
    MIDDLE_MAX_HEIGHT = 0.3;
    INNER_MAX_HEIGHT = 0.2;
    MAX_LENGTH = 100;
    MAX_FRAMERATE = 30;
    timeDelta = Math.floor(1000 / this.MAX_FRAMERATE);
    lastTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_5__["default"])();
    constructor() {
    }
    draw(data, context) {
        const now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_5__["default"])();
        if (now - this.lastTimestamp < this.timeDelta) {
            return;
        }
        this.lastTimestamp = now;
        const width = context.canvas.width;
        const height = context.canvas.height;
        const minRadius = Math.min(width, height) / 2;
        let length = Math.floor(this.MAX_LENGTH * (1 + Math.min(1, (minRadius - 500) / 200)));
        const step = Math.floor(data.length / length * 0.6);
        context.clearRect(0, 0, width, height);
        const radius = Math.min(width / 2, height / 2) * (0.95 - this.OUTER_MAX_HEIGHT);
        const outerPoints = [];
        const lines = [];
        const innerPoints = [];
        const color = [];
        const delta = 2 * Math.PI / length;
        const degDelta = 360 / length;
        const hslColor = rgbToHsl(255, 0, 0);
        for (let i = 0; i < length; i++) {
            const outerFactor = Math.pow(data[i * step] / 255, 1.5);
            const innerFactor = Math.pow(data[i * step] / 255, 1);
            const lineFactor = Math.pow(data[i * step] / 255, 2.2);
            outerPoints.push({
                x: width / 2 + (radius + this.OUTER_MAX_HEIGHT * minRadius * outerFactor) * Math.cos(i * delta * -1),
                y: height / 2 + (radius + this.OUTER_MAX_HEIGHT * minRadius * outerFactor) * Math.sin(i * delta * -1),
            });
            innerPoints.push({
                x: width / 2 + (radius - this.INNER_MAX_HEIGHT * minRadius * innerFactor) * Math.cos(i * delta * -1),
                y: height / 2 + (radius - this.INNER_MAX_HEIGHT * minRadius * innerFactor) * Math.sin(i * delta * -1),
            });
            lines.push({
                start: {
                    x: width / 2 + radius * Math.cos(i * delta * -1),
                    y: height / 2 + radius * Math.sin(i * delta * -1),
                },
                end: {
                    x: width / 2 + (radius + this.MIDDLE_MAX_HEIGHT * minRadius * lineFactor) * Math.cos(i * delta * -1),
                    y: height / 2 + (radius + this.MIDDLE_MAX_HEIGHT * minRadius * lineFactor) * Math.sin(i * delta * -1),
                }
            });
            let deg = Math.floor(i * degDelta) - 60;
            if (deg < 0) {
                deg += 360;
            }
            const interpolatedHue = interpolateHue(hslColor[0], deg);
            const newRgbColor = hslToRgb(interpolatedHue, hslColor[1], hslColor[2]);
            color.push(`rgb(${newRgbColor[0]},${newRgbColor[1]},${newRgbColor[2]})`);
        }
        context.lineCap = 'round';
        context.lineWidth = 8;
        context.shadowBlur = 20;
        context.shadowOffsetX = 0;
        context.shadowOffsetY = 0;
        for (let i = 0; i < outerPoints.length; i++) {
            context.strokeStyle = color[i];
            context.fillStyle = color[i];
            context.shadowColor = color[i];
            context.beginPath();
            context.arc(outerPoints[i].x, outerPoints[i].y, 4, 0, Math.PI * 2, true);
            context.fill();
            context.beginPath();
            context.arc(innerPoints[i].x, innerPoints[i].y, 4, 0, Math.PI * 2, true);
            context.fill();
            context.beginPath();
            context.moveTo(lines[i].start.x, lines[i].start.y);
            context.lineTo(lines[i].end.x, lines[i].end.y);
            context.stroke();
        }
        context.lineWidth = 2;
        for (let i = 0; i < innerPoints.length; i++) {
            let next = (i === innerPoints.length - 1) ? 0 : (i + 1);
            const gradient = context.createLinearGradient(innerPoints[i].x, innerPoints[i].y, innerPoints[next].x, innerPoints[next].y);
            gradient.addColorStop(0, color[i]);
            gradient.addColorStop(1, color[next]);
            context.strokeStyle = gradient;
            context.shadowColor = color[i];
            context.beginPath();
            context.moveTo(innerPoints[i].x, innerPoints[i].y);
            context.lineTo(innerPoints[next].x, innerPoints[next].y);
            context.stroke();
        }
    }
}
const PcmVisualization = {
    name: 'PcmVisualization',
    template: (_PcmVisualization_hbs__WEBPACK_IMPORTED_MODULE_2___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        }
    },
    data: function () {
        return {
            style: (_PcmVisualization_styl__WEBPACK_IMPORTED_MODULE_3___default()),
        };
    },
    methods: {
        draw() {
            this.analyser.getByteFrequencyData(this.buffer);
            this.drawer.draw(this.buffer, this.context);
            requestAnimationFrame(() => {
                if (!this.playing) {
                    return;
                }
                this.draw();
            });
        },
        init(player) {
            if (player.hasVideo()) {
                this.playing = false;
                this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);
            }
            else if (player.hasAudio()) {
                this.playing = true;
                if (!this.analyser) {
                    this.analyser = avplayer_AVPlayer__WEBPACK_IMPORTED_MODULE_0__["default"].audioContext.createAnalyser();
                    this.buffer = new Uint8Array(this.analyser.frequencyBinCount);
                }
                player.getAudioOutputNode().connect(this.analyser);
                this.draw();
            }
        }
    },
    afterMount() {
        this.namespace = '.component_pcm_visualization' + Math.random();
        this.$refs['canvas'].width = this.$el.offsetWidth * devicePixelRatio;
        this.$refs['canvas'].height = this.$el.offsetHeight * devicePixelRatio;
        this.context = this.$refs['canvas'].getContext('2d');
        this.drawer = new Drawer();
        const player = this.get('player');
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_1__.PLAYED + this.namespace, () => {
            this.init(player);
        });
        if (player.getStatus() === 6 /* AVPlayerStatus.PLAYED */) {
            this.init(player);
        }
        this.onresize = (0,common_function_debounce__WEBPACK_IMPORTED_MODULE_4__["default"])(() => {
            this.$refs['canvas'].width = this.$el.offsetWidth * devicePixelRatio;
            this.$refs['canvas'].height = this.$el.offsetHeight * devicePixelRatio;
        }, 500);
        window.addEventListener('resize', this.onresize);
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
        this.playing = false;
        window.removeEventListener('resize', this.onresize);
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PcmVisualization);


/***/ }),

/***/ "./src/ui/avplayer/components/progress/Progress.ts":
/*!*********************************************************!*\
  !*** ./src/ui/avplayer/components/progress/Progress.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./..\..\..\..\avutil\struct\rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _Progress_hbs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Progress.hbs */ "./src/ui/avplayer/components/progress/Progress.hbs");
/* harmony import */ var _Progress_hbs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Progress_hbs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Progress_styl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Progress.styl */ "./src/ui/avplayer/components/progress/Progress.styl");
/* harmony import */ var _Progress_styl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_Progress_styl__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var avplayer_eventType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avplayer/eventType */ "./src/avplayer/eventType.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var common_util_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/string */ "./src/common/util/string.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");









const Progress = {
    name: 'Progress',
    template: (_Progress_hbs__WEBPACK_IMPORTED_MODULE_2___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        indicatorUrl: {
            type: 'string',
        }
    },
    data: function () {
        return {
            style: (_Progress_styl__WEBPACK_IMPORTED_MODULE_3___default()),
            startX: 0,
            start: false,
            seekTime: 0,
            currentTime: 0,
            totalTime: 0,
            loadedTime: 0,
            hoverX: 0,
            indicatorSize: 0,
            showTip: false,
            isFileSource: false,
            chapters: [],
            hoverChapter: ''
        };
    },
    computed: {
        playedWidth: function () {
            const seekTime = this.get('seekTime');
            const currentTime = this.get('currentTime');
            const totalTime = this.get('totalTime');
            if (this.get('start')) {
                return seekTime / totalTime * 100;
            }
            else {
                return currentTime / totalTime * 100;
            }
        },
        loadedWidth: function () {
            const isFileSource = this.get('isFileSource');
            if (isFileSource) {
                return 0;
            }
            return (this.get('currentTime') + this.get('loadedTime')) / this.get('totalTime') * 100;
        },
        hoverWidth: function () {
            const hoverX = this.get('hoverX');
            if (this.$refs && this.$refs['slider']) {
                const parentX = this.$refs['slider'].getBoundingClientRect().left;
                let width = hoverX - parentX;
                if (width < 0) {
                    width = 0;
                }
                if (width > this.$refs['slider'].offsetWidth) {
                    width = this.$refs['slider'].offsetWidth;
                }
                return width / this.$refs['slider'].offsetWidth * 100;
            }
            return 0;
        },
        hoverTime: function () {
            const hoverWidth = this.get('hoverWidth');
            return Math.round(hoverWidth / 100 * this.get('totalTime'));
        }
    },
    filters: {
        formatTime(time) {
            if (time < 0) {
                time = 0;
            }
            const secs = ((time / 1000 % 60) >> 0);
            const mins = ((time / 1000 / 60 % 60) >> 0);
            const hours = ((time / 1000 / 3600) >> 0);
            if (hours) {
                return common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%02d:%02d:%02d', hours, mins, secs);
            }
            return common_util_string__WEBPACK_IMPORTED_MODULE_6__.format('%02d:%02d', mins, secs);
        }
    },
    methods: {
        mousemove: function (event) {
            if (!this.get('start')) {
                return;
            }
            const screenX = this.get('startX');
            const total = this.$refs['slider'].offsetWidth;
            let diff = 0;
            diff = (event.screenX - screenX) / total * this.get('totalTime');
            let value = this.get('seekTime') + diff;
            if (value < 0) {
                value = 0;
            }
            if (value > this.get('totalTime')) {
                value = this.get('totalTime');
            }
            this.set('seekTime', value);
            this.set('startX', event.screenX);
        },
        mouseup: function () {
            if (this.get('start')) {
                this.set('start', false);
                const player = this.get('player');
                this.seeking = true;
                player.seek(BigInt(Math.floor(this.get('seekTime')))).then(() => {
                    this.seeking = false;
                });
                this.set('currentTime', this.get('seekTime'));
            }
        },
        hoverEnter: function (event) {
            this.set('hoverX', event.originalEvent.clientX);
            this.set('showTip', true);
        },
        hoverMove: function (event) {
            this.set('hoverX', event.originalEvent.clientX);
        },
        hoverLeave: function (event) {
            this.set('hoverX', this.$refs['slider'].offsetLeft);
            this.set('showTip', false);
        },
        hoverClick: function (event) {
            const player = this.get('player');
            const status = player.getStatus();
            if (status !== 6 /* AVPlayerStatus.PLAYED */ && status !== 7 /* AVPlayerStatus.PAUSED */) {
                return;
            }
            this.seeking = true;
            player.seek(BigInt(Math.floor(this.get('hoverTime')))).then(() => {
                this.seeking = false;
            });
            this.set('currentTime', this.get('hoverTime'));
        },
        indicatorDown: function (event) {
            this.set('startX', event.originalEvent.screenX);
            this.set('start', true);
            this.set('seekTime', this.get('currentTime'));
        },
        chapterEnter(chapter) {
            this.set('hoverChapter', chapter.text);
            this.set('showTip', true);
        },
        chapterLeave(chapter) {
            this.set('hoverChapter', '');
            this.set('showTip', true);
        },
        chapterClick(chapter) {
            const player = this.get('player');
            this.seeking = true;
            player.seek(chapter.start).then(() => {
                this.seeking = false;
            });
            this.set('currentTime', Number(chapter.start));
        },
        init(player) {
            this.set('currentTime', Number(player.currentTime));
            this.set('totalTime', Number(player.getDuration()));
            this.set('isFileSource', !common_util_is__WEBPACK_IMPORTED_MODULE_7__.string(player.getSource()));
            this.set('chapters', player.getChapters().map((chapter) => {
                const start = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_5__.avRescaleQ)(chapter.start, chapter.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_8__.AV_MILLI_TIME_BASE_Q);
                return {
                    text: chapter.metadata['title'],
                    start,
                    left: Number(start) / this.get('totalTime') * 100
                };
            }));
        }
    },
    afterMount() {
        this.onmouseup = (event) => {
            this.mouseup();
        };
        this.onmousemove = (event) => {
            this.mousemove(event);
        };
        document.addEventListener('mouseup', this.onmouseup);
        document.addEventListener('mousemove', this.onmousemove);
        this.namespace = '.Progress' + Math.random();
        const player = this.get('player');
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_4__.LOADED + this.namespace, () => {
            this.init(player);
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_4__.STOPPED + this.namespace, () => {
            this.set('currentTime', 0);
            this.set('loadedTime', 0);
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_4__.SEEKED + this.namespace, () => {
            this.set('currentTime', Number(player.currentTime));
        });
        player.on(avplayer_eventType__WEBPACK_IMPORTED_MODULE_4__.TIME + this.namespace, (pts) => {
            if (this.seeking) {
                return;
            }
            this.set('currentTime', Number(pts));
            const stats = player.getStats();
            const streams = player.getStreams();
            if (player.hasAudio()) {
                const selectStream = streams.find((stream) => {
                    return stream.id === player.getSelectedAudioStreamId();
                });
                if (selectStream) {
                    this.set('loadedTime', stats.audioPacketQueueLength / (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_5__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__["default"])(selectStream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_0__.Rational)) * 1000);
                }
            }
            else if (player.hasVideo()) {
                const selectStream = streams.find((stream) => {
                    return stream.id === player.getSelectedVideoStreamId();
                });
                if (selectStream) {
                    this.set('loadedTime', stats.videoPacketQueueLength / (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_5__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_1__["default"])(selectStream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_0__.Rational)) * 1000);
                }
            }
        });
        if (player.getStatus() >= 4 /* AVPlayerStatus.LOADED */) {
            this.init(player);
        }
        const box = document.querySelector('#avplayer-ui-container');
        const boxStyles = getComputedStyle(box);
        const size = boxStyles.getPropertyValue('--libmedia-ui-indicator-size').trim();
        this.set('indicatorSize', parseInt(size));
    },
    beforeDestroy() {
        document.removeEventListener('mouseup', this.onmouseup);
        document.removeEventListener('mousemove', this.onmousemove);
        const player = this.get('player');
        player.off(this.namespace);
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Progress);


/***/ }),

/***/ "./src/ui/avplayer/components/settings/Settings.ts":
/*!*********************************************************!*\
  !*** ./src/ui/avplayer/components/settings/Settings.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Settings_hbs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Settings.hbs */ "./src/ui/avplayer/components/settings/Settings.hbs");
/* harmony import */ var _Settings_hbs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Settings_hbs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Settings_styl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Settings.styl */ "./src/ui/avplayer/components/settings/Settings.styl");
/* harmony import */ var _Settings_styl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Settings_styl__WEBPACK_IMPORTED_MODULE_1__);


var TAB;
(function (TAB) {
    TAB[TAB["DECODER"] = 0] = "DECODER";
    TAB[TAB["PLAY"] = 1] = "PLAY";
    TAB[TAB["SUBTITLE"] = 2] = "SUBTITLE";
    TAB[TAB["VIDEO"] = 3] = "VIDEO";
    TAB[TAB["AUDIO"] = 4] = "AUDIO";
    TAB[TAB["FILTER"] = 5] = "FILTER";
    TAB[TAB["KEYBOARD"] = 6] = "KEYBOARD";
    TAB[TAB["LANGUAGE"] = 7] = "LANGUAGE";
    TAB[TAB["SKIN"] = 8] = "SKIN";
})(TAB || (TAB = {}));
const Settings = {
    name: 'Settings',
    template: (_Settings_hbs__WEBPACK_IMPORTED_MODULE_0___default()),
    propTypes: {
        player: {
            type: 'object',
            required: true
        },
        language: {
            type: 'object',
            required: true
        }
    },
    data: function () {
        const language = this.get('language');
        const list = [
            {
                id: TAB.DECODER,
                name: language.SETTING_TAB_DECODER
            },
            {
                id: TAB.PLAY,
                name: language.SETTING_TAB_PLAY
            },
            {
                id: TAB.SUBTITLE,
                name: language.SETTING_TAB_SUBTITLE
            },
            {
                id: TAB.VIDEO,
                name: language.SETTING_TAB_VIDEO
            },
            {
                id: TAB.AUDIO,
                name: language.SETTING_TAB_AUDIO
            },
            {
                id: TAB.FILTER,
                name: language.SETTING_TAB_FILTER
            },
            {
                id: TAB.KEYBOARD,
                name: language.SETTING_TAB_KEYBOARD
            },
            {
                id: TAB.LANGUAGE,
                name: language.SETTING_TAB_LANGUAGE
            },
            {
                id: TAB.SKIN,
                name: language.SETTING_TAB_SKIN
            }
        ];
        return {
            style: (_Settings_styl__WEBPACK_IMPORTED_MODULE_1___default()),
            tab: TAB.DECODER,
            list
        };
    },
    methods: {
        close: function () {
            this.fire('closeSettings');
        }
    },
    afterMount() {
        this.namespace = '.component_settings' + Math.random();
    },
    beforeDestroy() {
        const player = this.get('player');
        if (this.namespace) {
            player.off(this.namespace);
        }
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Settings);


/***/ }),

/***/ "./src/ui/avplayer/i18n/chinese.ts":
/*!*****************************************!*\
  !*** ./src/ui/avplayer/i18n/chinese.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BUTTON_ADD: () => (/* binding */ BUTTON_ADD),
/* harmony export */   CHECKBOX_LIVE: () => (/* binding */ CHECKBOX_LIVE),
/* harmony export */   CONTROL_AUDIO_TRACK: () => (/* binding */ CONTROL_AUDIO_TRACK),
/* harmony export */   CONTROL_PLAYRATE: () => (/* binding */ CONTROL_PLAYRATE),
/* harmony export */   CONTROL_SUBTITLE_TRACK: () => (/* binding */ CONTROL_SUBTITLE_TRACK),
/* harmony export */   CONTROL_SUBTITLE_TRACK_ADD: () => (/* binding */ CONTROL_SUBTITLE_TRACK_ADD),
/* harmony export */   CONTROL_VIDEO_TRACK: () => (/* binding */ CONTROL_VIDEO_TRACK),
/* harmony export */   FOLDER_OPEN_DIR: () => (/* binding */ FOLDER_OPEN_DIR),
/* harmony export */   FOLDER_OPEN_FILE: () => (/* binding */ FOLDER_OPEN_FILE),
/* harmony export */   FOLDER_OPEN_URL_PLACEHOLDER: () => (/* binding */ FOLDER_OPEN_URL_PLACEHOLDER),
/* harmony export */   INFO_TITLE: () => (/* binding */ INFO_TITLE),
/* harmony export */   LOADING_MESSAGE_ANALYZE_FILE: () => (/* binding */ LOADING_MESSAGE_ANALYZE_FILE),
/* harmony export */   LOADING_MESSAGE_LOAD_AUDIO_DECODER: () => (/* binding */ LOADING_MESSAGE_LOAD_AUDIO_DECODER),
/* harmony export */   LOADING_MESSAGE_LOAD_END: () => (/* binding */ LOADING_MESSAGE_LOAD_END),
/* harmony export */   LOADING_MESSAGE_LOAD_FAILED: () => (/* binding */ LOADING_MESSAGE_LOAD_FAILED),
/* harmony export */   LOADING_MESSAGE_LOAD_VIDEO_DECODER: () => (/* binding */ LOADING_MESSAGE_LOAD_VIDEO_DECODER),
/* harmony export */   LOADING_MESSAGE_OPEN_FILE: () => (/* binding */ LOADING_MESSAGE_OPEN_FILE),
/* harmony export */   MENU_STATS: () => (/* binding */ MENU_STATS),
/* harmony export */   SETTINGS_TITLE: () => (/* binding */ SETTINGS_TITLE),
/* harmony export */   SETTING_TAB_AUDIO: () => (/* binding */ SETTING_TAB_AUDIO),
/* harmony export */   SETTING_TAB_DECODER: () => (/* binding */ SETTING_TAB_DECODER),
/* harmony export */   SETTING_TAB_FILTER: () => (/* binding */ SETTING_TAB_FILTER),
/* harmony export */   SETTING_TAB_KEYBOARD: () => (/* binding */ SETTING_TAB_KEYBOARD),
/* harmony export */   SETTING_TAB_LANGUAGE: () => (/* binding */ SETTING_TAB_LANGUAGE),
/* harmony export */   SETTING_TAB_PLAY: () => (/* binding */ SETTING_TAB_PLAY),
/* harmony export */   SETTING_TAB_SKIN: () => (/* binding */ SETTING_TAB_SKIN),
/* harmony export */   SETTING_TAB_SUBTITLE: () => (/* binding */ SETTING_TAB_SUBTITLE),
/* harmony export */   SETTING_TAB_VIDEO: () => (/* binding */ SETTING_TAB_VIDEO),
/* harmony export */   TIP_DELETE: () => (/* binding */ TIP_DELETE),
/* harmony export */   TIP_FOLD: () => (/* binding */ TIP_FOLD),
/* harmony export */   TIP_FULLSCREEN: () => (/* binding */ TIP_FULLSCREEN),
/* harmony export */   TIP_LOOP_START: () => (/* binding */ TIP_LOOP_START),
/* harmony export */   TIP_LOOP_STOP: () => (/* binding */ TIP_LOOP_STOP),
/* harmony export */   TIP_PAUSE: () => (/* binding */ TIP_PAUSE),
/* harmony export */   TIP_PIP_START: () => (/* binding */ TIP_PIP_START),
/* harmony export */   TIP_PIP_STOP: () => (/* binding */ TIP_PIP_STOP),
/* harmony export */   TIP_PLAY: () => (/* binding */ TIP_PLAY),
/* harmony export */   TIP_SETTING: () => (/* binding */ TIP_SETTING),
/* harmony export */   TIP_UNFOLD: () => (/* binding */ TIP_UNFOLD)
/* harmony export */ });
const TIP_PLAY = '';
const TIP_PAUSE = '';
const TIP_SETTING = '';
const TIP_FULLSCREEN = '';
const TIP_LOOP_START = '';
const TIP_LOOP_STOP = '';
const TIP_PIP_START = '';
const TIP_PIP_STOP = '';
const TIP_FOLD = '';
const TIP_UNFOLD = '';
const TIP_DELETE = '';
const CONTROL_PLAYRATE = '';
const CONTROL_AUDIO_TRACK = '';
const CONTROL_VIDEO_TRACK = '';
const CONTROL_SUBTITLE_TRACK = '';
const CONTROL_SUBTITLE_TRACK_ADD = '';
const FOLDER_OPEN_DIR = '';
const FOLDER_OPEN_FILE = '';
const FOLDER_OPEN_URL_PLACEHOLDER = '';
const BUTTON_ADD = '';
const CHECKBOX_LIVE = '';
const LOADING_MESSAGE_OPEN_FILE = '...';
const LOADING_MESSAGE_ANALYZE_FILE = '(${mux})...';
const LOADING_MESSAGE_LOAD_AUDIO_DECODER = '(${decoder})...';
const LOADING_MESSAGE_LOAD_VIDEO_DECODER = '(${decoder})...';
const LOADING_MESSAGE_LOAD_END = ' (`)';
const LOADING_MESSAGE_LOAD_FAILED = ' ()';
const INFO_TITLE = '';
const MENU_STATS = '';
const SETTINGS_TITLE = '';
const SETTING_TAB_DECODER = '';
const SETTING_TAB_PLAY = '';
const SETTING_TAB_SUBTITLE = '';
const SETTING_TAB_VIDEO = '';
const SETTING_TAB_AUDIO = '';
const SETTING_TAB_FILTER = '';
const SETTING_TAB_KEYBOARD = '';
const SETTING_TAB_LANGUAGE = '';
const SETTING_TAB_SKIN = '';


/***/ }),

/***/ "./src/ui/avplayer/i18n/english.ts":
/*!*****************************************!*\
  !*** ./src/ui/avplayer/i18n/english.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BUTTON_ADD: () => (/* binding */ BUTTON_ADD),
/* harmony export */   CHECKBOX_LIVE: () => (/* binding */ CHECKBOX_LIVE),
/* harmony export */   CONTROL_AUDIO_TRACK: () => (/* binding */ CONTROL_AUDIO_TRACK),
/* harmony export */   CONTROL_PLAYRATE: () => (/* binding */ CONTROL_PLAYRATE),
/* harmony export */   CONTROL_SUBTITLE_TRACK: () => (/* binding */ CONTROL_SUBTITLE_TRACK),
/* harmony export */   CONTROL_SUBTITLE_TRACK_ADD: () => (/* binding */ CONTROL_SUBTITLE_TRACK_ADD),
/* harmony export */   CONTROL_VIDEO_TRACK: () => (/* binding */ CONTROL_VIDEO_TRACK),
/* harmony export */   FOLDER_OPEN_DIR: () => (/* binding */ FOLDER_OPEN_DIR),
/* harmony export */   FOLDER_OPEN_FILE: () => (/* binding */ FOLDER_OPEN_FILE),
/* harmony export */   FOLDER_OPEN_URL_PLACEHOLDER: () => (/* binding */ FOLDER_OPEN_URL_PLACEHOLDER),
/* harmony export */   INFO_TITLE: () => (/* binding */ INFO_TITLE),
/* harmony export */   LOADING_MESSAGE_ANALYZE_FILE: () => (/* binding */ LOADING_MESSAGE_ANALYZE_FILE),
/* harmony export */   LOADING_MESSAGE_LOAD_AUDIO_DECODER: () => (/* binding */ LOADING_MESSAGE_LOAD_AUDIO_DECODER),
/* harmony export */   LOADING_MESSAGE_LOAD_END: () => (/* binding */ LOADING_MESSAGE_LOAD_END),
/* harmony export */   LOADING_MESSAGE_LOAD_FAILED: () => (/* binding */ LOADING_MESSAGE_LOAD_FAILED),
/* harmony export */   LOADING_MESSAGE_LOAD_VIDEO_DECODER: () => (/* binding */ LOADING_MESSAGE_LOAD_VIDEO_DECODER),
/* harmony export */   LOADING_MESSAGE_OPEN_FILE: () => (/* binding */ LOADING_MESSAGE_OPEN_FILE),
/* harmony export */   MENU_STATS: () => (/* binding */ MENU_STATS),
/* harmony export */   SETTINGS_TITLE: () => (/* binding */ SETTINGS_TITLE),
/* harmony export */   SETTING_TAB_AUDIO: () => (/* binding */ SETTING_TAB_AUDIO),
/* harmony export */   SETTING_TAB_DECODER: () => (/* binding */ SETTING_TAB_DECODER),
/* harmony export */   SETTING_TAB_FILTER: () => (/* binding */ SETTING_TAB_FILTER),
/* harmony export */   SETTING_TAB_KEYBOARD: () => (/* binding */ SETTING_TAB_KEYBOARD),
/* harmony export */   SETTING_TAB_LANGUAGE: () => (/* binding */ SETTING_TAB_LANGUAGE),
/* harmony export */   SETTING_TAB_PLAY: () => (/* binding */ SETTING_TAB_PLAY),
/* harmony export */   SETTING_TAB_SKIN: () => (/* binding */ SETTING_TAB_SKIN),
/* harmony export */   SETTING_TAB_SUBTITLE: () => (/* binding */ SETTING_TAB_SUBTITLE),
/* harmony export */   SETTING_TAB_VIDEO: () => (/* binding */ SETTING_TAB_VIDEO),
/* harmony export */   TIP_DELETE: () => (/* binding */ TIP_DELETE),
/* harmony export */   TIP_FOLD: () => (/* binding */ TIP_FOLD),
/* harmony export */   TIP_FULLSCREEN: () => (/* binding */ TIP_FULLSCREEN),
/* harmony export */   TIP_LOOP_START: () => (/* binding */ TIP_LOOP_START),
/* harmony export */   TIP_LOOP_STOP: () => (/* binding */ TIP_LOOP_STOP),
/* harmony export */   TIP_PAUSE: () => (/* binding */ TIP_PAUSE),
/* harmony export */   TIP_PIP: () => (/* binding */ TIP_PIP),
/* harmony export */   TIP_PLAY: () => (/* binding */ TIP_PLAY),
/* harmony export */   TIP_SETTING: () => (/* binding */ TIP_SETTING),
/* harmony export */   TIP_UNFOLD: () => (/* binding */ TIP_UNFOLD)
/* harmony export */ });
const TIP_PLAY = 'Play';
const TIP_PAUSE = 'Pause';
const TIP_SETTING = 'Settings';
const TIP_FULLSCREEN = 'Fullscreen';
const TIP_LOOP_START = 'Open Loop';
const TIP_LOOP_STOP = 'Close Loop';
const TIP_PIP = 'Picture In Picture';
const TIP_FOLD = 'Fold';
const TIP_UNFOLD = 'Unfold';
const TIP_DELETE = 'Delete';
const CONTROL_PLAYRATE = 'Speed';
const CONTROL_AUDIO_TRACK = 'Audio';
const CONTROL_VIDEO_TRACK = 'Video';
const CONTROL_SUBTITLE_TRACK = 'Subtitle';
const CONTROL_SUBTITLE_TRACK_ADD = 'Add';
const FOLDER_OPEN_DIR = 'Open Fold';
const FOLDER_OPEN_FILE = 'Open File';
const FOLDER_OPEN_URL_PLACEHOLDER = 'Input Url';
const BUTTON_ADD = 'Add';
const CHECKBOX_LIVE = 'Live';
const LOADING_MESSAGE_OPEN_FILE = 'opening source...';
const LOADING_MESSAGE_ANALYZE_FILE = 'analyzing source(${mux})...';
const LOADING_MESSAGE_LOAD_AUDIO_DECODER = 'loading audio decoder(${decoder})...';
const LOADING_MESSAGE_LOAD_VIDEO_DECODER = 'loading video decoder(${decoder})...';
const LOADING_MESSAGE_LOAD_END = 'readied (`)';
const LOADING_MESSAGE_LOAD_FAILED = 'failed ()';
const INFO_TITLE = 'Stats Info';
const MENU_STATS = 'Source Stats Info';
const SETTINGS_TITLE = 'Settings';
const SETTING_TAB_DECODER = 'Decoder';
const SETTING_TAB_PLAY = 'Play';
const SETTING_TAB_SUBTITLE = 'Subtitle';
const SETTING_TAB_VIDEO = 'Picture';
const SETTING_TAB_AUDIO = 'Sound';
const SETTING_TAB_FILTER = 'Filter';
const SETTING_TAB_KEYBOARD = 'Shortcut';
const SETTING_TAB_LANGUAGE = 'Language';
const SETTING_TAB_SKIN = 'Skin';


/***/ }),

/***/ "./src/ui/avplayer/i18n/getLanguage.ts":
/*!*********************************************!*\
  !*** ./src/ui/avplayer/i18n/getLanguage.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getLanguage)
/* harmony export */ });
/* harmony import */ var _chinese__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chinese */ "./src/ui/avplayer/i18n/chinese.ts");
/* harmony import */ var _english__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./english */ "./src/ui/avplayer/i18n/english.ts");
/* harmony import */ var common_util_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/url */ "./src/common/util/url.ts");
/* harmony import */ var _util_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/storage */ "./src/ui/util/storage.ts");




const map = {
    ["chinese" /* Language.CHINESE */]: 1,
    ["chinese_traditional" /* Language.CHINESE_TRADITIONAL */]: 1,
    ["english" /* Language.ENGLISH */]: 1,
};
function getSystemLanguage() {
    // @ts-ignore
    return navigator.systemLanguage || navigator.browserLanguage || navigator.userLanguage || navigator.language;
}
function getLanguage() {
    let language = common_util_url__WEBPACK_IMPORTED_MODULE_2__.parseQuery(location.search).language;
    if (!map[language]) {
        language = _util_storage__WEBPACK_IMPORTED_MODULE_3__.get(_util_storage__WEBPACK_IMPORTED_MODULE_3__.LOCAL_STORAGE_KEY_SYSTEM_LANGUAGE);
        if (!language) {
            language = getSystemLanguage().toLowerCase();
            if (language.indexOf('en') > -1) {
                language = "english" /* Language.ENGLISH */;
            }
            else if (language.indexOf('zh-hk') > -1 || language.indexOf('zh-tw') > -1) {
                language = "chinese_traditional" /* Language.CHINESE_TRADITIONAL */;
            }
            else if (language.indexOf('zh') > -1) {
                language = "chinese" /* Language.CHINESE */;
            }
            else {
                language = "chinese" /* Language.CHINESE */;
            }
        }
        _util_storage__WEBPACK_IMPORTED_MODULE_3__.set(_util_storage__WEBPACK_IMPORTED_MODULE_3__.LOCAL_STORAGE_KEY_SYSTEM_LANGUAGE, language);
    }
    switch (language) {
        case "chinese" /* Language.CHINESE */:
            return _chinese__WEBPACK_IMPORTED_MODULE_0__;
        case "english" /* Language.ENGLISH */:
            return _english__WEBPACK_IMPORTED_MODULE_1__;
        default:
            return _chinese__WEBPACK_IMPORTED_MODULE_0__;
    }
}


/***/ }),

/***/ "./src/ui/components/slider/Slider.ts":
/*!********************************************!*\
  !*** ./src/ui/components/slider/Slider.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Slider_hbs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Slider.hbs */ "./src/ui/components/slider/Slider.hbs");
/* harmony import */ var _Slider_hbs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Slider_hbs__WEBPACK_IMPORTED_MODULE_0__);

const Slider = {
    name: 'slider',
    model: 'value',
    template: (_Slider_hbs__WEBPACK_IMPORTED_MODULE_0___default()),
    propTypes: {
        value: {
            type: 'number',
            required: true
        },
        max: {
            type: 'number',
            value: 100
        },
        min: {
            type: 'number',
            value: 0
        },
        step: {
            type: 'number',
            value: 1
        },
        direction: {
            // 'vertical' | 'horizontal'
            type: 'string',
            value: 'vertical'
        }
    },
    data: function () {
        return {
            startX: 0,
            startY: 0,
            start: false
        };
    },
    computed: {
        offset: function () {
            return this.get('direction') === 'vertical' ? `top: ${(1 - this.get('value') / this.get('max')) * 100}%` : `right: ${(1 - this.get('value') / this.get('max')) * 100}%`;
        }
    },
    methods: {
        mousedown: function (event) {
            this.set('startX', event.originalEvent.screenX);
            this.set('startY', event.originalEvent.screenY);
            this.set('start', true);
        },
        mousemove: function (event) {
            if (!this.get('start')) {
                return;
            }
            const pageX = this.get('startX');
            const pageY = this.get('startY');
            let diff = 0;
            const direction = this.get('direction');
            const step = this.get('step');
            if (direction === 'vertical') {
                const total = this.$refs['slider'].offsetHeight;
                diff = -(event.screenY - pageY) / total * this.get('max') * step;
            }
            else if (direction === 'horizontal') {
                const total = this.$refs['slider'].offsetWidth;
                diff = (event.screenX - pageX) / total * this.get('max') * step;
            }
            let value = this.get('value') + diff;
            if (value < this.get('min')) {
                value = this.get('min');
            }
            if (value > this.get('max')) {
                value = this.get('max');
            }
            this.set('value', Math.round(value));
            this.set('startX', event.screenX);
            this.set('startY', event.screenY);
        },
        mouseup: function () {
            if (this.get('start')) {
                this.set('start', false);
            }
        }
    },
    afterMount() {
        this.onmouseup = (event) => {
            this.mouseup();
        };
        this.onmousemove = (event) => {
            this.mousemove(event);
        };
        document.addEventListener('mouseup', this.onmouseup);
        document.addEventListener('mousemove', this.onmousemove);
    },
    beforeDestroy() {
        document.removeEventListener('mouseup', this.onmouseup);
        document.removeEventListener('mousemove', this.onmousemove);
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Slider);


/***/ }),

/***/ "./src/ui/util/db.ts":
/*!***************************!*\
  !*** ./src/ui/util/db.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KEY_FOLDER_ROOT: () => (/* binding */ KEY_FOLDER_ROOT),
/* harmony export */   load: () => (/* binding */ load),
/* harmony export */   store: () => (/* binding */ store)
/* harmony export */ });
const KEY_FOLDER_ROOT = 'libmedia_folder_root';
const DB_NAME = 'libmedia_db';
const TABLE = 'store';
let db;
let openPromise;
async function open() {
    openPromise = new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, 1);
        request.onupgradeneeded = function (event) {
            // @ts-ignore
            db = event.target.result;
            if (!db.objectStoreNames.contains(TABLE)) {
                const objectStore = db.createObjectStore(TABLE, { keyPath: 'id', autoIncrement: true });
                objectStore.createIndex('name', 'name', { unique: false });
            }
        };
        request.onsuccess = function (event) {
            // @ts-ignore
            db = event.target.result;
            resolve();
        };
        request.onerror = function (event) {
            reject(event);
        };
    });
    return openPromise;
}
async function load(name) {
    if (!db) {
        if (openPromise) {
            await openPromise;
        }
        else {
            await open();
        }
    }
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([TABLE], 'readwrite');
        const objectStore = transaction.objectStore(TABLE);
        const index = objectStore.index('name');
        const request = index.get(name);
        request.onsuccess = function (event) {
            resolve(event.target.result?.data);
        };
        request.onerror = function (event) {
            reject(event);
        };
    });
}
async function store(name, data) {
    if (!db) {
        if (openPromise) {
            await openPromise;
        }
        else {
            await open();
        }
    }
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([TABLE], 'readwrite');
        const objectStore = transaction.objectStore(TABLE);
        const index = objectStore.index('name');
        const request = index.get(name);
        request.onsuccess = function (event) {
            if (event.target.result) {
                const request = objectStore.put({
                    id: event.target.result.id,
                    name,
                    data
                });
                request.onsuccess = function () {
                    resolve();
                };
                request.onerror = function (event) {
                    reject(event);
                };
            }
            else {
                const request = objectStore.put({
                    name,
                    data
                });
                request.onsuccess = function () {
                    resolve();
                };
                request.onerror = function (event) {
                    reject(event);
                };
            }
        };
        request.onerror = function (event) {
            reject(event);
        };
    });
}


/***/ }),

/***/ "./src/ui/util/outside.ts":
/*!********************************!*\
  !*** ./src/ui/util/outside.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const outside = {
    on: function (element, listener, addEventListener) {
        setTimeout(function () {
            document.addEventListener('click', listener.onOutside = function (event) {
                let target = event.target;
                //  DOM 
                if (target.parentNode && !element.contains(target)) {
                    listener(event);
                }
            });
        }, 0);
    },
    off: function (element, listener, removeEventListener) {
        if (listener.onOutside) {
            document.removeEventListener('click', listener.onOutside);
            listener.onOutside = null;
        }
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (outside);


/***/ }),

/***/ "./src/ui/util/storage.ts":
/*!********************************!*\
  !*** ./src/ui/util/storage.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LOCAL_STORAGE_KEY_LOOP: () => (/* binding */ LOCAL_STORAGE_KEY_LOOP),
/* harmony export */   LOCAL_STORAGE_KEY_PLAY_RATE: () => (/* binding */ LOCAL_STORAGE_KEY_PLAY_RATE),
/* harmony export */   LOCAL_STORAGE_KEY_SYSTEM_LANGUAGE: () => (/* binding */ LOCAL_STORAGE_KEY_SYSTEM_LANGUAGE),
/* harmony export */   LOCAL_STORAGE_KEY_VOLUME: () => (/* binding */ LOCAL_STORAGE_KEY_VOLUME),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   set: () => (/* binding */ set)
/* harmony export */ });
/* unused harmony export remove */
const LOCAL_STORAGE_KEY_VOLUME = 'libmedia_volume';
const LOCAL_STORAGE_KEY_SYSTEM_LANGUAGE = 'libmedia_system_language';
const LOCAL_STORAGE_KEY_PLAY_RATE = 'libmedia_play_rate';
const LOCAL_STORAGE_KEY_LOOP = 'libmedia_play_loop';
function set(key, value) {
    localStorage.setItem(key, value);
}
function get(key, defaultValue) {
    const value = localStorage.getItem(key);
    return value == undefined ? defaultValue : value;
}
function remove(key) {
    localStorage.removeItem(key);
}


/***/ }),

/***/ "./node_modules/yox/dist/standard/runtime/yox.js":
/*!*******************************************************!*\
  !*** ./node_modules/yox/dist/standard/runtime/yox.js ***!
  \*******************************************************/
/***/ (function(module) {

/**
 * yox.js v1.0.0-alpha.408
 * (c) 2017-2023 musicode
 * Released under the MIT License.
 */

(function (global, factory) {
   true ? module.exports = factory() :
  0;
}(this, (function () { 'use strict';

  var VNODE_TYPE_TEXT = 1;
  var VNODE_TYPE_COMMENT = 2;
  var VNODE_TYPE_ELEMENT = 3;
  var VNODE_TYPE_FRAGMENT = 5;
  var VNODE_TYPE_SLOT = 7;
  var DIRECTIVE_MODEL = 'model';
  var DIRECTIVE_CUSTOM = 'o';
  var MODEL_PROP_DEFAULT = 'value';
  var HOOK_BEFORE_CREATE = 'beforeCreate';
  var HOOK_AFTER_CREATE = 'afterCreate';
  var HOOK_BEFORE_RENDER = 'beforeRender';
  var HOOK_AFTER_RENDER = 'afterRender';
  var HOOK_BEFORE_MOUNT = 'beforeMount';
  var HOOK_AFTER_MOUNT = 'afterMount';
  var HOOK_BEFORE_UPDATE = 'beforeUpdate';
  var HOOK_AFTER_UPDATE = 'afterUpdate';
  var HOOK_BEFORE_DESTROY = 'beforeDestroy';
  var HOOK_AFTER_DESTROY = 'afterDestroy';
  var HOOK_BEFORE_PROPS_UPDATE = 'beforePropsUpdate';

  /**
   * 
   */
  var TRUE = true;
  var FALSE = false;
  var NULL = null;
  var UNDEFINED = void 0;
  var RAW_TRUE = 'true';
  var RAW_FALSE = 'false';
  var RAW_UNDEFINED = 'undefined';
  var RAW_FILTER = 'filter';
  var RAW_COMPONENT = 'component';
  var RAW_DIRECTIVE = 'directive';
  var RAW_TRANSITION = 'transition';
  var RAW_FUNCTION = 'function';
  var RAW_LENGTH = 'length';
  var RAW_WILDCARD = '*';
  var RAW_DOT = '.';
  var NODE_TYPE_ELEMENT = 1;
  var NODE_TYPE_TEXT = 3;
  var NODE_TYPE_COMMENT = 8;
  /**
   * Single instance for window in browser
   */
  var WINDOW = typeof window !== RAW_UNDEFINED ? window : UNDEFINED;
  /**
   * Single instance for document in browser
   */
  var DOCUMENT = typeof document !== RAW_UNDEFINED ? document : UNDEFINED;
  /**
   * tap 
   *
   *  pc  click  touchend 
   *
   *  on-tap="handler" 
   *
   *  Yox.dom.addSpecialEvent 
   *
   */
  var EVENT_TAP = 'tap';
  /**
   * 
   */
  var EVENT_CLICK = 'click';
  /**
   * 
   */
  var EVENT_INPUT = 'input';
  /**
   * 
   */
  var EVENT_CHANGE = 'change';
  /**
   * model
   */
  var EVENT_MODEL = 'model';
  /**
   * Single instance for noop function
   */
  var EMPTY_FUNCTION = function () {
      /** yox */
  };
  /**
   *  `a || EMPTY_OBJECT` 
   */
  var EMPTY_OBJECT = Object.freeze({});
  /**
   * 
   */
  var EMPTY_ARRAY = Object.freeze([]);
  /**
   * 
   */
  var EMPTY_STRING = '';
  /**
   * 
   */
  var LOG_LEVEL_DEBUG = 1;
  var LOG_LEVEL_INFO = 2;
  var LOG_LEVEL_WARN = 3;
  var LOG_LEVEL_ERROR = 4;
  var LOG_LEVEL_FATAL = 5;
  /**
   * empty function 
   *  INFO DEBUG 
   */
  var LOG_LEVEL_DEFAULT = /yox/.test(EMPTY_FUNCTION.toString()) ? LOG_LEVEL_INFO : LOG_LEVEL_WARN;
  /**
   * 
   */
  var PUBLIC_CONFIG = {
      leftDelimiter: '{',
      rightDelimiter: '}',
      uglifyCompiled: FALSE,
      minifyCompiled: FALSE,
      logLevel: LOG_LEVEL_DEFAULT,
  };

  /**
   * Check if value is a function.
   *
   * @param value
   * @return
   */
  function func(value) {
      return typeof value === RAW_FUNCTION;
  }
  /**
   * Check if value is an array.
   *
   * @param value
   * @return
   */
  function array$1(value) {
      return Array.isArray(value);
  }
  /**
   * Check if value is an object.
   *
   * @param value
   * @return
   */
  function object$1(value) {
      //  IE  null  object
      return value !== NULL && typeof value === 'object';
  }
  /**
   * Check if value is a string.
   *
   * @param value
   * @return
   */
  function string$1(value) {
      return typeof value === 'string';
  }
  /**
   * Check if value is a number.
   *
   * @param value
   * @return
   */
  function number(value) {
      return typeof value === 'number' && !isNaN(value);
  }
  /**
   * Check if value is boolean.
   *
   * @param value
   * @return
   */
  function boolean(value) {
      return value === TRUE || value === FALSE;
  }
  /**
   * Check if value is numeric.
   *
   * @param value
   * @return
   */
  function numeric(value) {
      return !isNaN(value - parseFloat(value));
  }

  var is = /*#__PURE__*/Object.freeze({
    __proto__: null,
    func: func,
    array: array$1,
    object: object$1,
    string: string$1,
    number: number,
    boolean: boolean,
    numeric: numeric
  });

  /**
   * 
   *
   * @param fn 
   * @param context  this 
   * @param args 
   * @return 
   */
  function execute (fn, context, args) {
      return array$1(args)
          ? fn.apply(context, args)
          : context !== UNDEFINED
              ? fn.call(context, args)
              : args !== UNDEFINED
                  ? fn(args)
                  : fn();
  }

  var CustomEvent = function(type, originalEvent) {
      // 
      //  Emitter  true
      // CustomEvent 
      this.type = type;
      this.phase = CustomEvent.PHASE_CURRENT;
      if (originalEvent) {
          this.originalEvent = originalEvent;
      }
  };
  CustomEvent.is = function (event) {
      return event instanceof CustomEvent;
  };
  /**
   * 
   */
  CustomEvent.prototype.preventDefault = function () {
      var instance = this;
      if (!instance.isPrevented) {
          var originalEvent = instance.originalEvent;
          if (originalEvent) {
              originalEvent.preventDefault();
          }
          instance.isPrevented = TRUE;
      }
      return instance;
  };
  /**
   * 
   */
  CustomEvent.prototype.stopPropagation = function () {
      var instance = this;
      if (!instance.isStoped) {
          var originalEvent = instance.originalEvent;
          if (originalEvent) {
              originalEvent.stopPropagation();
          }
          instance.isStoped = TRUE;
      }
      return instance;
  };
  CustomEvent.prototype.prevent = function () {
      return this.preventDefault();
  };
  CustomEvent.prototype.stop = function () {
      return this.stopPropagation();
  };
  CustomEvent.PHASE_CURRENT = 0;
  CustomEvent.PHASE_UPWARD = 1;
  CustomEvent.PHASE_DOWNWARD = -1;

  /**
   * 
   *
   * @param array
   * @param callback  false 
   * @param reversed 
   */
  function each$2(array, callback, reversed) {
      var length = array.length;
      if (length) {
          if (reversed) {
              for (var i = length - 1; i >= 0; i--) {
                  if (callback(array[i], i) === FALSE) {
                      break;
                  }
              }
          }
          else {
              for (var i$1 = 0; i$1 < length; i$1++) {
                  if (callback(array[i$1], i$1) === FALSE) {
                      break;
                  }
              }
          }
      }
  }
  function nativePush(array, item) {
      array[array.length] = item;
  }
  function nativeUnshift(array, item) {
      array.unshift(item);
  }
  /**
   * 
   *
   * @param array
   * @param value
   * @param action
   */
  function addItem(array, value, action) {
      if (array$1(value)) {
          each$2(value, function (item) {
              action(array, item);
          });
      }
      else {
          action(array, value);
      }
  }
  /**
   * 
   *
   * @param array
   * @param target
   */
  function push(array, target) {
      addItem(array, target, nativePush);
  }
  /**
   * 
   *
   * @param array
   * @param target
   */
  function unshift(array, target) {
      addItem(array, target, nativeUnshift);
  }
  /**
   * 
   *
   * @param array 
   * @param target 
   * @param strict 
   * @return  -1
   */
  function indexOf$1(array, target, strict) {
      var result = -1;
      each$2(array, function (item, index) {
          if (strict === FALSE ? item == target : item === target) {
              result = index;
              return FALSE;
          }
      });
      return result;
  }
  /**
   * 
   *
   * @param array 
   * @return
   */
  function last(array) {
      var length = array.length;
      if (length > 0) {
          return array[length - 1];
      }
  }
  /**
   * 
   *
   * ...
   *
   * @param array 
   * @return 
   */
  function pop(array) {
      var length = array.length;
      if (length > 0) {
          return array.pop();
      }
  }
  /**
   * 
   *
   * @param array 
   * @param item 
   * @param strict 
   * @return 
   */
  function remove$1(array, target, strict) {
      var result = 0;
      each$2(array, function (item, index) {
          if (strict === FALSE ? item == target : item === target) {
              array.splice(index, 1);
              result++;
          }
      }, TRUE);
      return result;
  }
  /**
   *  item
   *
   * @param array 
   * @param target 
   * @param strict 
   * @return
   */
  function has$2(array, target, strict) {
      return indexOf$1(array, target, strict) >= 0;
  }
  /**
   * 
   *
   * @param array 
   * @return
   */
  function toArray(array) {
      return array$1(array)
          ? array
          : execute(EMPTY_ARRAY.slice, array);
  }
  /**
   * 
   *
   * @param array 
   * @param key 
   * @param value
   * @return
   */
  function toObject(array, key, value) {
      var result = {};
      each$2(array, function (item) {
          result[key ? item[key] : item] = value || item;
      });
      return result;
  }
  /**
   * 
   *
   * @param array
   * @param separator
   * @return
   */
  function join$1(array, separator) {
      return array.join(separator);
  }
  /**
   *  0 
   *
   * @param array
   * @return
   */
  function falsy$2(array) {
      return !array$1(array) || !array.length;
  }

  var array = /*#__PURE__*/Object.freeze({
    __proto__: null,
    each: each$2,
    push: push,
    unshift: unshift,
    indexOf: indexOf$1,
    last: last,
    pop: pop,
    remove: remove$1,
    has: has$2,
    toArray: toArray,
    toObject: toObject,
    join: join$1,
    falsy: falsy$2
  });

  function toString (target, defaultValue) {
      return target != NULL && target.toString
          ? target.toString()
          : defaultValue !== UNDEFINED
              ? defaultValue
              : EMPTY_STRING;
  }

  function isNative (target) {
      return func(target)
          && toString(target).indexOf('[native code]') >= 0;
  }

  var createPureObject = function () {
      var obj = Object.create(NULL);
      return {
          get: function(key) {
              return obj[key];
          },
          set: function(key, value) {
              obj[key] = value;
          },
          has: function(key) {
              return key in obj;
          },
          keys: function() {
              return Object.keys(obj);
          }
      };
  };

  /**
   * 
   *
   * @param fn 
   * @return 
   */
  function createOneKeyCache(fn) {
      var cache = createPureObject();
      return function (key) {
          var hit = cache.get(key);
          if (hit !== UNDEFINED) {
              return hit;
          }
          var value = fn(key);
          cache.set(key, value);
          return value;
      };
  }
  /**
   * 
   *
   * @param fn 
   * @return 
   */
  function createTwoKeyCache(fn) {
      var cache = createPureObject();
      return function (key1, key2) {
          var hit1 = cache.get(key1);
          if (hit1) {
              var hit2 = hit1.get(key2);
              if (hit2) {
                  return hit2;
              }
          }
          else {
              hit1 = createPureObject();
              cache.set(key1, hit1);
          }
          var value = fn(key1, key2);
          hit1.set(key2, value);
          return value;
      };
  }

  var camelizePattern = /-([a-z])/gi, hyphenatePattern = /\B([A-Z])/g, capitalizePattern = /^[a-z]/;
  /**
   * 
   *
   * @param str
   * @return 
   */
  var camelize = createOneKeyCache(function (str) {
      return str.replace(camelizePattern, function (_, $1) {
          return upper($1);
      });
  });
  /**
   * 
   *
   * @param str
   * @return 
   */
  var hyphenate = createOneKeyCache(function (str) {
      return str.replace(hyphenatePattern, function (_, $1) {
          return '-' + lower($1);
      });
  });
  /**
   * 
   *
   * @param str
   * @return
   */
  var capitalize = createOneKeyCache(function (str) {
      return str.replace(capitalizePattern, upper);
  });
  /**
   * 
   *
   * @param str
   * @param count 
   * @return
   */
  function repeat(str, count) {
      return join$1(new Array(count + 1), str);
  }
  /**
   * 
   *
   * @param str
   * @return 
   */
  function trim(str) {
      return falsy$1(str)
          ? EMPTY_STRING
          : str.trim();
  }
  /**
   * 
   *
   * @param str
   * @param start
   * @param end
   * @return
   */
  function slice(str, start, end) {
      return number(end)
          ? start === end
              ? EMPTY_STRING
              : str.slice(start, end)
          : str.slice(start);
  }
  /**
   * 
   *
   * @param str
   * @param part
   * @param start
   * @return
   */
  function indexOf(str, part, start) {
      return str.indexOf(part, start !== UNDEFINED ? start : 0);
  }
  /**
   * 
   *
   * @param str
   * @param part
   * @param end
   * @return
   */
  function lastIndexOf(str, part, end) {
      return str.lastIndexOf(part, end !== UNDEFINED ? end : str.length);
  }
  /**
   * str  part 
   *
   * @param str
   * @param part
   * @return
   */
  function startsWith(str, part) {
      return indexOf(str, part) === 0;
  }
  /**
   * str  part 
   *
   * @param str
   * @param part
   * @return
   */
  function endsWith(str, part) {
      var offset = str.length - part.length;
      return offset >= 0 && lastIndexOf(str, part) === offset;
  }
  /**
   * 
   */
  function charAt(str, index) {
      return str.charAt(index || 0);
  }
  /**
   * 
   */
  function codeAt(str, index) {
      return str.charCodeAt(index || 0);
  }
  /**
   * 
   */
  function upper(str) {
      return str.toUpperCase();
  }
  /**
   * 
   */
  function lower(str) {
      return str.toLowerCase();
  }
  /**
   * str  part
   *
   * @param str
   * @param part
   * @return 
   */
  function has$1(str, part) {
      return indexOf(str, part) >= 0;
  }
  /**
   * str  value  true  map
   *
   * @param str
   * @param separator
   */
  function toMap(str, separator) {
      var map = Object.create(NULL);
      each$2(str.split(separator || ','), function (item) {
          map[item] = TRUE;
      });
      return map;
  }
  /**
   *  0 
   *
   * @param str
   * @return
   */
  function falsy$1(str) {
      return !string$1(str) || !str.length;
  }

  var string = /*#__PURE__*/Object.freeze({
    __proto__: null,
    camelize: camelize,
    hyphenate: hyphenate,
    capitalize: capitalize,
    repeat: repeat,
    trim: trim,
    slice: slice,
    indexOf: indexOf,
    lastIndexOf: lastIndexOf,
    startsWith: startsWith,
    endsWith: endsWith,
    charAt: charAt,
    codeAt: codeAt,
    upper: upper,
    lower: lower,
    has: has$1,
    toMap: toMap,
    falsy: falsy$1
  });

  var dotPattern = /\./g, asteriskPattern = /\*/g, doubleAsteriskPattern = /\*\*/g;
  /**
   *  keypath  prefix  -1
   *
   * @param keypath
   * @param prefix
   * @return
   */
  var match = createTwoKeyCache(function (keypath, prefix) {
      if (keypath === prefix) {
          return prefix.length;
      }
      prefix += RAW_DOT;
      return startsWith(keypath, prefix)
          ? prefix.length
          : -1;
  });
  var getKeypathTokens = createOneKeyCache(function (keypath) {
      return indexOf(keypath, RAW_DOT) < 0
          ? [keypath]
          : keypath.split(RAW_DOT);
  });
  /**
   *  keypath 
   *
   * @param keypath
   * @param callback  false 
   */
  function each$1(keypath, callback) {
      var tokens = string$1(keypath) ? getKeypathTokens(keypath) : keypath;
      for (var i = 0, lastIndex = tokens.length - 1; i <= lastIndex; i++) {
          if (callback(tokens[i], i, lastIndex) === FALSE) {
              break;
          }
      }
  }
  /**
   *  keypath 
   *
   * @param keypath1
   * @param keypath2
   */
  var join = createTwoKeyCache(function (keypath1, keypath2) {
      return keypath1 && keypath2
          ? keypath1 + RAW_DOT + keypath2
          : keypath1 || keypath2;
  });
  /**
   * 
   *
   * @param keypath
   */
  var isFuzzy = createOneKeyCache(function (keypath) {
      return has$1(keypath, RAW_WILDCARD);
  });
  var getFuzzyPattern = createOneKeyCache(function (pattern) {
      return new RegExp(("^" + (pattern
          .replace(dotPattern, '\\.')
          .replace(asteriskPattern, '(\\w+)')
          .replace(doubleAsteriskPattern, '([\.\\w]+?)')) + "$"));
  });
  /**
   *  keypath
   *
   * @param keypath
   * @param pattern
   */
  var matchFuzzy = createTwoKeyCache(function (keypath, pattern) {
      var result = keypath.match(getFuzzyPattern(pattern));
      return result
          ? result[1]
          : UNDEFINED;
  });

  /**
   *  value holder
   */
  var holder = {
      value: UNDEFINED
  };

  /**
   *  key 
   *
   * @param object
   * @return
   */
  function keys(object) {
      return Object.keys(object);
  }
  /**
   * 
   *
   * @param object
   * @param callback  false 
   */
  function each(object, callback) {
      for (var key in object) {
          if (callback(object[key], key) === FALSE) {
              break;
          }
      }
  }
  /**
   * 
   *
   * @return
   */
  function extend(original, object) {
      each(object, function (value, key) {
          original[key] = value;
      });
      return original;
  }
  /**
   * 
   *
   * @return
   */
  function merge(object1, object2) {
      return object1 && object2
          ? extend(extend({}, object1), object2)
          : object1 || object2;
  }
  /**
   * 
   *
   * @param object
   * @param deep 
   * @return
   */
  function copy(object, deep) {
      var result = object;
      if (array$1(object)) {
          if (deep) {
              result = [];
              each$2(object, function (item, index) {
                  result[index] = copy(item, deep);
              });
          }
          else {
              result = object.slice();
          }
      }
      else if (object$1(object)) {
          result = {};
          each(object, function (value, key) {
              result[key] = deep ? copy(value, deep) : value;
          });
      }
      return result;
  }
  function getCallback(value) {
      // 
      return func(value.get)
          ? value.get()
          : value;
  }
  /**
   *  keypath
   *
   * 
   *
   * @param object
   * @param keypath
   * @return
   */
  function get(object, keypath, callback) {
      var result = object;
      each$1(keypath, function (key, index, lastIndex) {
          if (result != NULL) {
              // 
              var value = result[key], 
              // 
              //  hasValue
              hasValue = value !== UNDEFINED;
              //  hasValue 
              //  value 
              if (value) {
                  // 
                  value = (callback || getCallback)(value);
              }
              if (index === lastIndex) {
                  if (hasValue) {
                      holder.value = value;
                      result = holder;
                  }
                  else {
                      result = UNDEFINED;
                  }
              }
              else {
                  result = value;
              }
          }
          else {
              result = UNDEFINED;
              return FALSE;
          }
      });
      return result;
  }
  /**
   * 
   *
   * @param object
   * @param keypath
   * @param value
   * @param autofill 
   */
  function set(object, keypath, value, autofill) {
      var next = object;
      each$1(keypath, function (key, index, lastIndex) {
          if (index === lastIndex) {
              next[key] = value;
          }
          else if (next[key]) {
              next = next[key];
          }
          else if (autofill) {
              next = next[key] = {};
          }
          else {
              return FALSE;
          }
      });
  }
  /**
   *  key
   *
   * @param object
   * @param key
   * @return
   */
  function has(object, key) {
      //  hasOwnProperty
      return object[key] !== UNDEFINED;
  }
  /**
   * 
   *
   * @param object
   * @return
   */
  function falsy(object) {
      return !object$1(object)
          || array$1(object)
          || !keys(object).length;
  }

  var object = /*#__PURE__*/Object.freeze({
    __proto__: null,
    keys: keys,
    each: each,
    extend: extend,
    merge: merge,
    copy: copy,
    get: get,
    set: set,
    has: has,
    falsy: falsy
  });

  /**
   * 
   */
  var DEBUG = LOG_LEVEL_DEBUG;
  var INFO = LOG_LEVEL_INFO;
  var WARN = LOG_LEVEL_WARN;
  var ERROR = LOG_LEVEL_ERROR;
  var FATAL = LOG_LEVEL_FATAL;
  /**
   * 
   */
  var nativeConsole = typeof console !== RAW_UNDEFINED ? console : NULL, 
  /**
   * console 
   * ie  edge  console.log 
   */
  stylePrefix = WINDOW && /edge|msie|trident/i.test(WINDOW.navigator.userAgent)
      ? EMPTY_STRING
      : '%c', 
  /**
   * 
   */
  printLog = nativeConsole
      ? stylePrefix
          ? function (tag, msg, style) {
              nativeConsole.log(stylePrefix + tag, style, msg);
          }
          : function (tag, msg) {
              nativeConsole.log(tag, msg);
          }
      : EMPTY_FUNCTION;
  /**
   * 
   */
  function getLogLevel() {
      var ref = PUBLIC_CONFIG;
      var logLevel = ref.logLevel;
      if (logLevel >= DEBUG && logLevel <= FATAL) {
          return logLevel;
      }
      return LOG_LEVEL_DEFAULT;
  }
  function getStyle(backgroundColor) {
      return ("background-color:" + backgroundColor + ";border-radius:12px;color:#fff;font-size:10px;padding:3px 6px;");
  }
  /**
   *  debug 
   *
   * @param msg
   */
  function debug(msg, tag) {
      if (getLogLevel() <= DEBUG) {
          printLog(tag || 'Yox debug', msg, getStyle('#999'));
      }
  }
  /**
   *  info 
   *
   * @param msg
   */
  function info(msg, tag) {
      if (getLogLevel() <= INFO) {
          printLog(tag || 'Yox info', msg, getStyle('#2db7f5'));
      }
  }
  /**
   *  warn 
   *
   * @param msg
   */
  function warn(msg, tag) {
      if (getLogLevel() <= WARN) {
          printLog(tag || 'Yox warn', msg, getStyle('#f90'));
      }
  }
  /**
   *  error 
   *
   * @param msg
   */
  function error(msg, tag) {
      if (getLogLevel() <= ERROR) {
          printLog(tag || 'Yox error', msg, getStyle('#ed4014'));
      }
  }
  /**
   * 
   *
   * @param msg
   */
  function fatal(msg, tag) {
      if (getLogLevel() <= FATAL) {
          throw new Error(("[" + (tag || 'Yox fatal') + "]: " + msg));
      }
  }

  var logger = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DEBUG: DEBUG,
    INFO: INFO,
    WARN: WARN,
    ERROR: ERROR,
    FATAL: FATAL,
    debug: debug,
    info: info,
    warn: warn,
    error: error,
    fatal: fatal
  });

  var Emitter = function(ns) {
      this.ns = ns || FALSE;
      this.listeners = {};
  };
  /**
   * 
   *
   * @param type 
   * @param args 
   * @param filter 
   */
  Emitter.prototype.fire = function (type, args, filter) {
      var instance = this, event = string$1(type) ? instance.toEvent(type) : type, list = instance.listeners[event.type], isComplete = TRUE;
      if (list) {
          // 
          list = list.slice();
          // 
          //  args  CustomEvent 
          //  (event, data)
          var customEvent = args && CustomEvent.is(args[0])
              ? args[0]
              : UNDEFINED;
          //  array.each
          for (var i = 0, length = list.length; i < length; i++) {
              var options = list[i];
              // 
              if (!matchNamespace(event.ns, options)
                  //  fire 
                  || !has$2(list, options)
                  //  filter filter  options
                  || (filter && !filter(event, args, options))) {
                  continue;
              }
              var result = execute(options.listener, options.ctx, args);
              // 
              options.num = options.num ? (options.num + 1) : 1;
              //  listener 
              if (options.num === options.max) {
                  instance.off(event.type, {
                      ns: event.ns,
                      listener: options.listener,
                  });
              }
              //  false customEvent.stop  false
              if (customEvent) {
                  if (result === FALSE) {
                      customEvent.prevent().stop();
                  }
                  else if (customEvent.isStoped) {
                      result = FALSE;
                  }
              }
              if (result === FALSE) {
                  isComplete = FALSE;
                  break;
              }
          }
      }
      return isComplete;
  };
  /**
   * 
   *
   * @param type
   * @param listener
   */
  Emitter.prototype.on = function (type, listener) {
      var instance = this, listeners = instance.listeners, options = func(listener)
          ? { listener: listener }
          : listener;
      if (object$1(options) && func(options.listener)) {
          if (!string$1(options.ns)) {
              var event = instance.toEvent(type);
              options.ns = event.ns;
              type = event.type;
          }
          push(listeners[type] || (listeners[type] = []), options);
      }
  };
  /**
   * 
   *
   * @param type
   * @param listener
   */
  Emitter.prototype.off = function (type, listener) {
      var instance = this, listeners = instance.listeners;
      if (type) {
          var filter = instance.toFilter(type, listener), each$1 = function (list, name) {
              each$2(list, function (item, index) {
                  if (matchListener(filter.listener, item) && matchNamespace(filter.ns, item)) {
                      list.splice(index, 1);
                  }
              }, TRUE);
              if (!list.length) {
                  delete listeners[name];
              }
          };
          if (filter.type) {
              if (listeners[filter.type]) {
                  each$1(listeners[filter.type], filter.type);
              }
          }
          //  type  .ns
          else if (filter.ns) {
              each(listeners, each$1);
          }
      }
      else {
          // 
          instance.listeners = {};
      }
  };
  /**
   * 
   *
   * @param type
   * @param listener
   */
  Emitter.prototype.has = function (type, listener) {
      var instance = this, listeners = instance.listeners, filter = instance.toFilter(type, listener), result = TRUE, each$1 = function (list) {
          each$2(list, function (item) {
              if (matchListener(filter.listener, item) && matchNamespace(filter.ns, item)) {
                  return result = FALSE;
              }
          });
          return result;
      };
      if (filter.type) {
          if (listeners[filter.type]) {
              each$1(listeners[filter.type]);
          }
      }
      else if (filter.ns) {
          each(listeners, each$1);
      }
      return !result;
  };
  /**
   * 
   *
   * @param type
   */
  Emitter.prototype.toEvent = function (type) {
      //  ns 
      //  event 
      var event = {
          type: type,
          ns: EMPTY_STRING,
      };
      // 
      if (this.ns) {
          var index = indexOf(type, RAW_DOT);
          if (index >= 0) {
              event.type = slice(type, 0, index);
              event.ns = slice(type, index + 1);
          }
      }
      return event;
  };
  Emitter.prototype.toFilter = function (type, listener) {
      var filter;
      if (listener) {
          filter = func(listener)
              ? { listener: listener }
              : listener;
      }
      else {
          filter = {};
      }
      if (string$1(filter.ns)) {
          filter.type = type;
      }
      else {
          var event = this.toEvent(type);
          filter.type = event.type;
          filter.ns = event.ns;
      }
      return filter;
  };
  /**
   *  options  listener
   *
   * @param listener
   * @param options
   */
  function matchListener(listener, options) {
      return listener
          ? listener === options.listener
          : TRUE;
  }
  /**
   *  options 
   *
   *  namespace  options.ns 
   *
   * 
   *
   * @param namespace
   * @param options
   */
  function matchNamespace(namespace, options) {
      var ns = options.ns;
      return ns && namespace
          ? ns === namespace
          : TRUE;
  }

  var nextTick;
  // IE (10+)  node
  if (typeof setImmediate === RAW_FUNCTION && isNative(setImmediate)) {
      nextTick = setImmediate;
  }
  //  MessageChannel  setImmediate  polyfill
  //  message  dom events 
  //  IE10+ 
  if (typeof MessageChannel === RAW_FUNCTION && isNative(MessageChannel)) {
      nextTick = function (fn) {
          var channel = new MessageChannel();
          channel.port1.onmessage = fn;
          channel.port2.postMessage(1);
      };
  }
  else {
      nextTick = setTimeout;
  }
  var nextTick$1 = nextTick;

  var shared;
  var NextTask = function(hooks) {
      var instance = this;
      instance.tasks = [];
      instance.hooks = hooks || EMPTY_OBJECT;
  };
  /**
   * 
   */
  NextTask.shared = function () {
      return shared || (shared = new NextTask());
  };
  /**
   * 
   */
  NextTask.prototype.append = function (func, context) {
      var instance = this;
          var tasks = instance.tasks;
      push(tasks, {
          fn: func,
          ctx: context
      });
      if (tasks.length === 1) {
          nextTick$1(function () {
              instance.run();
          });
      }
  };
  /**
   * 
   */
  NextTask.prototype.prepend = function (func, context) {
      var instance = this;
          var tasks = instance.tasks;
      unshift(tasks, {
          fn: func,
          ctx: context
      });
      if (tasks.length === 1) {
          nextTick$1(function () {
              instance.run();
          });
      }
  };
  /**
   * 
   */
  NextTask.prototype.clear = function () {
      this.tasks.length = 0;
  };
  /**
   * 
   */
  NextTask.prototype.run = function () {
      var instance = this;
          var tasks = instance.tasks;
          var hooks = instance.hooks;
          var length = tasks.length;
      if (length) {
          instance.tasks = [];
          if (hooks.beforeTask) {
              hooks.beforeTask();
          }
          for (var i = 0; i < length; i++) {
              execute(tasks[i].fn, tasks[i].ctx);
          }
          if (hooks.afterTask) {
              hooks.afterTask();
          }
      }
  };

  /**
   * 
   *
   * @param fn 
   * @param delay 
   * @param immediate 
   * @return 
   */
  function debounce (fn, delay, immediate) {
      var timer;
      return function () {
          if (!timer) {
              var args = toArray(arguments);
              if (immediate) {
                  execute(fn, UNDEFINED, args);
              }
              timer = setTimeout(function () {
                  timer = UNDEFINED;
                  if (!immediate) {
                      execute(fn, UNDEFINED, args);
                  }
              }, delay);
          }
      };
  }

  // vnode.data 
  var VNODE = '$vnode';
  var LOADING = '$loading';
  var LEAVING = '$leaving';
  var MODEL_CONTROL = '$model_control';
  var MODEL_DESTROY = '$model_destroy';
  var EVENT_DESTROY = '$event_destroy';
  var DIRECTIVE_HOOKS = '$directive_hooks';
  var DIRECTIVE_UPDATING = '$directive_updating';

  function addEvent$1(api, element, component, data, key, lazy, event) {
      var name = event.name;
      var listener = event.listener;
      if (lazy) {
          var value = lazy[name] || lazy[EMPTY_STRING];
          if (value === TRUE) {
              name = EVENT_CHANGE;
          }
          else if (value > 0) {
              listener = debounce(listener, value, 
              // 
              //  tap 
              name === EVENT_CLICK || name === EVENT_TAP);
          }
      }
      if (component) {
          if (event.isNative) {
              var target = component.$el;
              api.on(target, name, listener);
              return function () {
                  api.off(target, name, listener);
              };
          }
          // event  ns  listener  ThisListenerOptions 
          component.on(name, event);
          data[EVENT_DESTROY + key] = function () {
              component.off(name, event);
              delete data[EVENT_DESTROY + key];
          };
      }
      else {
          api.on(element, name, listener);
          data[EVENT_DESTROY + key] = function () {
              api.off(element, key, listener);
              delete data[EVENT_DESTROY + key];
          };
      }
  }
  function afterCreate$5(api, vnode) {
      var events = vnode.events;
      if (events) {
          var element = vnode.node, component = vnode.component, lazy = vnode.lazy, data = vnode.data;
          for (var key in events) {
              addEvent$1(api, element, component, data, key, lazy, events[key]);
          }
      }
  }
  function afterUpdate$4(api, vnode, oldVNode) {
      var newEvents = vnode.events, oldEvents = oldVNode.events;
      if (newEvents !== oldEvents) {
          var element = vnode.node, component = vnode.component, lazy = vnode.lazy, data = vnode.data;
          if (oldEvents) {
              var newValue = newEvents || EMPTY_OBJECT;
              for (var key in oldEvents) {
                  if (!newValue[key]) {
                      var destroy = data[EVENT_DESTROY + key];
                      if (destroy) {
                          destroy();
                      }
                  }
              }
          }
          if (newEvents) {
              var oldValue = oldEvents || EMPTY_OBJECT;
              for (var key$1 in newEvents) {
                  var event = newEvents[key$1], oldEvent = oldValue[key$1];
                  if (!oldEvent) {
                      addEvent$1(api, element, component, data, key$1, lazy, event);
                  }
                  else if (event.value !== oldEvent.value) {
                      var destroy$1 = data[EVENT_DESTROY + key$1];
                      if (destroy$1) {
                          destroy$1();
                      }
                      addEvent$1(api, element, component, data, key$1, lazy, event);
                  }
                  else if (oldEvent.runtime && event.runtime) {
                      oldEvent.runtime.execute = event.runtime.execute;
                      event.runtime = oldEvent.runtime;
                  }
              }
          }
      }
  }
  function beforeDestroy$3(api, vnode) {
      var events = vnode.events, data = vnode.data;
      if (events) {
          for (var key in events) {
              var destroy = data[EVENT_DESTROY + key];
              if (destroy) {
                  destroy();
              }
          }
      }
  }

  var eventHook = /*#__PURE__*/Object.freeze({
    __proto__: null,
    afterCreate: afterCreate$5,
    afterUpdate: afterUpdate$4,
    beforeDestroy: beforeDestroy$3
  });

  function debounceIfNeeded(fn, lazy) {
      //  lazy
      return lazy && lazy !== TRUE
          ? debounce(fn, lazy)
          : fn;
  }
  var inputControl = {
      set: function(node, value) {
          node.value = toString(value);
      },
      sync: function(node, keypath, context) {
          context.set(keypath, node.value);
      },
  }, radioControl = {
      set: function(node, value) {
          node.checked = node.value === toString(value);
      },
      sync: function(node, keypath, context) {
          if (node.checked) {
              context.set(keypath, node.value);
          }
      },
  }, checkboxControl = {
      set: function(node, value) {
          node.checked = array$1(value)
              ? has$2(value, node.value, FALSE)
              : !!value;
      },
      sync: function(node, keypath, context) {
          var value = context.get(keypath);
          if (array$1(value)) {
              if (node.checked) {
                  context.append(keypath, node.value);
              }
              else {
                  context.removeAt(keypath, indexOf$1(value, node.value, FALSE));
              }
          }
          else {
              context.set(keypath, node.checked);
          }
      },
  }, selectControl = {
      set: function(node, value) {
          var multiple = node.multiple;
          var options = node.options;
          for (var i = 0, length = options.length; i < length; i++) {
              if (multiple) {
                  options[i].selected = has$2(value, options[i].value, FALSE);
              }
              else if (options[i].value == value) {
                  node.selectedIndex = i;
                  return;
              }
          }
          if (!multiple) {
              node.selectedIndex = -1;
          }
      },
      sync: function(node, keypath, context) {
          var multiple = node.multiple;
          var options = node.options;
          if (multiple) {
              var values = [];
              for (var i = 0, length = options.length; i < length; i++) {
                  if (options[i].selected) {
                      values.push(options[i].value);
                  }
              }
              context.set(keypath, values);
          }
          else {
              context.set(keypath, options[node.selectedIndex].value);
          }
      },
  };
  function addModel(api, element, component, data, vnode) {
      var context = vnode.context;
      var model = vnode.model;
      var lazy = vnode.lazy;
      var nativeAttrs = vnode.nativeAttrs;
      var keypath = model.keypath;
      var value = model.value;
      var lazyValue = lazy && (lazy[DIRECTIVE_MODEL] || lazy[EMPTY_STRING]);
      if (component) {
          var viewBinding = component.$model, viewSyncing = debounceIfNeeded(function (newValue) {
              context.set(keypath, newValue);
          }, lazyValue);
          component.watch(viewBinding, viewSyncing);
          data[MODEL_DESTROY] = function () {
              component.unwatch(viewBinding, viewSyncing);
              delete data[MODEL_DESTROY];
          };
      }
      else {
          var control = vnode.tag === 'select'
              ? selectControl
              : inputControl, 
          // checkbox,radio,select  change 
          eventName = EVENT_CHANGE;
          if (control === inputControl) {
              var type = nativeAttrs && nativeAttrs.type;
              if (type === 'radio') {
                  control = radioControl;
              }
              else if (type === 'checkbox') {
                  control = checkboxControl;
              }
              //  model 
              // model  yox-dom 
              // 
              else if (lazyValue !== TRUE) {
                  eventName = EVENT_MODEL;
              }
          }
          var sync = debounceIfNeeded(function () {
              control.sync(element, keypath, context);
          }, lazyValue);
          api.on(element, eventName, sync);
          control.set(element, value);
          data[MODEL_CONTROL] = control;
          data[MODEL_DESTROY] = function () {
              api.off(element, eventName, sync);
              delete data[MODEL_DESTROY];
              delete data[MODEL_CONTROL];
          };
      }
  }
  function afterCreate$4(api, vnode) {
      var model = vnode.model;
      if (model) {
          addModel(api, vnode.node, vnode.component, vnode.data, vnode);
      }
  }
  function afterUpdate$3(api, vnode, oldVNode) {
      var data = vnode.data, newModel = vnode.model, oldModel = oldVNode.model;
      if (newModel) {
          var element = vnode.node, component = vnode.component;
          if (!oldModel) {
              addModel(api, element, component, data, vnode);
          }
          else if (newModel.keypath !== oldModel.keypath) {
              data[MODEL_DESTROY]();
              addModel(api, element, component, data, vnode);
          }
          else {
              if (component) {
                  component.set(component.$model, newModel.value);
              }
              else {
                  var control = data[MODEL_CONTROL];
                  if (control) {
                      control.set(element, newModel.value);
                  }
              }
          }
      }
      else if (oldModel) {
          data[MODEL_DESTROY]();
      }
  }
  function beforeDestroy$2(api, vnode) {
      var data = vnode.data, destroy = data[MODEL_DESTROY];
      if (destroy) {
          destroy();
      }
  }

  var modelHook = /*#__PURE__*/Object.freeze({
    __proto__: null,
    afterCreate: afterCreate$4,
    afterUpdate: afterUpdate$3,
    beforeDestroy: beforeDestroy$2
  });

  function afterCreate$3(api, vnode) {
      var nativeAttrs = vnode.nativeAttrs;
      if (nativeAttrs) {
          var element = vnode.node;
          for (var name in nativeAttrs) {
              api.setAttr(element, name, nativeAttrs[name]);
          }
      }
  }
  function afterUpdate$2(api, vnode, oldVNode) {
      var newNativeAttrs = vnode.nativeAttrs, oldNativeAttrs = oldVNode.nativeAttrs;
      if (newNativeAttrs !== oldNativeAttrs) {
          var element = vnode.node;
          if (newNativeAttrs) {
              var oldValue = oldNativeAttrs || EMPTY_OBJECT;
              for (var name in newNativeAttrs) {
                  if (oldValue[name] === UNDEFINED
                      || newNativeAttrs[name] !== oldValue[name]) {
                      api.setAttr(element, name, newNativeAttrs[name]);
                  }
              }
          }
          if (oldNativeAttrs) {
              var newValue = newNativeAttrs || EMPTY_OBJECT;
              for (var name$1 in oldNativeAttrs) {
                  if (newValue[name$1] === UNDEFINED) {
                      api.removeAttr(element, name$1);
                  }
              }
          }
      }
  }

  var nativeAttrHook = /*#__PURE__*/Object.freeze({
    __proto__: null,
    afterCreate: afterCreate$3,
    afterUpdate: afterUpdate$2
  });

  function afterCreate$2(api, vnode) {
      var nativeStyles = vnode.nativeStyles;
      if (nativeStyles) {
          var elementStyle = vnode.node.style;
          for (var name in nativeStyles) {
              api.setStyle(elementStyle, name, nativeStyles[name]);
          }
      }
  }
  function afterUpdate$1(api, vnode, oldVNode) {
      var newNativeStyles = vnode.nativeStyles, oldNativeStyles = oldVNode.nativeStyles;
      if (newNativeStyles !== oldNativeStyles) {
          var elementStyle = vnode.node.style;
          if (newNativeStyles) {
              var oldValue = oldNativeStyles || EMPTY_OBJECT;
              for (var name in newNativeStyles) {
                  if (oldValue[name] === UNDEFINED
                      || newNativeStyles[name] !== oldValue[name]) {
                      api.setStyle(elementStyle, name, newNativeStyles[name]);
                  }
              }
          }
          if (oldNativeStyles) {
              var newValue = newNativeStyles || EMPTY_OBJECT;
              for (var name$1 in oldNativeStyles) {
                  if (newValue[name$1] === UNDEFINED) {
                      api.removeStyle(elementStyle, name$1);
                  }
              }
          }
      }
  }

  var nativeStyleHook = /*#__PURE__*/Object.freeze({
    __proto__: null,
    afterCreate: afterCreate$2,
    afterUpdate: afterUpdate$1
  });

  function callDirectiveCreate(data, vnode, directive) {
      data[DIRECTIVE_HOOKS + directive.name] = directive.create(vnode.component || vnode.node, directive, vnode);
  }
  function callDirectiveHook(data, vnode, directive, hookName) {
      var hooks = data[DIRECTIVE_HOOKS + directive.name], hook = hooks && hooks[hookName];
      if (hook) {
          hook(directive, vnode);
      }
  }
  function genetateDirectiveHook(hookName) {
      return function (api, vnode) {
          var directives = vnode.directives;
          if (directives) {
              var data = vnode.data;
              for (var name in directives) {
                  callDirectiveHook(data, vnode, directives[name], hookName);
              }
          }
      };
  }
  function afterCreate$1(api, vnode) {
      var directives = vnode.directives;
      if (directives) {
          var data = vnode.data;
          for (var name in directives) {
              callDirectiveCreate(data, vnode, directives[name]);
          }
      }
  }
  function beforeUpdate$1(api, vnode, oldVNode) {
      var newDirectives = vnode.directives, oldDirectives = oldVNode.directives, data = vnode.data;
      //  beforeDestroy 
      if (oldDirectives) {
          var newValue = newDirectives || EMPTY_OBJECT;
          for (var name in oldDirectives) {
              if (newValue[name] === UNDEFINED) {
                  callDirectiveHook(data, vnode, oldDirectives[name], 'beforeDestroy');
              }
          }
      }
      if (newDirectives) {
          var oldValue = oldDirectives || EMPTY_OBJECT, updatingDirectives = [];
          for (var name$1 in newDirectives) {
              var directive = newDirectives[name$1];
              if (oldValue[name$1] === UNDEFINED) {
                  callDirectiveCreate(data, vnode, directive);
              }
              else if (directive.value !== oldValue[name$1].value) {
                  callDirectiveHook(data, vnode, directive, 'beforeUpdate');
                  updatingDirectives.push(directive);
              }
          }
          data[DIRECTIVE_UPDATING] = updatingDirectives;
      }
  }
  function afterUpdate(api, vnode, oldVNode) {
      var data = vnode.data;
      if (data) {
          var directives = data[DIRECTIVE_UPDATING];
          if (directives) {
              for (var i = 0, length = directives.length; i < length; i++) {
                  callDirectiveHook(data, vnode, directives[i], 'afterUpdate');
              }
              data[DIRECTIVE_UPDATING] = UNDEFINED;
          }
      }
  }
  var afterMount = genetateDirectiveHook('afterMount');
  var beforeDestroy$1 = genetateDirectiveHook('beforeDestroy');

  var directiveHook = /*#__PURE__*/Object.freeze({
    __proto__: null,
    afterCreate: afterCreate$1,
    beforeUpdate: beforeUpdate$1,
    afterUpdate: afterUpdate,
    afterMount: afterMount,
    beforeDestroy: beforeDestroy$1
  });

  function afterCreate(api, vnode) {
      var ref = vnode.ref;
      if (ref) {
          var context = vnode.context;
          var $refs = context.$refs;
          if (!$refs) {
              $refs = context.$refs = {};
          }
          $refs[ref] = vnode.component || vnode.node;
      }
  }
  //  ref 
  //  ref 
  //  ref1 ref1 
  function beforeUpdate(api, vnode, oldVNode) {
      var newRef = vnode.ref, oldRef = oldVNode.ref;
      if (newRef || oldRef) {
          var context = vnode.context, node = vnode.component || vnode.node;
          var $refs = context.$refs;
          if (newRef) {
              if (!oldRef) {
                  if (!$refs) {
                      $refs = context.$refs = {};
                  }
                  $refs[newRef] = node;
              }
              else if (newRef !== oldRef) {
                  if ($refs) {
                      if ($refs[newRef] === node) {
                          delete $refs[newRef];
                      }
                  }
                  else {
                      $refs = context.$refs = {};
                  }
                  $refs[newRef] = node;
              }
          }
          else if ($refs && oldRef && $refs[oldRef] === node) {
              delete $refs[oldRef];
          }
      }
  }
  function beforeDestroy(api, vnode) {
      var ref = vnode.ref;
      if (ref) {
          var ref$1 = vnode.context;
          var $refs = ref$1.$refs;
          var node = vnode.component || vnode.node;
          if ($refs && $refs[ref] === node) {
              delete $refs[ref];
          }
      }
  }

  var refHook = /*#__PURE__*/Object.freeze({
    __proto__: null,
    afterCreate: afterCreate,
    beforeUpdate: beforeUpdate,
    beforeDestroy: beforeDestroy
  });

  function getFragmentHostNode(api, vnode) {
      if (vnode.type === VNODE_TYPE_FRAGMENT
          || vnode.type === VNODE_TYPE_SLOT) {
          var child = vnode.children[0];
          return child
              ? getFragmentHostNode(api, child)
              : api.createComment(EMPTY_STRING);
      }
      return vnode.node;
  }
  function insertNodeNatively(api, parentNode, node, referenceNode) {
      if (referenceNode) {
          api.before(parentNode, node, referenceNode);
      }
      else {
          api.append(parentNode, node);
      }
  }
  function textVNodeUpdateOperator(api, vnode, oldVNode) {
      var node = oldVNode.node;
      vnode.node = node;
      vnode.parentNode = oldVNode.parentNode;
      if (vnode.text !== oldVNode.text) {
          api.setNodeText(node, vnode.text);
      }
  }
  function elementVNodeEnterOperator(vnode) {
      if (vnode.data) {
          enterVNode(vnode, vnode.node);
      }
  }
  function elementVNodeLeaveOperator(vnode, done) {
      if (vnode.data
          && leaveVNode(vnode, vnode.node, done)) {
          return;
      }
      done();
  }
  function vnodeInsertOperator(api, parentNode, vnode, before) {
      //  insertNodeNatively
      if (before) {
          api.before(parentNode, vnode.node, before.node);
      }
      else {
          api.append(parentNode, vnode.node);
      }
  }
  function vnodeRemoveOperator(api, vnode) {
      api.remove(vnode.parentNode, vnode.node);
  }
  function vnodeLeaveOperator(vnode, done) {
      done();
  }
  function vnodeCreateChildrenOperator(api, vnode) {
      var children = vnode.children;
      for (var i = 0, length = children.length; i < length; i++) {
          createVNode(api, children[i]);
      }
  }
  function vnodeUpdateChildrenOperator(api, parentNode, vnode, oldVNode) {
      updateChildren(api, parentNode, vnode.children, oldVNode.children);
  }
  function vnodeDestroyChildrenOperator(api, vnode) {
      var children = vnode.children;
      for (var i = 0, length = children.length; i < length; i++) {
          destroyVNode(api, children[i]);
      }
  }
  function vnodeInsertChildrenOperator(api, parentNode, vnode, before) {
      var children = vnode.children;
      for (var i = 0, length = children.length; i < length; i++) {
          insertVNode(api, parentNode, children[i], before);
      }
  }
  function vnodeRemoveChildrenOperator(api, vnode) {
      var children = vnode.children;
      for (var i = 0, length = children.length; i < length; i++) {
          removeVNode(api, children[i]);
      }
  }
  var textVNodeOperator = {
      create: function(api, vnode) {
          vnode.node = api.createText(vnode.text);
      },
      update: textVNodeUpdateOperator,
      destroy: EMPTY_FUNCTION,
      insert: vnodeInsertOperator,
      remove: vnodeRemoveOperator,
      enter: EMPTY_FUNCTION,
      leave: vnodeLeaveOperator,
  };
  var commentVNodeOperator = {
      create: function(api, vnode) {
          vnode.node = api.createComment(vnode.text);
      },
      update: textVNodeUpdateOperator,
      destroy: EMPTY_FUNCTION,
      insert: vnodeInsertOperator,
      remove: vnodeRemoveOperator,
      enter: EMPTY_FUNCTION,
      leave: vnodeLeaveOperator,
  };
  var vnodeHooksList = [
      nativeAttrHook,
      nativeStyleHook,
      refHook,
      eventHook,
      modelHook,
      directiveHook ];
  var vnodeHooksLength = vnodeHooksList.length;
  function callVNodeHooks(name, args) {
      for (var i = 0; i < vnodeHooksLength; i++) {
          var hook = vnodeHooksList[i][name];
          if (hook) {
              hook.apply(UNDEFINED, args);
          }
      }
  }
  var elementVNodeOperator = {
      create: function(api, vnode) {
          var node = vnode.node = api.createElement(vnode.tag, vnode.isSvg);
          if (vnode.children) {
              addVNodes(api, node, vnode.children);
          }
          else if (vnode.text) {
              api.setElementText(node, vnode.text);
          }
          else if (vnode.html) {
              api.setHtml(node, vnode.html);
          }
          if (!vnode.isPure) {
              vnode.data = {};
          }
          callVNodeHooks('afterCreate', [api, vnode]);
      },
      update: function(api, vnode, oldVNode) {
          var node = oldVNode.node;
          vnode.node = node;
          vnode.parentNode = oldVNode.parentNode;
          vnode.data = oldVNode.data;
          if (!vnode.isPure && oldVNode.isPure) {
              vnode.data = {};
          }
          callVNodeHooks('beforeUpdate', [api, vnode, oldVNode]);
          var text = vnode.text;
          var html = vnode.html;
          var children = vnode.children;
          var oldText = oldVNode.text, oldHtml = oldVNode.html, oldChildren = oldVNode.children;
          if (string$1(text)) {
              if (oldChildren) {
                  removeVNodes(api, oldChildren);
              }
              if (text !== oldText) {
                  api.setElementText(node, text);
              }
          }
          else if (string$1(html)) {
              if (oldChildren) {
                  removeVNodes(api, oldChildren);
              }
              if (html !== oldHtml) {
                  api.setHtml(node, html);
              }
          }
          else if (children) {
              //  diff
              if (oldChildren) {
                  if (children !== oldChildren) {
                      updateChildren(api, node, children, oldChildren);
                  }
              }
              //  - 
              else {
                  if (oldText || oldHtml) {
                      api.setElementText(node, EMPTY_STRING);
                  }
                  addVNodes(api, node, children);
              }
          }
          //  - 
          else if (oldChildren) {
              removeVNodes(api, oldChildren);
          }
          //  text  text
          else if (oldText || oldHtml) {
              api.setElementText(node, EMPTY_STRING);
          }
          callVNodeHooks('afterUpdate', [api, vnode, oldVNode]);
      },
      destroy: function(api, vnode) {
          if (vnode.isPure) {
              return;
          }
          callVNodeHooks('beforeDestroy', [api, vnode]);
          var children = vnode.children;
          if (children) {
              for (var i = 0, length = children.length; i < length; i++) {
                  destroyVNode(api, children[i]);
              }
          }
      },
      insert: vnodeInsertOperator,
      remove: vnodeRemoveOperator,
      enter: elementVNodeEnterOperator,
      leave: elementVNodeLeaveOperator,
  };
  var componentVNodeOperator = {
      create: function(api, vnode) {
          var data = vnode.data = {};
          var componentOptions = UNDEFINED;
          // tag 
          if (vnode.tag) {
              vnode.context.loadComponent(vnode.tag, function (options) {
                  if (has(data, LOADING)) {
                      // 
                      if (data[LOADING]) {
                          //  vnode
                          if (data[VNODE]) {
                              vnode = data[VNODE];
                              // 
                              delete data[VNODE];
                          }
                          createComponent(api, vnode, options);
                          vnode.operator.enter(vnode);
                      }
                  }
                  // 
                  else {
                      componentOptions = options;
                  }
              });
          }
          // 
          vnode.node = api.createComment(RAW_COMPONENT);
          if (componentOptions) {
              createComponent(api, vnode, componentOptions);
          }
          else {
              data[LOADING] = TRUE;
          }
      },
      update: function(api, vnode, oldVNode) {
          var data = oldVNode.data;
          vnode.data = data;
          vnode.node = oldVNode.node;
          vnode.parentNode = oldVNode.parentNode;
          vnode.component = oldVNode.component;
          //  vnode
          //  vnode
          if (data[LOADING]) {
              data[VNODE] = vnode;
              return;
          }
          callVNodeHooks('beforeUpdate', [api, vnode, oldVNode]);
          var component = vnode.component;
          var slots = vnode.slots;
          if (component) {
              var nextProps = vnode.props;
              if (slots) {
                  nextProps = extend(nextProps || {}, slots);
              }
              if (nextProps) {
                  component.forceUpdate(nextProps);
              }
          }
          callVNodeHooks('afterUpdate', [api, vnode, oldVNode]);
      },
      destroy: function(api, vnode) {
          var component = vnode.component;
          if (component) {
              callVNodeHooks('beforeDestroy', [api, vnode]);
              component.destroy();
              //  shadow 
              vnode.shadow = component.$vnode;
              vnode.component = UNDEFINED;
          }
          else {
              vnode.data[LOADING] = FALSE;
          }
      },
      insert: function(api, parentNode, vnode, before) {
          var shadow = vnode.shadow;
          if (shadow) {
              shadow.operator.insert(api, parentNode, shadow, before);
              shadow.parentNode = parentNode;
          }
          else {
              vnodeInsertOperator(api, parentNode, vnode, before);
          }
      },
      remove: function(api, vnode) {
          var shadow = vnode.shadow;
          if (shadow) {
              shadow.operator.remove(api, shadow);
              shadow.parentNode = UNDEFINED;
          }
          else {
              vnodeRemoveOperator(api, vnode);
          }
      },
      enter: function(vnode) {
          var shadow = vnode.shadow;
          if (shadow) {
              if (vnode.transition) {
                  enterVNode(vnode, shadow.node);
              }
              else {
                  shadow.operator.enter(shadow);
              }
          }
      },
      leave: function(vnode, done) {
          var shadow = vnode.shadow;
          if (shadow) {
              if (vnode.transition) {
                  if (leaveVNode(vnode, shadow.node, done)) {
                      return;
                  }
              }
              else {
                  shadow.operator.leave(shadow, done);
                  return;
              }
          }
          done();
      },
  };
  var fragmentVNodeOperator = {
      create: function(api, vnode) {
          vnodeCreateChildrenOperator(api, vnode);
          vnode.node = getFragmentHostNode(api, vnode);
      },
      update: function(api, vnode, oldVNode) {
          var parentNode = oldVNode.parentNode;
          vnode.node = oldVNode.node;
          vnode.parentNode = parentNode;
          vnodeUpdateChildrenOperator(api, parentNode, vnode, oldVNode);
      },
      destroy: vnodeDestroyChildrenOperator,
      insert: vnodeInsertChildrenOperator,
      remove: vnodeRemoveChildrenOperator,
      enter: EMPTY_FUNCTION,
      leave: vnodeLeaveOperator,
  };
  var portalVNodeOperator = {
      create: function(api, vnode) {
          var target = UNDEFINED;
          if (vnode.to) {
              target = api.find(vnode.to);
          }
          //  body 
          if (!target) {
              target = api.getBodyElement();
          }
          vnode.target = target;
          // 
          // 
          vnode.node = api.createComment(EMPTY_STRING);
          var children = vnode.children;
          for (var i = 0, length = children.length; i < length; i++) {
              createVNode(api, children[i]);
              insertVNode(api, target, children[i]);
          }
      },
      update: function(api, vnode, oldVNode) {
          var target = oldVNode.target;
          vnode.node = oldVNode.node;
          vnode.parentNode = oldVNode.parentNode;
          vnode.target = target;
          vnodeUpdateChildrenOperator(api, target, vnode, oldVNode);
      },
      destroy: function(api, vnode) {
          var children = vnode.children;
          for (var i = 0, length = children.length; i < length; i++) {
              destroyVNode(api, children[i]);
              removeVNode(api, children[i]);
          }
      },
      insert: vnodeInsertOperator,
      remove: vnodeRemoveOperator,
      enter: EMPTY_FUNCTION,
      leave: vnodeLeaveOperator,
  };
  var slotVNodeOperator = {
      create: function(api, vnode) {
          vnodeCreateChildrenOperator(api, vnode);
          vnode.data = {};
          vnode.node = getFragmentHostNode(api, vnode);
          callVNodeHooks('afterCreate', [api, vnode]);
      },
      update: function(api, vnode, oldVNode) {
          var parentNode = oldVNode.parentNode;
          vnode.node = oldVNode.node;
          vnode.parentNode = parentNode;
          vnode.data = oldVNode.data;
          callVNodeHooks('beforeUpdate', [api, vnode, oldVNode]);
          vnodeUpdateChildrenOperator(api, parentNode, vnode, oldVNode);
          callVNodeHooks('afterUpdate', [api, vnode, oldVNode]);
      },
      destroy: function(api, vnode) {
          callVNodeHooks('beforeDestroy', [api, vnode]);
          vnodeDestroyChildrenOperator(api, vnode);
      },
      insert: vnodeInsertChildrenOperator,
      remove: vnodeRemoveChildrenOperator,
      enter: elementVNodeEnterOperator,
      leave: elementVNodeLeaveOperator,
  };
  function isPatchable(vnode, oldVNode) {
      return vnode.type === oldVNode.type
          && vnode.tag === oldVNode.tag
          && vnode.key === oldVNode.key;
  }
  function createKeyToIndex(vnodes, startIndex, endIndex) {
      var result, vnode, key;
      while (startIndex <= endIndex) {
          vnode = vnodes[startIndex];
          if (vnode && (key = vnode.key)) {
              if (!result) {
                  result = {};
              }
              result[key] = startIndex;
          }
          startIndex++;
      }
      return result || EMPTY_OBJECT;
  }
  function createComponent(api, vnode, options) {
      var data = vnode.data, child = (vnode.parent || vnode.context).createComponent(options, vnode);
      vnode.component = child;
      vnode.shadow = child.$vnode;
      data[LOADING] = FALSE;
      callVNodeHooks('afterCreate', [api, vnode]);
      return child;
  }
  function createVNode(api, vnode) {
      if (!vnode.node) {
          vnode.operator.create(api, vnode);
      }
  }
  function addVNodes(api, parentNode, vnodes, startIndex, endIndex, before) {
      var vnode, start = startIndex || 0, end = endIndex !== UNDEFINED ? endIndex : vnodes.length - 1;
      while (start <= end) {
          vnode = vnodes[start];
          createVNode(api, vnode);
          insertVNode(api, parentNode, vnode, before);
          start++;
      }
  }
  function insertVNode(api, parentNode, vnode, before) {
      var operator = vnode.operator;
      operator.insert(api, parentNode, vnode, before);
      vnode.parentNode = parentNode;
      callVNodeHooks('afterMount', [api, vnode]);
      operator.enter(vnode);
  }
  function removeVNodes(api, vnodes, startIndex, endIndex) {
      var vnode, start = startIndex || 0, end = endIndex !== UNDEFINED ? endIndex : vnodes.length - 1;
      while (start <= end) {
          vnode = vnodes[start];
          if (vnode) {
              destroyVNode(api, vnode);
              removeVNode(api, vnode);
          }
          start++;
      }
  }
  function destroyVNode(api, vnode) {
      vnode.operator.destroy(api, vnode);
  }
  function removeVNode(api, vnode) {
      var operator = vnode.operator;
      operator.leave(vnode, function () {
          operator.remove(api, vnode);
          vnode.parentNode = UNDEFINED;
      });
  }
  function enterVNode(vnode, node) {
      var context = vnode.context;
      var transition = vnode.transition;
      var data = vnode.data, leaving = data[LEAVING];
      if (leaving) {
          leaving();
      }
      if (transition) {
          var enter = transition.enter;
          if (enter) {
              enter.call(context, node);
          }
      }
  }
  function leaveVNode(vnode, node, done) {
      var context = vnode.context;
      var transition = vnode.transition;
      var data = vnode.data, leaving = data[LEAVING];
      if (leaving) {
          leaving();
      }
      if (transition) {
          var leave = transition.leave;
          if (leave) {
              leave.call(context, node, data[LEAVING] = function () {
                  if (data[LEAVING]) {
                      done();
                      data[LEAVING] = UNDEFINED;
                  }
              });
              return TRUE;
          }
      }
  }
  function updateChildren(api, parentNode, children, oldChildren) {
      var startIndex = 0, endIndex = children.length - 1, startVNode = children[startIndex], endVNode = children[endIndex], oldStartIndex = 0, oldEndIndex = oldChildren.length - 1, oldStartVNode = oldChildren[oldStartIndex], oldEndVNode = oldChildren[oldEndIndex], oldKeyToIndex, oldIndex;
      while (oldStartIndex <= oldEndIndex && startIndex <= endIndex) {
          //  UNDEFINED 
          if (!startVNode) {
              startVNode = children[++startIndex];
          }
          else if (!endVNode) {
              endVNode = children[--endIndex];
          }
          else if (!oldStartVNode) {
              oldStartVNode = oldChildren[++oldStartIndex];
          }
          else if (!oldEndVNode) {
              oldEndVNode = oldChildren[--oldEndIndex];
          }
          //  patch
          else if (isPatchable(startVNode, oldStartVNode)) {
              updateVNode(api, startVNode, oldStartVNode);
              startVNode = children[++startIndex];
              oldStartVNode = oldChildren[++oldStartIndex];
          }
          //  patch
          else if (isPatchable(endVNode, oldEndVNode)) {
              updateVNode(api, endVNode, oldEndVNode);
              endVNode = children[--endIndex];
              oldEndVNode = oldChildren[--oldEndIndex];
          }
          //    
          //  endVNode  oldStartVNode  patch
          // 
          else if (isPatchable(endVNode, oldStartVNode)) {
              updateVNode(api, endVNode, oldStartVNode);
              insertNodeNatively(api, parentNode, oldStartVNode.node, api.next(oldEndVNode.node));
              endVNode = children[--endIndex];
              oldStartVNode = oldChildren[++oldStartIndex];
          }
          //  oldEndVNode  startVNode  patch
          // 
          else if (isPatchable(startVNode, oldEndVNode)) {
              updateVNode(api, startVNode, oldEndVNode);
              insertNodeNatively(api, parentNode, oldEndVNode.node, oldStartVNode.node);
              startVNode = children[++startIndex];
              oldEndVNode = oldChildren[--oldEndIndex];
          }
          //  key
          else {
              if (!oldKeyToIndex) {
                  oldKeyToIndex = createKeyToIndex(oldChildren, oldStartIndex, oldEndIndex);
              }
              // 
              oldIndex = startVNode.key
                  ? oldKeyToIndex[startVNode.key]
                  : UNDEFINED;
              // 
              if (oldIndex !== UNDEFINED) {
                  patch(api, startVNode, oldChildren[oldIndex]);
                  oldChildren[oldIndex] = UNDEFINED;
              }
              // 
              else {
                  createVNode(api, startVNode);
              }
              insertVNode(api, parentNode, startVNode, oldStartVNode);
              startVNode = children[++startIndex];
          }
      }
      if (oldStartIndex > oldEndIndex) {
          addVNodes(api, parentNode, children, startIndex, endIndex, children[endIndex + 1]);
      }
      else if (startIndex > endIndex) {
          removeVNodes(api, oldChildren, oldStartIndex, oldEndIndex);
      }
  }
  function updateVNode(api, vnode, oldVNode) {
      if (vnode !== oldVNode) {
          vnode.operator.update(api, vnode, oldVNode);
      }
  }
  function patch(api, vnode, oldVNode) {
      if (vnode === oldVNode) {
          return;
      }
      //  patch
      if (!isPatchable(vnode, oldVNode)) {
          // 
          //  vnode  patch
          //  DOM  createComponent 
          var parentNode = oldVNode.parentNode;
          createVNode(api, vnode);
          if (parentNode) {
              insertVNode(api, parentNode, vnode, oldVNode);
              destroyVNode(api, oldVNode);
              removeVNode(api, oldVNode);
          }
          return;
      }
      updateVNode(api, vnode, oldVNode);
  }
  function create(api, node, context) {
      var vnode = {
          context: context,
          node: node,
          parentNode: api.parent(node),
      };
      switch (node.nodeType) {
          case NODE_TYPE_ELEMENT:
              vnode.data = {};
              vnode.tag = api.tag(node);
              vnode.type = VNODE_TYPE_ELEMENT;
              vnode.operator = elementVNodeOperator;
              break;
          case NODE_TYPE_TEXT:
              vnode.isPure = TRUE;
              vnode.text = node.nodeValue;
              vnode.type = VNODE_TYPE_TEXT;
              vnode.operator = textVNodeOperator;
              break;
          case NODE_TYPE_COMMENT:
              vnode.isPure = TRUE;
              vnode.text = node.nodeValue;
              vnode.type = VNODE_TYPE_COMMENT;
              vnode.operator = commentVNodeOperator;
              break;
      }
      return vnode;
  }
  function destroy(api, vnode, isRemove) {
      destroyVNode(api, vnode);
      if (isRemove) {
          removeVNode(api, vnode);
      }
  }
  function clone(vnode) {
      var children = vnode.children;
      return {
          type: vnode.type,
          data: vnode.data,
          node: vnode.node,
          parentNode: vnode.parentNode,
          target: vnode.target,
          shadow: vnode.shadow,
          parent: vnode.parent,
          component: vnode.component,
          context: vnode.context,
          operator: vnode.operator,
          tag: vnode.tag,
          isSvg: vnode.isSvg,
          isStatic: vnode.isStatic,
          isPure: vnode.isPure,
          slots: vnode.slots,
          props: vnode.props,
          nativeAttrs: vnode.nativeAttrs,
          nativeStyles: vnode.nativeStyles,
          directives: vnode.directives,
          events: vnode.events,
          lazy: vnode.lazy,
          transition: vnode.transition,
          model: vnode.model,
          to: vnode.to,
          ref: vnode.ref,
          key: vnode.key,
          text: vnode.text,
          html: vnode.html,
          children: children
              ? children.map(clone)
              : children,
      };
  }

  function parseStyleString(source, callback) {
      var parts = source.split(';');
      for (var i = 0, len = parts.length; i < len; i++) {
          var item = parts[i];
          var index = item.indexOf(':');
          if (index > 0) {
              var key = trim(item.substring(0, index));
              var value = trim(item.substring(index + 1));
              if (key && value) {
                  callback(camelize(key), value);
              }
          }
      }
  }

  function formatNumberNativeAttributeValue(name, value) {
      return toString(value);
  }
  function formatBooleanNativeAttributeValue(name, value, defaultValue) {
      //  true    true
      var isTrue = value === TRUE || value === RAW_TRUE || value === name;
      return isTrue === defaultValue
          ? UNDEFINED
          : (isTrue ? RAW_TRUE : RAW_FALSE);
  }

  // 
  //  IE  { class: 'xx' } 
  toMap('abstract,goto,native,static,enum,implements,package,super,byte,export,import,private,protected,public,synchronized,char,extends,int,throws,class,final,interface,transient,yield,let,const,float,double,boolean,long,short,volatile,default');

  var STATUS_INIT = 1;
  var STATUS_FRESH = 2;
  var STATUS_DIRTY = 3;
  function runGetter(instance) {
      var input = instance.input;
      var getter = instance.getter;
      instance.value = input
          ? getter.apply(UNDEFINED, input)
          : getter();
  }
  function runOutput(instance) {
      var value = instance.value;
      var output = instance.output;
      return output
          ? output(value)
          : value;
  }
  var Deps = function() {
      this.map = {};
      this.list = [];
  };
  Deps.prototype.add = function (observer, dep) {
      var deps = this.map[observer.id] || (this.map[observer.id] = {});
      if (!deps[dep]) {
          deps[dep] = observer;
          this.list.push([
              observer, dep
          ]);
      }
  };
  Deps.prototype.watch = function (watcher) {
      var ref = this;
          var list = ref.list;
      if (list) {
          for (var i = 0, length = list.length; i < length; i++) {
              list[i][0].watch(list[i][1], watcher);
          }
      }
  };
  Deps.prototype.unwatch = function (watcher) {
      var ref = this;
          var list = ref.list;
      if (list) {
          for (var i = 0, length = list.length; i < length; i++) {
              list[i][0].unwatch(list[i][1], watcher);
          }
      }
  };
  /**
   * 
   *
   *  cachedeps, getset 
   */
  var Computed = function(keypath, cache, sync, input, output, getter, setter, onChange) {
      var instance = this;
      instance.status = STATUS_INIT;
      instance.keypath = keypath;
      instance.cache = cache;
      instance.input = input;
      instance.output = output;
      instance.setter = setter;
      instance.getter = getter;
      instance.onChange = onChange;
      instance.watcherOptions = {
          sync: sync,
          watcher: function() {
              instance.refresh();
          }
      };
  };
  /**
   * 
   */
  Computed.prototype.get = function () {
      var instance = this;
          var status = instance.status;
          var watcherOptions = instance.watcherOptions;
      // 
      if (!instance.cache) {
          runGetter(instance);
      }
      // 
      else if (status !== STATUS_FRESH) {
          // 
          if (instance.staticDeps) {
              runGetter(instance);
          }
          // 
          else {
              var dynamicDeps = instance.dynamicDeps;
              // 
              if (dynamicDeps) {
                  dynamicDeps.unwatch(watcherOptions.watcher);
              }
              instance.dynamicDeps = UNDEFINED;
              var lastComputed = Computed.current;
              // 
              Computed.current = instance;
              runGetter(instance);
              // 
              Computed.current = lastComputed;
              dynamicDeps = instance.dynamicDeps;
              if (dynamicDeps) {
                  dynamicDeps.watch(watcherOptions);
              }
          }
      }
      if (status !== STATUS_FRESH) {
          instance.status = STATUS_FRESH;
      }
      return runOutput(instance);
  };
  Computed.prototype.set = function (value) {
      var ref = this;
          var setter = ref.setter;
      if (setter) {
          setter(value);
      }
      else if (func(value)) {
          this.getter = value;
          this.refresh();
      }
  };
  Computed.prototype.refresh = function () {
      var oldValue = this.value;
      this.status = STATUS_DIRTY;
      var newValue = this.get();
      if (newValue !== oldValue) {
          this.onChange(this.keypath, newValue, oldValue);
      }
  };
  Computed.prototype.addStaticDeps = function (observer, deps) {
      var staticDeps = this.staticDeps || (this.staticDeps = new Deps());
      for (var i = 0, length = deps.length; i < length; i++) {
          staticDeps.add(observer, deps[i]);
      }
      staticDeps.watch(this.watcherOptions);
  };
  Computed.prototype.addDynamicDep = function (observer, dep) {
      //  watch
      // 
      //  watch refresh
      var deps = this.dynamicDeps || (this.dynamicDeps = new Deps());
      deps.add(observer, dep);
  };

  var Context = function(keypath, scopeValue, scopeKey) {
      this.keypath = keypath;
      this.scopeValue = scopeValue;
      this.scopeKey = scopeKey;
  };
  Context.prototype.getScope = function () {
      var ref = this;
          var scopeValue = ref.scopeValue;
          var scopeKey = ref.scopeKey;
      return scopeKey !== UNDEFINED ? scopeValue[scopeKey] : scopeValue;
  };
  Context.prototype.getKeypath = function (name) {
      var ref = this;
          var keypath = ref.keypath;
      return keypath ? keypath + RAW_DOT + name : name;
  };
  function render(instance, template, rootScope, filters, globalFilters, directives, globalDirectives, transitions, globalTransitions, addDependency) {
      var rootKeypath = EMPTY_STRING, contextStack = [
          new Context(rootKeypath, rootScope)
      ], 
      //  vnode
      children = [], appendVNodeProperty = function (vnode, key, name, value) {
          if (vnode[key]) {
              vnode[key][name] = value;
          }
          else {
              var map = {};
              map[name] = value;
              vnode[key] = map;
          }
      }, renderStyleString = function (value) {
          var styles = {};
          parseStyleString(value, function (key, value) {
              styles[key] = value;
          });
          return styles;
      }, renderStyleExpr = function (value) {
          if (array$1(value)) {
              var styles = {};
              for (var i = 0, len = value.length; i < len; i++) {
                  var item = renderStyleExpr(value[i]);
                  if (item) {
                      for (var key in item) {
                          styles[key] = item[key];
                      }
                  }
              }
              return styles;
          }
          if (object$1(value)) {
              return value;
          }
          if (string$1(value)) {
              return renderStyleString(value);
          }
      }, renderTransition = function (name, transition) {
          return transition;
      }, 
      // holder 
      renderModel = function (holder) {
          return {
              keypath: holder.keypath,
              value: holder.value,
          };
      }, createEventNameListener = function (type, ns, isComponent) {
          return function (event, data, isNative) {
              // 
              if (isComponent && event.phase === CustomEvent.PHASE_DOWNWARD) {
                  return;
              }
              if (type !== event.type || ns !== event.ns) {
                  event = new CustomEvent(type, isNative
                      ? event.originalEvent
                      : event);
                  event.ns = ns;
              }
              instance.fire(event, data);
          };
      }, createEventMethodListener = function (method, runtime, isComponent) {
          return function (event, data) {
              // 
              if (isComponent && event.phase === CustomEvent.PHASE_DOWNWARD) {
                  return;
              }
              var result = callMethod(method, runtime
                  ? runtime.execute(event, data)
                  : (data ? [event, data] : [event]));
              if (result === FALSE) {
                  event.prevent().stop();
              }
          };
      }, renderEventMethod = function (key, value, name, ns, method, runtime, isComponent, isNative) {
          return {
              key: key,
              value: value,
              name: name,
              ns: ns,
              isNative: isNative,
              runtime: runtime,
              listener: createEventMethodListener(method, runtime, isComponent),
          };
      }, renderEventName = function (key, value, name, ns, to, toNs, isComponent, isNative) {
          return {
              key: key,
              value: value,
              name: name,
              ns: ns,
              isNative: isNative,
              listener: createEventNameListener(to, toNs, isComponent),
          };
      }, renderDirective = function (key, name, modifier, value, create) {
          return {
              ns: DIRECTIVE_CUSTOM,
              name: name,
              value: value,
              modifier: modifier,
              create: create,
          };
      }, callMethod = function (name, args) {
          var method = instance[name];
          if (args && args.length > 0) {
              return execute(method, instance, args);
          }
          return instance[name]();
      }, renderSpread = function (vnode, key, value) {
          if (object$1(value)) {
              for (var name in value) {
                  appendVNodeProperty(vnode, key, name, value[name]);
              }
          }
      }, renderEach = function (holder, renderChildren, renderElse) {
          var keypath = holder.keypath;
          var value = holder.value;
          var length = 0, needKeypath = !!keypath, oldScopeStack = contextStack, currentKeypath = last(contextStack).keypath;
          if (array$1(value)) {
              length = value.length;
              for (var i = 0; i < length; i++) {
                  if (needKeypath) {
                      currentKeypath = keypath + RAW_DOT + i;
                      // slice + push  concat 
                      contextStack = oldScopeStack.slice();
                      contextStack.push(new Context(currentKeypath, value, i));
                  }
                  renderChildren(contextStack, value[i], currentKeypath, length, i);
              }
          }
          else if (object$1(value)) {
              var keys$1 = keys(value);
              length = keys$1.length;
              for (var i$1 = 0; i$1 < length; i$1++) {
                  var key = keys$1[i$1];
                  if (needKeypath) {
                      //  key 
                      //  keypath
                      //  key 
                      currentKeypath = keypath + RAW_DOT + key;
                      // slice + push  concat 
                      contextStack = oldScopeStack.slice();
                      contextStack.push(new Context(currentKeypath, value, key));
                  }
                  renderChildren(contextStack, value[key], currentKeypath, length, key);
              }
          }
          if (contextStack !== oldScopeStack) {
              contextStack = oldScopeStack;
          }
          if (renderElse && length === 0) {
              renderElse();
          }
      }, renderRange = function (from, to, equal, renderChildren, renderElse) {
          var count = 0, length = 0, currentKeypath = last(contextStack).keypath;
          if (from < to) {
              length = to - from;
              if (equal) {
                  for (var i = from; i <= to; i++) {
                      renderChildren(contextStack, i, currentKeypath, length, count++);
                  }
              }
              else {
                  for (var i$1 = from; i$1 < to; i$1++) {
                      renderChildren(contextStack, i$1, currentKeypath, length, count++);
                  }
              }
          }
          else {
              length = from - to;
              if (equal) {
                  for (var i$2 = from; i$2 >= to; i$2--) {
                      renderChildren(contextStack, i$2, currentKeypath, length, count++);
                  }
              }
              else {
                  for (var i$3 = from; i$3 > to; i$3--) {
                      renderChildren(contextStack, i$3, currentKeypath, length, count++);
                  }
              }
          }
          if (renderElse && length === 0) {
              renderElse();
          }
      }, renderSlot = function (name, parent) {
          addDependency(name);
          var target = rootScope[name];
          if (target) {
              if (target instanceof Computed) {
                  //  slot  renderSlot  parent 
                  //  getter get
                  return parent
                      ? target.getter(parent)
                      : target.get();
              }
              return target;
          }
      }, lookupKeypath = function (stack, index, keypathStr, keypathList, lookup, filter) {
          var defaultResult;
          while (index >= 0) {
              var item = stack[index], currentKeypath = item.getKeypath(keypathStr), result = get(item.getScope(), keypathList);
              var valueHolder = setValueHolder(result ? result.value : UNDEFINED, currentKeypath);
              if (result) {
                  return valueHolder;
              }
              if (!defaultResult) {
                  defaultResult = valueHolder;
              }
              if (lookup && index > 0) {
                  index--;
              }
              else {
                  break;
              }
          }
          return filter
              ? setValueHolder(filter)
              : defaultResult;
      }, lookupProp = function (stack, index, prop, filter) {
          return lookupKeypath(stack, index, prop, [prop], TRUE, filter);
      }, readKeypath = function (value, keypath) {
          var result = get(value, keypath);
          return setValueHolder(result ? result.value : UNDEFINED);
      }, setValueHolder = function (value, keypath) {
          if (value && func(value.get)) {
              value = value.get();
          }
          holder.keypath = keypath;
          holder.value = value;
          if (keypath !== UNDEFINED) {
              addDependency(keypath);
          }
          return holder;
      }, renderTemplate = function (render, scope, keypath, children) {
          render(renderStyleString, renderStyleExpr, renderTransition, renderModel, renderEventMethod, renderEventName, renderDirective, renderSpread, renderEach, renderRange, renderSlot, appendVNodeProperty, formatNumberNativeAttributeValue, formatBooleanNativeAttributeValue, lookupKeypath, lookupProp, readKeypath, setValueHolder, toString, textVNodeOperator, commentVNodeOperator, elementVNodeOperator, componentVNodeOperator, fragmentVNodeOperator, portalVNodeOperator, slotVNodeOperator, instance, logger, filters, globalFilters, directives, globalDirectives, transitions, globalTransitions, contextStack, scope, keypath, children);
      };
      renderTemplate(template, rootScope, rootKeypath, children);
      return children[0];
  }

  var guid$1 = 0, 
  //  IE9 
  // 
  textContent = 'textContent', 
  //  text 
  innerText = textContent, 
  //  html 
  innerHTML = 'innerHTML', cssFloat = 'cssFloat', createEvent = function (event, node) {
      return event;
  }, findElement = function (selector) {
      var node = DOCUMENT.querySelector(selector);
      if (node) {
          return node;
      }
  }, addEventListener = function (node, type, listener) {
      node.addEventListener(type, listener, FALSE);
  }, removeEventListener = function (node, type, listener) {
      node.removeEventListener(type, listener, FALSE);
  }, 
  // IE9  classList
  addElementClass = function (node, className) {
      node.classList.add(className);
  }, removeElementClass = function (node, className) {
      node.classList.remove(className);
  };
  {
      if (DOCUMENT) {
          //  document.body  script  head 
          var testElement = DOCUMENT.documentElement;
          if (!(cssFloat in testElement.style)) {
              cssFloat = 'styleFloat';
          }
          if (!testElement.classList) {
              addElementClass = function (node, className) {
                  var classes = node.className.split(CHAR_WHITESPACE);
                  if (!has$2(classes, className)) {
                      push(classes, className);
                      node.className = join$1(classes, CHAR_WHITESPACE);
                  }
              };
              removeElementClass = function (node, className) {
                  var classes = node.className.split(CHAR_WHITESPACE);
                  if (remove$1(classes, className)) {
                      node.className = join$1(classes, CHAR_WHITESPACE);
                  }
              };
          }
          testElement = UNDEFINED;
      }
  }
  var CHAR_WHITESPACE = ' ', 
  /**
   *  HTML 
   */
  EVENT = '$event', 
  /**
   * 
   */
  COMPOSITION_START = 'compositionstart', 
  /**
   * 
   */
  COMPOSITION_END = 'compositionend', domain = 'http://www.w3.org/', namespaces = {
      svg: domain + '2000/svg',
      // xml: domain + 'XML/1998/namespace',
      // xlink: domain + '1999/xlink',
  }, nativeListenerCount = {}, nativeListeners = {}, customListeners = {}, specialEvents = {};
  specialEvents[EVENT_MODEL] = {
      on: function(node, listener) {
          var locked = FALSE;
          on(node, COMPOSITION_START, listener[COMPOSITION_START] = function () {
              locked = TRUE;
          });
          on(node, COMPOSITION_END, listener[COMPOSITION_END] = function (event) {
              locked = FALSE;
              listener(event);
          });
          addEventListener(node, EVENT_INPUT, listener[EVENT_INPUT] = function (event) {
              if (!locked) {
                  listener(event);
              }
          });
      },
      off: function(node, listener) {
          off(node, COMPOSITION_START, listener[COMPOSITION_START]);
          off(node, COMPOSITION_END, listener[COMPOSITION_END]);
          removeEventListener(node, EVENT_INPUT, listener[EVENT_INPUT]);
          listener[COMPOSITION_START] =
              listener[COMPOSITION_END] =
                  listener[EVENT_INPUT] = UNDEFINED;
      }
  };
  function getBodyElement() {
      return DOCUMENT.body;
  }
  function createElement(tag, isSvg) {
      return isSvg
          ? DOCUMENT.createElementNS(namespaces.svg, tag)
          : DOCUMENT.createElement(tag);
  }
  function createText(text) {
      return DOCUMENT.createTextNode(text);
  }
  function createComment(text) {
      return DOCUMENT.createComment(text);
  }
  function getAttr(node, name) {
      var value = node.getAttribute(name);
      if (value != NULL) {
          return value;
      }
  }
  function setAttr(node, name, value) {
      if (value === UNDEFINED) {
          node.removeAttribute(name);
      }
      else {
          node.setAttribute(name, value);
      }
  }
  function removeAttr(node, name) {
      node.removeAttribute(name);
  }
  //  HTMLElement  node.style 
  function setStyle(style, name, value) {
      if (value == NULL) {
          style[name] = EMPTY_STRING;
          return;
      }
      style[name === 'float' ? cssFloat : name] = value;
  }
  //  HTMLElement  node.style 
  function removeStyle(style, name) {
      style[name] = EMPTY_STRING;
  }
  function before(parentNode, node, beforeNode) {
      parentNode.insertBefore(node, beforeNode);
  }
  function append(parentNode, node) {
      parentNode.appendChild(node);
  }
  function replace(parentNode, node, oldNode) {
      parentNode.replaceChild(node, oldNode);
  }
  function remove(parentNode, node) {
      parentNode.removeChild(node);
  }
  function parent(node) {
      var parentNode = node.parentNode;
      if (parentNode) {
          return parentNode;
      }
  }
  function next(node) {
      var nextSibling = node.nextSibling;
      if (nextSibling) {
          return nextSibling;
      }
  }
  var find = findElement;
  function tag(node) {
      if (node.nodeType === NODE_TYPE_ELEMENT) {
          return lower(node.tagName);
      }
  }
  function getNodeText(node) {
      return node[textContent];
  }
  function setNodeText(node, text) {
      node[textContent] = text;
  }
  function getElementText(node) {
      return node[innerText];
  }
  function setElementText(node, text) {
      node[innerText] = text;
  }
  function getHtml(node) {
      return node[innerHTML];
  }
  function setHtml(node, html) {
      node[innerHTML] = html;
  }
  var addClass = addElementClass;
  var removeClass = removeElementClass;
  function on(node, type, listener) {
      var nativeKey = node[EVENT] || (node[EVENT] = ++guid$1), nativeListenerMap = nativeListeners[nativeKey] || (nativeListeners[nativeKey] = {}), customListenerMap = customListeners[nativeKey] || (customListeners[nativeKey] = {}), customListenerList = customListenerMap[type] || (customListenerMap[type] = []);
      //  native listener
      if (!nativeListenerMap[type]) {
          // 
          var special = specialEvents[type], 
          // 
          nativeListener = function (event) {
              var customEvent;
              if (CustomEvent.is(event)) {
                  customEvent = event;
                  if (customEvent.type !== type) {
                      customEvent.type = type;
                  }
              }
              else {
                  customEvent = new CustomEvent(type, createEvent(event));
              }
              // 
              var listenerList = customListenerList.slice();
              for (var i = 0, length = listenerList.length; i < length; i++) {
                  listenerList[i](customEvent, UNDEFINED, TRUE);
              }
          };
          nativeListenerMap[type] = nativeListener;
          if (nativeListenerCount[nativeKey]) {
              nativeListenerCount[nativeKey]++;
          }
          else {
              nativeListenerCount[nativeKey] = 1;
          }
          if (special) {
              special.on(node, nativeListener);
          }
          else {
              addEventListener(node, type, nativeListener);
          }
      }
      customListenerList.push(listener);
  }
  function off(node, type, listener) {
      var nativeKey = node[EVENT], nativeListenerMap = nativeListeners[nativeKey], customListenerMap = customListeners[nativeKey], customListenerList = customListenerMap && customListenerMap[type];
      if (customListenerList) {
          remove$1(customListenerList, listener);
          if (!customListenerList.length) {
              customListenerList = UNDEFINED;
              delete customListenerMap[type];
          }
      }
      //  type 
      if (nativeListenerMap && nativeListenerMap[type] && !customListenerList) {
          var special = specialEvents[type], nativeListener = nativeListenerMap[type];
          if (special) {
              special.off(node, nativeListener);
          }
          else {
              removeEventListener(node, type, nativeListener);
          }
          delete nativeListenerMap[type];
          if (nativeListenerCount[nativeKey]) {
              nativeListenerCount[nativeKey]--;
          }
      }
      if (!nativeListenerCount[nativeKey]) {
          node[EVENT] = UNDEFINED;
          delete nativeListeners[nativeKey];
          delete customListeners[nativeKey];
      }
  }
  function addSpecialEvent(type, hooks) {
      specialEvents[type] = hooks;
  }

  var domApi = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getBodyElement: getBodyElement,
    createElement: createElement,
    createText: createText,
    createComment: createComment,
    getAttr: getAttr,
    setAttr: setAttr,
    removeAttr: removeAttr,
    setStyle: setStyle,
    removeStyle: removeStyle,
    before: before,
    append: append,
    replace: replace,
    remove: remove,
    parent: parent,
    next: next,
    find: find,
    tag: tag,
    getNodeText: getNodeText,
    setNodeText: setNodeText,
    getElementText: getElementText,
    setElementText: setElementText,
    getHtml: getHtml,
    setHtml: setHtml,
    addClass: addClass,
    removeClass: removeClass,
    on: on,
    off: off,
    addSpecialEvent: addSpecialEvent
  });

  function toNumber (target, defaultValue) {
      return numeric(target)
          ? +target
          : defaultValue !== UNDEFINED
              ? defaultValue
              : 0;
  }

  function readValue (source, keypath) {
      if (source == NULL || keypath === EMPTY_STRING) {
          return source;
      }
      var result = get(source, keypath);
      if (result) {
          return result.value;
      }
  }

  /**
   * 
   *
   * @param newValue
   * @param oldValue
   * @param callback
   */
  function diffString (newValue, oldValue, callback) {
      var newIsString = string$1(newValue), oldIsString = string$1(oldValue);
      if (newIsString || oldIsString) {
          callback(RAW_LENGTH, newIsString ? newValue.length : UNDEFINED, oldIsString ? oldValue.length : UNDEFINED);
          return TRUE;
      }
  }

  /**
   * 
   *
   * @param newValue
   * @param oldValue
   * @param callback
   */
  function diffArray (newValue, oldValue, callback) {
      var newIsArray = array$1(newValue), oldIsArray = array$1(oldValue);
      if (newIsArray || oldIsArray) {
          var newLength = newIsArray ? newValue.length : UNDEFINED, oldLength = oldIsArray ? oldValue.length : UNDEFINED;
          callback(RAW_LENGTH, newLength, oldLength);
          for (var i = 0, length = Math.max(newLength || 0, oldLength || 0); i < length; i++) {
              callback(
              //  number  string
              EMPTY_STRING + i, newIsArray ? newValue[i] : UNDEFINED, oldIsArray ? oldValue[i] : UNDEFINED);
          }
          return TRUE;
      }
  }

  /**
   * 
   *
   * @param newValue
   * @param oldValue
   * @param callback
   */
  function diffObject (newValue, oldValue, callback) {
      var newIsObject = object$1(newValue), oldIsObject = object$1(oldValue);
      if (newIsObject || oldIsObject) {
          var diffed = createPureObject(), newObject = newIsObject ? newValue : EMPTY_OBJECT, oldObject = oldIsObject ? oldValue : EMPTY_OBJECT;
          if (newIsObject) {
              for (var key in newObject) {
                  var value = newObject[key];
                  if (value !== oldObject[key]) {
                      //  oldObject 
                      diffed.set(key, TRUE);
                      callback(key, value, oldObject[key]);
                  }
              }
          }
          if (oldIsObject) {
              for (var key$1 in oldObject) {
                  var value$1 = oldObject[key$1];
                  if (diffed.get(key$1) === UNDEFINED && value$1 !== newObject[key$1]) {
                      callback(key$1, newObject[key$1], value$1);
                  }
              }
          }
      }
  }

  /**
   * 
   */
  function diffRecursion(keypath, newValue, oldValue, fuzzyKeypaths, fuzzyKeypathLength, callback) {
      var diff = function (subKey, subNewValue, subOldValue) {
          if (subNewValue !== subOldValue) {
              var newKeypath = join(keypath, subKey);
              for (var i = 0; i < fuzzyKeypathLength; i++) {
                  var fuzzyKeypath = fuzzyKeypaths[i];
                  if (matchFuzzy(newKeypath, fuzzyKeypath) !== UNDEFINED) {
                      callback(fuzzyKeypath, newKeypath, subNewValue, subOldValue);
                  }
              }
              diffRecursion(newKeypath, subNewValue, subOldValue, fuzzyKeypaths, fuzzyKeypathLength, callback);
          }
      };
      diffString(newValue, oldValue, diff)
          || diffArray(newValue, oldValue, diff)
          || diffObject(newValue, oldValue, diff);
  }

  function diffWatcher (keypath, newValue, oldValue, watcher, isRecursive, callback) {
      var fuzzyKeypaths;
      //  keypath
      for (var watchKeypath in watcher) {
          //  users.*.name
          if (isFuzzy(watchKeypath)) {
              //  users.0 
              // users.0  users.*.name 
              //  users.0  users.*.name 
              // 
              if (matchFuzzy(keypath, watchKeypath) !== UNDEFINED) {
                  callback(watchKeypath, keypath, newValue, oldValue);
              }
              else if (isRecursive) {
                  if (fuzzyKeypaths) {
                      fuzzyKeypaths.push(watchKeypath);
                  }
                  else {
                      fuzzyKeypaths = [watchKeypath];
                  }
              }
          }
          // 
          else {
              //  users.0.name users.0
              var length = match(watchKeypath, keypath);
              if (length >= 0) {
                  var subKeypath = slice(watchKeypath, length), subNewValue = readValue(newValue, subKeypath), subOldValue = readValue(oldValue, subKeypath);
                  if (subNewValue !== subOldValue) {
                      callback(watchKeypath, watchKeypath, subNewValue, subOldValue);
                  }
              }
          }
      }
      // 
      // 
      // 
      if (fuzzyKeypaths) {
          diffRecursion(keypath, newValue, oldValue, fuzzyKeypaths, fuzzyKeypaths.length, callback);
      }
  }

  // 
  var optionsHolder = {
      watcher: EMPTY_FUNCTION,
  };
  /**
   *  watch options
   *
   * @param options
   */
  function formatWatcherOptions (options, immediate) {
      var isWatcher = func(options);
      if (isWatcher) {
          optionsHolder.watcher = options;
          optionsHolder.immediate = immediate === TRUE;
          return optionsHolder;
      }
      return options;
  }

  var guid = 0;
  /**
   * 
   *
   * 1. 
   * 2. 
   *
   * ``
   * 
   *
   *  observer.watch('keypath', listener)
   */
  var Observer = function(data, context, nextTask) {
      var instance = this;
      instance.id = guid++;
      instance.data = data || {};
      instance.context = context || instance;
      instance.nextTask = nextTask || new NextTask();
      instance.syncEmitter = new Emitter();
      instance.asyncEmitter = new Emitter();
      instance.asyncOldValues = {};
      instance.asyncKeypaths = {};
      instance.onComputedChange = function (keypath, newValue, oldValue) {
          instance.diff(keypath, newValue, oldValue);
      };
  };
  /**
   * 
   *
   * @param keypath
   * @param defaultValue
   * @param depIgnore
   * @return
   */
  Observer.prototype.get = function (keypath, defaultValue, depIgnore) {
      var instance = this;
          var data = instance.data;
          var currentComputed = Computed.current;
      //  ''  data
      if (keypath === EMPTY_STRING) {
          return data;
      }
      //  get 
      // 
      if (currentComputed && !depIgnore) {
          currentComputed.addDynamicDep(instance, keypath);
      }
      var result = get(data, keypath);
      return result
          ? result.value
          : defaultValue;
  };
  /**
   * 
   *
   * @param keypath
   * @param value
   */
  Observer.prototype.set = function (keypath, value) {
      var instance = this;
          var data = instance.data;
          var setValue = function (keypath, newValue) {
          var oldValue = instance.get(keypath);
          if (newValue === oldValue) {
              return;
          }
          var next;
          each$1(keypath, function (key, index, lastIndex) {
              if (index === 0) {
                  var item = data[key];
                  if (item && item instanceof Computed) {
                      if (lastIndex === 0) {
                          item.set(newValue);
                      }
                      else {
                          //  next 
                          next = item.get();
                      }
                  }
                  else {
                      if (lastIndex === 0) {
                          data[key] = newValue;
                      }
                      else {
                          next = data[key] || (data[key] = {});
                      }
                  }
                  return;
              }
              if (next) {
                  if (index === lastIndex) {
                      next[key] = newValue;
                  }
                  else {
                      next = next[key] || (next[key] = {});
                  }
              }
          });
          instance.diff(keypath, newValue, oldValue);
      };
      if (string$1(keypath)) {
          setValue(keypath, value);
      }
      else if (object$1(keypath)) {
          for (var key in keypath) {
              setValue(key, keypath[key]);
          }
      }
  };
  /**
   *  diff syncEmitter asyncEmitter
   *
   * @param keypath
   * @param newValue
   * @param oldValue
   */
  Observer.prototype.diff = function (keypath, newValue, oldValue) {
      var instance = this;
          var syncEmitter = instance.syncEmitter;
          var asyncEmitter = instance.asyncEmitter;
          var asyncOldValues = instance.asyncOldValues;
          var asyncKeypaths = instance.asyncKeypaths;
          var isRecursive = codeAt(keypath) !== 36;
      diffWatcher(keypath, newValue, oldValue, syncEmitter.listeners, isRecursive, function (watchKeypath, keypath, newValue, oldValue) {
          syncEmitter.fire({
              type: watchKeypath,
              ns: EMPTY_STRING,
          }, [
              newValue,
              oldValue,
              keypath ]);
      });
      /**
       * 
       *
       * observer.watch('a', function () {})
       *
       * observer.set('a', 1)
       *
       * observer.watch('a', function () {})
       *
       *  watcher 
       */
      diffWatcher(keypath, newValue, oldValue, asyncEmitter.listeners, isRecursive, function (watchKeypath, keypath, newValue, oldValue) {
          // 
          var options = asyncEmitter.listeners[watchKeypath];
          for (var i = 0, length = options.length; i < length; i++) {
              options[i].count++;
          }
          if (!asyncKeypaths[keypath]) {
              asyncOldValues[keypath] = oldValue;
              asyncKeypaths[keypath] = {};
          }
          asyncKeypaths[keypath][watchKeypath] = TRUE;
          if (!instance.pending) {
              instance.pending = TRUE;
              instance.nextTask.append(function () {
                  if (instance.pending) {
                      instance.diffAsync();
                  }
              });
          }
      });
  };
  /**
   *  diff
   */
  Observer.prototype.diffAsync = function () {
      var instance = this;
          var asyncEmitter = instance.asyncEmitter;
          var asyncOldValues = instance.asyncOldValues;
          var asyncKeypaths = instance.asyncKeypaths;
      instance.pending = UNDEFINED;
      instance.asyncOldValues = {};
      instance.asyncKeypaths = {};
      var loop = function ( keypath ) {
          var args = [
              instance.get(keypath),
              asyncOldValues[keypath],
              keypath ], keypaths = asyncKeypaths[keypath], hasChange = args[0] !== args[1], filterWatcher = function (event, args, options) {
              //  count
              //  count
              // count > 0 
              if (options.count) {
                  //  options 
                  //  user.* user.name  user.age
                  //  count 
                  options.count--;
                  // 
                  return hasChange;
              }
          };
          for (var watchKeypath in keypaths) {
              asyncEmitter.fire({
                  type: watchKeypath,
                  ns: EMPTY_STRING,
              }, args, filterWatcher);
          }
      };

          for (var keypath in asyncOldValues) loop( keypath );
  };
  /**
   * 
   *
   * @param keypath
   * @param options
   */
  Observer.prototype.addComputed = function (keypath, options) {
      var instance = this, context = instance.context, cache = TRUE, sync = TRUE, deps, input, getter, setter, output;
      //  bind  this
      //  call(context) 
      if (func(options)) {
          getter = options.bind(context);
      }
      else if (object$1(options)) {
          var computedOptions = options;
          if (boolean(computedOptions.cache)) {
              cache = computedOptions.cache;
          }
          if (boolean(computedOptions.sync)) {
              sync = computedOptions.sync;
          }
          if (array$1(computedOptions.deps)) {
              deps = computedOptions.deps;
          }
          //  0 
          if (!falsy$2(computedOptions.input)) {
              input = computedOptions.input;
          }
          if (func(computedOptions.output)) {
              output = computedOptions.output;
          }
          if (func(computedOptions.get)) {
              getter = computedOptions.get.bind(context);
          }
          if (func(computedOptions.set)) {
              setter = computedOptions.set.bind(context);
          }
      }
      if (getter) {
          var computed = new Computed(keypath, cache, sync, input, output, getter, setter, instance.onComputedChange);
          if (cache && deps) {
              computed.addStaticDeps(instance, deps);
          }
          return instance.data[keypath] = computed;
      }
  };
  /**
   * 
   *
   * @param keypath
   */
  Observer.prototype.removeComputed = function (keypath) {
      delete this.data[keypath];
  };
  /**
   * 
   *
   * @param keypath
   * @param watcher
   * @param immediate
   */
  Observer.prototype.watch = function (keypath, watcher, immediate) {
      var instance = this;
          var context = instance.context;
          var syncEmitter = instance.syncEmitter;
          var asyncEmitter = instance.asyncEmitter;
          var addWatcher = function (keypath, options) {
          var emitter = options.sync ? syncEmitter : asyncEmitter, 
          // formatWatcherOptions  options.watcher 
          listener = {
              ns: EMPTY_STRING,
              listener: options.watcher,
              ctx: context,
              count: 0,
          };
          if (options.once) {
              listener.max = 1;
          }
          emitter.on(keypath, listener);
          if (options.immediate) {
              options.watcher.call(context, instance.get(keypath), UNDEFINED, keypath);
          }
      };
      if (string$1(keypath)) {
          addWatcher(keypath, formatWatcherOptions(watcher, immediate));
      }
      else {
          for (var key in keypath) {
              addWatcher(key, formatWatcherOptions(keypath[key]));
          }
      }
  };
  /**
   * 
   *
   * @param keypath
   * @param watcher
   */
  Observer.prototype.unwatch = function (keypath, watcher) {
      this.syncEmitter.off(keypath, watcher);
      this.asyncEmitter.off(keypath, watcher);
  };
  /**
   *  keypath 
   *
   *  keypath 
   *
   * @param keypath
   * @return 
   */
  Observer.prototype.toggle = function (keypath) {
      var value = !this.get(keypath);
      this.set(keypath, value);
      return value;
  };
  /**
   *  keypath 
   *
   * 
   *
   * @param keypath  0 
   * @param step  1
   * @param max 
   */
  Observer.prototype.increase = function (keypath, step, max) {
      var value = toNumber(this.get(keypath), 0) + (step || 1);
      if (!number(max) || value <= max) {
          this.set(keypath, value);
          return value;
      }
  };
  /**
   *  keypath 
   *
   * 
   *
   * @param keypath  0 
   * @param step  1
   * @param min 
   */
  Observer.prototype.decrease = function (keypath, step, min) {
      var value = toNumber(this.get(keypath), 0) - (step || 1);
      if (!number(min) || value >= min) {
          this.set(keypath, value);
          return value;
      }
  };
  /**
   * 
   *
   * @param keypath
   * @param item
   * @param index
   */
  Observer.prototype.insert = function (keypath, item, index) {
      var list = this.get(keypath);
      list = array$1(list) ? list.slice() : [];
      var length = list.length;
      if (index === TRUE || index === length) {
          list.push(item);
      }
      else if (index === FALSE || index === 0) {
          list.unshift(item);
      }
      else if (index > 0 && index < length) {
          list.splice(index, 0, item);
      }
      else {
          return;
      }
      this.set(keypath, list);
      return TRUE;
  };
  /**
   * 
   *
   * @param keypath
   * @param item
   */
  Observer.prototype.append = function (keypath, item) {
      return this.insert(keypath, item, TRUE);
  };
  /**
   * 
   *
   * @param keypath
   * @param item
   */
  Observer.prototype.prepend = function (keypath, item) {
      return this.insert(keypath, item, FALSE);
  };
  /**
   * 
   *
   * @param keypath
   * @param index
   */
  Observer.prototype.removeAt = function (keypath, index) {
      var list = this.get(keypath);
      if (array$1(list)
          && index >= 0
          && index < list.length) {
          list = list.slice();
          list.splice(index, 1);
          this.set(keypath, list);
          return TRUE;
      }
  };
  /**
   * 
   *
   * @param keypath
   * @param item
   */
  Observer.prototype.remove = function (keypath, item) {
      var list = this.get(keypath);
      if (array$1(list)) {
          list = list.slice();
          if (remove$1(list, item)) {
              this.set(keypath, list);
              return TRUE;
          }
      }
  };
  /**
   * 
   *
   * @param data
   * @param deep
   */
  Observer.prototype.copy = function (data, deep) {
      return copy(data, deep);
  };
  /**
   * 
   */
  Observer.prototype.destroy = function () {
      var instance = this;
      instance.syncEmitter.off();
      instance.asyncEmitter.off();
      instance.nextTask.clear();
      instance.data = {};
  };

  var LifeCycle = function() {
      this.$emitter = new Emitter();
  };
  LifeCycle.prototype.fire = function (component, type, data) {
      this.$emitter.fire(type, [
          component,
          data ]);
  };
  LifeCycle.prototype.on = function (type, listener) {
      this.$emitter.on(type, listener);
      return this;
  };
  LifeCycle.prototype.off = function (type, listener) {
      this.$emitter.off(type, listener);
      return this;
  };
  var globalDirectives = {}, globalTransitions = {}, globalComponents = {}, globalFilters = {}, selectorPattern = /^[#.][-\w+]+$/, lifeCycle = new LifeCycle(), templateComputed = '$$template', templateComputedWatcher = {
      watcher: function(vnode) {
          this.update(vnode, this.$vnode);
      },
      sync: TRUE,
  }, outputSlot = function (vnodes) {
      return vnodes
          ? vnodes.map(clone)
          : vnodes;
  };
  var Yox = function(options) {
      var instance = this, $options = options || EMPTY_OBJECT;
      //  HOOK_BEFORE_CREATE  emitter
      // 
      // 
      instance.$emitter = new Emitter(TRUE);
      if ($options.events) {
          instance.on($options.events);
      }
      {
          // 
          if ($options.parent) {
              instance.$parent = $options.parent;
          }
          // 
          var beforeCreateHook = $options[HOOK_BEFORE_CREATE];
          if (beforeCreateHook) {
              beforeCreateHook.call(instance, $options);
          }
          lifeCycle.fire(instance, HOOK_BEFORE_CREATE, {
              options: $options,
          });
      }
      var data = $options.data;
      var props = $options.props;
      var vnode = $options.vnode;
      var propTypes = $options.propTypes;
      var computed = $options.computed;
      var methods = $options.methods;
      var watchers = $options.watchers;
      var extensions = $options.extensions;
      instance.$options = $options;
      if (extensions) {
          extend(instance, extensions);
      }
      // 
      var source = props ? copy(props) : {};
      {
          if (propTypes) {
              each(propTypes, function (rule, key) {
                  var value = source[key];
                  if (value === UNDEFINED) {
                      value = rule.value;
                      if (value !== UNDEFINED) {
                          source[key] = rule.type === RAW_FUNCTION
                              ? value
                              : func(value)
                                  ? value()
                                  : value;
                      }
                  }
              });
          }
      }
      //  props
      //  data  this.get() 
      var observer = instance.$observer = new Observer(source, instance, instance.$nextTask = new NextTask());
      if (computed) {
          each(computed, function (options, keypath) {
              observer.addComputed(keypath, options);
          });
      }
      var extend$1 = func(data) ? data.call(instance, options) : data;
      if (object$1(extend$1)) {
          each(extend$1, function (value, key) {
              source[key] = value;
          });
      }
      if (methods) {
          each(methods, function (method, name) {
              instance[name] = method;
          });
      }
      {
          var placeholder = UNDEFINED;
          var el = $options.el;
          var root = $options.root;
          var model = $options.model;
          var context = $options.context;
          var replace = $options.replace;
          var template = $options.template;
          var transitions = $options.transitions;
          var components = $options.components;
          var directives = $options.directives;
          var filters = $options.filters;
          var slots = $options.slots;
          if (model) {
              instance.$model = model;
          }
          //  template
          if (string$1(template)) {
              //  html
              if (selectorPattern.test(template)) {
                  placeholder = find(template);
                  if (placeholder) {
                      template = getHtml(placeholder);
                      placeholder = UNDEFINED;
                  }
              }
          }
          //  el
          if (el) {
              if (string$1(el)) {
                  var selector = el;
                  if (selectorPattern.test(selector)) {
                      placeholder = find(selector);
                  }
              }
              else {
                  placeholder = el;
              }
              if (!replace) {
                  append(placeholder, placeholder = createComment(EMPTY_STRING));
              }
          }
          // 
          if (root) {
              instance.$root = root;
          }
          // 
          //  slot $context  $parent
          if (context) {
              instance.$context = context;
          }
          setOptionsSmartly(instance, RAW_TRANSITION, transitions);
          setOptionsSmartly(instance, RAW_COMPONENT, components);
          setOptionsSmartly(instance, RAW_DIRECTIVE, directives);
          setOptionsSmartly(instance, RAW_FILTER, filters);
          if (template) {
              if (watchers) {
                  observer.watch(watchers);
              }
              if (slots) {
                  for (var name in slots) {
                      observer.addComputed(name, {
                          get: slots[name],
                          input: [instance],
                          output: outputSlot,
                      });
                  }
              }
              observer.addComputed(templateComputed, {
                  get: instance.render,
                  sync: FALSE,
              });
              observer.watch(templateComputed, templateComputedWatcher);
              {
                  var afterCreateHook = $options[HOOK_AFTER_CREATE];
                  if (afterCreateHook) {
                      afterCreateHook.call(instance);
                  }
                  lifeCycle.fire(instance, HOOK_AFTER_CREATE);
              }
              // 
              // template  html 
              // template 
              // 
              instance.$template = string$1(template)
                  ? Yox.compile(template)
                  : template;
              if (!vnode) {
                  vnode = create(domApi, placeholder, instance);
              }
              instance.update(instance.get(templateComputed), vnode);
              return;
          }
      }
      if (watchers) {
          observer.watch(watchers);
      }
      {
          var afterCreateHook$1 = $options[HOOK_AFTER_CREATE];
          if (afterCreateHook$1) {
              afterCreateHook$1.call(instance);
          }
          lifeCycle.fire(instance, HOOK_AFTER_CREATE);
      }
  };
  /**
   * 
   */
  Yox.define = function (options) {
      return options;
  };
  /**
   * 
   *
   *  install 
   */
  Yox.use = function (plugin) {
      plugin.install(Yox);
  };
  /**
   *  nextTick
   */
  Yox.nextTick = function (task, context) {
      NextTask.shared().append(task, context);
  };
  /**
   * 
   */
  Yox.compile = function (template, stringify) {
      {
          return template;
      }
  };
  /**
   * 
   */
  Yox.directive = function (name, directive$1) {
      {
          if (string$1(name) && !directive$1) {
              return getResource(globalDirectives, name);
          }
          {
              setResourceSmartly(globalDirectives, name, directive$1);
          }
      }
  };
  /**
   * 
   */
  Yox.transition = function (name, transition$1) {
      {
          if (string$1(name) && !transition$1) {
              return getResource(globalTransitions, name);
          }
          {
              setResourceSmartly(globalTransitions, name, transition$1);
          }
      }
  };
  /**
   * 
   */
  Yox.component = function (name, component$1) {
      {
          if (string$1(name) && !component$1) {
              return getResource(globalComponents, name);
          }
          {
              setResourceSmartly(globalComponents, name, component$1);
          }
      }
  };
  /**
   * 
   */
  Yox.filter = function (name, filter$1) {
      {
          if (string$1(name) && !filter$1) {
              return getResource(globalFilters, name);
          }
          {
              setResourceSmartly(globalFilters, name, filter$1);
          }
      }
  };
  /**
   * 
   */
  Yox.method = function (name, method$1) {
      if (string$1(name) && !method$1) {
          return YoxPrototype[name];
      }
      {
          setResourceSmartly(YoxPrototype, name, method$1);
      }
  };
  /**
   * 
   */
  Yox.prototype.get = function (keypath, defaultValue) {
      return this.$observer.get(keypath, defaultValue);
  };
  /**
   * 
   */
  Yox.prototype.set = function (keypath, value) {
      //  set
      // 
      var ref = this;
          var $observer = ref.$observer;
      if ($observer) {
          $observer.set(keypath, value);
      }
  };
  /**
   * 
   */
  Yox.prototype.on = function (type, listener) {
      addEventSmartly(this, type, listener);
      return this;
  };
  /**
   * 
   */
  Yox.prototype.once = function (type, listener) {
      addEventSmartly(this, type, listener, TRUE);
      return this;
  };
  /**
   * 
   */
  Yox.prototype.off = function (type, listener) {
      this.$emitter.off(type, listener);
      return this;
  };
  /**
   * 
   */
  Yox.prototype.fire = function (type, data, downward) {
      // fire(type)  fire(type, data) 
      // 
      //  Event target 
      var instance = this;
          var $emitter = instance.$emitter;
          var $parent = instance.$parent;
          var $children = instance.$children;
      // 
      var event;
      if (CustomEvent.is(type)) {
          event = type;
      }
      else if (string$1(type)) {
          event = new CustomEvent(type);
      }
      else {
          var emitterEvent = type;
          event = new CustomEvent(emitterEvent.type);
          event.ns = emitterEvent.ns;
      }
      //  fire 
      if (event.ns === UNDEFINED) {
          var emitterEvent$1 = $emitter.toEvent(event.type);
          event.type = emitterEvent$1.type;
          event.ns = emitterEvent$1.ns;
      }
      // 
      if (!event.target) {
          event.target = instance;
      }
      // 
      var args = [event], 
      // 
      isComplete;
      //  fire('name', true) 
      if (object$1(data)) {
          push(args, data);
      }
      else if (data === TRUE) {
          downward = TRUE;
      }
      // 
      // 
      // 
      isComplete = downward && event.target === instance
          ? TRUE
          : $emitter.fire(event, args);
      if (isComplete) {
          if (downward) {
              if ($children) {
                  event.phase = CustomEvent.PHASE_DOWNWARD;
                  each$2($children, function (child) {
                      return isComplete = child.fire(event, data, TRUE);
                  });
              }
          }
          else if ($parent) {
              event.phase = CustomEvent.PHASE_UPWARD;
              isComplete = $parent.fire(event, data);
          }
      }
      return isComplete;
  };
  /**
   * 
   */
  Yox.prototype.watch = function (keypath, watcher, immediate) {
      this.$observer.watch(keypath, watcher, immediate);
      return this;
  };
  /**
   * 
   */
  Yox.prototype.unwatch = function (keypath, watcher) {
      this.$observer.unwatch(keypath, watcher);
      return this;
  };
  /**
   *  callback
   *
   * @param name 
   * @param callback 
   */
  Yox.prototype.loadComponent = function (name, callback) {
      {
          if (!loadComponent(this.$components, name, callback)) {
              {
                  loadComponent(globalComponents, name, callback);
              }
          }
      }
  };
  /**
   * 
   *
   * @param options 
   * @param vnode 
   */
  Yox.prototype.createComponent = function (options, vnode) {
      {
          var instance = this;
          options = copy(options);
          options.root = instance.$root || instance;
          options.parent = instance;
          options.context = vnode.context;
          options.vnode = vnode;
          options.replace = TRUE;
          var props = vnode.props;
              var slots = vnode.slots;
              var model = vnode.model;
          if (model) {
              if (!props) {
                  props = {};
              }
              var key = options.model || MODEL_PROP_DEFAULT;
              props[key] = model.value;
              options.model = key;
          }
          if (props) {
              options.props = props;
          }
          if (slots) {
              options.slots = slots;
          }
          var child = new Yox(options);
          push(instance.$children || (instance.$children = []), child);
          var node = child.$el;
          if (node) {
              vnode.node = node;
          }
          return child;
      }
  };
  /**
   * 
   */
  Yox.prototype.directive = function (name, directive$1) {
      {
          var instance = this;
              var $directives = instance.$directives;
          if (string$1(name) && !directive$1) {
              return getResource($directives, name, Yox.directive);
          }
          {
              setResourceSmartly($directives || (instance.$directives = {}), name, directive$1);
          }
      }
  };
  /**
   * 
   */
  Yox.prototype.transition = function (name, transition$1) {
      {
          var instance = this;
              var $transitions = instance.$transitions;
          if (string$1(name) && !transition$1) {
              return getResource($transitions, name, Yox.transition);
          }
          {
              setResourceSmartly($transitions || (instance.$transitions = {}), name, transition$1);
          }
      }
  };
  /**
   * 
   */
  Yox.prototype.component = function (name, component$1) {
      {
          var instance = this;
              var $components = instance.$components;
          if (string$1(name) && !component$1) {
              return getResource($components, name, Yox.component);
          }
          {
              setResourceSmartly($components || (instance.$components = {}), name, component$1);
          }
      }
  };
  /**
   * 
   */
  Yox.prototype.filter = function (name, filter$1) {
      {
          var instance = this;
              var $filters = instance.$filters;
          if (string$1(name) && !filter$1) {
              return getResource($filters, name, Yox.filter);
          }
          {
              setResourceSmartly($filters || (instance.$filters = {}), name, filter$1);
          }
      }
  };
  /**
   * 
   * 
   */
  Yox.prototype.forceUpdate = function (props) {
      {
          var instance = this;
              var $options = instance.$options;
              var $vnode = instance.$vnode;
              var $nextTask = instance.$nextTask;
          if ($vnode) {
              if (props) {
                  var beforePropsUpdateHook = $options[HOOK_BEFORE_PROPS_UPDATE];
                  if (beforePropsUpdateHook) {
                      beforePropsUpdateHook.call(instance, props);
                  }
                  instance.set(props);
              }
              // 
              $nextTask.run();
              // 
              if (!props && $vnode === instance.$vnode) {
                  instance.update(instance.get(templateComputed), $vnode);
              }
          }
      }
  };
  /**
   *  virtual dom
   */
  Yox.prototype.render = function () {
      {
          var instance = this;
              var $options = instance.$options;
              var $observer = instance.$observer;
              var data = $observer.data;
              var beforeRenderHook = $options[HOOK_BEFORE_RENDER], afterRenderHook = $options[HOOK_AFTER_RENDER];
          if (beforeRenderHook) {
              beforeRenderHook.call(instance, data);
          }
          lifeCycle.fire(instance, HOOK_BEFORE_RENDER, {
              props: data,
          });
          var result = render(instance, instance.$template, data, instance.$filters, globalFilters, instance.$directives, globalDirectives, instance.$transitions, globalTransitions, function (keypath) {
              // Computed.current 
              // 
              var current = Computed.current;
              if (current) {
                  current.addDynamicDep($observer, keypath);
              }
          });
          if (afterRenderHook) {
              afterRenderHook.call(instance);
          }
          lifeCycle.fire(instance, HOOK_AFTER_RENDER);
          return result;
      }
  };
  /**
   *  virtual dom
   *
   * @param vnode
   * @param oldVNode
   */
  Yox.prototype.update = function (vnode, oldVNode) {
      {
          var instance = this;
              var $vnode = instance.$vnode;
              var $options = instance.$options;
              var afterHookName;
          if ($vnode) {
              var beforeUpdateHook = $options[HOOK_BEFORE_UPDATE];
              if (beforeUpdateHook) {
                  beforeUpdateHook.call(instance);
              }
              lifeCycle.fire(instance, HOOK_BEFORE_UPDATE);
              patch(domApi, vnode, oldVNode);
              afterHookName = HOOK_AFTER_UPDATE;
          }
          else {
              var beforeMountHook = $options[HOOK_BEFORE_MOUNT];
              if (beforeMountHook) {
                  beforeMountHook.call(instance);
              }
              lifeCycle.fire(instance, HOOK_BEFORE_MOUNT);
              patch(domApi, vnode, oldVNode);
              instance.$el = vnode.node;
              afterHookName = HOOK_AFTER_MOUNT;
          }
          instance.$vnode = vnode;
          //  nextTask 
          // 
          Yox.nextTick(function () {
              if (instance.$vnode) {
                  var afterHook = $options[afterHookName];
                  if (afterHook) {
                      afterHook.call(instance);
                  }
                  lifeCycle.fire(instance, afterHookName);
              }
          });
      }
  };
  /**
   * 
   *
   * @param props
   */
  Yox.prototype.checkProp = function (key, value) {
  };
  /**
   * 
   */
  Yox.prototype.destroy = function () {
      var instance = this;
          var $parent = instance.$parent;
          var $options = instance.$options;
          var $emitter = instance.$emitter;
          var $observer = instance.$observer;
      {
          var beforeDestroyHook = $options[HOOK_BEFORE_DESTROY];
          if (beforeDestroyHook) {
              beforeDestroyHook.call(instance);
          }
          lifeCycle.fire(instance, HOOK_BEFORE_DESTROY);
          if ($parent && $parent.$children) {
              remove$1($parent.$children, instance);
          }
          var $vnode = instance.$vnode;
          if ($vnode) {
              destroy(domApi, $vnode, !$parent);
          }
      }
      $observer.destroy();
      {
          var afterDestroyHook = $options[HOOK_AFTER_DESTROY];
          if (afterDestroyHook) {
              afterDestroyHook.call(instance);
          }
          lifeCycle.fire(instance, HOOK_AFTER_DESTROY);
      }
      //  after destroy 
      $emitter.off();
      instance.$el = UNDEFINED;
  };
  /**
   *  nextTick
   */
  Yox.prototype.nextTick = function (task) {
      this.$nextTask.append(task, this);
  };
  /**
   *  keypath 
   *
   *  keypath 
   */
  Yox.prototype.toggle = function (keypath) {
      return this.$observer.toggle(keypath);
  };
  /**
   *  keypath 
   *
   * 
   *
   * @param keypath  0 
   * @param step  1
   * @param max 
   */
  Yox.prototype.increase = function (keypath, step, max) {
      return this.$observer.increase(keypath, step, max);
  };
  /**
   *  keypath 
   *
   * 
   *
   * @param keypath  0 
   * @param step  1
   * @param min 
   */
  Yox.prototype.decrease = function (keypath, step, min) {
      return this.$observer.decrease(keypath, step, min);
  };
  /**
   * 
   *
   * @param keypath
   * @param item
   * @param index
   */
  Yox.prototype.insert = function (keypath, item, index) {
      return this.$observer.insert(keypath, item, index);
  };
  /**
   * 
   *
   * @param keypath
   * @param item
   */
  Yox.prototype.append = function (keypath, item) {
      return this.$observer.append(keypath, item);
  };
  /**
   * 
   *
   * @param keypath
   * @param item
   */
  Yox.prototype.prepend = function (keypath, item) {
      return this.$observer.prepend(keypath, item);
  };
  /**
   * 
   *
   * @param keypath
   * @param index
   */
  Yox.prototype.removeAt = function (keypath, index) {
      return this.$observer.removeAt(keypath, index);
  };
  /**
   * 
   *
   * @param keypath
   * @param item
   */
  Yox.prototype.remove = function (keypath, item) {
      return this.$observer.remove(keypath, item);
  };
  /**
   * 
   *
   * @param data
   * @param deep
   */
  Yox.prototype.copy = function (data, deep) {
      return this.$observer.copy(data, deep);
  };
  /**
   * core 
   */
  Yox.version = "1.0.0-alpha.408";
  /**
   * 
   */
  Yox.is = is;
  Yox.dom = domApi;
  Yox.array = array;
  Yox.object = object;
  Yox.string = string;
  Yox.logger = logger;
  Yox.Event = CustomEvent;
  Yox.Emitter = Emitter;
  Yox.lifeCycle = lifeCycle;
  /**
   * 
   */
  Yox.config = PUBLIC_CONFIG;
  var YoxPrototype = Yox.prototype;
  // 
  toObject(keys(YoxPrototype));
  function loadComponent(registry, name, callback) {
      if (registry && registry[name]) {
          var component = registry[name];
          // 
          if (func(component)) {
              registry[name] = [callback];
              var componentCallback = function (result) {
                  var queue = registry[name], options = result['default'] || result;
                  registry[name] = options;
                  each$2(queue, function (callback) {
                      callback(options);
                  });
              }, promise = component(componentCallback);
              if (promise) {
                  promise.then(componentCallback);
              }
          }
          // 
          else if (array$1(component)) {
              push(component, callback);
          }
          // 
          else {
              callback(component);
          }
          return TRUE;
      }
  }
  function getResource(registry, name, lookup) {
      if (registry && registry[name]) {
          return registry[name];
      }
      else if (lookup) {
          return lookup(name);
      }
  }
  function setResourceItem(registry, name, value, options) {
      if (options && options.format) {
          value = options.format(value);
      }
      registry[name] = value;
  }
  function setResourceSmartly(registry, name, value, options) {
      if (string$1(name)) {
          setResourceItem(registry, name, value, options);
      }
      else {
          each(name, function (value, key) {
              setResourceItem(registry, key, value, options);
          });
      }
  }
  function setOptionsSmartly(instance, key, value) {
      if (func(value)) {
          instance[key](value.call(instance));
      }
      else if (object$1(value)) {
          instance[key](value);
      }
  }
  function addEvent(instance, options, once) {
      instance.$emitter.on(options.type, {
          listener: options.listener,
          ns: options.ns,
          max: once ? 1 : -1,
          ctx: instance,
      });
  }
  function addEventSmartly(instance, type, listener, once) {
      var $emitter = instance.$emitter;
      if (string$1(type)) {
          addEvent(instance, $emitter.toFilter(type, listener), once);
      }
      else if (array$1(type)) {
          each$2(type, function (filter) {
              addEvent(instance, filter, once);
          });
      }
      else {
          each(type, function (value, key) {
              addEvent(instance, $emitter.toFilter(key, value), once);
          });
      }
  }

  return Yox;

})));
//# sourceMappingURL=yox.js.map


/***/ }),

/***/ "./src/cheap/asm/memory.asm":
/*!**********************************!*\
  !*** ./src/cheap/asm/memory.asm ***!
  \**********************************/
/***/ ((module) => {

module.exports = "AGFzbQEAAAABKQhgAn9/AGACf34AYAJ/fQBgAn98AGABfwF/YAF/AX5gAX8BfWABfwF8AhIBA2VudgZtZW1vcnkCAwGAgAQDDw4AAAABAgMEBAQEBAUGBweIAQ4Gd3JpdGU4AAAHd3JpdGUxNgABB3dyaXRlMzIAAgd3cml0ZTY0AAMId3JpdGVmMzIABAh3cml0ZWY2NAAFBXJlYWQ4AAYGcmVhZFU4AAcGcmVhZDE2AAgHcmVhZFUxNgAJBnJlYWQzMgAKBnJlYWQ2NAALB3JlYWRmMzIADAdyZWFkZjY0AA0KfQ4JACAAIAE6AAALCQAgACABOwEACwkAIAAgATYCAAsJACAAIAE3AwALCQAgACABOAIACwkAIAAgATkDAAsHACAALAAACwcAIAAtAAALBwAgAC4BAAsHACAALwEACwcAIAAoAgALBwAgACkDAAsHACAAKgIACwcAIAArAwAL";

/***/ }),

/***/ "./src/cheap/thread/asm/atomics.asm":
/*!******************************************!*\
  !*** ./src/cheap/thread/asm/atomics.asm ***!
  \******************************************/
/***/ ((module) => {

module.exports = "AGFzbQEAAAABLAdgAX8Bf2ABfwF+YAJ/fwF/YAJ/fgF+YAN/f38Bf2ADf35+AX5gA39/fgF/AhIBA2VudgZtZW1vcnkCAwGAgAQDKCcAAAABAgICAwICAgMCAgIDAgICAwICAgMCAgIDAgICAwQEBAUCAgYHhgMnBWxvYWQ4AAAGbG9hZDE2AAEGbG9hZDMyAAIGbG9hZDY0AAMGc3RvcmU4AAQHc3RvcmUxNgAFB3N0b3JlMzIABgdzdG9yZTY0AAcEYWRkOAAIBWFkZDE2AAkFYWRkMzIACgVhZGQ2NAALBHN1YjgADAVzdWIxNgANBXN1YjMyAA4Fc3ViNjQADwRhbmQ4ABAFYW5kMTYAEQVhbmQzMgASBWFuZDY0ABMDb3I4ABQEb3IxNgAVBG9yMzIAFgRvcjY0ABcEeG9yOAAYBXhvcjE2ABkFeG9yMzIAGgV4b3I2NAAbCWV4Y2hhbmdlOAAcCmV4Y2hhbmdlMTYAHQpleGNoYW5nZTMyAB4KZXhjaGFuZ2U2NAAfEWNvbXBhcmVfZXhjaGFuZ2U4ACASY29tcGFyZV9leGNoYW5nZTE2ACESY29tcGFyZV9leGNoYW5nZTMyACISY29tcGFyZV9leGNoYW5nZTY0ACMGbm90aWZ5ACQEd2FpdAAlC3dhaXRUaW1lb3V0ACYKugMnCAAgAP4SAAALCAAgAP4TAQALCAAgAP4QAgALCAAgAP4RAwALDAAgACAB/hkAACABCwwAIAAgAf4aAQAgAQsMACAAIAH+FwIAIAELDAAgACAB/hgDACABCwoAIAAgAf4gAAALCgAgACAB/iEBAAsKACAAIAH+HgIACwoAIAAgAf4fAwALCgAgACAB/icAAAsKACAAIAH+KAEACwoAIAAgAf4lAgALCgAgACAB/iYDAAsKACAAIAH+LgAACwoAIAAgAf4vAQALCgAgACAB/iwCAAsKACAAIAH+LQMACwoAIAAgAf41AAALCgAgACAB/jYBAAsKACAAIAH+MwIACwoAIAAgAf40AwALCgAgACAB/jwAAAsKACAAIAH+PQEACwoAIAAgAf46AgALCgAgACAB/jsDAAsKACAAIAH+QwAACwoAIAAgAf5EAQALCgAgACAB/kECAAsKACAAIAH+QgMACwwAIAAgASAC/koAAAsMACAAIAEgAv5LAQALDAAgACABIAL+SAIACwwAIAAgASAC/kkDAAsKACAAIAH+AAIACwwAIAAgAUJ//gECAAsMACAAIAEgAv4BAgAL";

/***/ }),

/***/ "./src/cheap/webassembly/runtime/asm/libc.asm":
/*!****************************************************!*\
  !*** ./src/cheap/webassembly/runtime/asm/libc.asm ***!
  \****************************************************/
/***/ ((module) => {

module.exports = "AGFzbQEAAAABEANgAX8Bf2ABfwBgAn9/AX8CWQYDZW52Bm1lbW9yeQIDAYCABANlbnYGbWFsbG9jAAADZW52BGZyZWUAAQNlbnYGY2FsbG9jAAIDZW52B3JlYWxsb2MAAgNlbnYNYWxpZ25lZF9hbGxvYwACAwYFAAECAgIHMwUGbWFsbG9jAAUEZnJlZQAGBmNhbGxvYwAHB3JlYWxsb2MACAxhbGlnbmVkQWxsb2MACQoqBQYAIAAQAAsGACAAEAELCAAgACABEAILCAAgACABEAMLCAAgACABEAML";

/***/ }),

/***/ "./src/cheap/webassembly/runtime/asm/thread.asm":
/*!******************************************************!*\
  !*** ./src/cheap/webassembly/runtime/asm/thread.asm ***!
  \******************************************************/
/***/ ((module) => {

module.exports = "AGFzbQEAAAABEwNgAX8Bf2ACf38Bf2ADf39/AX8CEgEDZW52Bm1lbW9yeQIDAYCABAMIBwAAAAECAAAHQwcEbG9jawAAB3RyeWxvY2sAAQZ1bmxvY2sAAgR3YWl0AAMJdGltZWR3YWl0AAQGc2lnbmFsAAUJYnJvYWRjYXN0AAYKjgIHVgEBfyAAQQBBAf5IAgAhASABQQBHBEADQCABQQJGBH9BAQUgAEEBQQL+SAIAQQBHCwRAIABBAkJ//gECABoLIABBAEEC/kgCACEBIAFBAEcNAAsLQQALFwAgAEEAQQH+SAIAQQBGBH9BAAVBEAsLIwAgAEEB/iUCAEEBRwRAIABBAP4XAgAgAEEB/gACABoLQQALHQAgACAA/hACACABEAIaQn/+AQIAGiABEAAaQQALKQAgACAA/hACACABEAIaIAIpAwD+AQIAIAEQABpBAkYEf0HwAAVBAAsLFgAgAEEB/h4CABogAEEB/gACABpBAAsaACAAQQH+HgIAGiAAQYCAgIAE/gACABpBAAs=";

/***/ }),

/***/ "./node_modules/ass-compiler/dist/esm/ass-compiler.js":
/*!************************************************************!*\
  !*** ./node_modules/ass-compiler/dist/esm/ass-compiler.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compile: () => (/* binding */ compile)
/* harmony export */ });
/* unused harmony exports decompile, parse, stringify */
function parseEffect(text) {
  var param = text
    .toLowerCase()
    .trim()
    .split(/\s*;\s*/);
  if (param[0] === 'banner') {
    return {
      name: param[0],
      delay: param[1] * 1 || 0,
      leftToRight: param[2] * 1 || 0,
      fadeAwayWidth: param[3] * 1 || 0,
    };
  }
  if (/^scroll\s/.test(param[0])) {
    return {
      name: param[0],
      y1: Math.min(param[1] * 1, param[2] * 1),
      y2: Math.max(param[1] * 1, param[2] * 1),
      delay: param[3] * 1 || 0,
      fadeAwayHeight: param[4] * 1 || 0,
    };
  }
  if (text !== '') {
    return { name: text };
  }
  return null;
}

function parseDrawing(text) {
  if (!text) { return []; }
  return text
    .toLowerCase()
    // numbers
    .replace(/([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)/g, ' $1 ')
    // commands
    .replace(/([mnlbspc])/g, ' $1 ')
    .trim()
    .replace(/\s+/g, ' ')
    .split(/\s(?=[mnlbspc])/)
    .map(function (cmd) { return (
      cmd.split(' ')
        .filter(function (x, i) { return !(i && isNaN(x * 1)); })
    ); });
}

var numTags = [
  'b', 'i', 'u', 's', 'fsp',
  'k', 'K', 'kf', 'ko', 'kt',
  'fe', 'q', 'p', 'pbo', 'a', 'an',
  'fscx', 'fscy', 'fax', 'fay', 'frx', 'fry', 'frz', 'fr',
  'be', 'blur', 'bord', 'xbord', 'ybord', 'shad', 'xshad', 'yshad' ];

var numRegexs = numTags.map(function (nt) { return ({ name: nt, regex: new RegExp(("^" + nt + "-?\\d")) }); });

function parseTag(text) {
  var assign;

  var tag = {};
  for (var i = 0; i < numRegexs.length; i++) {
    var ref = numRegexs[i];
    var name = ref.name;
    var regex = ref.regex;
    if (regex.test(text)) {
      tag[name] = text.slice(name.length) * 1;
      return tag;
    }
  }
  if (/^fn/.test(text)) {
    tag.fn = text.slice(2);
  } else if (/^r/.test(text)) {
    tag.r = text.slice(1);
  } else if (/^fs[\d+-]/.test(text)) {
    tag.fs = text.slice(2);
  } else if (/^\d?c&?H?[0-9a-fA-F]+|^\d?c$/.test(text)) {
    var ref$1 = text.match(/^(\d?)c&?H?(\w*)/);
    var num = ref$1[1];
    var color = ref$1[2];
    tag[("c" + (num || 1))] = color && ("000000" + color).slice(-6);
  } else if (/^\da&?H?[0-9a-fA-F]+/.test(text)) {
    var ref$2 = text.match(/^(\d)a&?H?([0-9a-f]+)/i);
    var num$1 = ref$2[1];
    var alpha = ref$2[2];
    tag[("a" + num$1)] = ("00" + alpha).slice(-2);
  } else if (/^alpha&?H?[0-9a-fA-F]+/.test(text)) {
    (assign = text.match(/^alpha&?H?([0-9a-f]+)/i), tag.alpha = assign[1]);
    tag.alpha = ("00" + (tag.alpha)).slice(-2);
  } else if (/^(?:pos|org|move|fad|fade)\([^)]+/.test(text)) {
    var ref$3 = text.match(/^(\w+)\((.*?)\)?$/);
    var key = ref$3[1];
    var value = ref$3[2];
    tag[key] = value
      .trim()
      .split(/\s*,\s*/)
      .map(Number);
  } else if (/^i?clip\([^)]+/.test(text)) {
    var p = text
      .match(/^i?clip\((.*?)\)?$/)[1]
      .trim()
      .split(/\s*,\s*/);
    tag.clip = {
      inverse: /iclip/.test(text),
      scale: 1,
      drawing: null,
      dots: null,
    };
    if (p.length === 1) {
      tag.clip.drawing = parseDrawing(p[0]);
    }
    if (p.length === 2) {
      tag.clip.scale = p[0] * 1;
      tag.clip.drawing = parseDrawing(p[1]);
    }
    if (p.length === 4) {
      tag.clip.dots = p.map(Number);
    }
  } else if (/^t\(/.test(text)) {
    var p$1 = text
      .match(/^t\((.*?)\)?$/)[1]
      .trim()
      .replace(/\\.*/, function (x) { return x.replace(/,/g, '\n'); })
      .split(/\s*,\s*/);
    if (!p$1[0]) { return tag; }
    tag.t = {
      t1: 0,
      t2: 0,
      accel: 1,
      tags: p$1[p$1.length - 1]
        .replace(/\n/g, ',')
        .split('\\')
        .slice(1)
        .map(parseTag),
    };
    if (p$1.length === 2) {
      tag.t.accel = p$1[0] * 1;
    }
    if (p$1.length === 3) {
      tag.t.t1 = p$1[0] * 1;
      tag.t.t2 = p$1[1] * 1;
    }
    if (p$1.length === 4) {
      tag.t.t1 = p$1[0] * 1;
      tag.t.t2 = p$1[1] * 1;
      tag.t.accel = p$1[2] * 1;
    }
  }

  return tag;
}

function parseTags(text) {
  var tags = [];
  var depth = 0;
  var str = '';
  // `\b\c` -> `b\c\`
  // `a\b\c` -> `b\c\`
  var transText = text.split('\\').slice(1).concat('').join('\\');
  for (var i = 0; i < transText.length; i++) {
    var x = transText[i];
    if (x === '(') { depth++; }
    if (x === ')') { depth--; }
    if (depth < 0) { depth = 0; }
    if (!depth && x === '\\') {
      if (str) {
        tags.push(str);
      }
      str = '';
    } else {
      str += x;
    }
  }
  return tags.map(parseTag);
}

function parseText(text) {
  var pairs = text.split(/{([^{}]*?)}/);
  var parsed = [];
  if (pairs[0].length) {
    parsed.push({ tags: [], text: pairs[0], drawing: [] });
  }
  for (var i = 1; i < pairs.length; i += 2) {
    var tags = parseTags(pairs[i]);
    var isDrawing = tags.reduce(function (v, tag) { return (tag.p === undefined ? v : !!tag.p); }, false);
    parsed.push({
      tags: tags,
      text: isDrawing ? '' : pairs[i + 1],
      drawing: isDrawing ? parseDrawing(pairs[i + 1]) : [],
    });
  }
  return {
    raw: text,
    combined: parsed.map(function (frag) { return frag.text; }).join(''),
    parsed: parsed,
  };
}

function parseTime(time) {
  var t = time.split(':');
  return t[0] * 3600 + t[1] * 60 + t[2] * 1;
}

function parseDialogue(text, format) {
  var fields = text.split(',');
  if (fields.length > format.length) {
    var textField = fields.slice(format.length - 1).join();
    fields = fields.slice(0, format.length - 1);
    fields.push(textField);
  }

  var dia = {};
  for (var i = 0; i < fields.length; i++) {
    var fmt = format[i];
    var fld = fields[i].trim();
    switch (fmt) {
      case 'Layer':
      case 'MarginL':
      case 'MarginR':
      case 'MarginV':
        dia[fmt] = fld * 1;
        break;
      case 'Start':
      case 'End':
        dia[fmt] = parseTime(fld);
        break;
      case 'Effect':
        dia[fmt] = parseEffect(fld);
        break;
      case 'Text':
        dia[fmt] = parseText(fld);
        break;
      default:
        dia[fmt] = fld;
    }
  }

  return dia;
}

var stylesFormat = ['Name', 'Fontname', 'Fontsize', 'PrimaryColour', 'SecondaryColour', 'OutlineColour', 'BackColour', 'Bold', 'Italic', 'Underline', 'StrikeOut', 'ScaleX', 'ScaleY', 'Spacing', 'Angle', 'BorderStyle', 'Outline', 'Shadow', 'Alignment', 'MarginL', 'MarginR', 'MarginV', 'Encoding'];
var eventsFormat = ['Layer', 'Start', 'End', 'Style', 'Name', 'MarginL', 'MarginR', 'MarginV', 'Effect', 'Text'];

function parseFormat(text) {
  var fields = stylesFormat.concat(eventsFormat);
  return text.match(/Format\s*:\s*(.*)/i)[1]
    .split(/\s*,\s*/)
    .map(function (field) {
      var caseField = fields.find(function (f) { return f.toLowerCase() === field.toLowerCase(); });
      return caseField || field;
    });
}

function parseStyle(text, format) {
  var values = text.match(/Style\s*:\s*(.*)/i)[1].split(/\s*,\s*/);
  return Object.assign.apply(Object, [ {} ].concat( format.map(function (fmt, idx) {
    var obj;

    return (( obj = {}, obj[fmt] = values[idx], obj ));
  }) ));
}

function parse(text) {
  var tree = {
    info: {},
    styles: { format: [], style: [] },
    events: { format: [], comment: [], dialogue: [] },
  };
  var lines = text.split(/\r?\n/);
  var state = 0;
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i].trim();
    if (/^;/.test(line)) { continue; }

    if (/^\[Script Info\]/i.test(line)) { state = 1; }
    else if (/^\[V4\+? Styles\]/i.test(line)) { state = 2; }
    else if (/^\[Events\]/i.test(line)) { state = 3; }
    else if (/^\[.*\]/.test(line)) { state = 0; }

    if (state === 0) { continue; }
    if (state === 1) {
      if (/:/.test(line)) {
        var ref = line.match(/(.*?)\s*:\s*(.*)/);
        var key = ref[1];
        var value = ref[2];
        tree.info[key] = value;
      }
    }
    if (state === 2) {
      if (/^Format\s*:/i.test(line)) {
        tree.styles.format = parseFormat(line);
      }
      if (/^Style\s*:/i.test(line)) {
        tree.styles.style.push(parseStyle(line, tree.styles.format));
      }
    }
    if (state === 3) {
      if (/^Format\s*:/i.test(line)) {
        tree.events.format = parseFormat(line);
      }
      if (/^(?:Comment|Dialogue)\s*:/i.test(line)) {
        var ref$1 = line.match(/^(\w+?)\s*:\s*(.*)/i);
        var key$1 = ref$1[1];
        var value$1 = ref$1[2];
        tree.events[key$1.toLowerCase()].push(parseDialogue(value$1, tree.events.format));
      }
    }
  }

  return tree;
}

function stringifyInfo(info) {
  return Object.keys(info).map(function (key) { return (key + ": " + (info[key])); }).join('\n');
}

function pad00(n) {
  return ("00" + n).slice(-2);
}

function stringifyTime(tf) {
  var t = Number.parseFloat(tf.toFixed(2));
  var ms = t.toFixed(2).slice(-2);
  var s = (t | 0) % 60;
  var m = (t / 60 | 0) % 60;
  var h = t / 3600 | 0;
  return (h + ":" + (pad00(m)) + ":" + (pad00(s)) + "." + ms);
}

function stringifyEffect(eff) {
  if (!eff) { return ''; }
  if (eff.name === 'banner') {
    return ("Banner;" + (eff.delay) + ";" + (eff.leftToRight) + ";" + (eff.fadeAwayWidth));
  }
  if (/^scroll\s/.test(eff.name)) {
    return ((eff.name.replace(/^\w/, function (x) { return x.toUpperCase(); })) + ";" + (eff.y1) + ";" + (eff.y2) + ";" + (eff.delay) + ";" + (eff.fadeAwayHeight));
  }
  return eff.name;
}

function stringifyDrawing(drawing) {
  return drawing.map(function (cmds) { return cmds.join(' '); }).join(' ');
}

function stringifyTag(tag) {
  var ref = Object.keys(tag);
  var key = ref[0];
  if (!key) { return ''; }
  var _ = tag[key];
  if (['pos', 'org', 'move', 'fad', 'fade'].some(function (ft) { return ft === key; })) {
    return ("\\" + key + "(" + _ + ")");
  }
  if (/^[ac]\d$/.test(key)) {
    return ("\\" + (key[1]) + (key[0]) + "&H" + _ + "&");
  }
  if (key === 'alpha') {
    return ("\\alpha&H" + _ + "&");
  }
  if (key === 'clip') {
    return ("\\" + (_.inverse ? 'i' : '') + "clip(" + (_.dots || ("" + (_.scale === 1 ? '' : ((_.scale) + ",")) + (stringifyDrawing(_.drawing)))) + ")");
  }
  if (key === 't') {
    return ("\\t(" + ([_.t1, _.t2, _.accel, _.tags.map(stringifyTag).join('')]) + ")");
  }
  return ("\\" + key + _);
}

function stringifyText(Text) {
  return Text.parsed.map(function (ref) {
    var tags = ref.tags;
    var text = ref.text;
    var drawing = ref.drawing;

    var tagText = tags.map(stringifyTag).join('');
    var content = drawing.length ? stringifyDrawing(drawing) : text;
    return ("" + (tagText ? ("{" + tagText + "}") : '') + content);
  }).join('');
}

function stringifyEvent(event, format) {
  return format.map(function (fmt) {
    switch (fmt) {
      case 'Start':
      case 'End':
        return stringifyTime(event[fmt]);
      case 'MarginL':
      case 'MarginR':
      case 'MarginV':
        return event[fmt] || '0000';
      case 'Effect':
        return stringifyEffect(event[fmt]);
      case 'Text':
        return stringifyText(event.Text);
      default:
        return event[fmt];
    }
  }).join();
}

function stringify(ref) {
  var ref$1;

  var info = ref.info;
  var styles = ref.styles;
  var events = ref.events;
  return [
    '[Script Info]',
    stringifyInfo(info),
    '',
    '[V4+ Styles]',
    ("Format: " + (styles.format.join(', '))) ].concat( styles.style.map(function (style) { return ("Style: " + (styles.format.map(function (fmt) { return style[fmt]; }).join())); }),
    [''],
    ['[Events]'],
    [("Format: " + (events.format.join(', ')))],
    (ref$1 = [])
      .concat.apply(ref$1, ['Comment', 'Dialogue'].map(function (type) { return (
        events[type.toLowerCase()].map(function (dia) { return ({
          start: dia.Start,
          end: dia.End,
          string: (type + ": " + (stringifyEvent(dia, events.format))),
        }); })
      ); }))
      .sort(function (a, b) { return (a.start - b.start) || (a.end - b.end); })
      .map(function (x) { return x.string; }),
    [''] ).join('\n');
}

function createCommand(arr) {
  var cmd = {
    type: null,
    prev: null,
    next: null,
    points: [],
  };
  if (/[mnlbs]/.test(arr[0])) {
    cmd.type = arr[0]
      .toUpperCase()
      .replace('N', 'L')
      .replace('B', 'C');
  }
  for (var len = arr.length - !(arr.length & 1), i = 1; i < len; i += 2) {
    cmd.points.push({ x: arr[i] * 1, y: arr[i + 1] * 1 });
  }
  return cmd;
}

function isValid(cmd) {
  if (!cmd.points.length || !cmd.type) {
    return false;
  }
  if (/C|S/.test(cmd.type) && cmd.points.length < 3) {
    return false;
  }
  return true;
}

function getViewBox(commands) {
  var ref;

  var minX = Infinity;
  var minY = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;
  (ref = []).concat.apply(ref, commands.map(function (ref) {
    var points = ref.points;

    return points;
  })).forEach(function (ref) {
    var x = ref.x;
    var y = ref.y;

    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x);
    maxY = Math.max(maxY, y);
  });
  return {
    minX: minX,
    minY: minY,
    width: maxX - minX,
    height: maxY - minY,
  };
}

/**
 * Convert S command to B command
 * Reference from https://github.com/d3/d3/blob/v3.5.17/src/svg/line.js#L259
 * @param  {Array}  points points
 * @param  {String} prev   type of previous command
 * @param  {String} next   type of next command
 * @return {Array}         converted commands
 */
function s2b(points, prev, next) {
  var results = [];
  var bb1 = [0, 2 / 3, 1 / 3, 0];
  var bb2 = [0, 1 / 3, 2 / 3, 0];
  var bb3 = [0, 1 / 6, 2 / 3, 1 / 6];
  var dot4 = function (a, b) { return (a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]); };
  var px = [points[points.length - 1].x, points[0].x, points[1].x, points[2].x];
  var py = [points[points.length - 1].y, points[0].y, points[1].y, points[2].y];
  results.push({
    type: prev === 'M' ? 'M' : 'L',
    points: [{ x: dot4(bb3, px), y: dot4(bb3, py) }],
  });
  for (var i = 3; i < points.length; i++) {
    px = [points[i - 3].x, points[i - 2].x, points[i - 1].x, points[i].x];
    py = [points[i - 3].y, points[i - 2].y, points[i - 1].y, points[i].y];
    results.push({
      type: 'C',
      points: [
        { x: dot4(bb1, px), y: dot4(bb1, py) },
        { x: dot4(bb2, px), y: dot4(bb2, py) },
        { x: dot4(bb3, px), y: dot4(bb3, py) } ],
    });
  }
  if (next === 'L' || next === 'C') {
    var last = points[points.length - 1];
    results.push({ type: 'L', points: [{ x: last.x, y: last.y }] });
  }
  return results;
}

function toSVGPath(instructions) {
  return instructions.map(function (ref) {
    var type = ref.type;
    var points = ref.points;

    return (
    type + points.map(function (ref) {
      var x = ref.x;
      var y = ref.y;

      return (x + "," + y);
    }).join(',')
  );
  }).join('');
}

function compileDrawing(rawCommands) {
  var ref$1;

  var commands = [];
  var i = 0;
  while (i < rawCommands.length) {
    var arr = rawCommands[i];
    var cmd = createCommand(arr);
    if (isValid(cmd)) {
      if (cmd.type === 'S') {
        var ref = (commands[i - 1] || { points: [{ x: 0, y: 0 }] }).points.slice(-1)[0];
        var x = ref.x;
        var y = ref.y;
        cmd.points.unshift({ x: x, y: y });
      }
      if (i) {
        cmd.prev = commands[i - 1].type;
        commands[i - 1].next = cmd.type;
      }
      commands.push(cmd);
      i++;
    } else {
      if (i && commands[i - 1].type === 'S') {
        var additionPoints = {
          p: cmd.points,
          c: commands[i - 1].points.slice(0, 3),
        };
        commands[i - 1].points = commands[i - 1].points.concat(
          (additionPoints[arr[0]] || []).map(function (ref) {
            var x = ref.x;
            var y = ref.y;

            return ({ x: x, y: y });
        })
        );
      }
      rawCommands.splice(i, 1);
    }
  }
  var instructions = (ref$1 = []).concat.apply(
    ref$1, commands.map(function (ref) {
      var type = ref.type;
      var points = ref.points;
      var prev = ref.prev;
      var next = ref.next;

      return (
      type === 'S'
        ? s2b(points, prev, next)
        : { type: type, points: points }
    );
  })
  );

  return Object.assign({ instructions: instructions, d: toSVGPath(instructions) }, getViewBox(commands));
}

var tTags = [
  'fs', 'fsp', 'clip',
  'c1', 'c2', 'c3', 'c4', 'a1', 'a2', 'a3', 'a4', 'alpha',
  'fscx', 'fscy', 'fax', 'fay', 'frx', 'fry', 'frz', 'fr',
  'be', 'blur', 'bord', 'xbord', 'ybord', 'shad', 'xshad', 'yshad' ];

function compileTag(tag, key, presets) {
  var obj, obj$1, obj$2;

  if ( presets === void 0 ) presets = {};
  var value = tag[key];
  if (value === undefined) {
    return null;
  }
  if (key === 'pos' || key === 'org') {
    return value.length === 2 ? ( obj = {}, obj[key] = { x: value[0], y: value[1] }, obj ) : null;
  }
  if (key === 'move') {
    var x1 = value[0];
    var y1 = value[1];
    var x2 = value[2];
    var y2 = value[3];
    var t1 = value[4]; if ( t1 === void 0 ) t1 = 0;
    var t2 = value[5]; if ( t2 === void 0 ) t2 = 0;
    return value.length === 4 || value.length === 6
      ? { move: { x1: x1, y1: y1, x2: x2, y2: y2, t1: t1, t2: t2 } }
      : null;
  }
  if (key === 'fad' || key === 'fade') {
    if (value.length === 2) {
      var t1$1 = value[0];
      var t2$1 = value[1];
      return { fade: { type: 'fad', t1: t1$1, t2: t2$1 } };
    }
    if (value.length === 7) {
      var a1 = value[0];
      var a2 = value[1];
      var a3 = value[2];
      var t1$2 = value[3];
      var t2$2 = value[4];
      var t3 = value[5];
      var t4 = value[6];
      return { fade: { type: 'fade', a1: a1, a2: a2, a3: a3, t1: t1$2, t2: t2$2, t3: t3, t4: t4 } };
    }
    return null;
  }
  if (key === 'clip') {
    var inverse = value.inverse;
    var scale = value.scale;
    var drawing = value.drawing;
    var dots = value.dots;
    if (drawing) {
      return { clip: { inverse: inverse, scale: scale, drawing: compileDrawing(drawing), dots: dots } };
    }
    if (dots) {
      var x1$1 = dots[0];
      var y1$1 = dots[1];
      var x2$1 = dots[2];
      var y2$1 = dots[3];
      return { clip: { inverse: inverse, scale: scale, drawing: drawing, dots: { x1: x1$1, y1: y1$1, x2: x2$1, y2: y2$1 } } };
    }
    return null;
  }
  if (/^[xy]?(bord|shad)$/.test(key)) {
    value = Math.max(value, 0);
  }
  if (key === 'bord') {
    return { xbord: value, ybord: value };
  }
  if (key === 'shad') {
    return { xshad: value, yshad: value };
  }
  if (/^c\d$/.test(key)) {
    return ( obj$1 = {}, obj$1[key] = value || presets[key], obj$1 );
  }
  if (key === 'alpha') {
    return { a1: value, a2: value, a3: value, a4: value };
  }
  if (key === 'fr') {
    return { frz: value };
  }
  if (key === 'fs') {
    return {
      fs: /^\+|-/.test(value)
        ? (value * 1 > -10 ? (1 + value / 10) : 1) * presets.fs
        : value * 1,
    };
  }
  if (key === 'K') {
    return { kf: value };
  }
  if (key === 't') {
    var t1$3 = value.t1;
    var accel = value.accel;
    var tags = value.tags;
    var t2$3 = value.t2 || (presets.end - presets.start) * 1e3;
    var compiledTag = {};
    tags.forEach(function (t) {
      var k = Object.keys(t)[0];
      if (~tTags.indexOf(k) && !(k === 'clip' && !t[k].dots)) {
        Object.assign(compiledTag, compileTag(t, k, presets));
      }
    });
    return { t: { t1: t1$3, t2: t2$3, accel: accel, tag: compiledTag } };
  }
  return ( obj$2 = {}, obj$2[key] = value, obj$2 );
}

var a2an = [
  null, 1, 2, 3,
  null, 7, 8, 9,
  null, 4, 5, 6 ];

var globalTags = ['r', 'a', 'an', 'pos', 'org', 'move', 'fade', 'fad', 'clip'];

function inheritTag(pTag) {
  return JSON.parse(JSON.stringify(Object.assign({}, pTag, {
    k: undefined,
    kf: undefined,
    ko: undefined,
    kt: undefined,
  })));
}

function compileText(ref) {
  var styles = ref.styles;
  var style = ref.style;
  var parsed = ref.parsed;
  var start = ref.start;
  var end = ref.end;

  var alignment;
  var pos;
  var org;
  var move;
  var fade;
  var clip;
  var slices = [];
  var slice = { style: style, fragments: [] };
  var prevTag = {};
  for (var i = 0; i < parsed.length; i++) {
    var ref$1 = parsed[i];
    var tags = ref$1.tags;
    var text = ref$1.text;
    var drawing = ref$1.drawing;
    var reset = (void 0);
    for (var j = 0; j < tags.length; j++) {
      var tag = tags[j];
      reset = tag.r === undefined ? reset : tag.r;
    }
    var fragment = {
      tag: reset === undefined ? inheritTag(prevTag) : {},
      text: text,
      drawing: drawing.length ? compileDrawing(drawing) : null,
    };
    for (var j$1 = 0; j$1 < tags.length; j$1++) {
      var tag$1 = tags[j$1];
      alignment = alignment || a2an[tag$1.a || 0] || tag$1.an;
      pos = pos || compileTag(tag$1, 'pos');
      org = org || compileTag(tag$1, 'org');
      move = move || compileTag(tag$1, 'move');
      fade = fade || compileTag(tag$1, 'fade') || compileTag(tag$1, 'fad');
      clip = compileTag(tag$1, 'clip') || clip;
      var key = Object.keys(tag$1)[0];
      if (key && !~globalTags.indexOf(key)) {
        var sliceTag = styles[style].tag;
        var c1 = sliceTag.c1;
        var c2 = sliceTag.c2;
        var c3 = sliceTag.c3;
        var c4 = sliceTag.c4;
        var fs = prevTag.fs || sliceTag.fs;
        var compiledTag = compileTag(tag$1, key, { start: start, end: end, c1: c1, c2: c2, c3: c3, c4: c4, fs: fs });
        if (key === 't') {
          fragment.tag.t = fragment.tag.t || [];
          fragment.tag.t.push(compiledTag.t);
        } else {
          Object.assign(fragment.tag, compiledTag);
        }
      }
    }
    prevTag = fragment.tag;
    if (reset !== undefined) {
      slices.push(slice);
      slice = { style: styles[reset] ? reset : style, fragments: [] };
    }
    if (fragment.text || fragment.drawing) {
      var prev = slice.fragments[slice.fragments.length - 1] || {};
      if (prev.text && fragment.text && !Object.keys(fragment.tag).length) {
        // merge fragment to previous if its tag is empty
        prev.text += fragment.text;
      } else {
        slice.fragments.push(fragment);
      }
    }
  }
  slices.push(slice);

  return Object.assign({ alignment: alignment, slices: slices }, pos, org, move, fade, clip);
}

function compileDialogues(ref) {
  var styles = ref.styles;
  var dialogues = ref.dialogues;

  var minLayer = Infinity;
  var results = [];
  for (var i = 0; i < dialogues.length; i++) {
    var dia = dialogues[i];
    if (dia.Start >= dia.End) {
      continue;
    }
    if (!styles[dia.Style]) {
      dia.Style = 'Default';
    }
    var stl = styles[dia.Style].style;
    var compiledText = compileText({
      styles: styles,
      style: dia.Style,
      parsed: dia.Text.parsed,
      start: dia.Start,
      end: dia.End,
    });
    var alignment = compiledText.alignment || stl.Alignment;
    minLayer = Math.min(minLayer, dia.Layer);
    results.push(Object.assign({
      layer: dia.Layer,
      start: dia.Start,
      end: dia.End,
      style: dia.Style,
      name: dia.Name,
      // reset style by `\r` will not effect margin and alignment
      margin: {
        left: dia.MarginL || stl.MarginL,
        right: dia.MarginR || stl.MarginR,
        vertical: dia.MarginV || stl.MarginV,
      },
      effect: dia.Effect,
    }, compiledText, { alignment: alignment }));
  }
  for (var i$1 = 0; i$1 < results.length; i$1++) {
    results[i$1].layer -= minLayer;
  }
  return results.sort(function (a, b) { return a.start - b.start || a.end - b.end; });
}

// same as Aegisub
// https://github.com/Aegisub/Aegisub/blob/master/src/ass_style.h
var DEFAULT_STYLE = {
  Name: 'Default',
  Fontname: 'Arial',
  Fontsize: '20',
  PrimaryColour: '&H00FFFFFF&',
  SecondaryColour: '&H000000FF&',
  OutlineColour: '&H00000000&',
  BackColour: '&H00000000&',
  Bold: '0',
  Italic: '0',
  Underline: '0',
  StrikeOut: '0',
  ScaleX: '100',
  ScaleY: '100',
  Spacing: '0',
  Angle: '0',
  BorderStyle: '1',
  Outline: '2',
  Shadow: '2',
  Alignment: '2',
  MarginL: '10',
  MarginR: '10',
  MarginV: '10',
  Encoding: '1',
};

/**
 * @param {String} color
 * @returns {Array} [AA, BBGGRR]
 */
function parseStyleColor(color) {
  if (/^(&|H|&H)[0-9a-f]{6,}/i.test(color)) {
    var ref = color.match(/&?H?([0-9a-f]{2})?([0-9a-f]{6})/i);
    var a = ref[1];
    var c = ref[2];
    return [a || '00', c];
  }
  var num = parseInt(color, 10);
  if (!isNaN(num)) {
    var min = -2147483648;
    var max = 2147483647;
    if (num < min) {
      return ['00', '000000'];
    }
    var aabbggrr = (min <= num && num <= max)
      ? ("00000000" + ((num < 0 ? num + 4294967296 : num).toString(16))).slice(-8)
      : String(num).slice(0, 8);
    return [aabbggrr.slice(0, 2), aabbggrr.slice(2)];
  }
  return ['00', '000000'];
}

function compileStyles(ref) {
  var info = ref.info;
  var style = ref.style;
  var defaultStyle = ref.defaultStyle;

  var result = {};
  var styles = [Object.assign({}, defaultStyle, { Name: 'Default' })].concat(style);
  var loop = function ( i ) {
    var s = Object.assign({}, DEFAULT_STYLE, styles[i]);
    // this behavior is same as Aegisub by black-box testing
    if (/^(\*+)Default$/.test(s.Name)) {
      s.Name = 'Default';
    }
    Object.keys(s).forEach(function (key) {
      if (key !== 'Name' && key !== 'Fontname' && !/Colour/.test(key)) {
        s[key] *= 1;
      }
    });
    var ref$1 = parseStyleColor(s.PrimaryColour);
    var a1 = ref$1[0];
    var c1 = ref$1[1];
    var ref$2 = parseStyleColor(s.SecondaryColour);
    var a2 = ref$2[0];
    var c2 = ref$2[1];
    var ref$3 = parseStyleColor(s.OutlineColour);
    var a3 = ref$3[0];
    var c3 = ref$3[1];
    var ref$4 = parseStyleColor(s.BackColour);
    var a4 = ref$4[0];
    var c4 = ref$4[1];
    var tag = {
      fn: s.Fontname,
      fs: s.Fontsize,
      c1: c1,
      a1: a1,
      c2: c2,
      a2: a2,
      c3: c3,
      a3: a3,
      c4: c4,
      a4: a4,
      b: Math.abs(s.Bold),
      i: Math.abs(s.Italic),
      u: Math.abs(s.Underline),
      s: Math.abs(s.StrikeOut),
      fscx: s.ScaleX,
      fscy: s.ScaleY,
      fsp: s.Spacing,
      frz: s.Angle,
      xbord: s.Outline,
      ybord: s.Outline,
      xshad: s.Shadow,
      yshad: s.Shadow,
      fe: s.Encoding,
      q: /^[0-3]$/.test(info.WrapStyle) ? info.WrapStyle * 1 : 2,
    };
    result[s.Name] = { style: s, tag: tag };
  };

  for (var i = 0; i < styles.length; i++) loop( i );
  return result;
}

function compile(text, options) {
  if ( options === void 0 ) options = {};

  var tree = parse(text);
  var styles = compileStyles({
    info: tree.info,
    style: tree.styles.style,
    defaultStyle: options.defaultStyle || {},
  });
  return {
    info: tree.info,
    width: tree.info.PlayResX * 1 || null,
    height: tree.info.PlayResY * 1 || null,
    collisions: tree.info.Collisions || 'Normal',
    styles: styles,
    dialogues: compileDialogues({
      styles: styles,
      dialogues: tree.events.dialogue,
    }),
  };
}

function decompileStyle(ref) {
  var style = ref.style;
  var tag = ref.tag;

  var obj = Object.assign({}, style, {
    PrimaryColour: ("&H" + (tag.a1) + (tag.c1)),
    SecondaryColour: ("&H" + (tag.a2) + (tag.c2)),
    OutlineColour: ("&H" + (tag.a3) + (tag.c3)),
    BackColour: ("&H" + (tag.a4) + (tag.c4)),
  });
  return ("Style: " + (stylesFormat.map(function (fmt) { return obj[fmt]; }).join()));
}

var drawingInstructionMap = {
  M: 'm',
  L: 'l',
  C: 'b',
};

function decompileDrawing(ref) {
  var instructions = ref.instructions;

  return instructions.map(function (ref) {
    var ref$1;

    var type = ref.type;
    var points = ref.points;
    return (
    (ref$1 = [drawingInstructionMap[type]])
      .concat.apply(ref$1, points.map(function (ref) {
        var x = ref.x;
        var y = ref.y;

        return [x, y];
    }))
      .join(' ')
  );
  }).join(' ');
}

var ca = function (x) { return function (n) { return function (_) { return ("" + n + x + "&H" + _ + "&"); }; }; };
var c = ca('c');
var a = ca('a');

var tagDecompiler = {
  c1: c(1),
  c2: c(2),
  c3: c(3),
  c4: c(4),
  a1: a(1),
  a2: a(2),
  a3: a(3),
  a4: a(4),
  pos: function (_) { return ("pos(" + ([_.x, _.y]) + ")"); },
  org: function (_) { return ("org(" + ([_.x, _.y]) + ")"); },
  move: function (_) { return ("move(" + ([_.x1, _.y1, _.x2, _.y2, _.t1, _.t2]) + ")"); },
  fade: function (_) { return (
    _.type === 'fad'
      ? ("fad(" + ([_.t1, _.t2]) + ")")
      : ("fade(" + ([_.a1, _.a2, _.a3, _.t1, _.t2, _.t3, _.t4]) + ")")
  ); },
  clip: function (_) { return ((_.inverse ? 'i' : '') + "clip(" + (_.dots
      ? ("" + ([_.dots.x1, _.dots.y1, _.dots.x2, _.dots.y2]))
      : ("" + (_.scale === 1 ? '' : ((_.scale) + ",")) + (decompileDrawing(_.drawing)))) + ")"); },
  // eslint-disable-next-line no-use-before-define
  t: function (arr) { return arr.map(function (_) { return ("t(" + ([_.t1, _.t2, _.accel, decompileTag(_.tag)]) + ")"); }).join('\\'); },
};

function decompileTag(tag) {
  return Object.keys(tag).map(function (key) {
    var fn = tagDecompiler[key] || (function (_) { return ("" + key + _); });
    return ("\\" + (fn(tag[key])));
  }).join('');
}

function decompileSlice(slice) {
  return slice.fragments.map(function (ref) {
    var tag = ref.tag;
    var text = ref.text;
    var drawing = ref.drawing;

    var tagText = decompileTag(tag);
    return ("" + (tagText ? ("{" + tagText + "}") : '') + (drawing ? decompileDrawing(drawing) : text));
  }).join('');
}

function decompileText(dia, style) {
  return dia.slices
    .filter(function (slice) { return slice.fragments.length; })
    .map(function (slice, idx) {
      var sliceCopy = JSON.parse(JSON.stringify(slice));
      var tag = {};
      if (idx) {
        tag.r = slice.style === dia.style ? '' : slice.style;
      } else {
        if (style.Alignment !== dia.alignment) {
          tag.an = dia.alignment;
        }
        ['pos', 'org', 'move', 'fade', 'clip'].forEach(function (key) {
          if (dia[key]) {
            tag[key] = dia[key];
          }
        });
      }
      // make sure additional tags are first
      sliceCopy.fragments[0].tag = Object.assign(tag, sliceCopy.fragments[0].tag);
      return sliceCopy;
    })
    .map(decompileSlice)
    .join('');
}

function getMargin(margin, styleMargin) {
  return margin === styleMargin ? '0000' : margin;
}

function decompileDialogue(dia, style) {
  return ("Dialogue: " + ([
    dia.layer,
    stringifyTime(dia.start),
    stringifyTime(dia.end),
    dia.style,
    dia.name,
    getMargin(dia.margin.left, style.MarginL),
    getMargin(dia.margin.right, style.MarginR),
    getMargin(dia.margin.vertical, style.MarginV),
    stringifyEffect(dia.effect),
    decompileText(dia, style) ].join()));
}

function decompile(ref) {
  var info = ref.info;
  var width = ref.width;
  var height = ref.height;
  var collisions = ref.collisions;
  var styles = ref.styles;
  var dialogues = ref.dialogues;

  return [
    '[Script Info]',
    stringifyInfo(Object.assign({}, info, {
      PlayResX: width,
      PlayResY: height,
      Collisions: collisions,
    })),
    '',
    '[V4+ Styles]',
    ("Format: " + (stylesFormat.join(', '))) ].concat( Object.keys(styles).map(function (name) { return decompileStyle(styles[name]); }),
    [''],
    ['[Events]'],
    [("Format: " + (eventsFormat.join(', ')))],
    dialogues
      .sort(function (x, y) { return x.start - y.start || x.end - y.end; })
      .map(function (dia) { return decompileDialogue(dia, styles[dia.style].style); }),
    [''] ).join('\n');
}




/***/ }),

/***/ "./node_modules/ass-compiler/src/compiler/dialogues.js":
/*!*************************************************************!*\
  !*** ./node_modules/ass-compiler/src/compiler/dialogues.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileDialogues: () => (/* binding */ compileDialogues)
/* harmony export */ });
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text.js */ "./node_modules/ass-compiler/src/compiler/text.js");


function compileDialogues({ styles, dialogues }) {
  let minLayer = Infinity;
  const results = [];
  for (let i = 0; i < dialogues.length; i++) {
    const dia = dialogues[i];
    if (dia.Start >= dia.End) {
      continue;
    }
    if (!styles[dia.Style]) {
      dia.Style = 'Default';
    }
    const stl = styles[dia.Style].style;
    const compiledText = (0,_text_js__WEBPACK_IMPORTED_MODULE_0__.compileText)({
      styles,
      style: dia.Style,
      parsed: dia.Text.parsed,
      start: dia.Start,
      end: dia.End,
    });
    const alignment = compiledText.alignment || stl.Alignment;
    minLayer = Math.min(minLayer, dia.Layer);
    results.push(Object.assign({
      layer: dia.Layer,
      start: dia.Start,
      end: dia.End,
      style: dia.Style,
      name: dia.Name,
      // reset style by `\r` will not effect margin and alignment
      margin: {
        left: dia.MarginL || stl.MarginL,
        right: dia.MarginR || stl.MarginR,
        vertical: dia.MarginV || stl.MarginV,
      },
      effect: dia.Effect,
    }, compiledText, { alignment }));
  }
  for (let i = 0; i < results.length; i++) {
    results[i].layer -= minLayer;
  }
  return results.sort((a, b) => a.start - b.start || a.end - b.end);
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/compiler/drawing.js":
/*!***********************************************************!*\
  !*** ./node_modules/ass-compiler/src/compiler/drawing.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileDrawing: () => (/* binding */ compileDrawing)
/* harmony export */ });
/* unused harmony exports s2b, toSVGPath */
function createCommand(arr) {
  const cmd = {
    type: null,
    prev: null,
    next: null,
    points: [],
  };
  if (/[mnlbs]/.test(arr[0])) {
    cmd.type = arr[0]
      .toUpperCase()
      .replace('N', 'L')
      .replace('B', 'C');
  }
  for (let len = arr.length - !(arr.length & 1), i = 1; i < len; i += 2) {
    cmd.points.push({ x: arr[i] * 1, y: arr[i + 1] * 1 });
  }
  return cmd;
}

function isValid(cmd) {
  if (!cmd.points.length || !cmd.type) {
    return false;
  }
  if (/C|S/.test(cmd.type) && cmd.points.length < 3) {
    return false;
  }
  return true;
}

function getViewBox(commands) {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  [].concat(...commands.map(({ points }) => points)).forEach(({ x, y }) => {
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x);
    maxY = Math.max(maxY, y);
  });
  return {
    minX,
    minY,
    width: maxX - minX,
    height: maxY - minY,
  };
}

/**
 * Convert S command to B command
 * Reference from https://github.com/d3/d3/blob/v3.5.17/src/svg/line.js#L259
 * @param  {Array}  points points
 * @param  {String} prev   type of previous command
 * @param  {String} next   type of next command
 * @return {Array}         converted commands
 */
function s2b(points, prev, next) {
  const results = [];
  const bb1 = [0, 2 / 3, 1 / 3, 0];
  const bb2 = [0, 1 / 3, 2 / 3, 0];
  const bb3 = [0, 1 / 6, 2 / 3, 1 / 6];
  const dot4 = (a, b) => (a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]);
  let px = [points[points.length - 1].x, points[0].x, points[1].x, points[2].x];
  let py = [points[points.length - 1].y, points[0].y, points[1].y, points[2].y];
  results.push({
    type: prev === 'M' ? 'M' : 'L',
    points: [{ x: dot4(bb3, px), y: dot4(bb3, py) }],
  });
  for (let i = 3; i < points.length; i++) {
    px = [points[i - 3].x, points[i - 2].x, points[i - 1].x, points[i].x];
    py = [points[i - 3].y, points[i - 2].y, points[i - 1].y, points[i].y];
    results.push({
      type: 'C',
      points: [
        { x: dot4(bb1, px), y: dot4(bb1, py) },
        { x: dot4(bb2, px), y: dot4(bb2, py) },
        { x: dot4(bb3, px), y: dot4(bb3, py) },
      ],
    });
  }
  if (next === 'L' || next === 'C') {
    const last = points[points.length - 1];
    results.push({ type: 'L', points: [{ x: last.x, y: last.y }] });
  }
  return results;
}

function toSVGPath(instructions) {
  return instructions.map(({ type, points }) => (
    type + points.map(({ x, y }) => `${x},${y}`).join(',')
  )).join('');
}

function compileDrawing(rawCommands) {
  const commands = [];
  let i = 0;
  while (i < rawCommands.length) {
    const arr = rawCommands[i];
    const cmd = createCommand(arr);
    if (isValid(cmd)) {
      if (cmd.type === 'S') {
        const { x, y } = (commands[i - 1] || { points: [{ x: 0, y: 0 }] }).points.slice(-1)[0];
        cmd.points.unshift({ x, y });
      }
      if (i) {
        cmd.prev = commands[i - 1].type;
        commands[i - 1].next = cmd.type;
      }
      commands.push(cmd);
      i++;
    } else {
      if (i && commands[i - 1].type === 'S') {
        const additionPoints = {
          p: cmd.points,
          c: commands[i - 1].points.slice(0, 3),
        };
        commands[i - 1].points = commands[i - 1].points.concat(
          (additionPoints[arr[0]] || []).map(({ x, y }) => ({ x, y })),
        );
      }
      rawCommands.splice(i, 1);
    }
  }
  const instructions = [].concat(
    ...commands.map(({ type, points, prev, next }) => (
      type === 'S'
        ? s2b(points, prev, next)
        : { type, points }
    )),
  );

  return Object.assign({ instructions, d: toSVGPath(instructions) }, getViewBox(commands));
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/compiler/styles.js":
/*!**********************************************************!*\
  !*** ./node_modules/ass-compiler/src/compiler/styles.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileStyles: () => (/* binding */ compileStyles)
/* harmony export */ });
/* unused harmony export parseStyleColor */
// same as Aegisub
// https://github.com/Aegisub/Aegisub/blob/master/src/ass_style.h
const DEFAULT_STYLE = {
  Name: 'Default',
  Fontname: 'Arial',
  Fontsize: '20',
  PrimaryColour: '&H00FFFFFF&',
  SecondaryColour: '&H000000FF&',
  OutlineColour: '&H00000000&',
  BackColour: '&H00000000&',
  Bold: '0',
  Italic: '0',
  Underline: '0',
  StrikeOut: '0',
  ScaleX: '100',
  ScaleY: '100',
  Spacing: '0',
  Angle: '0',
  BorderStyle: '1',
  Outline: '2',
  Shadow: '2',
  Alignment: '2',
  MarginL: '10',
  MarginR: '10',
  MarginV: '10',
  Encoding: '1',
};

/**
 * @param {String} color
 * @returns {Array} [AA, BBGGRR]
 */
function parseStyleColor(color) {
  if (/^(&|H|&H)[0-9a-f]{6,}/i.test(color)) {
    const [, a, c] = color.match(/&?H?([0-9a-f]{2})?([0-9a-f]{6})/i);
    return [a || '00', c];
  }
  const num = parseInt(color, 10);
  if (!Number.isNaN(num)) {
    const min = -2147483648;
    const max = 2147483647;
    if (num < min) {
      return ['00', '000000'];
    }
    const aabbggrr = (min <= num && num <= max)
      ? `00000000${(num < 0 ? num + 4294967296 : num).toString(16)}`.slice(-8)
      : String(num).slice(0, 8);
    return [aabbggrr.slice(0, 2), aabbggrr.slice(2)];
  }
  return ['00', '000000'];
}

function compileStyles({ info, style, defaultStyle }) {
  const result = {};
  const styles = [Object.assign({}, defaultStyle, { Name: 'Default' })].concat(style);
  for (let i = 0; i < styles.length; i++) {
    const s = Object.assign({}, DEFAULT_STYLE, styles[i]);
    // this behavior is same as Aegisub by black-box testing
    if (/^(\*+)Default$/.test(s.Name)) {
      s.Name = 'Default';
    }
    Object.keys(s).forEach((key) => {
      if (key !== 'Name' && key !== 'Fontname' && !/Colour/.test(key)) {
        s[key] *= 1;
      }
    });
    const [a1, c1] = parseStyleColor(s.PrimaryColour);
    const [a2, c2] = parseStyleColor(s.SecondaryColour);
    const [a3, c3] = parseStyleColor(s.OutlineColour);
    const [a4, c4] = parseStyleColor(s.BackColour);
    const tag = {
      fn: s.Fontname,
      fs: s.Fontsize,
      c1,
      a1,
      c2,
      a2,
      c3,
      a3,
      c4,
      a4,
      b: Math.abs(s.Bold),
      i: Math.abs(s.Italic),
      u: Math.abs(s.Underline),
      s: Math.abs(s.StrikeOut),
      fscx: s.ScaleX,
      fscy: s.ScaleY,
      fsp: s.Spacing,
      frz: s.Angle,
      xbord: s.Outline,
      ybord: s.Outline,
      xshad: s.Shadow,
      yshad: s.Shadow,
      fe: s.Encoding,
      q: /^[0-3]$/.test(info.WrapStyle) ? info.WrapStyle * 1 : 2,
    };
    result[s.Name] = { style: s, tag };
  }
  return result;
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/compiler/tag.js":
/*!*******************************************************!*\
  !*** ./node_modules/ass-compiler/src/compiler/tag.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileTag: () => (/* binding */ compileTag)
/* harmony export */ });
/* harmony import */ var _drawing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawing.js */ "./node_modules/ass-compiler/src/compiler/drawing.js");


const tTags = [
  'fs', 'fsp', 'clip',
  'c1', 'c2', 'c3', 'c4', 'a1', 'a2', 'a3', 'a4', 'alpha',
  'fscx', 'fscy', 'fax', 'fay', 'frx', 'fry', 'frz', 'fr',
  'be', 'blur', 'bord', 'xbord', 'ybord', 'shad', 'xshad', 'yshad',
];

function compileTag(tag, key, presets = {}) {
  let value = tag[key];
  if (value === undefined) {
    return null;
  }
  if (key === 'pos' || key === 'org') {
    return value.length === 2 ? { [key]: { x: value[0], y: value[1] } } : null;
  }
  if (key === 'move') {
    const [x1, y1, x2, y2, t1 = 0, t2 = 0] = value;
    return value.length === 4 || value.length === 6
      ? { move: { x1, y1, x2, y2, t1, t2 } }
      : null;
  }
  if (key === 'fad' || key === 'fade') {
    if (value.length === 2) {
      const [t1, t2] = value;
      return { fade: { type: 'fad', t1, t2 } };
    }
    if (value.length === 7) {
      const [a1, a2, a3, t1, t2, t3, t4] = value;
      return { fade: { type: 'fade', a1, a2, a3, t1, t2, t3, t4 } };
    }
    return null;
  }
  if (key === 'clip') {
    const { inverse, scale, drawing, dots } = value;
    if (drawing) {
      return { clip: { inverse, scale, drawing: (0,_drawing_js__WEBPACK_IMPORTED_MODULE_0__.compileDrawing)(drawing), dots } };
    }
    if (dots) {
      const [x1, y1, x2, y2] = dots;
      return { clip: { inverse, scale, drawing, dots: { x1, y1, x2, y2 } } };
    }
    return null;
  }
  if (/^[xy]?(bord|shad)$/.test(key)) {
    value = Math.max(value, 0);
  }
  if (key === 'bord') {
    return { xbord: value, ybord: value };
  }
  if (key === 'shad') {
    return { xshad: value, yshad: value };
  }
  if (/^c\d$/.test(key)) {
    return { [key]: value || presets[key] };
  }
  if (key === 'alpha') {
    return { a1: value, a2: value, a3: value, a4: value };
  }
  if (key === 'fr') {
    return { frz: value };
  }
  if (key === 'fs') {
    return {
      fs: /^\+|-/.test(value)
        ? (value * 1 > -10 ? (1 + value / 10) : 1) * presets.fs
        : value * 1,
    };
  }
  if (key === 'K') {
    return { kf: value };
  }
  if (key === 't') {
    const { t1, accel, tags } = value;
    const t2 = value.t2 || (presets.end - presets.start) * 1e3;
    const compiledTag = {};
    tags.forEach((t) => {
      const k = Object.keys(t)[0];
      if (~tTags.indexOf(k) && !(k === 'clip' && !t[k].dots)) {
        Object.assign(compiledTag, compileTag(t, k, presets));
      }
    });
    return { t: { t1, t2, accel, tag: compiledTag } };
  }
  return { [key]: value };
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/compiler/text.js":
/*!********************************************************!*\
  !*** ./node_modules/ass-compiler/src/compiler/text.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileText: () => (/* binding */ compileText)
/* harmony export */ });
/* harmony import */ var _drawing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawing.js */ "./node_modules/ass-compiler/src/compiler/drawing.js");
/* harmony import */ var _tag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tag.js */ "./node_modules/ass-compiler/src/compiler/tag.js");



const a2an = [
  null, 1, 2, 3,
  null, 7, 8, 9,
  null, 4, 5, 6,
];

const globalTags = ['r', 'a', 'an', 'pos', 'org', 'move', 'fade', 'fad', 'clip'];

function inheritTag(pTag) {
  return JSON.parse(JSON.stringify(Object.assign({}, pTag, {
    k: undefined,
    kf: undefined,
    ko: undefined,
    kt: undefined,
  })));
}

function compileText({ styles, style, parsed, start, end }) {
  let alignment;
  let pos;
  let org;
  let move;
  let fade;
  let clip;
  const slices = [];
  let slice = { style, fragments: [] };
  let prevTag = {};
  for (let i = 0; i < parsed.length; i++) {
    const { tags, text, drawing } = parsed[i];
    let reset;
    for (let j = 0; j < tags.length; j++) {
      const tag = tags[j];
      reset = tag.r === undefined ? reset : tag.r;
    }
    const fragment = {
      tag: reset === undefined ? inheritTag(prevTag) : {},
      text,
      drawing: drawing.length ? (0,_drawing_js__WEBPACK_IMPORTED_MODULE_0__.compileDrawing)(drawing) : null,
    };
    for (let j = 0; j < tags.length; j++) {
      const tag = tags[j];
      alignment = alignment || a2an[tag.a || 0] || tag.an;
      pos = pos || (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.compileTag)(tag, 'pos');
      org = org || (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.compileTag)(tag, 'org');
      move = move || (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.compileTag)(tag, 'move');
      fade = fade || (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.compileTag)(tag, 'fade') || (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.compileTag)(tag, 'fad');
      clip = (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.compileTag)(tag, 'clip') || clip;
      const key = Object.keys(tag)[0];
      if (key && !~globalTags.indexOf(key)) {
        const sliceTag = styles[style].tag;
        const { c1, c2, c3, c4 } = sliceTag;
        const fs = prevTag.fs || sliceTag.fs;
        const compiledTag = (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.compileTag)(tag, key, { start, end, c1, c2, c3, c4, fs });
        if (key === 't') {
          fragment.tag.t = fragment.tag.t || [];
          fragment.tag.t.push(compiledTag.t);
        } else {
          Object.assign(fragment.tag, compiledTag);
        }
      }
    }
    prevTag = fragment.tag;
    if (reset !== undefined) {
      slices.push(slice);
      slice = { style: styles[reset] ? reset : style, fragments: [] };
    }
    if (fragment.text || fragment.drawing) {
      const prev = slice.fragments[slice.fragments.length - 1] || {};
      if (prev.text && fragment.text && !Object.keys(fragment.tag).length) {
        // merge fragment to previous if its tag is empty
        prev.text += fragment.text;
      } else {
        slice.fragments.push(fragment);
      }
    }
  }
  slices.push(slice);

  return Object.assign({ alignment, slices }, pos, org, move, fade, clip);
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/parser/drawing.js":
/*!*********************************************************!*\
  !*** ./node_modules/ass-compiler/src/parser/drawing.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseDrawing: () => (/* binding */ parseDrawing)
/* harmony export */ });
function parseDrawing(text) {
  if (!text) return [];
  return text
    .toLowerCase()
    // numbers
    .replace(/([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)/g, ' $1 ')
    // commands
    .replace(/([mnlbspc])/g, ' $1 ')
    .trim()
    .replace(/\s+/g, ' ')
    .split(/\s(?=[mnlbspc])/)
    .map((cmd) => (
      cmd.split(' ')
        .filter((x, i) => !(i && Number.isNaN(x * 1)))
    ));
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/parser/effect.js":
/*!********************************************************!*\
  !*** ./node_modules/ass-compiler/src/parser/effect.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseEffect: () => (/* binding */ parseEffect)
/* harmony export */ });
function parseEffect(text) {
  const param = text
    .toLowerCase()
    .trim()
    .split(/\s*;\s*/);
  if (param[0] === 'banner') {
    return {
      name: param[0],
      delay: param[1] * 1 || 0,
      leftToRight: param[2] * 1 || 0,
      fadeAwayWidth: param[3] * 1 || 0,
    };
  }
  if (/^scroll\s/.test(param[0])) {
    return {
      name: param[0],
      y1: Math.min(param[1] * 1, param[2] * 1),
      y2: Math.max(param[1] * 1, param[2] * 1),
      delay: param[3] * 1 || 0,
      fadeAwayHeight: param[4] * 1 || 0,
    };
  }
  if (text !== '') {
    return { name: text };
  }
  return null;
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/parser/tag.js":
/*!*****************************************************!*\
  !*** ./node_modules/ass-compiler/src/parser/tag.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseTag: () => (/* binding */ parseTag)
/* harmony export */ });
/* harmony import */ var _drawing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawing.js */ "./node_modules/ass-compiler/src/parser/drawing.js");


const numTags = [
  'b', 'i', 'u', 's', 'fsp',
  'k', 'K', 'kf', 'ko', 'kt',
  'fe', 'q', 'p', 'pbo', 'a', 'an',
  'fscx', 'fscy', 'fax', 'fay', 'frx', 'fry', 'frz', 'fr',
  'be', 'blur', 'bord', 'xbord', 'ybord', 'shad', 'xshad', 'yshad',
];

const numRegexs = numTags.map((nt) => ({ name: nt, regex: new RegExp(`^${nt}-?\\d`) }));

function parseTag(text) {
  const tag = {};
  for (let i = 0; i < numRegexs.length; i++) {
    const { name, regex } = numRegexs[i];
    if (regex.test(text)) {
      tag[name] = text.slice(name.length) * 1;
      return tag;
    }
  }
  if (/^fn/.test(text)) {
    tag.fn = text.slice(2);
  } else if (/^r/.test(text)) {
    tag.r = text.slice(1);
  } else if (/^fs[\d+-]/.test(text)) {
    tag.fs = text.slice(2);
  } else if (/^\d?c&?H?[0-9a-fA-F]+|^\d?c$/.test(text)) {
    const [, num, color] = text.match(/^(\d?)c&?H?(\w*)/);
    tag[`c${num || 1}`] = color && `000000${color}`.slice(-6);
  } else if (/^\da&?H?[0-9a-fA-F]+/.test(text)) {
    const [, num, alpha] = text.match(/^(\d)a&?H?([0-9a-f]+)/i);
    tag[`a${num}`] = `00${alpha}`.slice(-2);
  } else if (/^alpha&?H?[0-9a-fA-F]+/.test(text)) {
    [, tag.alpha] = text.match(/^alpha&?H?([0-9a-f]+)/i);
    tag.alpha = `00${tag.alpha}`.slice(-2);
  } else if (/^(?:pos|org|move|fad|fade)\([^)]+/.test(text)) {
    const [, key, value] = text.match(/^(\w+)\((.*?)\)?$/);
    tag[key] = value
      .trim()
      .split(/\s*,\s*/)
      .map(Number);
  } else if (/^i?clip\([^)]+/.test(text)) {
    const p = text
      .match(/^i?clip\((.*?)\)?$/)[1]
      .trim()
      .split(/\s*,\s*/);
    tag.clip = {
      inverse: /iclip/.test(text),
      scale: 1,
      drawing: null,
      dots: null,
    };
    if (p.length === 1) {
      tag.clip.drawing = (0,_drawing_js__WEBPACK_IMPORTED_MODULE_0__.parseDrawing)(p[0]);
    }
    if (p.length === 2) {
      tag.clip.scale = p[0] * 1;
      tag.clip.drawing = (0,_drawing_js__WEBPACK_IMPORTED_MODULE_0__.parseDrawing)(p[1]);
    }
    if (p.length === 4) {
      tag.clip.dots = p.map(Number);
    }
  } else if (/^t\(/.test(text)) {
    const p = text
      .match(/^t\((.*?)\)?$/)[1]
      .trim()
      .replace(/\\.*/, (x) => x.replace(/,/g, '\n'))
      .split(/\s*,\s*/);
    if (!p[0]) return tag;
    tag.t = {
      t1: 0,
      t2: 0,
      accel: 1,
      tags: p[p.length - 1]
        .replace(/\n/g, ',')
        .split('\\')
        .slice(1)
        .map(parseTag),
    };
    if (p.length === 2) {
      tag.t.accel = p[0] * 1;
    }
    if (p.length === 3) {
      tag.t.t1 = p[0] * 1;
      tag.t.t2 = p[1] * 1;
    }
    if (p.length === 4) {
      tag.t.t1 = p[0] * 1;
      tag.t.t2 = p[1] * 1;
      tag.t.accel = p[2] * 1;
    }
  }

  return tag;
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/parser/tags.js":
/*!******************************************************!*\
  !*** ./node_modules/ass-compiler/src/parser/tags.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseTags: () => (/* binding */ parseTags)
/* harmony export */ });
/* harmony import */ var _tag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tag.js */ "./node_modules/ass-compiler/src/parser/tag.js");


function parseTags(text) {
  const tags = [];
  let depth = 0;
  let str = '';
  // `\b\c` -> `b\c\`
  // `a\b\c` -> `b\c\`
  const transText = text.split('\\').slice(1).concat('').join('\\');
  for (let i = 0; i < transText.length; i++) {
    const x = transText[i];
    if (x === '(') depth++;
    if (x === ')') depth--;
    if (depth < 0) depth = 0;
    if (!depth && x === '\\') {
      if (str) {
        tags.push(str);
      }
      str = '';
    } else {
      str += x;
    }
  }
  return tags.map(_tag_js__WEBPACK_IMPORTED_MODULE_0__.parseTag);
}


/***/ }),

/***/ "./node_modules/ass-compiler/src/parser/text.js":
/*!******************************************************!*\
  !*** ./node_modules/ass-compiler/src/parser/text.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseText: () => (/* binding */ parseText)
/* harmony export */ });
/* harmony import */ var _drawing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawing.js */ "./node_modules/ass-compiler/src/parser/drawing.js");
/* harmony import */ var _tags_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tags.js */ "./node_modules/ass-compiler/src/parser/tags.js");



function parseText(text) {
  const pairs = text.split(/{([^{}]*?)}/);
  const parsed = [];
  if (pairs[0].length) {
    parsed.push({ tags: [], text: pairs[0], drawing: [] });
  }
  for (let i = 1; i < pairs.length; i += 2) {
    const tags = (0,_tags_js__WEBPACK_IMPORTED_MODULE_1__.parseTags)(pairs[i]);
    const isDrawing = tags.reduce((v, tag) => (tag.p === undefined ? v : !!tag.p), false);
    parsed.push({
      tags,
      text: isDrawing ? '' : pairs[i + 1],
      drawing: isDrawing ? (0,_drawing_js__WEBPACK_IMPORTED_MODULE_0__.parseDrawing)(pairs[i + 1]) : [],
    });
  }
  return {
    raw: text,
    combined: parsed.map((frag) => frag.text).join(''),
    parsed,
  };
}


/***/ }),

/***/ "./node_modules/assjs/src/internal.js":
/*!********************************************!*\
  !*** ./node_modules/assjs/src/internal.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clear: () => (/* binding */ clear),
/* harmony export */   createResize: () => (/* binding */ createResize)
/* harmony export */ });
/* unused harmony exports createSeek, createPlay, createPause */
/* harmony import */ var _renderer_renderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer/renderer.js */ "./node_modules/assjs/src/renderer/renderer.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/assjs/src/utils.js");
/* eslint-disable no-param-reassign */



function clear(store) {
  const { box } = store;
  while (box.lastChild) {
    box.lastChild.remove();
  }
  store.actives = [];
  store.space = [];
}

function framing(store) {
  const { video, dialogues, actives } = store;
  const vct = video.currentTime - store.delay;
  for (let i = actives.length - 1; i >= 0; i -= 1) {
    const dia = actives[i];
    const { end } = dia;
    if (end < vct) {
      dia.$div.remove();
      actives.splice(i, 1);
    }
  }
  while (
    store.index < dialogues.length
    && vct >= dialogues[store.index].start
  ) {
    if (vct < dialogues[store.index].end) {
      const dia = (0,_renderer_renderer_js__WEBPACK_IMPORTED_MODULE_0__.renderer)(dialogues[store.index], store);
      if (!video.paused) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.batchAnimate)(dia, 'play');
      }
      actives.push(dia);
    }
    store.index += 1;
  }
}

function createSeek(store) {
  return function seek() {
    clear(store);
    const { video, dialogues } = store;
    const vct = video.currentTime - store.delay;
    store.index = (() => {
      for (let i = 0; i < dialogues.length; i += 1) {
        if (vct < dialogues[i].end) {
          return i;
        }
      }
      return (dialogues.length || 1) - 1;
    })();
    framing(store);
  };
}

function createPlay(store) {
  return function play() {
    const frame = () => {
      framing(store);
      store.requestId = requestAnimationFrame(frame);
    };
    cancelAnimationFrame(store.requestId);
    store.requestId = requestAnimationFrame(frame);
    store.actives.forEach((dia) => {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.batchAnimate)(dia, 'play');
    });
  };
}

function createPause(store) {
  return function pause() {
    cancelAnimationFrame(store.requestId);
    store.requestId = 0;
    store.actives.forEach((dia) => {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.batchAnimate)(dia, 'pause');
    });
  };
}

function createResize(that, store) {
  const { video, box, svg, layoutRes } = store;
  return function resize() {
    const cw = video.clientWidth;
    const ch = video.clientHeight;
    const vw = layoutRes.width || video.videoWidth || cw;
    const vh = layoutRes.height || video.videoHeight || ch;
    const sw = store.scriptRes.width;
    const sh = store.scriptRes.height;
    let rw = sw;
    let rh = sh;
    const videoScale = Math.min(cw / vw, ch / vh);
    if (that.resampling === 'video_width') {
      rh = sw / vw * vh;
    }
    if (that.resampling === 'video_height') {
      rw = sh / vh * vw;
    }
    store.scale = Math.min(cw / rw, ch / rh);
    if (that.resampling === 'script_width') {
      store.scale = videoScale * (vw / rw);
    }
    if (that.resampling === 'script_height') {
      store.scale = videoScale * (vh / rh);
    }
    const bw = store.scale * rw;
    const bh = store.scale * rh;
    store.width = bw;
    store.height = bh;
    store.resampledRes = { width: rw, height: rh };

    const cssText = `width:${bw}px;height:${bh}px;top:${(ch - bh) / 2}px;left:${(cw - bw) / 2}px;`;
    box.style.cssText = cssText;
    box.style.setProperty('--ass-scale', store.scale);
    box.style.setProperty('--ass-scale-stroke', store.sbas ? store.scale : 1);
    svg.style.cssText = cssText;

    createSeek(store)();
  };
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/animation.js":
/*!******************************************************!*\
  !*** ./node_modules/assjs/src/renderer/animation.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createAnimatableVars: () => (/* binding */ createAnimatableVars),
/* harmony export */   setKeyframes: () => (/* binding */ setKeyframes)
/* harmony export */ });
/* unused harmony exports createEffectKeyframes, createFadeKeyframes */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/assjs/src/utils.js");
/* harmony import */ var _font_size_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./font-size.js */ "./node_modules/assjs/src/renderer/font-size.js");
/* harmony import */ var _stroke_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stroke.js */ "./node_modules/assjs/src/renderer/stroke.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform.js */ "./node_modules/assjs/src/renderer/transform.js");





// TODO: multi \t can't be merged directly
function mergeT(ts) {
  return ts.reduceRight((results, t) => {
    let merged = false;
    return results
      .map((r) => {
        merged = t.t1 === r.t1 && t.t2 === r.t2 && t.accel === r.accel;
        return { ...r, ...(merged ? { tag: { ...r.tag, ...t.tag } } : {}) };
      })
      .concat(merged ? [] : t);
  }, []);
}

function createEffectKeyframes({ effect, duration }) {
  // TODO: when effect and move both exist, its behavior is weird, for now only move works.
  const { name, delay, leftToRight } = effect;
  if (name === 'banner') {
    const tx = (duration / (delay || 1)) * (leftToRight ? 1 : -1);
    return [0, `calc(var(--ass-scale) * ${tx}px)`].map((x, i) => ({
      offset: i,
      transform: `translateX(${x})`,
    }));
  }
  if (name.startsWith('scroll')) {
    // speed is 1000px/s when delay=1
    const updown = /up/.test(name) ? -1 : 1;
    const y = duration / (delay || 1) * updown;
    return [
      { offset: 0, transform: 'translateY(-100%)' },
      { offset: 1, transform: `translateY(calc(var(--ass-scale) * ${y}px))` },
    ];
  }
  return [];
}

function createMoveKeyframes({ move, duration, dialogue }) {
  const { x1, y1, x2, y2, t1, t2 } = move;
  const t = [t1, t2 || duration];
  const pos = dialogue.pos || { x: 0, y: 0 };
  return [[x1, y1], [x2, y2]]
    .map(([x, y]) => [(x - pos.x), (y - pos.y)])
    .map(([x, y], index) => ({
      offset: Math.min(t[index] / duration, 1),
      transform: `translate(calc(var(--ass-scale) * ${x}px), calc(var(--ass-scale) * ${y}px))`,
    }));
}

function createFadeKeyframes(fade, duration) {
  if (fade.type === 'fad') {
    const { t1, t2 } = fade;
    const kfs = [];
    if (t1) {
      kfs.push([0, 0]);
    }
    if (t1 < duration) {
      if (t2 <= duration) {
        kfs.push([t1 / duration, 1]);
      }
      if (t1 + t2 < duration) {
        kfs.push([(duration - t2) / duration, 1]);
      }
      if (t2 > duration) {
        kfs.push([0, (t2 - duration) / t2]);
      } else if (t1 + t2 > duration) {
        kfs.push([(t1 + 0.5) / duration, 1 - (t1 + t2 - duration) / t2]);
      }
      if (t2) {
        kfs.push([1, 0]);
      }
    } else {
      kfs.push([1, duration / t1]);
    }
    return kfs.map(([offset, opacity]) => ({ offset, opacity }));
  }
  const { a1, a2, a3, t1, t2, t3, t4 } = fade;
  const opacities = [a1, a2, a3].map((a) => 1 - a / 255);
  return [0, t1, t2, t3, t4, duration]
    .map((t) => t / duration)
    .map((t, i) => ({ offset: t, opacity: opacities[i >> 1] }))
    .filter(({ offset }) => offset <= 1);
}

function createTransformKeyframes({ fromTag, tag, fragment }) {
  const toTag = { ...fromTag, ...tag };
  if (fragment.drawing) {
    // scales will be handled inside svg
    Object.assign(toTag, {
      p: 0,
      fscx: ((tag.fscx || fromTag.fscx) / fromTag.fscx) * 100,
      fscy: ((tag.fscy || fromTag.fscy) / fromTag.fscy) * 100,
    });
    Object.assign(fromTag, { fscx: 100, fscy: 100 });
  }
  return Object.fromEntries((0,_transform_js__WEBPACK_IMPORTED_MODULE_3__.createTransform)(toTag));
}

function createAnimatableVars(tag) {
  return [
    ['real-fs', (0,_font_size_js__WEBPACK_IMPORTED_MODULE_1__.getRealFontSize)(tag.fn, tag.fs)],
    ['tag-fs', tag.fs],
    ['tag-fsp', tag.fsp],
    ['fill-color', (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.color2rgba)(tag.a1 + tag.c1)],
  ]
    .filter(([, v]) => v)
    .map(([k, v]) => [`--ass-${k}`, v]);
}

if (window.CSS.registerProperty) {
  ['real-fs', 'tag-fs', 'tag-fsp'].forEach((k) => {
    window.CSS.registerProperty({
      name: `--ass-${k}`,
      syntax: '<number>',
      inherits: true,
      initialValue: '0',
    });
  });
  window.CSS.registerProperty({
    name: '--ass-fill-color',
    syntax: '<color>',
    inherits: true,
    initialValue: 'transparent',
  });
}

// TODO: accel is not implemented yet, maybe it can be simulated by cubic-bezier?
function setKeyframes(dialogue, store) {
  const { start, end, effect, move, fade, slices } = dialogue;
  const duration = (end - start) * 1000;
  const keyframes = [
    ...(effect && !move ? createEffectKeyframes({ effect, duration }) : []),
    ...(move ? createMoveKeyframes({ move, duration, dialogue }) : []),
    ...(fade ? createFadeKeyframes(fade, duration) : []),
  ].sort((a, b) => a.offset - b.offset);
  if (keyframes.length > 0) {
    Object.assign(dialogue, { keyframes });
  }
  slices.forEach((slice) => {
    const sliceTag = store.styles[slice.style].tag;
    slice.fragments.forEach((fragment) => {
      if (!fragment.tag.t || fragment.tag.t.length === 0) {
        return;
      }
      const fromTag = { ...sliceTag, ...fragment.tag };
      const tTags = mergeT(fragment.tag.t).sort((a, b) => a.t2 - b.t2 || a.t1 - b.t1);
      if (tTags[0].t1 > 0) {
        tTags.unshift({ t1: 0, t2: tTags[0].t1, tag: fromTag });
      }
      tTags.reduce((prevTag, curr) => {
        const tag = { ...prevTag, ...curr.tag };
        tag.t = null;
        Object.assign(curr.tag, tag);
        return tag;
      }, {});
      const fDuration = Math.max(duration, ...tTags.map(({ t2 }) => t2));
      const kfs = tTags.map(({ t2, tag }) => ({
        offset: t2 / fDuration,
        ...Object.fromEntries(createAnimatableVars({
          ...tag,
          a1: tag.a1 || fromTag.a1,
          c1: tag.c1 || fromTag.c1,
        })),
        ...Object.fromEntries((0,_stroke_js__WEBPACK_IMPORTED_MODULE_2__.createCSSStroke)(
          { ...fromTag, ...tag },
          store.sbas ? store.scale : 1,
        )),
        ...createTransformKeyframes({ fromTag, tag, fragment }),
      })).sort((a, b) => a.offset - b.offset);
      if (kfs.length > 0) {
        Object.assign(fragment, { keyframes: kfs, duration: fDuration });
      }
    });
  });
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/clip.js":
/*!*************************************************!*\
  !*** ./node_modules/assjs/src/renderer/clip.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getClipPath: () => (/* binding */ getClipPath)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/assjs/src/utils.js");


function addClipPath($defs, clip, id, sw, sh) {
  if ($defs.querySelector(`#${id}`)) return;
  let d = '';
  if (clip.dots !== null) {
    let { x1, y1, x2, y2 } = clip.dots;
    x1 /= sw;
    y1 /= sh;
    x2 /= sw;
    y2 /= sh;
    d = `M${x1},${y1}L${x1},${y2},${x2},${y2},${x2},${y1}Z`;
  }
  if (clip.drawing !== null) {
    d = clip.drawing.instructions.map(({ type, points }) => (
      type + points.map(({ x, y }) => `${x / sw},${y / sh}`).join(',')
    )).join('');
  }
  const scale = 1 / (1 << (clip.scale - 1));
  if (clip.inverse) {
    d += `M0,0L0,${scale},${scale},${scale},${scale},0,0,0Z`;
  }
  const $clipPath = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('clipPath', [
    ['id', id],
    ['clipPathUnits', 'objectBoundingBox'],
  ]);
  $clipPath.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('path', [
    ['d', d],
    ['transform', `scale(${scale})`],
    ['clip-rule', 'evenodd'],
  ]));
  $defs.append($clipPath);
}

function getClipPath(dialogue, store) {
  const { id, clip } = dialogue;
  if (!clip) return {};
  const { width, height } = store.scriptRes;
  addClipPath(store.defs, clip, id, width, height);
  const $clipArea = document.createElement('div');
  store.box.insertBefore($clipArea, dialogue.$div);
  $clipArea.append(dialogue.$div);
  $clipArea.className = 'ASS-clip-area';
  $clipArea.style.clipPath = `url(#${id})`;
  return { $div: $clipArea };
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/dom.js":
/*!************************************************!*\
  !*** ./node_modules/assjs/src/renderer/dom.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDialogue: () => (/* binding */ createDialogue)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/assjs/src/utils.js");
/* harmony import */ var _drawing_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawing.js */ "./node_modules/assjs/src/renderer/drawing.js");
/* harmony import */ var _animation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./animation.js */ "./node_modules/assjs/src/renderer/animation.js");
/* harmony import */ var _stroke_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stroke.js */ "./node_modules/assjs/src/renderer/stroke.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transform.js */ "./node_modules/assjs/src/renderer/transform.js");






function encodeText(text, q) {
  return text
    .replace(/\\h/g, ' ')
    .replace(/\\N/g, '\n')
    .replace(/\\n/g, q === 2 ? '\n' : ' ');
}

function createDialogue(dialogue, store) {
  const { video, styles } = store;
  const $div = document.createElement('div');
  $div.className = 'ASS-dialogue';
  const df = document.createDocumentFragment();
  const { align, slices, start, end } = dialogue;
  [
    ['--ass-align-h', ['left', 'center', 'right'][align.h]],
    ['--ass-align-v', ['bottom', 'center', 'top'][align.v]],
  ].forEach(([k, v]) => {
    $div.style.setProperty(k, v);
  });
  const animationOptions = {
    duration: (end - start) * 1000,
    delay: Math.min(0, start - (video.currentTime - store.delay)) * 1000,
    fill: 'forwards',
  };
  const animations = [];
  slices.forEach((slice) => {
    const sliceTag = styles[slice.style].tag;
    const borderStyle = styles[slice.style].style.BorderStyle;
    slice.fragments.forEach((fragment) => {
      const { text, drawing } = fragment;
      const tag = { ...sliceTag, ...fragment.tag };
      let cssText = '';
      const cssVars = [];
      if (!drawing) {
        cssVars.push(...(0,_animation_js__WEBPACK_IMPORTED_MODULE_2__.createAnimatableVars)(tag));
        const scale = store.sbas ? store.scale : 1;
        cssVars.push(...(0,_stroke_js__WEBPACK_IMPORTED_MODULE_3__.createCSSStroke)(tag, scale));

        cssText += `font-family:"${tag.fn}";`;
        cssText += tag.b ? `font-weight:${tag.b === 1 ? 'bold' : tag.b};` : '';
        cssText += tag.i ? 'font-style:italic;' : '';
        cssText += (tag.u || tag.s) ? `text-decoration:${tag.u ? 'underline' : ''} ${tag.s ? 'line-through' : ''};` : '';
      }
      if (drawing && tag.pbo) {
        const pbo = -tag.pbo * (tag.fscy || 100) / 100;
        cssText += `vertical-align:calc(var(--ass-scale) * ${pbo}px);`;
      }

      cssVars.push(...(0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.createTransform)(tag));
      const tags = [tag, ...(tag.t || []).map((t) => t.tag)];
      const hasRotate = _transform_js__WEBPACK_IMPORTED_MODULE_4__.rotateTags.some((x) => tags.some((t) => t[x]));
      const hasScale = _transform_js__WEBPACK_IMPORTED_MODULE_4__.scaleTags.some((x) => tags.some((t) => t[x] !== undefined && t[x] !== 100));
      const hasSkew = _transform_js__WEBPACK_IMPORTED_MODULE_4__.skewTags.some((x) => tags.some((t) => t[x]));

      encodeText(text, tag.q).split('\n').forEach((content, idx) => {
        const $span = document.createElement('span');
        const $ssspan = document.createElement('span');
        $span.dataset.wrapStyle = tag.q;
        $span.dataset.borderStyle = borderStyle;
        if (hasScale || hasSkew) {
          if (hasScale) {
            $ssspan.dataset.scale = '';
          }
          if (hasSkew) {
            $ssspan.dataset.skew = '';
          }
          $ssspan.textContent = content;
        }
        if (hasRotate) {
          $span.dataset.rotate = '';
        }
        if (drawing) {
          $span.dataset.drawing = '';
          const obj = (0,_drawing_js__WEBPACK_IMPORTED_MODULE_1__.createDrawing)(fragment, sliceTag, store);
          if (!obj) return;
          $span.style.cssText = obj.cssText;
          $span.append(obj.$svg);
        } else {
          $span.dataset.text = '';
          if (idx) {
            df.append(document.createElement('br'));
          }
          if (!content) return;
          if (hasScale || hasSkew) {
            $span.append($ssspan);
          } else {
            $span.textContent = content;
          }
          const el = hasScale || hasSkew ? $ssspan : $span;
          if (tag.xbord || tag.ybord || tag.xshad || tag.yshad) {
            el.dataset.text = content;
          }
        }
        $span.style.cssText += cssText;
        cssVars.forEach(([k, v]) => {
          $span.style.setProperty(k, v);
        });
        if (fragment.keyframes) {
          const animation = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.initAnimation)(
            $span,
            fragment.keyframes,
            { ...animationOptions, duration: fragment.duration },
          );
          animations.push(animation);
        }
        df.append($span);
      });
    });
  });
  if (dialogue.keyframes) {
    animations.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.initAnimation)($div, dialogue.keyframes, animationOptions));
  }
  $div.append(df);
  return { $div, animations };
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/drawing.js":
/*!****************************************************!*\
  !*** ./node_modules/assjs/src/renderer/drawing.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDrawing: () => (/* binding */ createDrawing)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/assjs/src/utils.js");
/* harmony import */ var _stroke_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stroke.js */ "./node_modules/assjs/src/renderer/stroke.js");



function createDrawing(fragment, styleTag, store) {
  if (!fragment.drawing.d) return null;
  const tag = { ...styleTag, ...fragment.tag };
  const { minX, minY, width, height } = fragment.drawing;
  const baseScale = store.scale / (1 << (tag.p - 1));
  const scaleX = (tag.fscx ? tag.fscx / 100 : 1) * baseScale;
  const scaleY = (tag.fscy ? tag.fscy / 100 : 1) * baseScale;
  const blur = tag.blur || tag.be || 0;
  const vbx = tag.xbord + (tag.xshad < 0 ? -tag.xshad : 0) + blur;
  const vby = tag.ybord + (tag.yshad < 0 ? -tag.yshad : 0) + blur;
  const vbw = width * scaleX + 2 * tag.xbord + Math.abs(tag.xshad) + 2 * blur;
  const vbh = height * scaleY + 2 * tag.ybord + Math.abs(tag.yshad) + 2 * blur;
  const $svg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('svg', [
    ['width', vbw],
    ['height', vbh],
    ['viewBox', `${-vbx} ${-vby} ${vbw} ${vbh}`],
  ]);
  const strokeScale = store.sbas ? store.scale : 1;
  const filterId = `ASS-${(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.uuid)()}`;
  const $defs = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('defs');
  $defs.append((0,_stroke_js__WEBPACK_IMPORTED_MODULE_1__.createSVGStroke)(tag, filterId, strokeScale));
  $svg.append($defs);
  const symbolId = `ASS-${(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.uuid)()}`;
  const $symbol = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('symbol', [
    ['id', symbolId],
    ['viewBox', `${minX} ${minY} ${width} ${height}`],
  ]);
  $symbol.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('path', [['d', fragment.drawing.d]]));
  $svg.append($symbol);
  $svg.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('use', [
    ['width', width * scaleX],
    ['height', height * scaleY],
    ['xlink:href', `#${symbolId}`],
    ['filter', `url(#${filterId})`],
  ]));
  $svg.style.cssText = (
    'position:absolute;'
    + `left:${minX * scaleX - vbx}px;`
    + `top:${minY * scaleY - vby}px;`
  );
  return {
    $svg,
    cssText: `position:relative;width:${width * scaleX}px;height:${height * scaleY}px;`,
  };
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/font-size.js":
/*!******************************************************!*\
  !*** ./node_modules/assjs/src/renderer/font-size.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $fixFontSize: () => (/* binding */ $fixFontSize),
/* harmony export */   getRealFontSize: () => (/* binding */ getRealFontSize)
/* harmony export */ });
// https://github.com/weizhenye/ASS/wiki/Font-Size-in-ASS

const $fixFontSize = document.createElement('div');
$fixFontSize.className = 'ASS-fix-font-size';
const $span = document.createElement('span');
$span.textContent = '0';
$fixFontSize.append($span);

const unitsPerEm = 2048;
const lineSpacing = Object.create(null);

function getRealFontSize(fn, fs) {
  if (!lineSpacing[fn]) {
    $span.style.fontFamily = fn;
    lineSpacing[fn] = $span.clientHeight;
  }
  return fs * unitsPerEm / lineSpacing[fn];
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/position.js":
/*!*****************************************************!*\
  !*** ./node_modules/assjs/src/renderer/position.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPosition: () => (/* binding */ getPosition)
/* harmony export */ });
function allocate(dialogue, store) {
  const { video, space, scale } = store;
  const { layer, margin, width, height, alignment, end } = dialogue;
  const stageWidth = store.width - Math.trunc(scale * (margin.left + margin.right));
  const stageHeight = store.height;
  const vertical = Math.trunc(scale * margin.vertical);
  const vct = video.currentTime * 100;
  space[layer] = space[layer] || {
    left: { width: new Uint16Array(stageHeight + 1), end: new Uint32Array(stageHeight + 1) },
    center: { width: new Uint16Array(stageHeight + 1), end: new Uint32Array(stageHeight + 1) },
    right: { width: new Uint16Array(stageHeight + 1), end: new Uint32Array(stageHeight + 1) },
  };
  const channel = space[layer];
  const alignH = ['right', 'left', 'center'][alignment % 3];
  const willCollide = (y) => {
    const lw = channel.left.width[y];
    const cw = channel.center.width[y];
    const rw = channel.right.width[y];
    const le = channel.left.end[y];
    const ce = channel.center.end[y];
    const re = channel.right.end[y];
    return (
      (alignH === 'left' && (
        (le > vct && lw)
        || (ce > vct && cw && 2 * width + cw > stageWidth)
        || (re > vct && rw && width + rw > stageWidth)
      ))
      || (alignH === 'center' && (
        (le > vct && lw && 2 * lw + width > stageWidth)
        || (ce > vct && cw)
        || (re > vct && rw && 2 * rw + width > stageWidth)
      ))
      || (alignH === 'right' && (
        (le > vct && lw && lw + width > stageWidth)
        || (ce > vct && cw && 2 * width + cw > stageWidth)
        || (re > vct && rw)
      ))
    );
  };
  let count = 0;
  let result = 0;
  const find = (y) => {
    count = willCollide(y) ? 0 : count + 1;
    if (count >= height) {
      result = y;
      return true;
    }
    return false;
  };
  if (alignment <= 3) {
    result = stageHeight - vertical - 1;
    for (let i = result; i > vertical; i -= 1) {
      if (find(i)) break;
    }
  } else if (alignment >= 7) {
    result = vertical + 1;
    for (let i = result; i < stageHeight - vertical; i += 1) {
      if (find(i)) break;
    }
  } else {
    result = (stageHeight - height) >> 1;
    for (let i = result; i < stageHeight - vertical; i += 1) {
      if (find(i)) break;
    }
  }
  if (alignment > 3) {
    result -= height - 1;
  }
  for (let i = result; i < result + height; i += 1) {
    channel[alignH].width[i] = width;
    channel[alignH].end[i] = end * 100;
  }
  return result;
}

function getPosition(dialogue, store) {
  const { scale } = store;
  const { effect, move, align, width, height, margin, slices } = dialogue;
  let x = 0;
  let y = 0;
  if (effect && effect.name === 'banner') {
    x = effect.lefttoright ? -width : store.width;
    y = [
      store.height - height - margin.vertical,
      (store.height - height) / 2,
      margin.vertical,
    ][align.v];
  } else if (dialogue.pos || move) {
    const pos = dialogue.pos || { x: 0, y: 0 };
    const sx = scale * pos.x;
    const sy = scale * pos.y;
    x = [sx, sx - width / 2, sx - width][align.h];
    y = [sy - height, sy - height / 2, sy][align.v];
  } else {
    x = [
      0,
      (store.width - width) / 2,
      store.width - width - scale * margin.right,
    ][align.h];
    const hasT = slices.some((slice) => (
      slice.fragments.some(({ keyframes }) => keyframes?.length)
    ));
    y = hasT
      ? [
        store.height - height - margin.vertical,
        (store.height - height) / 2,
        margin.vertical,
      ][align.v]
      : allocate(dialogue, store);
  }
  // TODO: use % for x and y
  return { x, y };
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/renderer.js":
/*!*****************************************************!*\
  !*** ./node_modules/assjs/src/renderer/renderer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   renderer: () => (/* binding */ renderer)
/* harmony export */ });
/* harmony import */ var _clip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clip.js */ "./node_modules/assjs/src/renderer/clip.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom.js */ "./node_modules/assjs/src/renderer/dom.js");
/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./position.js */ "./node_modules/assjs/src/renderer/position.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./style.js */ "./node_modules/assjs/src/renderer/style.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transform.js */ "./node_modules/assjs/src/renderer/transform.js");
/* harmony import */ var _scroll_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scroll.js */ "./node_modules/assjs/src/renderer/scroll.js");







function renderer(dialogue, store) {
  const { $div, animations } = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createDialogue)(dialogue, store);
  Object.assign(dialogue, { $div, animations });
  store.box.append($div);
  const { width } = $div.getBoundingClientRect();
  Object.assign(dialogue, { width });
  $div.style.cssText += (0,_style_js__WEBPACK_IMPORTED_MODULE_3__.createStyle)(dialogue);
  // height may be changed after createStyle
  const { height } = $div.getBoundingClientRect();
  Object.assign(dialogue, { height });
  const { x, y } = (0,_position_js__WEBPACK_IMPORTED_MODULE_2__.getPosition)(dialogue, store);
  Object.assign(dialogue, { x, y });
  $div.style.cssText += `width:${width}px;height:${height}px;left:${x}px;top:${y}px;`;
  (0,_transform_js__WEBPACK_IMPORTED_MODULE_4__.setTransformOrigin)(dialogue, store.scale);
  Object.assign(dialogue, (0,_clip_js__WEBPACK_IMPORTED_MODULE_0__.getClipPath)(dialogue, store));
  if (dialogue.effect?.name?.startsWith('scroll')) {
    Object.assign(dialogue, (0,_scroll_js__WEBPACK_IMPORTED_MODULE_5__.getScrollEffect)(dialogue, store));
  }
  return dialogue;
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/scroll.js":
/*!***************************************************!*\
  !*** ./node_modules/assjs/src/renderer/scroll.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getScrollEffect: () => (/* binding */ getScrollEffect)
/* harmony export */ });
function getScrollEffect(dialogue, store) {
  const $scrollArea = document.createElement('div');
  $scrollArea.className = 'ASS-scroll-area';
  store.box.insertBefore($scrollArea, dialogue.$div);
  $scrollArea.append(dialogue.$div);
  const { height } = store.scriptRes;
  const { name, y1, y2 } = dialogue.effect;
  const min = Math.min(y1, y2);
  const max = Math.max(y1, y2);
  const top = min / height * 100;
  const bottom = (height - max) / height * 100;
  $scrollArea.style.cssText += `top:${top}%;bottom:${bottom}%;`;
  const up = /up/.test(name);
  // eslint-disable-next-line no-param-reassign
  dialogue.$div.style.cssText += up ? 'top:100%;' : 'top:0%;';
  return {
    $div: $scrollArea,
  };
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/stroke.js":
/*!***************************************************!*\
  !*** ./node_modules/assjs/src/renderer/stroke.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createCSSStroke: () => (/* binding */ createCSSStroke),
/* harmony export */   createSVGStroke: () => (/* binding */ createSVGStroke)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/assjs/src/utils.js");


function createSVGStroke(tag, id, scale) {
  const hasBorder = tag.xbord || tag.ybord;
  const hasShadow = tag.xshad || tag.yshad;
  const isOpaque = tag.a1 !== 'FF';
  const blur = tag.blur || tag.be || 0;
  const $filter = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('filter', [['id', id]]);
  $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feGaussianBlur', [
    ['stdDeviation', hasBorder ? 0 : blur],
    ['in', 'SourceGraphic'],
    ['result', 'sg_b'],
  ]));
  $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feFlood', [
    ['flood-color', (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.color2rgba)(tag.a1 + tag.c1)],
    ['result', 'c1'],
  ]));
  $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feComposite', [
    ['operator', 'in'],
    ['in', 'c1'],
    ['in2', 'sg_b'],
    ['result', 'main'],
  ]));
  if (hasBorder) {
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feMorphology', [
      ['radius', `${tag.xbord * scale} ${tag.ybord * scale}`],
      ['operator', 'dilate'],
      ['in', 'SourceGraphic'],
      ['result', 'dil'],
    ]));
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feGaussianBlur', [
      ['stdDeviation', blur],
      ['in', 'dil'],
      ['result', 'dil_b'],
    ]));
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feComposite', [
      ['operator', 'out'],
      ['in', 'dil_b'],
      ['in2', 'SourceGraphic'],
      ['result', 'dil_b_o'],
    ]));
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feFlood', [
      ['flood-color', (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.color2rgba)(tag.a3 + tag.c3)],
      ['result', 'c3'],
    ]));
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feComposite', [
      ['operator', 'in'],
      ['in', 'c3'],
      ['in2', 'dil_b_o'],
      ['result', 'border'],
    ]));
  }
  if (hasShadow && (hasBorder || isOpaque)) {
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feOffset', [
      ['dx', tag.xshad * scale],
      ['dy', tag.yshad * scale],
      ['in', hasBorder ? 'dil' : 'SourceGraphic'],
      ['result', 'off'],
    ]));
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feGaussianBlur', [
      ['stdDeviation', blur],
      ['in', 'off'],
      ['result', 'off_b'],
    ]));
    if (!isOpaque) {
      $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feOffset', [
        ['dx', tag.xshad * scale],
        ['dy', tag.yshad * scale],
        ['in', 'SourceGraphic'],
        ['result', 'sg_off'],
      ]));
      $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feComposite', [
        ['operator', 'out'],
        ['in', 'off_b'],
        ['in2', 'sg_off'],
        ['result', 'off_b_o'],
      ]));
    }
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feFlood', [
      ['flood-color', (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.color2rgba)(tag.a4 + tag.c4)],
      ['result', 'c4'],
    ]));
    $filter.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feComposite', [
      ['operator', 'in'],
      ['in', 'c4'],
      ['in2', isOpaque ? 'off_b' : 'off_b_o'],
      ['result', 'shadow'],
    ]));
  }
  const $merge = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feMerge', []);
  if (hasShadow && (hasBorder || isOpaque)) {
    $merge.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feMergeNode', [['in', 'shadow']]));
  }
  if (hasBorder) {
    $merge.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feMergeNode', [['in', 'border']]));
  }
  $merge.append((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createSVGEl)('feMergeNode', [['in', 'main']]));
  $filter.append($merge);
  return $filter;
}

function get4QuadrantPoints([x, y]) {
  return [[0, 0], [0, 1], [1, 0], [1, 1]]
    .filter(([i, j]) => (i || x) && (j || y))
    .map(([i, j]) => [(i || -1) * x, (j || -1) * y]);
}

function getOffsets(x, y) {
  if (x === y) return [];
  const nx = Math.min(x, y);
  const ny = Math.max(x, y);
  // const offsets = [[nx, ny]];
  // for (let i = 0; i < nx; i++) {
  //   for (let j = Math.round(nx + 0.5); j < ny; j++) {
  //     offsets.push([i, j]);
  //   }
  // }
  // return [].concat(...offsets.map(get4QuadrantPoints));
  return Array.from({ length: Math.ceil(ny) - 1 }, (_, i) => i + 1).concat(ny)
    .map((n) => [(ny - n) / ny * nx, n])
    .map(([i, j]) => (x > y ? [j, i] : [i, j]))
    .flatMap(get4QuadrantPoints);
}

// TODO: a1 === 'ff'
function createCSSStroke(tag, scale) {
  const bc = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.color2rgba)(`00${tag.c3}`);
  const bx = tag.xbord * scale;
  const by = tag.ybord * scale;
  const sc = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.color2rgba)(`00${tag.c4}`);
  const blur = tag.blur || tag.be || 0;
  // TODO: is there any way to remove this hack?
  const deltaOffsets = getOffsets(bx, by);
  return [
    ['border-width', `${Math.min(bx, by) * 2}px`],
    ['border-color', bc],
    ['border-opacity', (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.alpha2opacity)(tag.a3)],
    ['border-delta', deltaOffsets.map(([x, y]) => `${x}px ${y}px ${bc}`).join(',')],
    ['shadow-color', sc],
    ['shadow-opacity', (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.alpha2opacity)(tag.a4)],
    ['shadow-delta', deltaOffsets.map(([x, y]) => `${x}px ${y}px ${sc}`).join(',')],
    ['tag-blur', blur],
    ['tag-xbord', tag.xbord],
    ['tag-ybord', tag.ybord],
    ['tag-xshad', tag.xshad],
    ['tag-yshad', tag.yshad],
  ].map(([k, v]) => [`--ass-${k}`, v]);
}

if (window.CSS.registerProperty) {
  window.CSS.registerProperty({
    name: '--ass-border-width',
    syntax: '<length>',
    inherits: true,
    initialValue: '0px',
  });
  ['border-color', 'shadow-color'].forEach((k) => {
    window.CSS.registerProperty({
      name: `--ass-${k}`,
      syntax: '<color>',
      inherits: true,
      initialValue: 'transparent',
    });
  });
  ['border-opacity', 'shadow-opacity'].forEach((k) => {
    window.CSS.registerProperty({
      name: `--ass-${k}`,
      syntax: '<number>',
      inherits: true,
      initialValue: '1',
    });
  });
  ['blur', 'xbord', 'ybord', 'xshad', 'yshad'].forEach((k) => {
    window.CSS.registerProperty({
      name: `--ass-tag-${k}`,
      syntax: '<number>',
      inherits: true,
      initialValue: '0',
    });
  });
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/style.js":
/*!**************************************************!*\
  !*** ./node_modules/assjs/src/renderer/style.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createStyle: () => (/* binding */ createStyle)
/* harmony export */ });
function createStyle(dialogue) {
  const { layer, align, effect, pos, margin } = dialogue;
  let cssText = '';
  if (layer) cssText += `z-index:${layer};`;
  cssText += `text-align:${['left', 'center', 'right'][align.h]};`;
  if (!effect) {
    cssText += `max-width:calc(100% - var(--ass-scale) * ${margin.left + margin.right}px);`;
    if (!pos) {
      if (align.h !== 0) {
        cssText += `margin-right:calc(var(--ass-scale) * ${margin.right}px);`;
      }
      if (align.h !== 2) {
        cssText += `margin-left:calc(var(--ass-scale) * ${margin.left}px);`;
      }
    }
  }
  return cssText;
}


/***/ }),

/***/ "./node_modules/assjs/src/renderer/transform.js":
/*!******************************************************!*\
  !*** ./node_modules/assjs/src/renderer/transform.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createTransform: () => (/* binding */ createTransform),
/* harmony export */   rotateTags: () => (/* binding */ rotateTags),
/* harmony export */   scaleTags: () => (/* binding */ scaleTags),
/* harmony export */   setTransformOrigin: () => (/* binding */ setTransformOrigin),
/* harmony export */   skewTags: () => (/* binding */ skewTags)
/* harmony export */ });
const rotateTags = ['frx', 'fry', 'frz'];
const scaleTags = ['fscx', 'fscy'];
const skewTags = ['fax', 'fay'];

if (window.CSS.registerProperty) {
  [...rotateTags, ...skewTags].forEach((tag) => {
    window.CSS.registerProperty({
      name: `--ass-tag-${tag}`,
      syntax: '<number>',
      inherits: true,
      initialValue: 0,
    });
  });
  scaleTags.forEach((tag) => {
    window.CSS.registerProperty({
      name: `--ass-tag-${tag}`,
      syntax: '<number>',
      inherits: true,
      initialValue: 1,
    });
  });
}

function createTransform(tag) {
  return [
    ...[...rotateTags, ...skewTags].map((x) => ([`--ass-tag-${x}`, `${tag[x] || 0}`])),
    ...scaleTags.map((x) => ([`--ass-tag-${x}`, tag.p ? 1 : (tag[x] || 100) / 100])),
  ];
}

function setTransformOrigin(dialogue, scale) {
  const { align, width, height, x, y, $div } = dialogue;
  const org = {};
  if (dialogue.org) {
    org.x = dialogue.org.x * scale;
    org.y = dialogue.org.y * scale;
  } else {
    org.x = [x, x + width / 2, x + width][align.h];
    org.y = [y + height, y + height / 2, y][align.v];
  }
  for (let i = $div.childNodes.length - 1; i >= 0; i -= 1) {
    const node = $div.childNodes[i];
    if (node.dataset.rotate === '') {
      // It's not extremely precise for offsets are round the value to an integer.
      const tox = org.x - x - node.offsetLeft;
      const toy = org.y - y - node.offsetTop;
      node.style.cssText += `transform-origin:${tox}px ${toy}px;`;
    }
  }
}


/***/ }),

/***/ "./node_modules/assjs/src/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/assjs/src/utils.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alpha2opacity: () => (/* binding */ alpha2opacity),
/* harmony export */   batchAnimate: () => (/* binding */ batchAnimate),
/* harmony export */   color2rgba: () => (/* binding */ color2rgba),
/* harmony export */   createSVGEl: () => (/* binding */ createSVGEl),
/* harmony export */   initAnimation: () => (/* binding */ initAnimation),
/* harmony export */   uuid: () => (/* binding */ uuid)
/* harmony export */ });
/* unused harmony export addGlobalStyle */
function alpha2opacity(a) {
  return 1 - `0x${a}` / 255;
}

function color2rgba(c) {
  const t = c.match(/(\w\w)(\w\w)(\w\w)(\w\w)/);
  const a = alpha2opacity(t[1]);
  const b = +`0x${t[2]}`;
  const g = +`0x${t[3]}`;
  const r = +`0x${t[4]}`;
  return `rgba(${r},${g},${b},${a})`;
}

function uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = Math.trunc(Math.random() * 16);
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

/**
 * @param {string} name SVG tag
 * @param {[string, string][]} attrs
 * @returns
 */
function createSVGEl(name, attrs = []) {
  const $el = document.createElementNS('http://www.w3.org/2000/svg', name);
  for (let i = 0; i < attrs.length; i += 1) {
    const attr = attrs[i];
    $el.setAttributeNS(
      attr[0] === 'xlink:href' ? 'http://www.w3.org/1999/xlink' : null,
      attr[0],
      attr[1],
    );
  }
  return $el;
}

const GLOBAL_CSS = '__GLOBAL_CSS__';
/**
 * @param {HTMLElement} container
 */
function addGlobalStyle(container) {
  const rootNode = container.getRootNode() || document;
  const styleRoot = rootNode === document ? document.head : rootNode;
  let $style = styleRoot.querySelector('#ASS-global-style');
  if (!$style) {
    $style = document.createElement('style');
    $style.type = 'text/css';
    $style.id = 'ASS-global-style';
    $style.append(document.createTextNode(GLOBAL_CSS));
    styleRoot.append($style);
  }
}

function initAnimation($el, keyframes, options) {
  const animation = $el.animate(keyframes, options);
  animation.pause();
  return animation;
}

function batchAnimate(dia, action) {
  (dia.animations || []).forEach((animation) => {
    animation[action]();
  });
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".avplayer.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "AVPlayer:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkAVPlayer"] = self["webpackChunkAVPlayer"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module factories are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./src/ui/avplayer/AVPlayer.ts");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=avplayer.js.map